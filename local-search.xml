<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>rocketmq 原理解析</title>
    <link href="/2022/09/06/basic-middle-rocketmq/"/>
    <url>/2022/09/06/basic-middle-rocketmq/</url>
    
    <content type="html"><![CDATA[<h1 id="rocketmq-原理解析"><a href="#rocketmq-原理解析" class="headerlink" title="rocketmq 原理解析"></a>rocketmq 原理解析</h1><h2 id="RocketMQ-如何保证消息不丢失-保证可靠性"><a href="#RocketMQ-如何保证消息不丢失-保证可靠性" class="headerlink" title="RocketMQ 如何保证消息不丢失/保证可靠性"></a>RocketMQ 如何保证消息不丢失/保证可靠性</h2><h4 id="消息在-RocketMQ-流转大概可以分为三个阶段：发送阶段、存储阶段、消费阶段，那么可靠性就要从这三个阶段考虑。"><a href="#消息在-RocketMQ-流转大概可以分为三个阶段：发送阶段、存储阶段、消费阶段，那么可靠性就要从这三个阶段考虑。" class="headerlink" title="消息在 RocketMQ 流转大概可以分为三个阶段：发送阶段、存储阶段、消费阶段，那么可靠性就要从这三个阶段考虑。"></a>消息在 RocketMQ 流转大概可以分为三个阶段：发送阶段、存储阶段、消费阶段，那么可靠性就要从这三个阶段考虑。</h4><ul><li>生产者发送消息时主要依靠<strong>发送确认</strong>来确保消息可靠性的。同步异步发送都可以获取到发送状态，通过这个发送状态来判断本次消息是否成功发送。另外，发送消息时还可以指定一个超时时间，如果超出这个超时时间可以再次发送。</li><li>消费者消费消息时也存在一个<strong>消费确认机制</strong>，当消费者消费消息成功或失败都会给 Broker 返回消费状态，消费成功则结束本次流程；消费失败 Broker 则会重新发送消息。如果停电、宕机 Broker 都不会认为消费成功，也会继续重新投递。</li><li>Broker 存储阶段保证消息不丢失的手段就是<strong>把消息记录到 CommitLog 中</strong>，保证消息不会丢失。</li></ul><h4 id="关于保证成功记录到-CommitLog-有两种方式："><a href="#关于保证成功记录到-CommitLog-有两种方式：" class="headerlink" title="关于保证成功记录到 CommitLog 有两种方式："></a>关于保证成功记录到 CommitLog 有两种方式：</h4><ul><li>同步刷盘，生产者把消息发送到 Broker 后，只有 Broker 成功地把消息写入到 CommitLog 后，才能给生产者返回发送成功的 ACK。这种方式可靠性更高，但是牺牲了效率。</li><li>异步刷盘，Broker 把消息写入到 CommitLog 采用后台异步线程刷盘的方式，刷盘完成后回调接口返回发送成功的 ACK。可以降低读写延迟，提高 RocketMQ 的吞吐量，但是当 Broker 宕机时会丢失部分未从内存中写入到文件的消息。</li></ul><h2 id="RocketMQ-中消息重复的问题"><a href="#RocketMQ-中消息重复的问题" class="headerlink" title="RocketMQ 中消息重复的问题"></a>RocketMQ 中消息重复的问题</h2><p>在分布式消息队列中，同时确保消息不丢失和不重复是很难的，RocketMQ 选择了保证消息不丢失，消息重复的问题需要在业务端自行解决。</p><p>在 RocketMQ 中，造成消息重复的<strong>根本原因是网络波动</strong>，会导致消费者收到两条一样的消息。</p><p>RocketMQ 不保证消息不重复，如果要严格确保不重复，需要在业务端去重，可以使用如下手段：</p><ul><li>多次消费不影响：消费端的消息处理业务逻辑保证幂等性，这样无论消息消费多少次都对业务没有影响；</li><li>过滤重复消息：生产者发送时确保每一条消息都有唯一编号（业务相关的比如说是订单号），建立一个消费记录表，当拿到这个消息时保存到数据库，给这个消息做唯一约束，当出现重复消费时，唯一约束就不满足，那么就抛弃这条消息。</li></ul><h2 id="RocketMQ-消息堆积问题"><a href="#RocketMQ-消息堆积问题" class="headerlink" title="RocketMQ 消息堆积问题"></a>RocketMQ 消息堆积问题</h2><p>消息队列其中一个很重要的作用就是削峰，那么消息队列必然有一定的消息堆积能力来顶住请求的洪峰来保证后端服务的稳定性。</p><p>如果发生消息积压，这时候需要考虑如何让消费者提高消费能力，可以从以下情况考虑：</p><ul><li>如果 Queue 的数量大于消费者数量，这时需要做的是<strong>消费者扩容</strong>，默认消费模式是集群消费模式，消息会雨露均沾地发送给消费者，所以可以让消费者数量增加到和 Queue 的数量一致。</li></ul><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220909153107.png" alt="img"></p><ul><li>如果 Queue 的数量小于或等于消费者数量还发生大规模消息堆积时，这种情况无论再增加消费者数量，消费能力都不会提升，这时需要做的是<strong>消息迁移 Queue 扩容</strong>，具体做法是修改消费者逻辑，让消费者把这些消息使用一个临时的 Topic，这个 Topic 下建更多的 Queue，把原来的消息转发到这些 Queue 上，另外安排对应这个临时 Topic 的消费者来消费这些堆积的消息。</li></ul><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220909155342.png" alt="img"></p><h2 id="RocketMQ-中顺序消息的问题"><a href="#RocketMQ-中顺序消息的问题" class="headerlink" title="RocketMQ 中顺序消息的问题"></a>RocketMQ 中顺序消息的问题</h2><p>RocketMQ 的顺序消息包含两个层面，有顺序地生产消息以及有顺序地消费消息。有些业务场景下必须保证顺序，比如订单的生成、付款、发货，这个顺序是必须保证的。</p><p>RocketMQ 顺序消息可以分为全局有序以及分区有序，全局有序与分区有序的区别与落地在这篇文章中也适当介绍了：<a href="https://gelald.github.io/javrin/docs/writings/message-queue/RocketMQ-operation-client.html">RocketMQ 操作落地 (rocketmq-client 方式)</a>。</p><p>全局有序消息</p><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220909151552.png" alt="img"></p><p>分区有序消息</p><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220909151906.png" alt="img"></p><p>如果要严格控制消息的顺序，那么生产者、queue、消费者最好都是一对一的关系，把整个流程中并发的部分全都消除了，各部分都设计成单线程工作。但是这样的设计，完全牺牲了 RocketMQ 高并发高吞吐的特性，也容易成为系统性能瓶颈。</p><p>但是全局有序导致性能低下的问题 RocketMQ 不打算解决，理由如下：</p><ul><li>乱序的应用实际上大量存在，系统中一般极少数情况需要对消息做严格的顺序；</li><li>消息在队列中无序，不代表最终消息也是无序的，可以使用其他手段来控制顺序。比如给消息打上标识顺序的标签，在业务层再处理顺序问题等。</li></ul><h2 id="RocketMQ-延时消息原理"><a href="#RocketMQ-延时消息原理" class="headerlink" title="RocketMQ 延时消息原理"></a>RocketMQ 延时消息原理</h2><h3 id="SCHEDULE-TOPIC-XXXX-介绍"><a href="#SCHEDULE-TOPIC-XXXX-介绍" class="headerlink" title="SCHEDULE_TOPIC_XXXX 介绍"></a><code>SCHEDULE_TOPIC_XXXX</code> 介绍</h3><p><code>SCHEDULE_TOPIC_XXXX</code> 是 RocketMQ 一个系统类型的 Topic，用于标识延时消息。</p><p>这个 Topic 有 18 个队列，分别唯一对应着 RocketMQ 的 18 个延时等级，对应关系为：<strong>queueId = delayTimeLevel – 1</strong>。</p><h3 id="ScheduleMessageService-介绍"><a href="#ScheduleMessageService-介绍" class="headerlink" title="ScheduleMessageService 介绍"></a><code>ScheduleMessageService</code> 介绍</h3><p>这是 Broker 中的一个延时服务，专门消费 Topic 为 <code>SCHEDULE_TOPIC_XXXX</code> 的延时消息，并将其投递到目标 Topic 中。</p><p><code>ScheduleMessageService</code> 在启动时，会创建一个定时器 Timer，并根据延迟级别的个数，启动对应数量的 TimerTask，每个 TimerTask 负责一个延迟级别的消费与投递。</p><h3 id="延时消息在-Broker-的流转过程"><a href="#延时消息在-Broker-的流转过程" class="headerlink" title="延时消息在 Broker 的流转过程"></a>延时消息在 Broker 的流转过程</h3><p>生产者发送延时消息到 Broker，再到消费者消费的过程，消息将经过以下流转：</p><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220830160040.png" alt="img"></p><ol><li>Broker 把消息的 Topic 修改成<code>SCHEDULE_TOPIC_XXX</code>，然后根据本次消息的延时等级计算需要投递到的具体队列。同时还要把消息原来的 Topic 及其队列信息存储到消息的属性中，方便后面正确投递。</li><li>在从 CommitLog 把消息转发到 queue 的过程中，会计算这个延时消息需要在什么时候进行投递，<strong>投递时间=消息存储时间+延时等级对应的时间</strong>。</li><li>延时消费服务 <code>ScheduleMessageService</code> 消费这个延时消息。</li><li>从消息属性中取出并设置原来消息的 Topic 和队列信息，存储到 CommitLog. 此时这个消息已经完成延时，和普通消息没有区别，所以 ConsumeQueue 中的 Message Tag HashCode 需要重新计算消息 Tag 的哈希值再存储。</li><li>由于消息的 Topic 已经修改为原来的 Topic，所以直接投递到对应的队列中。</li><li>消费者消费这条消息。</li></ol><h2 id="RocketMQ-事务消息原理"><a href="#RocketMQ-事务消息原理" class="headerlink" title="RocketMQ 事务消息原理"></a>RocketMQ 事务消息原理</h2><h3 id="实现事务消息核心"><a href="#实现事务消息核心" class="headerlink" title="实现事务消息核心"></a>实现事务消息核心</h3><ul><li>两阶段提交：第一阶段生产者发送 Half 消息到 Broker 来测试 RocketMQ 是否正常；Broker 只有在收到第二阶段的消息时，消费者才能对消息进行消费。</li><li>事务补偿机制：当 Broker 收到状态为 <code>unknown</code> 的消息或者由于网络波动、生产者宕机导致长时间没有收到第二阶段的提交时，Broker 会调用生产者接口来回查本次事务的状态。</li></ul><p>这两个核心是实现分布式事务最终一致性的关键。</p><h3 id="事务消息的流程"><a href="#事务消息的流程" class="headerlink" title="事务消息的流程"></a>事务消息的流程</h3><blockquote><p>以支付订单后奖励积分为例，此时生产者是订单系统，消费者是积分系统，当积分系统收到订单系统传来订单支付成功，那么就给用户提供积分的奖励</p></blockquote><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220830164439.png" alt="img"></p><ul><li>订单系统会发送一条 Half 消息到 RocketMQ 中，这个 Half 消息其实是一个代表订单成功支付的消息，只不过目前这个状态积分系统是无法感知这个消息的存在的。</li><li>如果发送 Half 消息后没有收到 MQ 的响应，那么可以认定 MQ 此时有问题，那么就在订单系统中回滚这笔订单，例如订单关闭或者发起退款。</li><li>如果收到 MQ 的响应，那么可以认定 MQ 是正常的，订单系统可以执行自己的本地事务，比如更新订单状态。</li><li>如果在处理自己系统的业务时，本地事务发生异常了，那么就发送一个 rollback 请求到 MQ 中，让 MQ 删除之前发送的 Half 消息；如果业务逻辑成功执行、本地事务成功提交，那么就发送一个 commit 请求到 MQ 中，MQ 收到 commit 请求后，之前的 Half 消息也就对积分系统可见了；如果业务逻辑的事务状态为 unknown ，那么 MQ 就会发起回查，回查生产者本地事务的状态。</li><li>假设由于网络波动、生产者重启导致事务消息的二次确认丢失，MQ 也有补偿措施，它会去扫描自己处于 Half 状态的消息，如果这个 MQ 一直没有接收到对这个 Half 消息的第二阶段的提交，会回调一个接口，让订单系统查询这个订单的状态，进而进行第二阶段的提交。所以这个回查的接口非常重要，要保证提交 commit 或者 rollback。</li></ul><h2 id="死信队列原理"><a href="#死信队列原理" class="headerlink" title="死信队列原理"></a>死信队列原理</h2><blockquote><p>死信队列用于处理无法被正常消费的消息，即死信消息。</p></blockquote><h3 id="死信消息的产生"><a href="#死信消息的产生" class="headerlink" title="死信消息的产生"></a>死信消息的产生</h3><p>当一条消息在消费失败时，RocketMQ 消费者会自动对消息进行重试消费；当重试失败次数达到最大值依然是失败时，那么可以认为消费者在正常情况下是无法消费这个消息的。此时，RocketMQ 并不会立刻丢弃这个消息，而是将其发送到消费者对应的死信队列中。</p><p>死信消息放到死信队列中后不会再被原来的消费者消费，此时他的 Topic 变成了 <code>%DLQ%消费者组</code> ，需要使用另外的消费者来订阅消费这些死信消息。死信消息可以助于我们统计异常数据并做后续的数据修复处理。</p><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220909105631.png" alt="img"></p><p>默认的重试次数与重试间隔时间如下：</p><table><thead><tr><th>重试次数</th><th>重试间隔时间</th><th>重试次数</th><th>重试间隔时间</th></tr></thead><tbody><tr><td>1</td><td>10 秒</td><td>9</td><td>7 分钟</td></tr><tr><td>2</td><td>30 秒</td><td>10</td><td>8 分钟</td></tr><tr><td>3</td><td>1 分钟</td><td>11</td><td>9 分钟</td></tr><tr><td>4</td><td>2 分钟</td><td>12</td><td>10 分钟</td></tr><tr><td>5</td><td>3 分钟</td><td>13</td><td>20 分钟</td></tr><tr><td>6</td><td>4 分钟</td><td>14</td><td>30 分钟</td></tr><tr><td>7</td><td>5 分钟</td><td>15</td><td>1 小时</td></tr><tr><td>8</td><td>6 分钟</td><td>16</td><td>2 小时</td></tr></tbody></table><p>其中重试间隔时间可以通过修改 Broker 的配置文件的 messageDelayLevel 配置项来修改。</p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 消息重试16次分别间隔</span>messageDelayLevel =1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</code></pre></div><h3 id="死信队列的特点"><a href="#死信队列的特点" class="headerlink" title="死信队列的特点"></a>死信队列的特点</h3><p>一个死信队列对应一个消费者组，不对应某一个消费者实例或 Topic。</p>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>rocketmq</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rocketmq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java synchronized lock</title>
    <link href="/2021/11/05/java-synchornized/"/>
    <url>/2021/11/05/java-synchornized/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-Synchronized"><a href="#Java-Synchronized" class="headerlink" title="Java Synchronized"></a>Java Synchronized</h1><p>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。</p><p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p><ul><li>普通同步方法，锁是当前实例对象</li><li>静态同步方法，锁是当前类的class对象</li><li>同步方法块，锁是括号里面的对象</li></ul><h3 id="synchronized-和-volatile-的区别是什么？"><a href="#synchronized-和-volatile-的区别是什么？" class="headerlink" title=". synchronized 和 volatile 的区别是什么？"></a><strong>. synchronized 和 volatile 的区别是什么？</strong></h3><ul><li>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li><li>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。</li><li>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。</li><li>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</li><li>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</li></ul><h3 id="synchronized-和-Lock-有什么区别？"><a href="#synchronized-和-Lock-有什么区别？" class="headerlink" title="synchronized 和 Lock 有什么区别？"></a><strong>synchronized 和 Lock 有什么区别？</strong></h3><ul><li>首先synchronized是java内置关键字，在jvm层面，Lock是个java类；</li><li>synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；</li><li>synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；</li><li>用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；</li><li>synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；</li><li>Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。</li></ul><h3 id="synchronized-和-ReentrantLock-区别是什么？"><a href="#synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="synchronized 和 ReentrantLock 区别是什么？"></a><strong>synchronized 和 ReentrantLock 区别是什么？</strong></h3><p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：</p><ul><li>ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</li><li>ReentrantLock可以获取各种锁的信息</li><li>ReentrantLock可以灵活地实现多路通知</li></ul><p>另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gw4d7j3x92j30nq0d50tl.jpg" alt="img"></p><h4 id="锁的级别从低到高："><a href="#锁的级别从低到高：" class="headerlink" title="锁的级别从低到高："></a>锁的级别从低到高：</h4><blockquote><p> 无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</p></blockquote><h3 id="锁分级别原因："><a href="#锁分级别原因：" class="headerlink" title="锁分级别原因："></a>锁分级别原因：</h3><p>没有优化以前，synchronized是重量级锁（悲观锁），使用 wait 和 notify、notifyAll 来切换线程状态非常消耗系统资源；线程的挂起和唤醒间隔很短暂，这样很浪费资源，影响性能。所以 JVM 对 synchronized 关键字进行了优化，把锁分为 无锁、偏向锁、轻量级锁、重量级锁 状态。</p><h4 id="无锁："><a href="#无锁：" class="headerlink" title="无锁："></a>无锁：</h4><p>没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功，其他修改失败的线程会不断重试直到修改成功。</p><h4 id="偏向锁："><a href="#偏向锁：" class="headerlink" title="偏向锁："></a>偏向锁：</h4><p>对象的代码一直被同一线程执行，不存在多个线程竞争，该线程在后续的执行中自动获取锁，降低获取锁带来的性能开销。偏向锁，指的就是偏向第一个加锁线程，该线程是不会主动释放偏向锁的，只有当其他线程尝试竞争偏向锁才会被释放。</p><p>偏向锁的撤销，需要在某个时间点上没有字节码正在执行时，先暂停拥有偏向锁的线程，然后判断锁对象是否处于被锁定状态。如果线程不处于活动状态，则将对象头设置成无锁状态，并撤销偏向锁；</p><p><code>如果线程处于活动状态，升级为轻量级锁的状态。</code></p><h4 id="轻量级锁："><a href="#轻量级锁：" class="headerlink" title="轻量级锁："></a>轻量级锁：</h4><p>轻量级锁是指当锁是偏向锁的时候，被第二个线程 B 所访问，此时偏向锁就会升级为轻量级锁，线程 B 会通过自旋的形式尝试获取锁，线程不会阻塞，从而提高性能。</p><p>当前只有一个等待线程，则该线程将通过自旋进行等待。但是当自旋超过一定的次数时，轻量级锁便会升级为重量级锁；当一个线程已持有锁，另一个线程在自旋，而此时又有第三个线程来访时，轻量级锁也会升级为重量级锁。</p><h4 id="重量级锁："><a href="#重量级锁：" class="headerlink" title="重量级锁："></a>重量级锁：</h4><p>指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。</p><p>重量级锁通过对象内部的监视器（monitor）实现，而其中 monitor 的本质是依赖于底层操作系统的 Mutex Lock 实现，操作系统实现线程之间的切换需要从用户态切换到内核态，切换成本非常高。</p><h4 id="锁状态对比："><a href="#锁状态对比：" class="headerlink" title="锁状态对比："></a>锁状态对比：</h4><table><thead><tr><th></th><th align="center">偏向锁</th><th>轻量级锁</th><th>重量级锁</th></tr></thead><tbody><tr><td>适用场景</td><td align="center">只有一个线程进入同步块</td><td>虽然很多线程，但是没有冲突：多条线程进入同步块，但是线程进入时间错开因而并未争抢锁</td><td>发生了锁争抢的情况：多条线程进入同步块并争用锁</td></tr><tr><td>本质</td><td align="center">取消同步操作</td><td>CAS操作代替互斥同步</td><td>互斥同步</td></tr><tr><td>优点</td><td align="center">不阻塞，执行效率高（只有第一次获取偏向锁时需要CAS操作，后面只是比对ThreadId）</td><td>不会阻塞</td><td>不会空耗CPU</td></tr><tr><td>缺点</td><td align="center">适用场景太局限。若竞争产生，会有额外的偏向锁撤销的消耗</td><td>长时间获取不到锁空耗CPU</td><td>阻塞，上下文切换，重量级操作，消耗操作系统资源</td></tr></tbody></table><h3 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a><strong>什么是死锁？</strong></h3><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是操作系统层面的一个错误，是进程死锁的简称，最早在 1965 年由 Dijkstra 在研究银行家算法时提出的，它是计算机操作系统乃至整个并发程序设计领域最难处理的问题之一。</p><h3 id="怎么防止死锁？"><a href="#怎么防止死锁？" class="headerlink" title="怎么防止死锁？"></a><strong>怎么防止死锁？</strong></h3><p>死锁的四个必要条件：</p><ul><li>互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源</li><li>请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放</li><li>不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放</li><li>环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系</li></ul><p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之 一不满足，就不会发生死锁。</p><p>理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和 解除死锁。</p><p>所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确 定资源的合理分配算法，避免进程永久占据系统资源。</p><blockquote><p>此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>date</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql-master-slave</title>
    <link href="/2021/11/04/mysql-master-slave/"/>
    <url>/2021/11/04/mysql-master-slave/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql-主从复制"><a href="#Mysql-主从复制" class="headerlink" title="Mysql 主从复制"></a>Mysql 主从复制</h1><h2 id="一、概要"><a href="#一、概要" class="headerlink" title="一、概要"></a><strong>一、概要</strong></h2><p>mysql从3.23版本开始提供复制功能，复制是将主库的<strong>DDL</strong>和<strong>DML</strong>操作通过二进制日志传递到复制服务器（从库）上，然后从库对这些日志重新执行（重做），从而使得主库和从库保持数据一致。</p><h2 id="1-1-mysql-复制的优点"><a href="#1-1-mysql-复制的优点" class="headerlink" title="1.1 mysql 复制的优点**"></a><strong>1.1</strong> <strong>mysql</strong> 复制的优点**</h2><ul><li>如果主库出现问题，可以快速切换到从库提供服务</li><li>可以在从库执行查询操作，降低主库的访问压力。</li><li>可以在从库进行备份，以免备份期间影响主库的服务。</li></ul><h2 id="1-2-Mysql-复制解决的问题"><a href="#1-2-Mysql-复制解决的问题" class="headerlink" title="1.2 Mysql 复制解决的问题**"></a><strong>1.2</strong> <strong>Mysql</strong> 复制解决的问题**</h2><ul><li>数据分布 (Data distribution )</li><li>负载平衡(load balancing)</li><li>数据备份(Backups) ，保证数据安全</li><li>高可用性和容错行(High availability and failover)</li><li>实现读写分离，缓解数据库压力</li></ul><blockquote><p><em>注意：由于</em> <em>mysql</em> <em>实现的异步复制，所以主库和从库数据之间存在一定的差异，在从库执行查询操作需要考虑这些数据的差异，一般只有更新不频繁和对实时性要求不高的数据可以通过从库查询，实行要求高的仍要从主库查询。</em></p></blockquote><h1 id="二、-MySQL-主从复制的概念"><a href="#二、-MySQL-主从复制的概念" class="headerlink" title="二、 MySQL** 主从复制的概念**"></a><strong>二、</strong> MySQL** 主从复制的概念**</h1><p><strong>MySQL 主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点</strong>。MySQL 默认采用<strong>异步复制</strong>方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。</p><h1 id="三、-MySQL-主从复制的主要用途"><a href="#三、-MySQL-主从复制的主要用途" class="headerlink" title="三、 MySQL** 主从复制的主要用途**"></a><strong>三、</strong> MySQL** 主从复制的主要用途**</h1><h2 id="3-1-读写分离"><a href="#3-1-读写分离" class="headerlink" title="3.1 读写分离"></a><strong>3.1</strong> <strong>读写分离</strong></h2><p>在开发工作中，有时候会遇见某个sql 语句需要锁表，导致暂时不能使用读的服务，这样就会影响现有业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。</p><h2 id="3-2-数据实时备份，当系统中某个节点发生故障时，可以方便的故障切换-主从切换"><a href="#3-2-数据实时备份，当系统中某个节点发生故障时，可以方便的故障切换-主从切换" class="headerlink" title="3.2 数据实时备份，当系统中某个节点发生故障时，可以方便的故障切换( 主从切换** )**"></a><strong>3.2</strong> <strong>数据实时备份，当系统中某个节点发生故障时，可以方便的故障切换(</strong> 主从切换** )**</h2><h2 id="3-3-高可用-（-HA-）"><a href="#3-3-高可用-（-HA-）" class="headerlink" title="3.3 高可用 （** HA** ）**"></a><strong>3.3</strong> <strong>高可用</strong> （** HA** ）**</h2><h2 id="3-4-架构扩展"><a href="#3-4-架构扩展" class="headerlink" title="3.4 架构扩展"></a><strong>3.4</strong> <strong>架构扩展</strong></h2><p>随着系统中业务访问量的增大，如果是单机部署数据库，就会导致I/O访问频率过高。有了主从复制，增加多个数据存储节点，将负载分布在多个从节点上，降低单机磁盘I/O访问的频率，提高单个机器的I/O性能。</p><h1 id="四、-MySQL-主从形式一主一从"><a href="#四、-MySQL-主从形式一主一从" class="headerlink" title="四、 MySQL** 主从形式一主一从**"></a><strong>四、</strong> MySQL** 主从形式一主一从**</h1><h2 id="4-1-一主多从"><a href="#4-1-一主多从" class="headerlink" title="4.1 一主多从"></a><strong>4.1</strong> <strong>一主多从</strong></h2><p>提高系统的读性能</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gw24d8i4k4j306s07ct8m.jpg" alt="img"></p><p>一主一从和一主多从是最常见的主从架构，实施起来简单并且有效，不仅可以实现HA，而且还能读写分离，进而提升集群的并发能力。</p><h2 id="4-2-多主一从-（从-5-7-开始支持）"><a href="#4-2-多主一从-（从-5-7-开始支持）" class="headerlink" title="4.2 多主一从 （从 5.7** 开始支持）**"></a><strong>4.2</strong> <strong>多主一从 （从</strong> 5.7** 开始支持）**</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gw24db1yhrj3060058q2s.jpg" alt="img"></p><p>多主一从可以将多个mysql数据库备份到一台存储性能比较好的服务器上。</p><h2 id="4-3-双主复制"><a href="#4-3-双主复制" class="headerlink" title="4.3 双主复制"></a><strong>4.3</strong> <strong>双主复制</strong></h2><p>双主复制，也就是互做主从复制，每个<strong>master</strong> （主）<strong>既是master，又是另外一台服务器的</strong>slave** （从）**。这样任何一方所做的变更，都会通过复制应用到另外一方的数据库中。</p><h2 id="4-4-级联复制"><a href="#4-4-级联复制" class="headerlink" title="4.4 级联复制"></a><strong>4.4 级联复制</strong></h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gw24dbqy71j308e02y744.jpg" alt="img"></p><p>级联复制模式下，部分slave的数据同步不连接主节点，而是连接从节点。因为如果主节点有太多的从节点，就会损耗一部分性能用于<strong>replication</strong> （复制）<strong>，那么我们可以让3~5个从节点连接主节点，其它从节点作为二级或者三级与从节点连接，这样不仅可以缓解主节点的压力，并且对数据一致性没有负面影响。</strong>级联复制下从节点也要开启** binary log** （** bin-log** ）功能**。</p><h1 id="五、-MySQL-主从复制的原理"><a href="#五、-MySQL-主从复制的原理" class="headerlink" title="五、 MySQL** 主从复制的原理**"></a><strong>五、</strong> MySQL** 主从复制的原理**</h1><p>MySQL主从复制涉及到三个线程，一个运行在<strong>主节点（</strong> log dump thread** ）**，其余两个(<strong>I/O thread</strong>, <strong>SQL thread</strong>)运行在从节点，如下图所示:</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gw24d9axmcj30hs06zaaa.jpg" alt="img"></p><h2 id="5-1-主节点-log-dump-线程"><a href="#5-1-主节点-log-dump-线程" class="headerlink" title="5.1 主节点 log dump 线程"></a><strong>5.1</strong> <strong>主节点</strong> <strong>log dump</strong> <strong>线程</strong></h2><p>当从节点连接主节点时，主节点会为其创建一个log dump 线程，用于发送和读取bin-log的内容。在读取bin-log中的操作时，log dump线程会对主节点上的bin-log加锁，当读取完成，在发送给从节点之前，锁会被释放。<strong>主节点会为自己的每一个从节点创建一个</strong> log dump** <strong>线程</strong>。</p><h2 id="5-2-从节点-I-O-线程"><a href="#5-2-从节点-I-O-线程" class="headerlink" title="5.2 从节点 I/O 线程**"></a><strong>5.2</strong> <strong>从节点</strong> <strong>I/O</strong> 线程**</h2><p>当从节点上执行<code>start slave</code>命令之后，从节点会创建一个I/O线程用来连接主节点，请求主库中更新的bin-log。I/O线程接收到主节点的blog dump进程发来的更新之后，保存在本地<strong>relay-log</strong> （中继日志）**中。</p><h2 id="5-3-从节点-SQL-线程"><a href="#5-3-从节点-SQL-线程" class="headerlink" title="5.3 从节点 SQL 线程**"></a><strong>5.3</strong> <strong>从节点</strong> <strong>SQL</strong> 线程**</h2><p>SQL线程负责读取relay-log中的内容，解析成具体的操作并执行，最终保证主从数据的一致性。</p><p>对于每一个主从连接，都需要这三个进程来完成。当主节点有多个从节点时，主节点会为每一个当前连接的从节点建一个<strong>log dump</strong> <strong>进程</strong>，而每个从节点都有自己的<strong>I/O</strong> 进程<strong>，</strong>SQL** 进程**。从节点用两个线程将从主库拉取更新和执行分成独立的任务，这样在执行同步数据任务的时候，不会降低读操作的性能。比如，如果从节点没有运行，此时I/O进程可以很快从主节点获取更新，尽管SQL进程还没有执行。如果在SQL进程执行之前从节点服务停止，至少I/O进程已经从主节点拉取到了最新的变更并且保存在本地relay日志中，当服务再次起来之后，就可以完成数据的同步。</p><p>要实施复制，首先<strong>必须打开</strong> Master** <strong>端的</strong> binary log** （** bin-log** ）功能，否则无法实现**。</p><p>因为整个复制过程实际上就是Slave 从Master 端获取该日志然后再在自己身上完全顺序的执行日志中所记录的各种操作。如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gw24d9o2bgj30hs0733yl.jpg" alt="img"></p><h2 id="5-4-复制的基本过程"><a href="#5-4-复制的基本过程" class="headerlink" title="5.4 复制的基本过程"></a><strong>5.4</strong> <strong>复制的基本过程</strong></h2><ol><li>在从节点上执行sart slave命令开启主从复制开关，开始进行主从复制。从节点上的I/O 进程连接主节点，并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容；</li><li>主节点接收到来自从节点的I/O请求后，通过负责复制的I/O进程（log dump 线程）根据请求信息读取指定日志指定位置之后的日志信息，返回给从节点。返回信息中除了日志所包含的信息之外，还包括本次返回的信息的bin-log file 的以及bin-log position（bin-log中的下一个指定更新位置）；</li><li>从节点的I/O进程接收到主节点发送过来的日志内容、日志文件及位置点后，将接收到的日志内容更新到本机的relay-log（中继日志）的文件（Mysql-relay-bin.xxx）的最末端，并将读取到的binary log（bin-log）文件名和位置保存到<strong>master-info</strong> <strong>文件</strong>中，以便在下一次读取的时候能够清楚的告诉Master“我需要从某个bin-log 的哪个位置开始往后的日志内容，请发给我”；</li><li>Slave 的 SQL线程检测到relay-log 中新增加了内容后，会将relay-log的内容解析成在主节点上实际执行过SQL语句，然后在本数据库中按照解析出来的顺序执行，并在<strong>relay-log.info</strong>中记录当前应用中继日志的文件名和位置点。</li></ol><h1 id="六、-MySQL-主从复制的模式"><a href="#六、-MySQL-主从复制的模式" class="headerlink" title="六、 MySQL** 主从复制的模式**"></a><strong>六、</strong> MySQL** 主从复制的模式**</h1><p>MySQL 主从复制默认是<strong>异步的模式</strong>。MySQL增删改操作会全部记录在<strong>bin</strong> -** log** （** binary log** ）**中，当slave节点连接master时，会主动从master处获取最新的bin-log文件。并把bin-log存储到本地的relay-log中，然后去执行relay-log的更新内容。</p><h2 id="6-1-异步模式（-mysql-async-mode-）"><a href="#6-1-异步模式（-mysql-async-mode-）" class="headerlink" title="6.1 异步模式（ mysql async-mode** ）**"></a><strong>6.1</strong> <strong>异步模式（</strong> mysql async-mode** ）**</h2><p>异步模式如下图所示，这种模式下，主节点不会主动推送bin-log到从节点，主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已经接收并处理，这样就会有一个问题，主节点如果崩溃掉了，此时主节点上已经提交的事务可能并没有传到从节点上，如果此时，强行将从提升为主，可能导致新主节点上的数据不完整。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gw24dab5opj30hs07u0t2.jpg" alt="img"></p><h2 id="6-2-半同步模式-mysql-semi-sync"><a href="#6-2-半同步模式-mysql-semi-sync" class="headerlink" title="6.2 半同步模式 (mysql semi-sync)**"></a><strong>6.2</strong> <strong>半同步模式</strong> (mysql semi-sync)**</h2><p>介于异步复制和全同步复制之间，主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到relay-log中才返回成功信息给客户端（只能保证主库的bin-log至少传输到了一个从节点上，但并不能保证从节点将此事务执行更新到db中），否则需要等待直到超时时间然后切换成异步模式再提交。相对于异步复制，半同步复制提高了数据的安全性，一定程度的保证了数据能成功备份到从库，同时它也造成了一定程度的延迟，但是比全同步模式延迟要低，这个延迟最少是一个TCP/IP往返的时间。所以，半同步复制最好在低延时的网络中使用。如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gw24dciy1nj30hs08b0t9.jpg" alt="img"></p><p>半同步模式不是mysql内置的，从mysql 5.5开始集成，需要master 和slave 安装插件开启半同步模式。</p><h2 id="6-3-全同步模式"><a href="#6-3-全同步模式" class="headerlink" title="6.3 全同步模式"></a><strong>6.3</strong> <strong>全同步模式</strong></h2><p>指当主库执行完一个事务，然后所有的从库都复制了该事务并成功执行完才返回成功信息给客户端。因为需要等待所有从库执行完该事务才能返回成功信息，所以全同步复制的性能必然会收到严重的影响。</p><h2 id="6-4-异步模式，全同步模式，半同步模式-的对比图"><a href="#6-4-异步模式，全同步模式，半同步模式-的对比图" class="headerlink" title="6.4 异步模式，全同步模式，半同步模式 的对比图**"></a><strong>6.4</strong> <strong>异步模式，全同步模式，半同步模式</strong> 的对比图**</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gw24dambalj30j50dwq3n.jpg" alt="img"></p><h2 id="6-5-GTID-复制模式"><a href="#6-5-GTID-复制模式" class="headerlink" title="6.5 GTID 复制模式**"></a><strong>6.5 GTID</strong> 复制模式**</h2><p>在传统的复制里面，当发生故障，需要<strong>主从切换</strong>，需要找到bin-log和pos点（指从库更新到了主库bin-log的哪个位置，这个位置之前都已经更显完毕，这个位置之后未更新），然后将主节点指向新的主节点，相对来说比较麻烦，也容易出错。在MySQL 5.6里面，不用再找bin-log和pos点，我们只需要知道主节点的ip，端口，以及账号密码就行，因为复制是自动的，MySQL会通过内部机制<strong>GTID</strong>自动找点同步。</p><p>基于GTID的复制是MySQL 5.6后新增的复制方式.</p><p><strong>GTID (global transaction identifier)</strong> 即全局事务ID, 保证了在每个在主库上提交的事务在集群中有一个唯一的ID.</p><h3 id="6-5-1-GTID-复制原理"><a href="#6-5-1-GTID-复制原理" class="headerlink" title="6.5.1 GTID 复制原理**"></a><strong>6.5.1 GTID</strong> 复制原理**</h3><p>在原来基于日志的复制中, 从库需要告知主库要从哪个偏移量进行增量同步, 如果指定错误会造成数据的遗漏, 从而造成数据的不一致.</p><p>而基于GTID的复制中, 从库会告知主库已经执行的事务的GTID的值, 然后主库会将所有未执行的事务的GTID的列表返回给从库. 并且可以保证同一个事务只在指定的从库执行一次.<strong>通过全局的事务</strong> ID** 确定从库要执行的事务的方式代替了以前需要用** bin-log** 和** pos** 点确定从库要执行的事务的方式**。</p><p>GTID是由server_uuid和事物id组成，格式为：GTID=server_uuid:transaction_id。server_uuid是在数据库启动过程中自动生成，每台机器的server-uuid不一样。uuid存放在数据目录的auto.conf文件中，而transaction_id就是事务提交时系统顺序分配的一个不会重复的序列号。</p><p>主节点更新数据时，会在事务前产生GTID，一起记录到bin-log日志中。从节点的I/O线程将变更的bin-log，写入到本地的relay-log中。SQL线程从relay-log中获取GTID，然后对比本地bin-log是否有记录（所以MySQL从节点必须要开启binary-log）。如果有记录，说明该GTID的事务已经执行，从节点会忽略。如果没有记录，从节点就会从relay-log中执行该GTID的事务，并记录到binlog。在解析过程中会判断是否有主键，如果没有就用二级索引，如果有就用全部扫描。</p><h3 id="6-5-2-GTID-的好处"><a href="#6-5-2-GTID-的好处" class="headerlink" title="6.5.2 GTID 的好处**"></a><strong>6.5.2</strong> <strong>GTID</strong> 的好处**</h3><ol><li>GTID使用master_auto_position=1代替了binlog和position号的主从复制搭建方式，相比binlog和position方式更容易搭建主从复制。</li><li>GTID方便实现主从之间的failover（主从切换），不用一步一步的去查找position和binlog文件。</li></ol><h3 id="6-5-3-GTID-模式复制局限性"><a href="#6-5-3-GTID-模式复制局限性" class="headerlink" title="6.5.3 GTID 模式复制局限性**"></a><strong>6.5.3</strong> <strong>GTID</strong> 模式复制局限性**</h3><ol><li>不能使用create table table_name select * from table_name模式的语句</li><li>在一个事务中既包含事务表的操作又包含非事务表</li><li>不支持CREATE TEMPORARY TABLE or DROP TEMPORARY TABLE语句操作</li><li>使用GTID复制从库跳过错误时，不支持sql_slave_skip_counter参数的语法</li></ol><h2 id="6-6-多线程复制"><a href="#6-6-多线程复制" class="headerlink" title="6.6 多线程复制"></a><strong>6.6</strong> <strong>多线程复制</strong></h2><p>多线程复制（基于库），在MySQL 5.6以前的版本，slave的复制是单线程的，而master是并发写入的，所以延时是避免不了的。唯一有效的方法是把多个库放在多台slave，这样又有点浪费服务器。在MySQL 5.6里面，我们可以把多个表放在多个库，这样就可以使用多线程复制。</p><p>但 5.6 中的每个线程只能处理一个数据库，所以如果只有一个数据库，或者绝大多数写操作都是集中在某一个数据库的，那么这个“多线程复制”就不能充分发挥作用了</p><p>Mysql 5.7 对 “多线程复制” 进行了改善，可以按照逻辑时钟的方式来分配线程，大大提高了复制性能</p><h1 id="七、MySQL主从复制的方式"><a href="#七、MySQL主从复制的方式" class="headerlink" title="七、MySQL主从复制的方式"></a><strong>七、MySQL主从复制的方式</strong></h1><p>MySQL 主从复制有三种方式：<strong>基于</strong> SQL** 语句的复制<strong>（statement-based replication，SBR），</strong>基于行的复制<strong>（row-based replication，RBR)，</strong>混合模式复制<strong>（mixed-based replication,MBR)。对应的bin-log文件的格式也有三种：</strong>STATEMENT**, <strong>ROW</strong>, <strong>MIXED</strong>。</p><h2 id="7-1-Statement-base-Replication-SBR"><a href="#7-1-Statement-base-Replication-SBR" class="headerlink" title="7.1 Statement-base Replication (SBR)"></a><strong>7.1</strong> <strong>Statement-base Replication (SBR)</strong></h2><p>就是记录sql语句在bin-log中，Mysql 5.1.4 及之前的版本都是使用的这种复制格式。优点是只需要记录会修改数据的sql语句到bin-log中，减少了bin-log日质量，节约I/O，提高性能。缺点是在某些情况下，会导致主从节点中数据不一致（比如sleep(),now()等）。</p><h2 id="7-2-Row-based-Relication-RBR"><a href="#7-2-Row-based-Relication-RBR" class="headerlink" title="7.2 Row-based Relication(RBR)"></a><strong>7.2 Row-based Relication(RBR)</strong></h2><p>mysql master将SQL语句分解为基于Row更改的语句并记录在bin-log中，也就是只记录哪条数据被修改了，修改成什么样。优点是不会出现某些特定情况下的存储过程、或者函数、或者trigger的调用或者触发无法被正确复制的问题。缺点是会产生大量的日志，尤其是修改table的时候会让日志暴增,同时增加bin-log同步时间。也不能通过bin-log解析获取执行过的sql语句，只能看到发生的data变更。</p><h2 id="7-3-Mixed-format-Replication-MBR"><a href="#7-3-Mixed-format-Replication-MBR" class="headerlink" title="7.3 Mixed-format Replication(MBR)"></a><strong>7.3</strong> <strong>Mixed-format Replication(MBR)</strong></h2><p>MySQL NDB cluster 7.3 和7.4 使用的MBR。是以上两种模式的混合，对于一般的复制使用STATEMENT模式保存到bin-log，对于STATEMENT模式无法复制的操作则使用ROW模式来保存，MySQL会根据执行的SQL语句选择日志保存方式。</p><h1 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a><strong>八、总结</strong></h1><p>Mysql 主从复制是mysql 高可用，高性能的基础，有了这个基础，mysql 的部署会变得简单、灵活并且具有多样性，从而可以根据不同的业务场景做出灵活的调整。</p>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java aop</title>
    <link href="/2021/10/24/java-aop/"/>
    <url>/2021/10/24/java-aop/</url>
    
    <content type="html"><![CDATA[<h1 id="Java动态代理的两种实现方法"><a href="#Java动态代理的两种实现方法" class="headerlink" title="Java动态代理的两种实现方法"></a>Java动态代理的两种实现方法</h1><h2 id="接口定义实现"><a href="#接口定义实现" class="headerlink" title="接口定义实现"></a>接口定义实现</h2><p>AOP的拦截功能是由java中的动态代理来实现的。说白了，就是在目标类的基础上增加切面逻辑，生成增强的目标类（该切面逻辑或者在目标类函数执行之前，或者目标类函数执行之后，或者在目标类函数抛出异常时候执行。不同的切入时机对应不同的Interceptor的种类，如BeforeAdviseInterceptor，AfterAdviseInterceptor以及ThrowsAdviseInterceptor等）。</p><p>那么动态代理是如何实现将切面逻辑（advise）织入到目标类方法中去的呢？下面我们就来详细介绍并实现AOP中用到的两种动态代理。</p><p>AOP的源码中用到了两种动态代理来实现拦截切入功能：jdk动态代理和cglib动态代理。两种方法同时存在，各有优劣。</p><p>jdk动态代理是由java内部的反射机制来实现的，cglib动态代理底层则是借助asm来实现的。</p><p>总的来说，反射机制在生成类的过程中比较高效，而asm在生成类之后的相关执行过程中比较高效（可以通过将asm生成的类进行缓存，这样解决asm生成类过程低效问题）。还有一点必须注意：jdk动态代理的应用前提，必须是目标类基于统一的接口。如果没有上述前提，jdk动态代理不能应用。由此可以看出，jdk动态代理有一定的局限性，cglib这种第三方类库实现的动态代理应用更加广泛，且在效率上更有优势。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.meituan.hyt.test3.service;    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>; &#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.meituan.hyt.test3.service.impl;    <span class="hljs-keyword">import</span> com.meituan.hyt.test3.service.UserService;    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;    System.out.println(<span class="hljs-string">&quot;------getName------&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Tom&quot;</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;    System.out.println(<span class="hljs-string">&quot;------getAge------&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;    &#125; &#125;</code></pre></div><h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>jdk动态代理是jdk原生就支持的一种代理方式，它的实现原理，就是通过让target类和代理类实现同一接口，代理类持有target对象，来达到方法拦截的作用，这样通过接口的方式有两个弊端，一个是必须保证target类有接口，第二个是如果想要对target类的方法进行代理拦截，那么就要保证这些方法都要在接口中声明，实现上略微有点限制。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.meituan.hyt.test3.jdk;    <span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;    <span class="hljs-keyword">import</span> java.lang.reflect.Method;    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;    <span class="hljs-keyword">private</span> Object target;    MyInvocationHandler() &#123;    <span class="hljs-keyword">super</span>();    &#125;    MyInvocationHandler(Object target) &#123;    <span class="hljs-keyword">super</span>();    <span class="hljs-keyword">this</span>.target = target;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object o, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;getName&quot;</span>.equals(method.getName()))&#123;    System.out.println(<span class="hljs-string">&quot;++++++before &quot;</span> + method.getName() + <span class="hljs-string">&quot;++++++&quot;</span>);    Object result = method.invoke(target, args);    System.out.println(<span class="hljs-string">&quot;++++++after &quot;</span> + method.getName() + <span class="hljs-string">&quot;++++++&quot;</span>);    <span class="hljs-keyword">return</span> result;    &#125;<span class="hljs-keyword">else</span>&#123;    Object result = method.invoke(target, args);    <span class="hljs-keyword">return</span> result;    &#125;    &#125;    &#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.meituan.hyt.test3.jdk;    <span class="hljs-keyword">import</span> com.meituan.hyt.test3.service.UserService;    <span class="hljs-keyword">import</span> com.meituan.hyt.test3.service.impl.UserServiceImpl;    <span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;    <span class="hljs-keyword">import</span> java.lang.reflect.Proxy;    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl();    InvocationHandler invocationHandler = <span class="hljs-keyword">new</span> MyInvocationHandler(userService);    UserService userServiceProxy = (UserService)Proxy.newProxyInstance(userService.getClass().getClassLoader(),    userService.getClass().getInterfaces(), invocationHandler);    System.out.println(userServiceProxy.getName(<span class="hljs-number">1</span>));    System.out.println(userServiceProxy.getAge(<span class="hljs-number">1</span>));    &#125;    &#125;</code></pre></div><blockquote><p>运行结果</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs java">++++++before getName++++++------getName------++++++after getName++++++Tom------getAge------<span class="hljs-number">10</span></code></pre></div><h2 id="cglib动态代理"><a href="#cglib动态代理" class="headerlink" title="cglib动态代理"></a>cglib动态代理</h2><p>Cglib是一个优秀的动态代理框架，它的底层使用ASM在内存中动态的生成被代理类的子类，使用CGLIB即使代理类没有实现任何接口也可以实现动态代理功能。CGLIB具有简单易用，它的运行速度要远远快于JDK的Proxy动态代理：</p><p>cglib有两种可选方式，继承和引用。第一种是基于继承实现的动态代理，所以可以直接通过super调用target方法，但是这种方式在spring中是不支持的，因为这样的话，这个target对象就不能被spring所管理，所以cglib还是才用类似jdk的方式，通过持有target对象来达到拦截方法的效果。</p><p>CGLIB的核心类：<br>  net.sf.cglib.proxy.Enhancer – 主要的增强类<br>  net.sf.cglib.proxy.MethodInterceptor – 主要的方法拦截类，它是Callback接口的子接口，需要用户实现<br>  net.sf.cglib.proxy.MethodProxy – JDK的java.lang.reflect.Method类的代理类，可以方便的实现对源对象方法的调用,如使用：<br>  Object o = methodProxy.invokeSuper(proxy, args);//虽然第一个参数是被代理对象，也不会出现死循环的问题。</p><p>net.sf.cglib.proxy.MethodInterceptor接口是最通用的回调（callback）类型，它经常被基于代理的AOP用来实现拦截（intercept）方法的调用。这个接口只定义了一个方法<br>public Object intercept(Object object, java.lang.reflect.Method method,<br>Object[] args, MethodProxy proxy) throws Throwable;</p><p>第一个参数是代理对像，第二和第三个参数分别是拦截的方法和方法的参数。原来的方法可能通过使用java.lang.reflect.Method对象的一般反射调用，或者使用 net.sf.cglib.proxy.MethodProxy对象调用。net.sf.cglib.proxy.MethodProxy通常被首选使用，因为它更快。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.meituan.hyt.test3.cglib;    <span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;    <span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodProxy;    <span class="hljs-keyword">import</span> java.lang.reflect.Method;    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CglibProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;    System.out.println(<span class="hljs-string">&quot;++++++before &quot;</span> + methodProxy.getSuperName() + <span class="hljs-string">&quot;++++++&quot;</span>);    System.out.println(method.getName());    Object o1 = methodProxy.invokeSuper(o, args);    System.out.println(<span class="hljs-string">&quot;++++++before &quot;</span> + methodProxy.getSuperName() + <span class="hljs-string">&quot;++++++&quot;</span>);    <span class="hljs-keyword">return</span> o1;    &#125;    &#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.meituan.hyt.test3.cglib;    <span class="hljs-keyword">import</span> com.meituan.hyt.test3.service.UserService;    <span class="hljs-keyword">import</span> com.meituan.hyt.test3.service.impl.UserServiceImpl;    <span class="hljs-keyword">import</span> net.sf.cglib.proxy.Enhancer;    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main2</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    CglibProxy cglibProxy = <span class="hljs-keyword">new</span> CglibProxy();    Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();    enhancer.setSuperclass(UserServiceImpl.class);    enhancer.setCallback(cglibProxy);    UserService o = (UserService)enhancer.create();    o.getName(<span class="hljs-number">1</span>);    o.getAge(<span class="hljs-number">1</span>);    &#125;    &#125;</code></pre></div><blockquote><p>运行结果</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs java">++++++before CGLIBgetName0++++++getName------getName------++++++before CGLIBgetName0++++++++++++before CGLIBgetAge1++++++getAge------getAge------++++++before CGLIBgetAge1++++++</code></pre></div><h2 id="需要注意的问题"><a href="#需要注意的问题" class="headerlink" title="需要注意的问题"></a>需要注意的问题</h2><blockquote><p>需要注意的是，当一个方法没有被aop事务包裹，在该方法内部去调用另外一个有aop事务包裹的方法时，这个方法的aop事务不会生效。比如：</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">()</span> </span>&#123;    aopRegister();    &#125;    <span class="hljs-meta">@Transactional</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">aopRegister</span><span class="hljs-params">()</span> </span>&#123;    &#125;</code></pre></div><p>因为通过上面的分析我们知道，在spring中，无论通过jdk的形式还是cglib的形式，代理类对target对象的方法进行拦截，其实都是通过让代理类持有target对象的引用，当外部引用aop包围的方法时，调用的其实是代理类对应的方法，代理类持有target对象，便可以控制target方法执行时的全方位拦截。</p><p>而如果在target的内部方法register调用一个aop包围的target方法aopRegister，调用的其实就是target自身的方法，因为这时候的this指针是不可能指向代理类的。所以事务是不能生效的。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>javabin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>aop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java 动态代理的实现方式</title>
    <link href="/2021/10/24/java-proxy/"/>
    <url>/2021/10/24/java-proxy/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-代理模式实现方式，主要有如下五种方法"><a href="#Java-代理模式实现方式，主要有如下五种方法" class="headerlink" title="Java 代理模式实现方式，主要有如下五种方法"></a>Java 代理模式实现方式，主要有如下五种方法</h1><ul><li>静态代理，工程师编辑代理类代码，实现代理模式；在编译期就生成了代理类。</li><li>基于 JDK 实现动态代理，通过jdk提供的工具方法Proxy.newProxyInstance动态构建全新的代理类(继承Proxy类，并持有InvocationHandler接口引用 )字节码文件并实例化对象返回。(jdk动态代理是由java内部的反射机制来实例化代理对象，并代理的调用委托类方法)</li><li>基于CGlib 动态代理模式 基于继承被代理类生成代理子类，不用实现接口。只需要被代理类是非final 类即可。(cglib动态代理底层是借助asm字节码技术</li><li>基于 Aspectj 实现动态代理（修改目标类的字节，织入代理的字节，在程序编译的时候 插入动态代理的字节码，不会生成全新的Class ）</li><li>基于 instrumentation 实现动态代理（修改目标类的字节码、类装载的时候动态拦截去修改，基于javaagent） <code>-javaagent:spring-instrument-4.3.8.RELEASE.jar</code> （类装载的时候 插入动态代理的字节码，不会生成全新的Class ）</li></ul><h2 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h2><ul><li>委托类 即指的是代理模式中的被代理对象</li><li>代理类 指的是生成的代表委托类的一个角色</li></ul><h2 id="静态代理实现"><a href="#静态代理实现" class="headerlink" title="静态代理实现"></a>静态代理实现</h2><p>静态代理是代理类在编译期间就创建好了，不是编译器生成的代理类，而是手动创建的类。在编译时就已经将接口，被代理类，代理类等确定下来。，软件设计中所指的代理一般是指静态代理，也就是在代码中显式指定的代理。</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ul><li>委托类和代理类之间的约束接口Cat</li><li>约束接口实现类 Lion，实现 Cat 接口，委托角色</li><li>代理类实现 FeederProxy，实现Cat 接口，并含有一个 Cat接口引用属性。 代理角色，代理 cat接口属性引用实例的行为并可以新增公共逻辑</li></ul><h4 id="Cat接口"><a href="#Cat接口" class="headerlink" title="Cat接口"></a>Cat接口</h4><div class="hljs code-wrapper"><pre><code class="hljs javascript">package org.vincent.proxy.staticproxy;<span class="hljs-comment">/**</span><span class="hljs-comment">* <span class="hljs-doctag">@author <span class="hljs-variable">PengRong</span></span></span><span class="hljs-comment">* <span class="hljs-doctag">@package </span>org.vincent.proxy.staticproxy</span><span class="hljs-comment">* <span class="hljs-doctag">@date </span>2018/12/15 - 17:12</span><span class="hljs-comment">* <span class="hljs-doctag">@ProjectName <span class="hljs-variable">JavaAopLearning</span></span></span><span class="hljs-comment">* <span class="hljs-doctag">@Description</span>: 静态代理类接口, 委托类和代理类都需要实现的接口规范。</span><span class="hljs-comment">* 定义了一个猫科动物的两个行为接口，吃东西，奔跑。</span><span class="hljs-comment">* 作为代理类 和委托类之间的约束接口</span><span class="hljs-comment">*/</span>public interface Cat &#123;    public <span class="hljs-built_in">String</span> eatFood(<span class="hljs-built_in">String</span> foodName);     public boolean running();&#125;</code></pre></div><h4 id="委托类-Lion"><a href="#委托类-Lion" class="headerlink" title="委托类 Lion"></a>委托类 Lion</h4><div class="hljs code-wrapper"><pre><code class="hljs javascript">package org.vincent.proxy.staticproxy;<span class="hljs-comment">/**</span><span class="hljs-comment">* <span class="hljs-doctag">@author <span class="hljs-variable">PengRong</span></span></span><span class="hljs-comment">* <span class="hljs-doctag">@package </span>org.vincent.proxy.staticproxy</span><span class="hljs-comment">* <span class="hljs-doctag">@date </span>2018/12/15 - 17:15</span><span class="hljs-comment">* <span class="hljs-doctag">@ProjectName <span class="hljs-variable">JavaAopLearning</span></span></span><span class="hljs-comment">* <span class="hljs-doctag">@Description</span>: 狮子 实现了猫科动物接口Cat， 并实现了具体的行为。作为委托类实现</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lion</span> <span class="hljs-title">implements</span> <span class="hljs-title">Cat</span> </span>&#123;    private <span class="hljs-built_in">String</span> name;    private int    runningSpeed;    public <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> name;    &#125;    public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">setName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;    &#125;    public int <span class="hljs-function"><span class="hljs-title">getRunningSpeed</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> runningSpeed;    &#125;    public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">setRunningSpeed</span>(<span class="hljs-params">int runningSpeed</span>)</span> &#123;        <span class="hljs-built_in">this</span>.runningSpeed = runningSpeed;    &#125;    public <span class="hljs-function"><span class="hljs-title">Lion</span>(<span class="hljs-params"></span>)</span> &#123;&#125;    @Override    public <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">eatFood</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> foodName</span>)</span> &#123;        <span class="hljs-built_in">String</span> eat = <span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot; Lion eat food. foodName = &quot;</span> + foodName;        System.out.println(eat);        <span class="hljs-keyword">return</span> eat;    &#125;    @Override    public boolean <span class="hljs-function"><span class="hljs-title">running</span>(<span class="hljs-params"></span>)</span> &#123;        System.out.println(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot; Lion is running . Speed :&quot;</span> + <span class="hljs-built_in">this</span>.runningSpeed);        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;</code></pre></div><h4 id="代理类角色-FeederProxy"><a href="#代理类角色-FeederProxy" class="headerlink" title="代理类角色(FeederProxy)"></a>代理类角色(FeederProxy)</h4><div class="hljs code-wrapper"><pre><code class="hljs javascript">package org.vincent.proxy.staticproxy;<span class="hljs-comment">/**</span><span class="hljs-comment">* <span class="hljs-doctag">@author <span class="hljs-variable">PengRong</span></span></span><span class="hljs-comment">* <span class="hljs-doctag">@package </span>org.vincent.proxy.staticproxy</span><span class="hljs-comment">* <span class="hljs-doctag">@date </span>2018/12/15 - 17:19</span><span class="hljs-comment">* <span class="hljs-doctag">@ProjectName <span class="hljs-variable">JavaAopLearning</span></span></span><span class="hljs-comment">* <span class="hljs-doctag">@Description</span>: 饲养员 实现Cat接口，作为静态代理类实现。代理狮子的行为。</span><span class="hljs-comment">* 代理类中可以新增一些其他行为，在实践中主要做的是参数校验的功能。</span><span class="hljs-comment">*/</span>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeederProxy</span> <span class="hljs-title">implements</span> <span class="hljs-title">Cat</span> </span>&#123;    private Cat cat;    public <span class="hljs-function"><span class="hljs-title">FeederProxy</span>(<span class="hljs-params"></span>)</span> &#123;&#125;    public <span class="hljs-function"><span class="hljs-title">FeederProxy</span>(<span class="hljs-params">Cat cat</span>)</span> &#123;        <span class="hljs-keyword">if</span> (cat <span class="hljs-keyword">instanceof</span> Cat) &#123;            <span class="hljs-built_in">this</span>.cat = cat;        &#125;    &#125;    public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">setCat</span>(<span class="hljs-params">Cat cat</span>)</span> &#123;        <span class="hljs-keyword">if</span> (cat <span class="hljs-keyword">instanceof</span> Cat) &#123;            <span class="hljs-built_in">this</span>.cat = cat;        &#125;    &#125;    @Override    public <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">eatFood</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> foodName</span>)</span> &#123;        System.out.println(<span class="hljs-string">&quot;proxy Lion exec eatFood &quot;</span>);        <span class="hljs-keyword">return</span> cat.eatFood(foodName);    &#125;    @Override    public boolean <span class="hljs-function"><span class="hljs-title">running</span>(<span class="hljs-params"></span>)</span> &#123;        System.out.println(<span class="hljs-string">&quot;proxy Lion exec running.&quot;</span>);        <span class="hljs-keyword">return</span> cat.running();    &#125;&#125;</code></pre></div><h4 id="静态代理类测试"><a href="#静态代理类测试" class="headerlink" title="静态代理类测试"></a>静态代理类测试</h4><div class="hljs code-wrapper"><pre><code class="hljs javascript">package org.vincent.proxy;<span class="hljs-keyword">import</span> org.vincent.proxy.staticproxy.Cat;<span class="hljs-keyword">import</span> org.vincent.proxy.staticproxy.FeederProxy;<span class="hljs-keyword">import</span> org.vincent.proxy.staticproxy.Lion;<span class="hljs-comment">/**</span><span class="hljs-comment">* <span class="hljs-doctag">@author <span class="hljs-variable">PengRong</span></span></span><span class="hljs-comment">* <span class="hljs-doctag">@package </span>org.vincent.proxy</span><span class="hljs-comment">* <span class="hljs-doctag">@date </span>2018/12/15 - 18:31</span><span class="hljs-comment">* <span class="hljs-doctag">@ProjectName <span class="hljs-variable">JavaAopLearning</span></span></span><span class="hljs-comment">* <span class="hljs-doctag">@Description</span>: 静态代理类测试</span><span class="hljs-comment">*/</span>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">staticProxyTest</span> </span>&#123;    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;        Lion lion = <span class="hljs-keyword">new</span> Lion();        lion.setName(<span class="hljs-string">&quot;狮子 小王&quot;</span>);        lion.setRunningSpeed(<span class="hljs-number">100</span>);        <span class="hljs-comment">/**</span><span class="hljs-comment">         * new 静态代理类，静态代理类在编译前已经创建好了，和动态代理的最大区别点</span><span class="hljs-comment">         */</span>        Cat proxy = <span class="hljs-keyword">new</span> FeederProxy(lion);        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; -- &quot;</span> + proxy.eatFood(<span class="hljs-string">&quot;水牛&quot;</span>));        proxy.running();    &#125;&#125;</code></pre></div><p>静态代理很好的诠释了代理设计模式，代理模式最主要的就是有一个公共接口（Cat），一个委托类（Lion），一个代理类（FeederProxy）,代理类持有委托类的实例，代为执行具体类实例方法。 上面说到，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。这里的间接性就是指客户端不直接调用实际对象的方法，客户端依赖公共接口并使用代理类。 那么我们在代理过程中就可以加上一些其他用途。 就这个例子来说在 eatFood方法调用中，代理类在调用具体实现类之前添加<code>System.out.println(&quot;proxy Lion exec eatFood &quot;);</code>语句 就是添加间接性带来的收益。代理类存在的意义是为了增加一些公共的逻辑代码。</p><h2 id="动态代理类-基于接口实现"><a href="#动态代理类-基于接口实现" class="headerlink" title="动态代理类(基于接口实现)"></a>动态代理类(基于接口实现)</h2><blockquote><p>静态代理是代理类在代码运行前已经创建好，并生成class文件；动态代理类 是代理类在程序运行时创建的代理模式。</p></blockquote><p>动态代理类的代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。 想想你有100个静态代理类，现在有一个需求，每个代理类都需要新增一个处理逻辑，你需要打开100个代理类在每个代理方法里面新增处理逻辑吗？ 有或者代理类有5个方法，每个方法都需要新增一个处理逻辑， 你需要在每个方法都手动新增处理逻辑吗？ 想想就挺无趣的。动态代理类帮你一键搞定。</p><h3 id="动态代理类涉及角色"><a href="#动态代理类涉及角色" class="headerlink" title="动态代理类涉及角色"></a>动态代理类涉及角色</h3><ul><li>委托类和代理类实现的公共接口(Person.java)</li><li>实现公共接口的具体委托类(SoftwareEngineer.java)</li><li>InvocationHandler接口被Proxy类回调处理，一般实现 InvocationHandler 接口的类具有委托类引用，接口方法 invoke 中添加公共代码并调用委托类的接口方法。(PersonInvocationHandler.java)</li><li>JDK提供生成动态代理类的核心类Proxy ( JDK 提供的Proxy.java)</li></ul><h3 id="基于JDK技术-动态代理类技术核心-Proxy类和一个-InvocationHandler-接口"><a href="#基于JDK技术-动态代理类技术核心-Proxy类和一个-InvocationHandler-接口" class="headerlink" title="基于JDK技术 动态代理类技术核心 Proxy类和一个 InvocationHandler 接口"></a>基于JDK技术 动态代理类技术核心 Proxy类和一个 InvocationHandler 接口</h3><p>java的java.lang.reflect包下提供了Proxy类和一个 InvocationHandler 接口，这个类Proxy定义了生成JDK动态代理类的方法 <code>getProxyClass(ClassLoader loader,Class&lt;?&gt;... interfaces)</code>生成动态代理类,返回class实例代表一个class文件。可以保存该 class 文件查看jdk生成的代理类文件长什么样</p><p>该生成的动态代理类继承Proxy类，(重要特性) ，并实现公共接口。</p><p>InvocationHandler这个接口 是被动态代理类回调的接口，我们所有需要增加的针对委托类的统一处理逻辑都增加到invoke 方法里面在调用委托类接口方法之前或之后 结束战斗。</p><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><h5 id="公共接口"><a href="#公共接口" class="headerlink" title="公共接口"></a>公共接口</h5><div class="hljs code-wrapper"><pre><code class="hljs javascript">package org.vincent.proxy.dynamicproxy;<span class="hljs-comment">/**</span><span class="hljs-comment">* Created by PengRong on 2018/12/25.</span><span class="hljs-comment">* 创建Person 接口 用于定义 委托类和代理类之间的约束行为</span><span class="hljs-comment">*/</span>public interface Person&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">    *</span><span class="hljs-comment">    * <span class="hljs-doctag">@param </span>name 人名</span><span class="hljs-comment">    * <span class="hljs-doctag">@param </span>dst 工作目的地</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">void</span> goWorking(<span class="hljs-built_in">String</span> name, <span class="hljs-built_in">String</span> dst);    <span class="hljs-comment">/**</span><span class="hljs-comment">    * 获取名称</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">    */</span>   <span class="hljs-built_in">String</span> getName( );    <span class="hljs-comment">/**</span><span class="hljs-comment">    * 设置名称</span><span class="hljs-comment">    * <span class="hljs-doctag">@param <span class="hljs-variable">name</span></span></span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">void</span>  setName(<span class="hljs-built_in">String</span> name);&#125;</code></pre></div><h5 id="具体实现类，等下被委托，被代理的类-SoftwareEngineer-java"><a href="#具体实现类，等下被委托，被代理的类-SoftwareEngineer-java" class="headerlink" title="具体实现类，等下被委托，被代理的类 SoftwareEngineer.java"></a>具体实现类，等下被委托，被代理的类 SoftwareEngineer.java</h5><div class="hljs code-wrapper"><pre><code class="hljs javascript">package org.vincent.proxy.dynamicproxy;<span class="hljs-comment">/**</span><span class="hljs-comment">* Created by PengRong on 2018/12/25.</span><span class="hljs-comment">* 动态代理委托类实现， 实现接口 Person。 被动态生成的代理类代理</span><span class="hljs-comment">*/</span>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SoftwareEngineer</span> <span class="hljs-title">implements</span> <span class="hljs-title">Person</span> </span>&#123;    public <span class="hljs-function"><span class="hljs-title">SoftwareEngineer</span>(<span class="hljs-params"></span>)</span> &#123;&#125;    public <span class="hljs-function"><span class="hljs-title">SoftwareEngineer</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;    &#125;    private <span class="hljs-built_in">String</span> name;    @Override    public <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> name;    &#125;    @Override    public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">setName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;    &#125;    @Override    public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">goWorking</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name, <span class="hljs-built_in">String</span> dst</span>)</span> &#123;        System.out.println(<span class="hljs-string">&quot;name =&quot;</span> + name + <span class="hljs-string">&quot; ， 去 &quot;</span> + dst + <span class="hljs-string">&quot; 工作&quot;</span>);    &#125;&#125;</code></pre></div><h5 id="InvocationHandler-接口实现-PersonInvocationHandler-java"><a href="#InvocationHandler-接口实现-PersonInvocationHandler-java" class="headerlink" title="InvocationHandler 接口实现 PersonInvocationHandler.java"></a>InvocationHandler 接口实现 PersonInvocationHandler.java</h5><div class="hljs code-wrapper"><pre><code class="hljs javascript">package org.vincent.proxy.dynamicproxy;<span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<span class="hljs-keyword">import</span> java.lang.reflect.Method;<span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-comment">/**</span><span class="hljs-comment">* Created by PengRong on 2018/12/25.</span><span class="hljs-comment">* PersonInvocationHandler 类 实现InvocationHandler接口，这个类中持有一个被代理对象(委托类)的实例target。该类别JDK Proxy类回调</span><span class="hljs-comment">* InvocationHandler 接口中有一个invoke方法，当一个代理实例的方法被调用时，代理方法将被编码并分发到 InvocationHandler接口的invoke方法执行。</span><span class="hljs-comment">*/</span>public PersonInvocationHandler&lt;T&gt; implements InvocationHandler &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 被代理对象引用，invoke 方法里面method 需要使用这个 被代理对象</span><span class="hljs-comment">     */</span>    T target;    public <span class="hljs-function"><span class="hljs-title">PersonInvocationHandler</span>(<span class="hljs-params">T target</span>)</span> &#123;        <span class="hljs-built_in">this</span>.target = target;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 在</span><span class="hljs-comment">     * </span><span class="hljs-comment">     * <span class="hljs-doctag">@param </span>proxy 代表动态生成的 动态代理 对象实例</span><span class="hljs-comment">     * <span class="hljs-doctag">@param </span>method 代表被调用委托类的接口方法，和生成的代理类实例调用的接口方法是一致的，它对应的Method 实例</span><span class="hljs-comment">     * <span class="hljs-doctag">@param </span>args 代表调用接口方法对应的Object参数数组，如果接口是无参，则为null； 对于原始数据类型返回的他的包装类型。</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     * <span class="hljs-doctag">@throws <span class="hljs-variable">Throwable</span></span></span><span class="hljs-comment">     */</span>    @Override    public <span class="hljs-built_in">Object</span> invoke(<span class="hljs-built_in">Object</span> proxy, Method method, <span class="hljs-built_in">Object</span>[] args) throws Throwable &#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 在转调具体目标对象之前，可以执行一些功能处理</span><span class="hljs-comment">         */</span>        System.out.println(<span class="hljs-string">&quot;被动态代理类回调执行, 代理类 proxyClass =&quot;</span> + proxy.getClass() + <span class="hljs-string">&quot; 方法名: &quot;</span> + method.getName()            + <span class="hljs-string">&quot;方法. 方法返回类型：&quot;</span> + method.getReturnType()            + <span class="hljs-string">&quot; 接口方法入参数组: &quot;</span> + (args == <span class="hljs-literal">null</span> ? <span class="hljs-string">&quot;null&quot;</span> : Arrays.toString(args)));        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 代理过程中插入监测方法,计算该方法耗时</span><span class="hljs-comment">         */</span>        MonitorUtil.start();        Thread.sleep(<span class="hljs-number">1</span>); <span class="hljs-comment">/** 调用呗代理对象的真实方法， */</span>        <span class="hljs-built_in">Object</span> result = method.invoke(target, args);        MonitorUtil.finish(method.getName());        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre></div><h5 id="PersonInvocationHandler-invoke-方法中添加的公共代码，这里简单以统计方法执行时间为逻辑"><a href="#PersonInvocationHandler-invoke-方法中添加的公共代码，这里简单以统计方法执行时间为逻辑" class="headerlink" title="PersonInvocationHandler invoke 方法中添加的公共代码，这里简单以统计方法执行时间为逻辑"></a>PersonInvocationHandler invoke 方法中添加的公共代码，这里简单以统计方法执行时间为逻辑</h5><div class="hljs code-wrapper"><pre><code class="hljs javascript">package org.vincent.proxy.dynamicproxy;<span class="hljs-comment">/**</span><span class="hljs-comment">* Created by PengRong on 2018/12/25.</span><span class="hljs-comment">* 方法用时监控类</span><span class="hljs-comment">*/</span>public MonitorUtil &#123;    private <span class="hljs-keyword">static</span> ThreadLocal&lt;Long&gt; tl = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">start</span>(<span class="hljs-params"></span>)</span> &#123;        tl.set(System.currentTimeMillis());    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 结束时打印耗时</span><span class="hljs-comment">     * </span><span class="hljs-comment">     * <span class="hljs-doctag">@param </span>methodName 方法名</span><span class="hljs-comment">     */</span>    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">finish</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> methodName</span>)</span> &#123;        long finishTime = System.currentTimeMillis();        System.out.println(methodName + <span class="hljs-string">&quot;方法执行耗时&quot;</span> + (finishTime - tl.get()) + <span class="hljs-string">&quot;ms&quot;</span>);    &#125;&#125;</code></pre></div><h5 id="最后的是-怎么创建代理类"><a href="#最后的是-怎么创建代理类" class="headerlink" title="最后的是 怎么创建代理类"></a>最后的是 怎么创建代理类</h5><div class="hljs code-wrapper"><pre><code class="hljs javascript">package org.vincent.proxy.jdkdynamicProxy;<span class="hljs-keyword">import</span> org.vincent.proxy.dynamicproxy.Person;<span class="hljs-keyword">import</span> org.vincent.proxy.dynamicproxy.PersonInvocationHandler;<span class="hljs-keyword">import</span> org.vincent.proxy.dynamicproxy.SoftwareEngineer;<span class="hljs-keyword">import</span> sun.misc.ProxyGenerator;<span class="hljs-keyword">import</span> java.io.FileOutputStream;<span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<span class="hljs-keyword">import</span> java.lang.reflect.Field;<span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<span class="hljs-keyword">import</span> java.nio.file.Path;<span class="hljs-keyword">import</span> java.nio.file.Paths;<span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">import</span> java.util.Properties;<span class="hljs-comment">/**</span><span class="hljs-comment">* 动态代理类测试</span><span class="hljs-comment">* Created by PengRong on 2018/12/25.</span><span class="hljs-comment">*/</span>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdkDynamicProxyTest</span> </span>&#123;    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-built_in">String</span>[] args) throws Exception &#123; <span class="hljs-comment">// 打开保存JDK动态代理生成的类文件</span>        saveGeneratedJdkProxyFiles();        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 第一种方法: 通过 Proxy.newProxyInstance 方法 获取代理对象</span><span class="hljs-comment">         */</span>        System.out.println(<span class="hljs-string">&quot;-------------------第一种创建代理类方法--------------&quot;</span>);        <span class="hljs-comment">// 创建一个实例对象，这个对象是被代理的对象，委托类</span>        Person person = <span class="hljs-keyword">new</span> SoftwareEngineer(<span class="hljs-string">&quot;Vincent&quot;</span>);        <span class="hljs-comment">// 创建一个与代理类相关联的InvocationHandler,每一个代理类都有一个关联的</span>        <span class="hljs-comment">// InvocationHandler，并将代理类引用传递进去</span>        InvocationHandler Handler = <span class="hljs-keyword">new</span> PersonInvocationHandler&lt;&gt;(person);        <span class="hljs-comment">// 创建一个 代理对象 personProxy 来代理</span>        <span class="hljs-comment">// person，创建的代理对象的每个执行方法都会被替换执行Invocation接口中的invoke方法</span>        Person personProxy = (Person)<span class="hljs-built_in">Proxy</span>.newProxyInstance(Person.class.getClassLoader(),            <span class="hljs-keyword">new</span> Class&lt;?&gt;[] &#123;Person.class&#125;, Handler);        <span class="hljs-comment">/** 代理类信息 */</span>        System.out.println(<span class="hljs-string">&quot;package = &quot;</span> + personProxy.getClass().getPackage() + <span class="hljs-string">&quot; SimpleName = &quot;</span>            + personProxy.getClass().getSimpleName() + <span class="hljs-string">&quot; name =&quot;</span> + personProxy.getClass().getName()            + <span class="hljs-string">&quot; CanonicalName = &quot;</span> + <span class="hljs-string">&quot;&quot;</span> + personProxy.getClass().getCanonicalName() + <span class="hljs-string">&quot; 实现的接口 Interfaces = &quot;</span>            + Arrays.toString(personProxy.getClass().getInterfaces()) + <span class="hljs-string">&quot; superClass = &quot;</span>            + personProxy.getClass().getSuperclass() + <span class="hljs-string">&quot; methods =&quot;</span>            + Arrays.toString(personProxy.getClass().getMethods()));        <span class="hljs-comment">// 通过 代理类 执行 委托类的代码逻辑</span>        personProxy.goWorking(personProxy.getName(), <span class="hljs-string">&quot;深圳&quot;</span>);        System.out.println(<span class="hljs-string">&quot;-------------------第二种创建代理类方法--------------&quot;</span>);        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 动态代理对象步骤</span><span class="hljs-comment">         * 1、 创建一个与代理对象相关联的</span><span class="hljs-comment">         * InvocationHandler，以及真实的委托类实例</span><span class="hljs-comment">         * 2、Proxy类的getProxyClass静态方法生成一个动态代理类stuProxyClass，该类继承Proxy类，实现</span><span class="hljs-comment">         * Person.java接口；JDK动态代理的特点是代理类必须继承Proxy类</span><span class="hljs-comment">         * 3、通过代理类 proxyClass 获得他的带InvocationHandler</span><span class="hljs-comment">         * 接口的构造函数 ProxyConstructor</span><span class="hljs-comment">         * 4、通过 构造函数实例 ProxyConstructor 实例化一个代理对象，并将</span><span class="hljs-comment">         * InvocationHandler 接口实例传递给代理类。</span><span class="hljs-comment">         */</span>        <span class="hljs-comment">// 1、创建 InvocationHandler 实例并设置代理的目标类对象</span>        Person persontwo = <span class="hljs-keyword">new</span> SoftwareEngineer(<span class="hljs-string">&quot;Vincent&quot;</span>);        InvocationHandler Handlertwo = <span class="hljs-keyword">new</span> PersonInvocationHandler&lt;&gt;(persontwo);        <span class="hljs-comment">// 2 创建代理类,是一个字节码文件, 把 proxyClass</span>        <span class="hljs-comment">// 保存起来就能看到 他继承Proxy 类，实现Person接口</span>        Class&lt;?&gt; proxyClass = <span class="hljs-built_in">Proxy</span>.getProxyClass(Person.class.getClassLoader(), <span class="hljs-keyword">new</span> Class&lt;?&gt;[] &#123;Person.class&#125;);        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 代理类信息</span><span class="hljs-comment">         */</span>        System.out.println(<span class="hljs-string">&quot;package = &quot;</span> + proxyClass.getPackage() + <span class="hljs-string">&quot; SimpleName = &quot;</span> + proxyClass.getSimpleName()            + <span class="hljs-string">&quot; name =&quot;</span> + proxyClass.getName() + <span class="hljs-string">&quot; CanonicalName = &quot;</span> + <span class="hljs-string">&quot;&quot;</span> + proxyClass.getCanonicalName()            + <span class="hljs-string">&quot; 实现的接口 Interfaces = &quot;</span> + Arrays.toString(proxyClass.getInterfaces()) + <span class="hljs-string">&quot; superClass = &quot;</span>            + proxyClass.getSuperclass() + <span class="hljs-string">&quot; methods =&quot;</span> + Arrays.toString(proxyClass.getMethods()));        <span class="hljs-comment">// 3、 通过 proxyClass</span>        <span class="hljs-comment">// 获得</span>        <span class="hljs-comment">// 一个带有InvocationHandler参数的构造器constructor</span>        Constructor&lt;?&gt; ProxyConstructor = proxyClass.getConstructor(InvocationHandler.class);        <span class="hljs-comment">// 4、通过构造器创建一个 动态代理类 实例</span>        Person stuProxy = (Person)ProxyConstructor.newInstance(Handlertwo);        <span class="hljs-comment">/** 检测生成的类是否是代理类 */</span>        System.out.println(<span class="hljs-string">&quot;stuProxy isProxy &quot;</span> + <span class="hljs-built_in">Proxy</span>.isProxyClass(stuProxy.getClass()));        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 获取 代理类关联的</span><span class="hljs-comment">         * InvocationHandler 是哪个</span><span class="hljs-comment">         */</span>        InvocationHandler handlerObject = <span class="hljs-built_in">Proxy</span>.getInvocationHandler(stuProxy);        System.out.println(handlerObject.getClass().getName());        stuProxy.goWorking(stuProxy.getName(), <span class="hljs-string">&quot;广州&quot;</span>);        <span class="hljs-comment">// 保存代理類</span>        saveClass(<span class="hljs-string">&quot;$PersonProxy0&quot;</span>, proxyClass.getInterfaces(), <span class="hljs-string">&quot;D:/123/&quot;</span>);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">    * 设置保存Java动态代理生成的类文件。</span><span class="hljs-comment">    *</span><span class="hljs-comment">    * <span class="hljs-doctag">@throws <span class="hljs-variable">Exception</span></span></span><span class="hljs-comment">    */</span>   public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> saveGeneratedJdkProxyFiles() throws Exception &#123;       Field field = System.class.getDeclaredField(<span class="hljs-string">&quot;props&quot;</span>);       field.setAccessible(<span class="hljs-literal">true</span>);       Properties props = (Properties) field.get(<span class="hljs-literal">null</span>);       props.put(<span class="hljs-string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);   &#125;&#125;</code></pre></div><h4 id="解析JDK生成的动态代理类"><a href="#解析JDK生成的动态代理类" class="headerlink" title="解析JDK生成的动态代理类"></a>解析JDK生成的动态代理类</h4><p>saveGeneratedJdkProxyFiles方法 打开了存储jdk生成的动态代理类 以 接口方法 goWorking 为例讲解</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">public final <span class="hljs-class"><span class="hljs-keyword">class</span> $<span class="hljs-title">PersonProxy0</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Proxy</span> <span class="hljs-title">implements</span> <span class="hljs-title">Person</span> </span>&#123;    private <span class="hljs-keyword">static</span> Method m1;    private <span class="hljs-keyword">static</span> Method m5;    private <span class="hljs-keyword">static</span> Method m4;    private <span class="hljs-keyword">static</span> Method m2;    private <span class="hljs-keyword">static</span> Method m3;    private <span class="hljs-keyword">static</span> Method m0;    public $PersonProxy0(InvocationHandler var1) throws  &#123;        <span class="hljs-built_in">super</span>(var1);    &#125;    public final boolean equals(<span class="hljs-built_in">Object</span> var1) throws  &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> (<span class="hljs-built_in">Boolean</span>)<span class="hljs-built_in">super</span>.h.invoke(<span class="hljs-built_in">this</span>, m1, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>[]&#123;var1&#125;);        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | <span class="hljs-built_in">Error</span> var3) &#123;            <span class="hljs-keyword">throw</span> var3;        &#125; <span class="hljs-keyword">catch</span> (Throwable var4) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var4);        &#125;    &#125;    public final <span class="hljs-keyword">void</span> setName(<span class="hljs-built_in">String</span> var1) throws  &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-built_in">super</span>.h.invoke(<span class="hljs-built_in">this</span>, m5, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>[]&#123;var1&#125;);        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | <span class="hljs-built_in">Error</span> var3) &#123;            <span class="hljs-keyword">throw</span> var3;        &#125; <span class="hljs-keyword">catch</span> (Throwable var4) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var4);        &#125;    &#125;    public final <span class="hljs-built_in">String</span> getName() throws  &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> (<span class="hljs-built_in">String</span>)<span class="hljs-built_in">super</span>.h.invoke(<span class="hljs-built_in">this</span>, m4, (<span class="hljs-built_in">Object</span>[])<span class="hljs-literal">null</span>);        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | <span class="hljs-built_in">Error</span> var2) &#123;            <span class="hljs-keyword">throw</span> var2;        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var3);        &#125;    &#125;    public final <span class="hljs-built_in">String</span> toString() throws  &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> (<span class="hljs-built_in">String</span>)<span class="hljs-built_in">super</span>.h.invoke(<span class="hljs-built_in">this</span>, m2, (<span class="hljs-built_in">Object</span>[])<span class="hljs-literal">null</span>);        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | <span class="hljs-built_in">Error</span> var2) &#123;            <span class="hljs-keyword">throw</span> var2;        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var3);        &#125;    &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 对接口  goWorking 的调用 转变成   super.h.invoke(this, m5, new Object[]&#123;var1, var2&#125;); 调用。</span><span class="hljs-comment">         * h 就是Proxy.java类的一个 InvocationHandler 接口 属性，</span><span class="hljs-comment">         * 我们在创建 动态代理类实例时候都必须 传一个 InvocationHandler 接口的实例过去。 这里就是刚才我们定义的 PersonInvocationHandler 。</span><span class="hljs-comment">         * 回到过后是不是就回到了 PersonInvocationHandler.invoke方法里面，所以 PersonInvocationHandler 是我们生成的动态代理类的拦截器，拦截所有方法调用。</span><span class="hljs-comment"> */</span>    public final <span class="hljs-keyword">void</span> goWorking(<span class="hljs-built_in">String</span> var1, <span class="hljs-built_in">String</span> var2) throws  &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-built_in">super</span>.h.invoke(<span class="hljs-built_in">this</span>, m3, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>[]&#123;var1, var2&#125;);        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | <span class="hljs-built_in">Error</span> var4) &#123;            <span class="hljs-keyword">throw</span> var4;        &#125; <span class="hljs-keyword">catch</span> (Throwable var5) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var5);        &#125;    &#125;    public final int hashCode() throws  &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> (Integer)<span class="hljs-built_in">super</span>.h.invoke(<span class="hljs-built_in">this</span>, m0, (<span class="hljs-built_in">Object</span>[])<span class="hljs-literal">null</span>);        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | <span class="hljs-built_in">Error</span> var2) &#123;            <span class="hljs-keyword">throw</span> var2;        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var3);        &#125;    &#125; <span class="hljs-comment">/**</span><span class="hljs-comment">     * 静态代码块，根据动态代理实现的公共接口类接口方法 获取到所有接口方法 的 Method 实例</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-keyword">try</span> &#123;            m1 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;equals&quot;</span>, Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>));            m5 = Class.forName(<span class="hljs-string">&quot;com.luna.common.xml.Person&quot;</span>).getMethod(<span class="hljs-string">&quot;setName&quot;</span>, Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>));            m4 = Class.forName(<span class="hljs-string">&quot;com.luna.common.xml.Person&quot;</span>).getMethod(<span class="hljs-string">&quot;getName&quot;</span>);            m2 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;toString&quot;</span>);            m3 = Class.forName(<span class="hljs-string">&quot;com.luna.common.xml.Person&quot;</span>).getMethod(<span class="hljs-string">&quot;goWorking&quot;</span>, Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>), Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>));            m0 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;hashCode&quot;</span>);        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException var2) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchMethodError(var2.getMessage());        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException var3) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoClassDefFoundError(var3.getMessage());        &#125;    &#125;&#125;</code></pre></div><p>Jdk为我们的生成了一个叫$Proxy0（这个名字后面的0是编号，有多个代理类会一次递增）的代理类，这个类文件时默认不会保存在文件，<code>放在内存中的</code>，我们在创建代理对象时，就是通过反射获得这个类的构造方法，然后创建代理对象实例。通过对这个生成的代理类源码的查看，我们很容易能看出，动态代理实现的具体过程。</p><p>我们可以对 InvocationHandler 看做一个中介类，中介类持有一个被代理对象，被Proxy类回调。在invoke方法中调用了被代理对象的相应方法。通过聚合方式持有被代理对象的引用，把客户端对invoke的调用最终都转为对被代理对象的调用。</p><blockquote><p>客户端代码通过代理类引用调用接口方法时，通过代理类关联的中介类对象引用来调用中介类对象的invoke方法，从而达到代理执行被代理对象的方法。也就是说，动态代理Proxy类提供了模板实现，对外提供扩展点，外部通过实现InvocationHandler接口将被代理类纳入JDK代理类Proxy。</p></blockquote><h4 id="一个典型的基于JDK动态代理创建对象过程可分为以下四个步骤："><a href="#一个典型的基于JDK动态代理创建对象过程可分为以下四个步骤：" class="headerlink" title="一个典型的基于JDK动态代理创建对象过程可分为以下四个步骤："></a>一个典型的基于JDK动态代理创建对象过程可分为以下四个步骤：</h4><p>1、通过实现InvocationHandler接口创建自己的调用处理器 IvocationHandler handler = new InvocationHandlerImpl(…);</p><p>2、通过为Proxy类指定ClassLoader对象和一组interface代理类需要实现的接口，创建动态代理类类文件，默认JDK并不会保存这个文件到文件中；可以保存起来观察生成的代理类结构<code>Class clazz = Proxy.getProxyClass(classLoader,new Class[]&#123;...&#125;);</code></p><p>3、通过上面新建的代理clazz的反射机制获取动态代理类的一个构造函数，其构造函数入参类型是调用处理器接口(<code>IvocationHandler</code>)类型 <code>Constructor constructor = clazz.getConstructor(new Class[]&#123;InvocationHandler.class&#125;);</code></p><p>4、通过构造函数实例创建代理类实例，此时需将调用处理器对象作为参数被传入 Interface Proxy = (Interface)constructor.newInstance(new Object[] (handler)); 为了简化对象创建过程，<code>Proxy类中的newInstance工具方法封装了2~4</code>，只需两步即可完成代理对象的创建。</p><h4 id="JDK动态代理特点总结"><a href="#JDK动态代理特点总结" class="headerlink" title="JDK动态代理特点总结"></a>JDK动态代理特点总结</h4><ul><li>生成的代理类：$Proxy0 extends Proxy implements Person，我们看到代理类继承了Proxy类，Java的继承机制决定了JDK动态代理类们无法实现对 类 的动态代理。所以也就决定了java动态代理只能对接口进行代理，</li><li>每个生成的动态代理实例都会关联一个调用处理器对象，可以通过 Proxy 提供的静态方法 getInvocationHandler 去获得代理类实例的调用处理器对象。在代理类实例上调用其代理的接口中所声明的方法时，这些方法最终都会由调用处理器的 invoke 方法执行</li><li>代理类的根类 java.lang.Object 中有三个方法也同样会被分派到调用处理器的 invoke 方法执行，它们是 hashCode，equals 和 toString，可能的原因有：一是因为这些方法为 public 且非 final 类型，能够被代理类覆盖； 二是因为这些方法往往呈现出一个类的某种特征属性，具有一定的区分度，所以为了保证代理类与委托类对外的一致性，<code>这三个方法也应该被调用处理器分派到委托类执行。</code></li></ul><h4 id="JDK动态代理不足"><a href="#JDK动态代理不足" class="headerlink" title="JDK动态代理不足"></a>JDK动态代理不足</h4><p>JDK动态代理的代理类字节码在创建时，需要实现业务实现类所实现的接口作为参数。如果业务实现类是没有实现接口而是直接定义业务方法的话，就无法使用JDK动态代理了。(JDK动态代理重要特点是代理接口) 并且，如果业务实现类中新增了接口中没有的方法，这些方法是无法被代理的（因为无法被调用）。</p><blockquote><p>动态代理只能对接口产生代理，不能对类产生代理</p></blockquote><h3 id="基于CGlib-技术动态代理代理类实现-基于继承"><a href="#基于CGlib-技术动态代理代理类实现-基于继承" class="headerlink" title="基于CGlib 技术动态代理代理类实现 (基于继承)"></a>基于CGlib 技术动态代理代理类实现 (基于继承)</h3><p>Cglib是针对类来实现代理的，他的原理是对代理的目标类生成一个子类，并覆盖其中方法实现增强，因为底层是基于创建被代理类的一个子类，所以它避免了JDK动态代理类的缺陷。</p><p>但因为采用的是继承，所以不能对final修饰的类进行代理。final修饰的类不可继承。</p><h4 id="导入maven-依赖"><a href="#导入maven-依赖" class="headerlink" title="导入maven 依赖"></a>导入maven 依赖</h4><p>cglib 是基于asm 字节修改技术。导入 cglib 会间接导入 asm, ant, ant-launcher 三个jar 包。</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">&lt;!-- cglib 动态代理依赖 begin --&gt; &lt;dependency&gt;   &lt;groupId&gt;cglib&lt;/groupId&gt;   &lt;artifactId&gt;cglib&lt;/artifactId&gt;   &lt;version&gt;<span class="hljs-number">3.2</span><span class="hljs-number">.5</span>&lt;<span class="hljs-regexp">/version&gt;&lt;/</span>dependency&gt;&lt;!-- cglib 动态代理依赖 stop --&gt;</code></pre></div><h4 id="业务类实现"><a href="#业务类实现" class="headerlink" title="业务类实现"></a>业务类实现</h4><p>cglib是针对类来实现代理的，原理是对指定的业务类生成他的一个子类，并覆盖其中的业务方法来实现代理。因为采用的是继承，所以不能对final修饰的类进行代理。</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">package org.vincent.proxy.cglibproxy;<span class="hljs-comment">/**</span><span class="hljs-comment">* <span class="hljs-doctag">@Package</span>: org.vincent.proxy.cglibproxy &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Description</span>： Cglib 代理模式中 被代理的委托类 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@author</span>: lenovo &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Company</span>: PLCC &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Copyright</span>: Copyright (c) 2019 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Version</span>: 1.0 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Modified </span>By: &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Created </span>by lenovo on 2018/12/26-17:55 &lt;br/&gt;</span><span class="hljs-comment">*/</span>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;    public <span class="hljs-built_in">String</span>  <span class="hljs-function"><span class="hljs-title">call</span>(<span class="hljs-params"></span>)</span> &#123;       System.out.println(<span class="hljs-string">&quot;wang wang wang&quot;</span>);         <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Dog ..&quot;</span>;   &#125;&#125;</code></pre></div><h4 id="方法拦截器-实现-MethodInterceptor-接口"><a href="#方法拦截器-实现-MethodInterceptor-接口" class="headerlink" title="方法拦截器 实现 MethodInterceptor 接口"></a>方法拦截器 实现 MethodInterceptor 接口</h4><div class="hljs code-wrapper"><pre><code class="hljs javascript">package org.vincent.proxy.cglibproxy;<span class="hljs-keyword">import</span> net.sf.cglib.proxy.Enhancer;<span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;<span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodProxy;<span class="hljs-keyword">import</span> java.lang.reflect.Method;<span class="hljs-comment">/**</span><span class="hljs-comment">* <span class="hljs-doctag">@Package</span>: org.vincent.proxy.cglibproxy &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Description</span>： Cglib 方法拦截器,不用依赖被代理业务类的引用。  &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@author</span>: lenovo &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Company</span>: PLCC &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Copyright</span>: Copyright (c) 2019 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Version</span>: 1.0 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Modified </span>By: &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Created </span>by lenovo on 2018/12/26-17:56 &lt;br/&gt;</span><span class="hljs-comment">*/</span>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CglibMethodInterceptor</span> <span class="hljs-title">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">    * 用于生成 Cglib 动态代理类工具方法</span><span class="hljs-comment">    * <span class="hljs-doctag">@param </span>target 代表需要 被代理的 委托类的 Class 对象</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">    */</span>   public <span class="hljs-built_in">Object</span> <span class="hljs-function"><span class="hljs-title">CglibProxyGeneratory</span>(<span class="hljs-params">Class target</span>)</span> &#123;        <span class="hljs-comment">/** 创建cglib 代理类 start */</span>       <span class="hljs-comment">// 创建加强器，用来创建动态代理类</span>       Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();        <span class="hljs-comment">// 为代理类指定需要代理的类，也即是父类</span>       enhancer.setSuperclass(target);        <span class="hljs-comment">// 设置方法拦截器回调引用，对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept() 方法进行拦截</span>       enhancer.setCallback(<span class="hljs-built_in">this</span>);        <span class="hljs-comment">// 获取动态代理类对象并返回</span>       <span class="hljs-keyword">return</span> enhancer.create();        <span class="hljs-comment">/** 创建cglib 代理类 end */</span>   &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">    * 功能主要是在调用业务类方法之前 之后添加统计时间的方法逻辑.</span><span class="hljs-comment">    * intercept 因为  具有 MethodProxy proxy 参数的原因 不再需要代理类的引用对象了,直接通过proxy 对象访问被代理对象的方法(这种方式更快)。</span><span class="hljs-comment">    * 当然 也可以通过反射机制，通过 method 引用实例    Object result = method.invoke(target, args); 形式反射调用被代理类方法，</span><span class="hljs-comment">    * target 实例代表被代理类对象引用, 初始化 CglibMethodInterceptor 时候被赋值 。但是Cglib不推荐使用这种方式</span><span class="hljs-comment">    * <span class="hljs-doctag">@param </span>obj    代表Cglib 生成的动态代理类 对象本身</span><span class="hljs-comment">    * <span class="hljs-doctag">@param </span>method 代理类中被拦截的接口方法 Method 实例</span><span class="hljs-comment">    * <span class="hljs-doctag">@param </span>args   接口方法参数</span><span class="hljs-comment">    * <span class="hljs-doctag">@param </span>proxy  用于调用父类真正的业务类方法。可以直接调用被代理类接口方法</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">    * <span class="hljs-doctag">@throws <span class="hljs-variable">Throwable</span></span></span><span class="hljs-comment">    */</span>   @Override   public <span class="hljs-built_in">Object</span> intercept(<span class="hljs-built_in">Object</span> obj, Method method, <span class="hljs-built_in">Object</span>[] args, MethodProxy proxy) throws Throwable &#123;       System.out.println(<span class="hljs-string">&quot;before&quot;</span>);       MonitorUtil.start();       <span class="hljs-built_in">Object</span> result = proxy.invokeSuper(obj, args);        <span class="hljs-comment">//Object result = method.invoke(target, args);</span>       System.out.println(<span class="hljs-string">&quot;after&quot;</span>);       MonitorUtil.finish(method.getName());        <span class="hljs-keyword">return</span> result;   &#125;&#125;</code></pre></div><h4 id="一个切面，用于在方法拦截器中intercept-方法中调用真正业务方法之前-之后处理逻辑"><a href="#一个切面，用于在方法拦截器中intercept-方法中调用真正业务方法之前-之后处理逻辑" class="headerlink" title="一个切面，用于在方法拦截器中intercept 方法中调用真正业务方法之前 之后处理逻辑"></a>一个切面，用于在方法拦截器中intercept 方法中调用真正业务方法之前 之后处理逻辑</h4><div class="hljs code-wrapper"><pre><code class="hljs javascript">package org.vincent.proxy.cglibproxy;<span class="hljs-comment">/**</span><span class="hljs-comment">* Created by PengRong on 2018/12/25.</span><span class="hljs-comment">* 方法用时监控类,作为一个切面 ，具有两个方法</span><span class="hljs-comment">*/</span>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MonitorUtil</span> </span>&#123;    private <span class="hljs-keyword">static</span> ThreadLocal&lt;Long&gt; tl = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">start</span>(<span class="hljs-params"></span>)</span> &#123;        tl.set(System.currentTimeMillis());    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 结束时打印耗时</span><span class="hljs-comment">     * </span><span class="hljs-comment">     * <span class="hljs-doctag">@param </span>methodName 方法名</span><span class="hljs-comment">     */</span>    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">finish</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> methodName</span>)</span> &#123;        long finishTime = System.currentTimeMillis();        System.out.println(methodName + <span class="hljs-string">&quot;方法执行耗时&quot;</span> + (finishTime - tl.get()) + <span class="hljs-string">&quot;ms&quot;</span>);    &#125;&#125;</code></pre></div><h4 id="Cglib测试类"><a href="#Cglib测试类" class="headerlink" title="Cglib测试类"></a>Cglib测试类</h4><div class="hljs code-wrapper"><pre><code class="hljs javascript">package org.vincent.proxy.cglibproxy;<span class="hljs-keyword">import</span> net.sf.cglib.core.DebuggingClassWriter;<span class="hljs-keyword">import</span> net.sf.cglib.proxy.Enhancer;<span class="hljs-keyword">import</span> org.junit.Test;<span class="hljs-keyword">import</span> java.lang.reflect.Field;<span class="hljs-keyword">import</span> java.util.Properties;<span class="hljs-comment">/**</span><span class="hljs-comment">* <span class="hljs-doctag">@Package</span>: org.vincent.proxy.cglibproxy &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Description</span>： TODO &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@author</span>: lenovo &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Company</span>: PLCC &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Copyright</span>: Copyright (c) 2019 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Version</span>: 1.0 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Modified </span>By: &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Created </span>by lenovo on 2018/12/26-18:05 &lt;br/&gt;</span><span class="hljs-comment">*/</span>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CglibTest</span> </span>&#123;      @Test   public <span class="hljs-keyword">void</span> testCglib() throws Exception &#123;       System.out.println(System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>));        <span class="hljs-comment">/** 开启 保存cglib生成的动态代理类类文件*/</span>       saveGeneratedCGlibProxyFiles(System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>));        <span class="hljs-comment">/** 第一种方法: 创建cglib 代理类 start */</span>       <span class="hljs-comment">// 创建加强器，用来创建动态代理类</span>       Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();        <span class="hljs-comment">// 为代理类指定需要代理的类，也即是父类</span>       enhancer.setSuperclass(Dog.class);        <span class="hljs-comment">// new 一个新的方法拦截器</span>       CglibMethodInterceptor cglibMethodInterceptor = <span class="hljs-keyword">new</span> CglibMethodInterceptor();        <span class="hljs-comment">// 设置方法拦截器回调引用，对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept() 方法进行拦截</span>       enhancer.setCallback(cglibMethodInterceptor);        <span class="hljs-comment">// 获取动态代理类对象并返回</span>       Dog dog = (Dog) enhancer.create();        <span class="hljs-comment">/** 创建cglib 代理类 end */</span>       System.out.println(dog.call());        <span class="hljs-comment">// 对于上面这几步，可以新增一个工具方法 放置在 CglibMethodInterceptor 里面；也就有了第二种方法</span>       <span class="hljs-comment">// new 一个新的方法拦截器，该拦截器还顺带一个用于创建代理类的工具方法。看起来简单很多</span>       cglibMethodInterceptor = <span class="hljs-keyword">new</span> CglibMethodInterceptor();       dog = (Dog) cglibMethodInterceptor.CglibProxyGeneratory(Dog.class);       System.out.println(dog.call());   &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">    * 设置保存Cglib代理生成的类文件。</span><span class="hljs-comment">    *</span><span class="hljs-comment">    * <span class="hljs-doctag">@throws <span class="hljs-variable">Exception</span></span></span><span class="hljs-comment">    */</span>   public <span class="hljs-keyword">void</span> saveGeneratedCGlibProxyFiles(<span class="hljs-built_in">String</span> dir) throws Exception &#123;       Field field = System.class.getDeclaredField(<span class="hljs-string">&quot;props&quot;</span>);       field.setAccessible(<span class="hljs-literal">true</span>);       Properties props = (Properties) field.get(<span class="hljs-literal">null</span>);       System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, dir);<span class="hljs-comment">//dir为保存文件路径</span>       props.put(<span class="hljs-string">&quot;net.sf.cglib.core.DebuggingClassWriter.traceEnabled&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);   &#125;&#125;</code></pre></div><h4 id="Cglib-总结"><a href="#Cglib-总结" class="headerlink" title="Cglib 总结"></a>Cglib 总结</h4><ul><li>CGlib可以传入接口也可以传入普通的类，接口使用实现的方式,普通类使用会使用继承的方式生成代理类.</li><li>由于是继承方式,如果是 static方法,private方法,final方法等描述的方法是不能被代理的</li><li>做了方法访问优化，使用建立方法索引的方式避免了传统JDK动态代理需要通过Method方法反射调用.</li><li>提供callback 和filter设计，可以灵活地给不同的方法绑定不同的callback。编码更方便灵活。</li><li>CGLIB会默认代理Object中equals,toString,hashCode,clone等方法。比JDK代理多了clone。</li></ul><h2 id="静态代理-基于JDK动态代理-基于Cglib-动态代理"><a href="#静态代理-基于JDK动态代理-基于Cglib-动态代理" class="headerlink" title="静态代理 基于JDK动态代理 基于Cglib 动态代理"></a>静态代理 基于JDK动态代理 基于Cglib 动态代理</h2><p>静态代理是通过在代码中显式编码定义一个业务实现类的代理类，在代理类中对同名的业务方法进行包装，用户通过代理类调用被包装过的业务方法；</p><div class="note note-success">            <p>JDK动态代理是通过接口中的方法名，在动态生成的代理类中调用业务实现类的同名方法；</p><p>CGlib动态代理是通过继承业务类，生成的动态代理类是业务类的子类，通过重写业务方法进行代理；</p>          </div><p>静态代理在编译时产生class字节码文件，可以直接使用，效率高。动态代理必须实现InvocationHandler接口，通过invoke调用被委托类接口方法是通过反射方式，比较消耗系统性能，但可以减少代理类的数量，使用更灵活。 cglib代理无需实现接口，通过生成类字节码实现代理，比反射稍快，不存在性能问题，但cglib会继承目标对象，需要重写方法，所以目标对象不能为final类。</p><h2 id="AOP-实现案例"><a href="#AOP-实现案例" class="headerlink" title="AOP 实现案例"></a>AOP 实现案例</h2><p>AOP的源码中用到了两种动态代理来实现拦截切入功能：jdk动态代理和cglib动态代理。两种方法同时存在，各有优劣。 jdk动态代理是由java内部的反射机制来实现的，cglib动态代理底层则是借助asm来实现的。 总的来说，<code>反射机制在生成类的过程中比较高效，执行时候通过反射调用委托类接口方法比较慢；而asm在生成类之后的相关代理类执行过程中比较高效（可以通过将asm生成的类进行缓存，这样解决asm生成类过程低效问题）</code>。 还有一点必须注意：jdk动态代理的应用前提，必须是委托类基于统一的接口。如果没有上述前提，jdk动态代理不能应用。 由此可以看出，jdk动态代理有一定的局限性，cglib这种第三方类库实现的动态代理应用更加广泛，且在效率上更有优势。</p><p>实现AOP关键特点是定义好两个角色 切点 和 切面 。 代理模式中被代理类 委托类处于切点角色，需要添加的其他比如 校验逻辑，事务，审计逻辑 属于非功能实现逻辑通过 切面类定义的方法插入进去。</p><h3 id="JDK动态代理-aop-实现方式"><a href="#JDK动态代理-aop-实现方式" class="headerlink" title="JDK动态代理 aop 实现方式"></a>JDK动态代理 aop 实现方式</h3><h4 id="定义切面接口，完成将通用公共方法注入到被代理类接口调用处理中"><a href="#定义切面接口，完成将通用公共方法注入到被代理类接口调用处理中" class="headerlink" title="定义切面接口，完成将通用公共方法注入到被代理类接口调用处理中"></a>定义切面接口，完成将通用公共方法注入到被代理类接口调用处理中</h4><div class="hljs code-wrapper"><pre><code class="hljs javascript">package org.vincent.aop.dynamicproxy;<span class="hljs-comment">/**</span><span class="hljs-comment">* <span class="hljs-doctag">@Package</span>: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Description</span>： 定义切面接口，切面接口定义了两个切面方法，分别在切点接口方法执行前和执行后执行 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@author</span>: lenovo &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Company</span>: PLCC &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Copyright</span>: Copyright (c) 2019 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Version</span>: 1.0 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Modified </span>By: &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Created </span>by lenovo on 2018/12/26 &lt;br/&gt;</span><span class="hljs-comment">*/</span>public interface IAspect &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 在切点接口方法执行之前执行</span><span class="hljs-comment">     * </span><span class="hljs-comment">     * <span class="hljs-doctag">@param </span>args 切点参数列表</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    boolean startTransaction(<span class="hljs-built_in">Object</span>... args);    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 在切点接口方法执行之后执行</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">void</span> endTrasaction();&#125;</code></pre></div><h4 id="定义切面实现类"><a href="#定义切面实现类" class="headerlink" title="定义切面实现类"></a>定义切面实现类</h4><div class="hljs code-wrapper"><pre><code class="hljs javascript">package org.vincent.aop.dynamicproxy;<span class="hljs-keyword">import</span> java.util.Objects;<span class="hljs-comment">/**</span><span class="hljs-comment">* <span class="hljs-doctag">@Package</span>: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Description</span>： 改类作为AOP 模型中切面角色类， 实现切面接口，切面接口定义了两个切面方法，分别在切点接口方法执行前和执行后执行 。 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@author</span>: lenovo &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Company</span>: PLCC &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Copyright</span>: Copyright (c) 2019 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Version</span>: 1.0 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Modified </span>By: &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Created </span>by lenovo on 2018/12/26 &lt;br/&gt;</span><span class="hljs-comment">*/</span>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomAspect</span> <span class="hljs-title">implements</span> <span class="hljs-title">IAspect</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 对参数 做判空处理</span><span class="hljs-comment">     * </span><span class="hljs-comment">     * <span class="hljs-doctag">@param </span>args 切点参数列表</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    @Override    public boolean <span class="hljs-function"><span class="hljs-title">startTransaction</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span>... args</span>)</span> &#123;        Objects.nonNull(args);        boolean result = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">Object</span> temp : args) &#123;            <span class="hljs-keyword">if</span> (Objects.isNull(temp)) &#123;                result = <span class="hljs-literal">false</span>;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;    public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">endTrasaction</span>(<span class="hljs-params"></span>)</span> &#123;        System.out.println(<span class="hljs-string">&quot;I get datasource here and end transaction&quot;</span>);    &#125;&#125;</code></pre></div><h4 id="定义切点角色接口-因为是基于JDK实现的Aop-，所以委托类需要基于接口实现。"><a href="#定义切点角色接口-因为是基于JDK实现的Aop-，所以委托类需要基于接口实现。" class="headerlink" title="定义切点角色接口 因为是基于JDK实现的Aop ，所以委托类需要基于接口实现。"></a>定义切点角色接口 因为是基于JDK实现的Aop ，所以委托类需要基于接口实现。</h4><div class="hljs code-wrapper"><pre><code class="hljs javascript">package org.vincent.aop.dynamicproxy;<span class="hljs-comment">/**</span><span class="hljs-comment">* <span class="hljs-doctag">@Package</span>: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Description</span>： AOP基于动态代理 实现  &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@author</span>: lenovo &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Company</span>: PLCC &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Copyright</span>: Copyright (c) 2019 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Version</span>: 1.0 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Modified </span>By: &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Created </span>by lenovo on 2018/12/26 &lt;br/&gt;</span><span class="hljs-comment">*/</span>public interface IUserService &#123;     <span class="hljs-keyword">void</span> saveUser(<span class="hljs-built_in">String</span> username, <span class="hljs-built_in">String</span> password) throws Exception;&#125;</code></pre></div><h4 id="委托类实现"><a href="#委托类实现" class="headerlink" title="委托类实现"></a>委托类实现</h4><div class="hljs code-wrapper"><pre><code class="hljs javascript">package org.vincent.aop.dynamicproxy;<span class="hljs-comment">/**</span><span class="hljs-comment">* <span class="hljs-doctag">@Package</span>: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Description</span>： UserService接口实现类UserServiceImpl 该类 作为AOP中切点角色，切面定义的方法插入到切点的接口方法 执行前和执行后执行。 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@author</span>: lenovo &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Company</span>: PLCC &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Copyright</span>: Copyright (c) 2019 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Version</span>: 1.0 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Modified </span>By: &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Created </span>by lenovo on 2018/12/26 &lt;br/&gt;</span><span class="hljs-comment">*/</span>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-title">implements</span> <span class="hljs-title">IUserService</span></span>&#123;   @Override   public <span class="hljs-keyword">void</span> saveUser(<span class="hljs-built_in">String</span> username, <span class="hljs-built_in">String</span> password) throws Exception &#123;       System.out.println(<span class="hljs-string">&quot;save user[username=&quot;</span> + username + <span class="hljs-string">&quot;,password=&quot;</span> + password + <span class="hljs-string">&quot;]&quot;</span>);   &#125;&#125;</code></pre></div><h4 id="JDK动态代理生成器工具类"><a href="#JDK动态代理生成器工具类" class="headerlink" title="JDK动态代理生成器工具类"></a>JDK动态代理生成器工具类</h4><p>可以看到 generatorJDKProxy 方法入参只有两个参数 一个切点接口引用，一个切面接口引用；在InvocationHandler 内部类中可以完整看到切面类方法是怎么影响切点代码执行逻辑的。</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">package org.vincent.aop.dynamicproxy;<span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<span class="hljs-keyword">import</span> java.lang.reflect.Method;<span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-comment">/**</span><span class="hljs-comment">* <span class="hljs-doctag">@Package</span>: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Description</span>： JDK动态代理类生成器 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@author</span>: lenovo &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Company</span>: PLCC &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Copyright</span>: Copyright (c) 2019 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Version</span>: 1.0 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Modified </span>By: &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Created </span>by lenovo on 2018/12/26-16:48 &lt;br/&gt;</span><span class="hljs-comment">*/</span>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDKDynamicProxyGenerator</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@param </span>targetPoint 需要被代理的委托类对象</span><span class="hljs-comment">     * <span class="hljs-doctag">@param </span>aspect 切面对象,该对象方法将在切点方法之前或之后执行</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    public <span class="hljs-keyword">static</span> <span class="hljs-built_in">Object</span> <span class="hljs-function"><span class="hljs-title">generatorJDKProxy</span>(<span class="hljs-params">IUserService targetPoint, final IAspect aspect</span>)</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Proxy</span>.newProxyInstance(            <span class="hljs-comment">/**</span><span class="hljs-comment">             * 委托类使用的类加载器</span><span class="hljs-comment">             */</span>            targetPoint.getClass().getClassLoader(),            <span class="hljs-comment">/**</span><span class="hljs-comment">             * 委托类实现的接口</span><span class="hljs-comment">             */</span>            targetPoint.getClass().getInterfaces(),            <span class="hljs-comment">/**</span><span class="hljs-comment">             * 生成的动态代理类关联的 执行处理器，代理我们的业务逻辑被生成的动态代理类回调</span><span class="hljs-comment">             * 具体逻辑代码执行,返回值为方法执行结果, 在aop模型中，委托类的接口方法称为切点。</span><span class="hljs-comment">             */</span>            <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">InvocationHandler</span>(<span class="hljs-params"></span>)</span> &#123;                @Override                public <span class="hljs-built_in">Object</span> invoke(<span class="hljs-built_in">Object</span> proxy, Method method, <span class="hljs-built_in">Object</span>[] args) throws Throwable &#123;                    <span class="hljs-comment">// 执行切面方法,对入参进行校验</span>                    boolean prepareAction = aspect.startTransaction(args);                    <span class="hljs-keyword">if</span> (prepareAction) &#123; <span class="hljs-comment">// 具体逻辑代码执行,返回值为方法执行结果</span>                        <span class="hljs-built_in">Object</span> result = method.invoke(targetPoint, args);                        aspect.endTrasaction();                        <span class="hljs-keyword">return</span> result;                    &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;args: &quot;</span> + Arrays.toString(args) + <span class="hljs-string">&quot;不能为null &quot;</span>);                    &#125;                &#125;            &#125;);    &#125;&#125;</code></pre></div><h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><div class="hljs code-wrapper"><pre><code class="hljs javascript">package org.vincent.aop;<span class="hljs-keyword">import</span> org.junit.Test;<span class="hljs-keyword">import</span> org.vincent.aop.dynamicproxy.CustomAspect;<span class="hljs-keyword">import</span> org.vincent.aop.dynamicproxy.IUserService;<span class="hljs-keyword">import</span> org.vincent.aop.dynamicproxy.JDKDynamicProxyGenerator;<span class="hljs-keyword">import</span> org.vincent.aop.dynamicproxy.UserServiceImpl;<span class="hljs-comment">/**</span><span class="hljs-comment">* <span class="hljs-doctag">@Package</span>: org.vincent &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Description</span>： 基于动态代理类AOP测试案例 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@author</span>: lenovo &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Company</span>: PLCC &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Copyright</span>: Copyright (c) 2019 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Version</span>: 1.0 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Modified </span>By: &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Created </span>by lenovo on 2018/12/26-16:56 &lt;br/&gt;</span><span class="hljs-comment">*/</span>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">testAopJDKProxy</span> </span>&#123;   @Test   public <span class="hljs-keyword">void</span> testJDKProxy() throws Exception &#123;       System.out.println(<span class="hljs-string">&quot;无代理前 调用方法 userService.saveUser 输出......&quot;</span>);       IUserService userService = <span class="hljs-keyword">new</span> UserServiceImpl();       userService.saveUser(<span class="hljs-string">&quot;zby&quot;</span>, <span class="hljs-string">&quot;1234567890&quot;</span>);       System.out.println(<span class="hljs-string">&quot;有代理后AOP 是怎么样的？ Proxy......&quot;</span>);       IUserService proxyUserService = (IUserService) JDKDynamicProxyGenerator.generatorJDKProxy(userService, <span class="hljs-keyword">new</span> CustomAspect());       proxyUserService.saveUser(<span class="hljs-string">&quot;zby&quot;</span>, <span class="hljs-string">&quot;1234567890&quot;</span>);        <span class="hljs-comment">/** 制造异常,两个入参都是null   */</span>       proxyUserService.saveUser(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);   &#125;&#125;</code></pre></div><h3 id="Cglib-aop-实现方式"><a href="#Cglib-aop-实现方式" class="headerlink" title="Cglib aop 实现方式"></a>Cglib aop 实现方式</h3><h4 id="定义切面接口"><a href="#定义切面接口" class="headerlink" title="定义切面接口"></a>定义切面接口</h4><div class="hljs code-wrapper"><pre><code class="hljs javascript">package org.vincent.aop.cglib;<span class="hljs-comment">/**</span><span class="hljs-comment">* <span class="hljs-doctag">@Package</span>: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Description</span>： 定义切面接口，切面接口定义了两个切面方法，分别在切点接口方法执行前和执行后执行 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@author</span>: lenovo &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Company</span>: PLCC &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Copyright</span>: Copyright (c) 2019 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Version</span>: 1.0 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Modified </span>By: &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Created </span>by lenovo on 2018/12/26 &lt;br/&gt;</span><span class="hljs-comment">*/</span>public interface IAspect &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">    * 在切点接口方法执行之前执行</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">void</span> startTransaction();    <span class="hljs-comment">/**</span><span class="hljs-comment">    * 在切点接口方法执行之后执行</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">void</span> endTrasaction();&#125;</code></pre></div><h4 id="切面实现"><a href="#切面实现" class="headerlink" title="切面实现"></a>切面实现</h4><div class="hljs code-wrapper"><pre><code class="hljs javascript">package org.vincent.aop.cglib;<span class="hljs-comment">/**</span><span class="hljs-comment">* <span class="hljs-doctag">@Package</span>: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Description</span>： 改类作为AOP 模型中切面角色类， 实现切面接口，切面接口定义了两个切面方法，分别在切点接口方法执行前和执行后执行 。 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@author</span>: lenovo &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Company</span>: PLCC &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Copyright</span>: Copyright (c) 2019 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Version</span>: 1.0 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Modified </span>By: &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Created </span>by lenovo on 2018/12/26 &lt;br/&gt;</span><span class="hljs-comment">*/</span>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomAspect</span> <span class="hljs-title">implements</span> <span class="hljs-title">IAspect</span> </span>&#123;    @Override   public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">startTransaction</span>(<span class="hljs-params"></span>)</span> &#123;       System.out.println(<span class="hljs-string">&quot;cglib. I get datasource here and start transaction&quot;</span>);   &#125;    public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">endTrasaction</span>(<span class="hljs-params"></span>)</span> &#123;       System.out.println(<span class="hljs-string">&quot;cglib I get datasource here and end transaction&quot;</span>);   &#125;&#125;</code></pre></div><h4 id="Cglib-是基于类实现的动态代理即业务类只需要实现类即可，不用强制必须实现某个接口为了突出这个优点这里没有实现接口"><a href="#Cglib-是基于类实现的动态代理即业务类只需要实现类即可，不用强制必须实现某个接口为了突出这个优点这里没有实现接口" class="headerlink" title="Cglib 是基于类实现的动态代理即业务类只需要实现类即可，不用强制必须实现某个接口为了突出这个优点这里没有实现接口"></a>Cglib 是基于类实现的动态代理即业务类只需要实现类即可，不用强制必须实现某个接口为了突出这个优点这里没有实现接口</h4><div class="hljs code-wrapper"><pre><code class="hljs javascript">package org.vincent.aop.cglib;<span class="hljs-comment">/**</span><span class="hljs-comment">* <span class="hljs-doctag">@Package</span>: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Description</span>： 业务实现类UserServiceImpl 该类 作为AOP中切点角色，切面定义的方法插入到切点的接口方法 执行前和执行后执行。 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@author</span>: lenovo &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Company</span>: PLCC &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Copyright</span>: Copyright (c) 2019 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Version</span>: 1.0 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Modified </span>By: &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Created </span>by lenovo on 2018/12/26 &lt;br/&gt;</span><span class="hljs-comment">*/</span>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> </span>&#123;    public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">saveUser</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> username, <span class="hljs-built_in">String</span> password</span>)</span> &#123;       System.out.println(<span class="hljs-string">&quot;cglib save user[username=&quot;</span> + username + <span class="hljs-string">&quot;,password=&quot;</span> + password + <span class="hljs-string">&quot;]&quot;</span>);   &#125;&#125;</code></pre></div><h4 id="Cglib-动态代理生成器工具类"><a href="#Cglib-动态代理生成器工具类" class="headerlink" title="Cglib 动态代理生成器工具类"></a>Cglib 动态代理生成器工具类</h4><div class="hljs code-wrapper"><pre><code class="hljs javascript">package org.vincent.aop.cglib;<span class="hljs-keyword">import</span> net.sf.cglib.proxy.Enhancer;<span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;<span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodProxy;<span class="hljs-keyword">import</span> java.lang.reflect.Method;<span class="hljs-comment">/**</span><span class="hljs-comment">* <span class="hljs-doctag">@Package</span>: org.vincent.aop.cglib &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Description</span>： 基于Cglib代理类生成器工具类 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@author</span>: lenovo &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Company</span>: PLCC &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Copyright</span>: Copyright (c) 2019 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Version</span>: 1.0 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Modified </span>By: &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Created </span>by lenovo on 2018/12/26-17:04 &lt;br/&gt;</span><span class="hljs-comment">*/</span>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CglibProxyGenerator</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">    * <span class="hljs-doctag">@param </span>target 需要被代理的委托类对象，Cglib需要继承该类生成子类</span><span class="hljs-comment">    * <span class="hljs-doctag">@param </span>aspect 切面对象,改对象方法将在切点方法之前或之后执行</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">    */</span>   public <span class="hljs-keyword">static</span>  <span class="hljs-built_in">Object</span> <span class="hljs-function"><span class="hljs-title">generatorCglibProxy</span>(<span class="hljs-params">final <span class="hljs-built_in">Object</span> target, final IAspect aspect</span>)</span>&#123;        <span class="hljs-comment">//3.1 new Enhancer</span>       Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();        <span class="hljs-comment">//3.2 设置需要代理的父类</span>       enhancer.setSuperclass(target.getClass());        <span class="hljs-comment">//3.3 设置回调</span>       enhancer.setCallback(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">MethodInterceptor</span>(<span class="hljs-params"></span>)</span> &#123;            @Override           public <span class="hljs-built_in">Object</span> intercept(<span class="hljs-built_in">Object</span> proxy, Method method, <span class="hljs-built_in">Object</span>[] args, MethodProxy methodProxy)                   throws Throwable &#123;                <span class="hljs-comment">// 执行切面方法</span>               aspect.startTransaction();                <span class="hljs-comment">// 具体逻辑代码执行,返回值为方法执行结果</span>               <span class="hljs-built_in">Object</span> result = methodProxy.invokeSuper(proxy, args);                <span class="hljs-comment">// 执行切面方法</span>               aspect.endTrasaction();                <span class="hljs-comment">// 返回方法执行结果</span>               <span class="hljs-keyword">return</span> result;           &#125;       &#125;);        <span class="hljs-comment">// 3.4 创建代理对象</span>       <span class="hljs-keyword">return</span> enhancer.create();   &#125;&#125;</code></pre></div><h4 id="测试类-1"><a href="#测试类-1" class="headerlink" title="测试类"></a>测试类</h4><div class="hljs code-wrapper"><pre><code class="hljs javascript">package org.vincent.aop;<span class="hljs-keyword">import</span> org.junit.Test;<span class="hljs-keyword">import</span> org.vincent.aop.cglib.CglibProxyGenerator;<span class="hljs-keyword">import</span> org.vincent.aop.cglib.CustomAspect;<span class="hljs-keyword">import</span> org.vincent.aop.cglib.UserServiceImpl;<span class="hljs-comment">/**</span><span class="hljs-comment">* <span class="hljs-doctag">@Package</span>: org.vincent &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Description</span>： 基于动态代理类AOP测试案例 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@author</span>: lenovo &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Company</span>: PLCC &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Copyright</span>: Copyright (c) 2019 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Version</span>: 1.0 &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Modified </span>By: &lt;br/&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@Created </span>by lenovo on 2018/12/26-16:56 &lt;br/&gt;</span><span class="hljs-comment">*/</span>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">testAopCglibKProxy</span> </span>&#123;    @Test   public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">testCglibProxy</span>(<span class="hljs-params"></span>)</span> &#123;       System.out.println(<span class="hljs-string">&quot;before Proxy......&quot;</span>);       UserServiceImpl userService = <span class="hljs-keyword">new</span> UserServiceImpl();       userService.saveUser(<span class="hljs-string">&quot;zby&quot;</span>, <span class="hljs-string">&quot;1234567890&quot;</span>);       System.out.println(<span class="hljs-string">&quot;引入Cglib  Proxy代理库 后......&quot;</span>);       UserServiceImpl proxyUserService = (UserServiceImpl) CglibProxyGenerator.generatorCglibProxy(userService, <span class="hljs-keyword">new</span> CustomAspect());       proxyUserService.saveUser(<span class="hljs-string">&quot;zby&quot;</span>, <span class="hljs-string">&quot;1234567890&quot;</span>);   &#125;&#125;</code></pre></div><h3 id="AspectJ-实现-AOP-效果"><a href="#AspectJ-实现-AOP-效果" class="headerlink" title="AspectJ 实现 AOP 效果"></a>AspectJ 实现 AOP 效果</h3><p>AOP 实现的关键就在于 AOP 框架自动创建的 AOP 代理，AOP 代理则可分为静态代理和动态代理两大类:</p><ul><li>静态代理是指使用 AOP 框架提供的命令进行编译，从而在编译阶段通过AOP框架指令生成 AOP 代理类，因此也称为编译时增强；还有一种静态代理是编写代码实现不用工具；这种方式一般是代理模式会使用。</li><li>动态代理则在运行时借助于 JDK 动态代理、CGLIB 等在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。</li></ul><h4 id="基于-AspectJ-的编译时增强进行-AOP-POM-依赖"><a href="#基于-AspectJ-的编译时增强进行-AOP-POM-依赖" class="headerlink" title="基于 AspectJ 的编译时增强进行 AOP POM 依赖"></a>基于 AspectJ 的编译时增强进行 AOP POM 依赖</h4><p>原生 AspectJ 不依赖Spring案例, 基于 AspectJ 的编译时增强进行 AOP 它是在编译期修改字节码，增强功能；并不会生成新的代理类字节码。</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">&lt;!-- AspectJ begin--&gt;&lt;dependency&gt;   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;   &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;   &lt;version&gt;<span class="hljs-number">1.9</span><span class="hljs-number">.2</span>&lt;<span class="hljs-regexp">/version&gt;&lt;/</span>dependency&gt;&lt;dependency&gt;   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;   &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;   &lt;version&gt;<span class="hljs-number">1.9</span><span class="hljs-number">.2</span>&lt;<span class="hljs-regexp">/version&gt;&lt;/</span>dependency&gt;&lt;!-- AspectJ stop--&gt;</code></pre></div><h2 id="动态代理-使用场景"><a href="#动态代理-使用场景" class="headerlink" title="动态代理 使用场景"></a>动态代理 使用场景</h2><ul><li>日志集中打印</li><li>事务</li><li>权限管理</li><li>AOP</li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>json</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java interview 2</title>
    <link href="/2021/10/13/java-interview-2/"/>
    <url>/2021/10/13/java-interview-2/</url>
    
    <content type="html"><![CDATA[<div id="content_views" class="htmledit_views">                    <h2><a name="t0"></a>面向对象的三个特征</h2> <p>封装,继承,多态.这个应该是人人皆知.有时候也会加上抽象.</p> <h2><a name="t1"></a><a id="_7"></a>多态的好处</h2> <p>允许不同类对象对同一消息做出响应,即同一消息可以根据发送对象的不同而采用多种不同的行为方式(发送消息就是函数调用).主要有以下优点:</p> <ol><li>可替换性:多态对已存在代码具有可替换性.</li><li>可扩充性:增加新的子类不影响已经存在的类结构.</li><li>接口性:多态是超类通过方法签名,向子类提供一个公共接口,由子类来完善或者重写它来实现的.</li><li>灵活性:</li><li>简化性:</li></ol><h2><a name="t2"></a><a id="_17"></a>虚拟机是如何实现多态的</h2> <p>动态绑定技术(dynamic binding),执行期间判断所引用对象的实际类型,根据实际类型调用对应的方法.如果你知道Hotspot中oop-klass模型的实现,对这个问题就了解比较深了.</p> <h2><a name="t3"></a><a id="_21"></a>接口的意义</h2> <p>接口的意义用三个词就可以概括:规范,扩展,回调.</p> <h2><a name="t4"></a><a id="_24"></a>抽象类的意义</h2> <p>抽象类的意义可以用三句话来概括:</p> <ol><li>为其他子类提供一个公共的类型</li><li>封装子类中重复定义的内容</li><li>定义抽象方法,子类虽然有不同的实现,但是定义时一致的</li></ol><h2><a name="t5"></a><a id="_31"></a>接口和抽象类的区别</h2> <div class="table-box"><table><thead><tr><th>比较点</th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>默认方法</td><td>抽象类可以有默认的方法实现</td><td>java 8之前,接口中不存在方法的实现</td></tr><tr><td>实现方式</td><td>子类使用extends关键字来继承抽象类.如果子类不是抽象类,子类需要提供抽象类中所声明方法的实现</td><td>子类使用implements来实现接口,需要提供接口中所有声明的实现.</td></tr><tr><td>构造器</td><td>抽象类中可以有构造器</td><td>接口中不能</td></tr><tr><td>和正常类区别</td><td>抽象类不能被实例化</td><td>接口则是完全不同的类型</td></tr><tr><td>访问修饰符</td><td>抽象方法可以有public,protected和default等修饰</td><td>接口默认是public,不能使用其他修饰符</td></tr><tr><td>多继承</td><td>一个子类只能存在一个父类</td><td>一个子类可以存在多个接口</td></tr><tr><td>添加新方法</td><td>抽象类中添加新方法,可以提供默认的实现,因此可以不修改子类现有的代码</td><td>如果往接口中添加新方法,则子类中需要实现该方法</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr></tbody></table></div><h2><a name="t6"></a><a id="_43"></a>父类的静态方法能否被子类重写?</h2> <p>不能.重写只适用于实例方法,不能用于静态方法,而子类当中含有和父类相同签名的静态方法,我们一般称之为隐藏.</p> <h2><a name="t7"></a><a id="_47"></a>什么是不可变对象?好处是什么?</h2> <p>不可变对象指对象一旦被创建,状态就不能再改变,任何修改都会创建一个新的对象,如 String、Integer及其它包装类.不可变对象最大的好处是线程安全.</p> <h2><a name="t8"></a><a id="_51"></a>静态变量和实例变量的区别?</h2> <p>静态变量存储在方法区,属于类所有.实例变量存储在堆当中,其引用存在当前线程栈.需要注意的是从JDK1.8开始用于实现方法区的PermSpace被MetaSpace取代了.</p> <h2><a name="t9"></a><a id="_56"></a>能否创建一个包含可变对象的不可变对象?</h2> <p>当然可以,比如<code>final Person[] persons = new Persion[]&#123;&#125;</code>.persons是不可变对象的引用,但其数组中的Person实例却是可变的.这种情况下需要特别谨慎,不要共享可变对象的引用.这种情况下,如果数据需要变化时,就返回原对象的一个拷贝.</p> <h2><a name="t10"></a><a id="java__59"></a>java 创建对象的几种方式</h2> <p>java中提供了以下四种创建对象的方式:</p> <ul><li>new创建新对象</li><li>通过反射机制</li><li>采用clone机制</li><li>通过序列化机制</li></ul><p>前两者都需要显式地调用构造方法. 对于clone机制,需要注意浅拷贝和深拷贝的区别,对于序列化机制需要明确其实现原理,在java中序列化可以通过实现Externalizable或者Serializable来实现.</p> <h2><a name="t11"></a><a id="switchstring_70"></a>switch中能否使用string做参数?</h2> <p>在JDK 1.7之前,switch只能支持byte,short,char,int或者其对应的包装类以及Enum类型.从JDK 1.7之后switch开始支持String类型.但到目前为止,switch都不支持long类型.</p> <h2><a name="t12"></a><a id="Object_74"></a>Object中有哪些公共方法?</h2> <p><code>equals()</code>,<code>clone()</code>,<code>getClass()</code>,<code>notify(),notifyAll(),wait()</code>,<code>toString</code></p> <h2><a name="t13"></a><a id="javaeqauls_77"></a>java中<code>==</code>和<code>eqauls()</code>的区别?</h2> <ul><li><code>==</code>是运算符,用于比较两个变量是否相等,对于基本类型而言比较的是变量的值,对于对象类型而言比较的是对象的地址.</li><li><code>equals()</code>是Object类的方法,用于比较两个对象内容是否相等.默认Object类的<code>equals()</code>实现如下:</li></ul><div class="hljs code-wrapper"><pre class="has" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:930px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Object</span> </span>&#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    ......</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span> == obj);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    ......</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&#125;</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}" onclick="hljs.copyCode(event)"></div></pre></div> <p>&nbsp;不难看出此时<code>equals()</code>是比较两个对象的地址,此时直接<code>==</code>比较的的结果一样.对于可能用于集合存储中的对象元素而言,通常需要重写其<code>equals()</code>方法.</p> <h2><a name="t14"></a><a id="abaequalsb_95"></a><code>a==b</code>与<code>a.equals(b)</code>有什么区别</h2> <p>如果a 和b 都是对象,则&nbsp;<code>a==b</code>&nbsp;是比较两个对象内存地址,只有当 a 和 b 指向的是堆中的同一个对象才会返回 true.而&nbsp;<code>a.equals(b)</code>&nbsp;是进行内容比较,其比较结果取决于<code>equals()</code>具体实现.多数情况下,我们需要重写该方法,如String 类重写&nbsp;<code>equals()</code>用于两个不同对象，但是包含的字母相同的比较:</p> <div class="hljs code-wrapper"><pre class="has" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:930px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object anObject)</span> </span>&#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == anObject) &#123;                        <span class="hljs-comment">// 同一个对象直接返回true</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">if</span> (anObject <span class="hljs-keyword">instanceof</span> String) &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            String anotherString = (String)anObject;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">int</span> n = value.length;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">if</span> (n == anotherString.value.length) &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                <span class="hljs-keyword">char</span> v1[] = value;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                <span class="hljs-keyword">char</span> v2[] = anotherString.value;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                <span class="hljs-keyword">while</span> (n-- != <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">// 按字符依次比较</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                    <span class="hljs-keyword">if</span> (v1[i] != v2[i])</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                    i++;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="18"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="19"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="20"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="21"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    &#125;</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}" onclick="hljs.copyCode(event)"></div></pre></div> <h2><a name="t15"></a>Object中的<code>equals()</code>和<code>hashcode()</code>的联系</h2> <p><code>hashCode()</code>是Object类的一个方法,返回一个哈希值.如果两个对象根据equal()方法比较相等,那么调用这两个对象中任意一个对象的hashCode()方法必须产生相同的哈希值;如果两个对象根据eqaul()方法比较不相等,那么产生的哈希值不一定相等(碰撞的情况下还是会相等的.)</p> <h2><a name="t16"></a><a id="ahashCodeaequalsb_129"></a>a.hashCode()有什么用?与a.equals(b)有什么关系</h2> <p><code>hashCode()</code>方法是为对象产生整型的 hash 值,用作对象的唯一标识.它常用于基于 hash 的集合类,如 Hashtable,HashMap等等.根据 Java 规范,使用&nbsp;<code>equal()</code>方法来判断两个相等的对象,必须具有相同的 hashcode.</p> <p>将对象放入到集合中时,首先判断要放入对象的hashcode是否已经在集合中存在,不存在则直接放入集合.如果hashcode相等,然后通过<code>equal()</code>方法判断要放入对象与集合中的任意对象是否相等:如果<code>equal()</code>判断不相等,直接将该元素放入集合中,否则不放入.</p> <h2><a name="t17"></a><a id="hashcode_134"></a>有没有可能两个不相等的对象有相同的hashcode</h2> <p>有可能.在产生hash冲突时,两个不相等的对象就会有相同的 hashcode 值.当hash冲突产生时,一般有以下几种方式来处理:</p> <ul><li>拉链法:每个哈希表节点都有一个next指针,多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表进行存储.</li><li>开放定址法:一旦发生了冲突,就去寻找下一个空的散列地址,只要散列表足够大,空的散列地址总能找到,并将记录存入</li><li>再哈希:又叫双哈希法,有多个不同的Hash函数.当发生冲突时,使用第二个,第三个….等哈希函数计算地址,直到无冲突.</li></ul><h2><a name="t18"></a><a id="hashcode_143"></a>可以在hashcode中使用随机数字吗?</h2> <p>不行,因为同一对象的 hashcode 值必须是相同的.</p> <h2><a name="t19"></a><a id="___146"></a>&amp; 和 &amp;&amp;的区别</h2> <p>基础的概念不能弄混:&amp;是位操作,&amp;&amp;是逻辑运算符.需要记住逻辑运算符具有短路特性,而&amp;不具备短路特性.来看看一下代码执行结果?</p> <div class="hljs code-wrapper"><pre class="has" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:930px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">static</span> String name;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">if</span>(name!=<span class="hljs-keyword">null</span>&amp;userName.equals(<span class="hljs-string">""</span>))&#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            System.out.println(<span class="hljs-string">"ok"</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        &#125;<span class="hljs-keyword">else</span>&#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            System.out.println(<span class="hljs-string">"erro"</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&#125;</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}" onclick="hljs.copyCode(event)"></div></pre></div> <p>上述代码将会抛出空指针异常.原因你懂得.</p> <h2><a name="t20"></a><a id="java_166"></a>在.java文件内部可以有多少类(非内部类)?</h2> <p>在一个java文件中只能有一个public公共类,但是可以有多个default修饰的类.</p> <h2><a name="t21"></a><a id="_170"></a>如何正确的退出多层嵌套循环?</h2> <ol><li>使用标号和break;</li><li>通过在外层循环中添加标识符</li></ol><h2><a name="t22"></a><a id="_175"></a>内部类有什么作用?</h2> <p>内部类可以有多个实例,每个实例都有自己的状态信息,并且与其他外围对象的信息相互独立.在单个外围类当中,可以让多个内部类以不同的方式实现同一接口,或者继承同一个类.创建内部类对象的时刻不依赖于外部类对象的创建.内部类并没有令人疑惑的”is-a”关系,它就像是一个独立的实体.此外,内部类提供了更好的封装,除了该外围类,其他类都不能访问.</p> <h2><a name="t23"></a><a id="finalfinalizefinally_179"></a><code>final</code>,<code>finalize()</code>和<code>finally&#123;&#125;</code>的不同之处</h2> <p>三者没有任何相关性,遇到有问着问题的面试官就拖出去砍了吧.final是一个修饰符,用于修饰变量,方法和类.如果 final 修饰变量,意味着该变量的值在初始化后不能被改变.<code>finalize()</code>方法是在对象被回收之前调用的方法,给对象自己最后一个复活的机会.但是该方法由Finalizer线程调用,但调用时机无法保证.finally是一个关键字,与 try和catch一起用于异常的处理,<code>finally&#123;&#125;</code>一定会被执行,在此处我们通常用于资源关闭操作.</p> <h2><a name="t24"></a><a id="clone_183"></a><code>clone()</code>是哪个类的方法?</h2> <p>java.lang.Cloneable 是一个标示性接口,不包含任何方法.<code>clone ()</code>方法在 Object 类中定义的一个Native方法:</p> <div class="hljs code-wrapper"><pre class="has" name="code"><code class="language-java hljs"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException</span>;</code><div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}" onclick="hljs.copyCode(event)"></div></pre></div> <h2><a name="t25"></a>深拷贝和浅拷贝的区别是什么?</h2> <ul><li> <p>浅拷贝:被复制对象的所有变量都含有与原来的对象相同的值,而所有的对其他对象的引用仍然指向原来的对象.换言之,浅拷贝仅仅复制所考虑的对象,而不复制它所引用的对象.</p> </li><li> <p>深拷贝:被复制对象的所有变量都含有与原来的对象相同的值.而那些引用其他对象的变量将指向被复制过的新对象.而不再是原有的那些被引用的对象.换言之.深拷贝把要复制的对象所引用的对象都复制了一遍.</p> <p><img alt="image-20181023180427459" class="has" src="https://i.imgur.com/mBrnqBT.png"></p> </li></ul><h2><a name="t26"></a><a id="static_200"></a>static都有哪些用法?</h2> <p>所有的人都知道static关键字这两个基本的用法:静态变量和静态方法.也就是被static所修饰的变量/方法都属于类的静态资源,类实例所共享.</p> <p>除了静态变量和静态方法之外,static也用于静态块,多用于初始化操作:</p> <div class="hljs code-wrapper"><pre class="has" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:930px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">public</span> calss PreCache&#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">static</span>&#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-comment">//执行相关操作</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&#125;</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}" onclick="hljs.copyCode(event)"></div></pre></div> <p>此外static也多用于修饰内部类,此时称之为静态内部类.</p> <p>最后一种用法就是静态导包,即<code>import static</code>.import static是在JDK 1.5之后引入的新特性,可以用来指定导入某个类中的静态资源,并且不需要使用类名,可以直接使用资源名,比如:</p> <div class="hljs code-wrapper"><pre class="has" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:930px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Math.*;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-comment">//System.out.println(Math.sin(20));传统做法</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        System.out.println(sin(<span class="hljs-number">20</span>));</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&#125;</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}" onclick="hljs.copyCode(event)"></div></pre></div> <h2><a name="t27"></a>final有哪些用法?</h2> <p>final也是很多面试喜欢问的地方,但我觉得这个问题很无聊,通常能回答下以下5点就不错了:</p> <ul><li>被final修饰的类不可以被继承</li><li>被final修饰的方法不可以被重写</li><li>被final修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变.</li><li>被final修饰的方法,JVM会尝试将其内联,以提高运行效率</li><li>被final修饰的常量,在编译阶段会存入常量池中.</li></ul><p>除此之外,编译器对final域要遵守的两个重排序规则更好:</p> <ul><li>在构造函数内对一个final域的写入,与随后把这个被构造对象的引用赋值给一个引用变量,这两个操作之间不能重排序</li><li>初次读一个包含final域的对象的引用,与随后初次读这个final域,这两个操作之间不能重排序.</li></ul><h1><a name="t28"></a><a id="_241"></a>数据类型相关</h1> <h2><a name="t29"></a><a id="javaint_charlong_243"></a>java中int char,long各占多少字节?</h2> <p>这个问题其实很无聊.应该去问java中的各种数据类型在不同的平台运行时期所占位数一样么?</p> <div class="table-box"><table><thead><tr><th>类型</th><th>字节</th></tr></thead><tbody><tr><td>short</td><td>2</td></tr><tr><td>int</td><td>4</td></tr><tr><td>long</td><td>8</td></tr><tr><td>float</td><td>4</td></tr><tr><td>double</td><td>8</td></tr><tr><td>char</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td></tr></tbody></table></div><h2><a name="t30"></a><a id="64JVMint_259"></a>64位的JVM当中,int的长度是多少?</h2> <p>Java中数据类型所占用的位数和平台无关,在 32 位和64位 的Java 虚拟机中,int 类型的长度都是占4字节.</p> <h2><a name="t31"></a><a id="intInteger_262"></a>int和Integer的区别?</h2> <p>Integer是int的包装类型,在拆箱和装箱中,二者自动转换.int是基本类型,直接存数值;而integer是对象;用一个引用指向这个对象.由于Integer是一个对象,在JVM中对象需要一定的数据结构进行描述,相比int而言,其占用的内存更大一些.</p> <h2><a name="t32"></a><a id="String_s__new_StringabcString_266"></a><code>String s = new String("abc")</code>创建了几个String对象?</h2> <p>2个.一个是字符串字面常数,在字符串常量池中;另一个是new出来的字符串对象,在堆中.</p> <h2><a name="t33"></a><a id="s1s3truefalses1s4falsetrues1s5_270"></a>请问s1<code>==</code>s3是true还是false，s1<code>==</code>s4是false还是true?s1<code>==</code>s5呢？</h2> <div class="hljs code-wrapper"><pre class="has" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:930px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   String s1 = <span class="hljs-string">"abc"</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   String s2 = <span class="hljs-string">"a"</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   String s3 = s2 + <span class="hljs-string">"bc"</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   String s4 = <span class="hljs-string">"a"</span> + <span class="hljs-string">"bc"</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   String s5 = s3.intern();</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}" onclick="hljs.copyCode(event)"></div></pre></div> <p>s1<code>==</code>s3返回false,s1<code>==</code>s4返回true,s1<code>==</code>s5返回true.</p> <p>“abc"这个字符串常量值会直接方法字符串常量池中,s1是对其的引用.由于s2是个变量,编译器在编译期间无法确定该变量后续会不会改,因此无法直接将s3的值在编译器计算出来,因此s3是堆中"abc"的引用.因此s1!=s3.对于s4而言,其赋值号右边是常量表达式,因此可以在编译阶段直接被优化为"abc”,由于"abc"已经在字符串常量池中存在,因此s4是对其的引用,此时也就意味s1和s4引用了常量池中的同一个"abc".所以s1<code>==</code>s4.String中的<code>intern()</code>会首先从字符串常量池中检索是否已经存在字面值为"abc"的对象,如果不存在则先将其添加到字符串常量池中,否则直接返回已存在字符串常量的引用.此处由于"abc"已经存在字符串常量池中了,因此s5和s1引用的是同一个字符串常量.</p> <h2><a name="t34"></a><a id="s5s2_286"></a>以下代码中,s5<code>==</code>s2返回值是什么?</h2> <div class="hljs code-wrapper"><pre class="has" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:930px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">String s1=<span class="hljs-string">"ab"</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">String s2=<span class="hljs-string">"a"</span>+<span class="hljs-string">"b"</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">String s3=<span class="hljs-string">"a"</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">String s4=<span class="hljs-string">"b"</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">String s5=s3+s4;</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}" onclick="hljs.copyCode(event)"></div></pre></div> <p>返回false.在编译过程中,编译器会将s2直接优化为"ab",将其放置在常量池当中;而s5则是被创建在堆区,相当于s5=new String(“ab”);</p> <h2><a name="t35"></a><a id="Stringintern_298"></a>你对String对象的intern()熟悉么?</h2> <p>Stirng中的<code>intern()</code>是个Native方法,它会首先从常量池中查找是否存在该常量值的字符串,若不存在则先在常量池中创建,否则直接返回常量池已经存在的字符串的引用. 比如</p> <div class="hljs code-wrapper"><pre class="has" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:930px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> String s1=<span class="hljs-string">"aa"</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> String s2=s1.intern();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> System.out.print(s1==s2);</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}" onclick="hljs.copyCode(event)"></div></pre></div> <p>上述代码将返回true.因为在"aa"会在编译阶段确定下来,并放置字符串常量池中,因此最终s1和s2引用的是同一个字符串常量对象.</p> <h2><a name="t36"></a><a id="StringStringBufferStringBuilder_310"></a>String,StringBuffer和StringBuilder区别?</h2> <p>String是字符串常量,final修饰;StringBuffer字符串变量(线程安全);StringBuilder 字符串变量(线程不安全).此外StringBuilder和StringBuffer实现原理一样,都是基于数组扩容来实现的.</p> <h2><a name="t37"></a><a id="StringStringBuffer_314"></a>String和StringBuffer的区别?</h2> <p>String和StringBuffer主要区别是性能:String是不可变对象,每次对String类型进行操作都等同于产生了一个新的String对象,然后指向新的String对象.所以尽量不要对String进行大量的拼接操作,否则会产生很多临时对象,导致GC开始工作,影响系统性能.</p> <p>StringBuffer是对象本身操作,而不是产生新的对象,因此在有大量拼接的情况下,我们建议使用StringBuffer(线程安全).</p> <p>需要注意现在JVM会对String拼接做一定的优化,比如</p> <div class="hljs code-wrapper"><pre class="has" name="code"><code class="language-java hljs">String s=<span class="hljs-string">"This is only "</span>+ <span class="hljs-string">"simple"</span> +<span class="hljs-string">"test"</span>;</code><div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}" onclick="hljs.copyCode(event)"></div></pre></div> <p>以上代码在编译阶段会直接被优化成会`String s=“This is only simple test”.</p> <h2><a name="t38"></a><a id="StringBufferStringBuilder_328"></a>StringBuffer和StringBuilder</h2> <p>StringBuffer和StringBuilder的实现原理一样,其父类都是AbstractStringBuilder.StringBuffer是线程安全的,StringBuilder是JDK 1.5新增的,其功能和StringBuffer类似,但是非线程安全.因此,在没有多线程问题的前提下,使用StringBuilder会取得更好的性能.</p> <h2><a name="t39"></a><a id="_332"></a>什么是编译器常量?使用它有什么风险?</h2> <p>公共静态不可变,即public static final修饰的变量就是我们所说的编译期常量.这里的public可选的.实际上这些变量在编译时会被替换掉,因为编译器明确的能推断出这些变量的值(如果你熟悉C++,那么这里就相当于宏替换).</p> <p>编译器常量虽然能够提升性能,但是也存在一定问题:你使用了一个内部的或第三方库中的公有编译时常量,但是这个值后面被其他人改变了,但是你的客户端没有重新编译,这意味着你仍然在使用被修改之前的常量值.</p> <h2><a name="t40"></a><a id="30103_338"></a>3*0.1<code>==</code>0.3返回值是什么</h2> <p>false,因为有些浮点数不能完全精确的表示出来.</p> <h2><a name="t41"></a><a id="java_342"></a>java当中使用什么类型表示价格比较好?</h2> <p>如果不是特别关心内存和性能的话,使用BigDecimal.否则使用预定义精度的 double 类型.</p> <h2><a name="t42"></a><a id="byteString_345"></a>如何将byte转为String</h2> <p>可以使用String接收 byte[] 参数的构造器来进行转换,注意要使用的正确的编码,否则会使用平台默认编码.这个编码可能跟原来的编码相同.也可能不同.</p> <h2><a name="t43"></a><a id="intbyte_350"></a>可以将int强转为byte类型么?会产生什么问题?</h2> <p>可以做强制转换,但是Java中int是32位的而byte是8 位的.如果强制转化int类型的高24位将会被丢弃,byte 类型的范围是从-128到128.</p> <h2><a name="t44"></a><a id="aabab_353"></a>a=a+b与a+=b有什么区别吗?</h2> <p><code>+=</code>操作符会进行隐式自动类型转换,此处a+=b隐式的将加操作的结果类型强制转换为持有结果的类型,而a=a+b则不会自动进行类型转换.如：</p> <div class="hljs code-wrapper"><pre class="has" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:930px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">byte</span> a = <span class="hljs-number">127</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">byte</span> b = <span class="hljs-number">127</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">b = a + b; <span class="hljs-comment">// 报编译错误:cannot convert from int to byte</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">b += a; </div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}" onclick="hljs.copyCode(event)"></div></pre></div> <h2><a name="t45"></a>以下代码是否有错,有的话怎么改？</h2> <div class="hljs code-wrapper"><pre class="has" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:930px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">short</span> s1= <span class="hljs-number">1</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">s1 = s1 + <span class="hljs-number">1</span>;</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}" onclick="hljs.copyCode(event)"></div></pre></div> <h2><a name="t46"></a>以下代码是否有错,有的话怎么改？</h2> <div class="hljs code-wrapper"><pre class="has" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:930px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">short</span> s1= <span class="hljs-number">1</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">s1 = s1 + <span class="hljs-number">1</span>;</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}" onclick="hljs.copyCode(event)"></div></pre></div> <p>有错误.short类型在进行运算时会自动提升为int类型,也就是说<code>s1+1</code>的运算结果是int类型,而s1是short类型,此时编译器会报错.</p> <h2><a name="t47"></a><a id="_373"></a>以下代码是否有错,有的话怎么改？</h2> <div class="hljs code-wrapper"><pre class="has" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:930px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">short</span> s1= <span class="hljs-number">1</span>; </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">s1 += <span class="hljs-number">1</span>; </div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}" onclick="hljs.copyCode(event)"></div></pre></div> <p>+=操作符会对右边的表达式结果强转匹配左边的数据类型,所以没错.</p> <h2><a name="t48"></a><a id="_384"></a>了解泛型么?简述泛型的上界和下界?</h2> <p>有时候希望传入的类型有一个指定的范围，从而可以进行一些特定的操作,这时候就需要通配符了?在Java中常见的通配符主要有以下几种:</p> <ul><li><code>&lt;?&gt;</code>: 无限制通配符</li><li><code>&lt;? extends E&gt;</code>: extends 关键字声明了类型的上界,表示参数化的类型可能是所指定的类型,或者是此类型的子类</li><li><code>&lt;? super E&gt;</code>: super关键字声明了类型的下界,表示参数化的类型可能是指定的类型,或者是此类型的父类</li></ul><p>它们的目的都是为了使方法接口更为灵活,可以接受更为广泛的类型.</p> <ul><li><code>&lt; ? extends E&gt;</code>: 用于灵活<strong>读取</strong>，使得方法可以读取 E 或 E 的任意子类型的容器对象。</li><li><code>&lt; ? super E&gt;</code>: 用于灵活<strong>写入或比较</strong>,使得对象可以写入父类型的容器,使得父类型的比较方法可以应用于子类对象。</li></ul><p>用简单的一句话来概括就是为了获得最大限度的灵活性,要在表示生产者或者消费者的输入参数上使用通配符,使用的规则就是:生产者有上限(读操作使用extends),消费者有下限(写操作使用super).</p> <h1><a name="t49"></a><a id="_399"></a>垃圾回收</h1> <h2><a name="t50"></a><a id="_401"></a>简单的解释一下垃圾回收?</h2> <p>JVM中垃圾回收机制最基本的做法是分代回收.内存中的区域被划分成不同的世代,对象根据其存活的时间被保存在对应世代的区域中.一般的实现是划分成3个世代:年轻,年老和永久代.所有新生成的对象优先放在年轻代的(大对象可能被直接分配在老年代,作为一种分配担保机制),年轻代按照统计规律被分为三个区:一个Eden区，两个 Survivor区.在年轻代中经历了N次垃圾回收后仍然存活的对象,就会被放到年老代中.因此可以认为年老代中存放的都是一些生命周期较长的对象.</p> <p>方法区也被称为永久代,用于存储每一个java类的结构信息:比如运行时常量池,字段和方法数据,构造函数和普通方法的字节码内容以及类,实例,接口初始化时需要使用到的特殊方法等数据,根据虚拟机实现不同,GC可以选择对方法区进行回收也可以不回收.</p> <p>对于不同的世代可以使用不同的垃圾回收算法。比如对由于年轻代存放的对象多是朝生夕死,因此可以采用标记-复制,而对于老年代则可以采用标记-整理/清除.</p> <h3><a name="t51"></a><a id="Minor_GC_409"></a>Minor GC</h3> <p>发生在新生代的GC为Minor GC .在Minor GC时会将新生代中还存活着的对象复制进一个Survivor中,然后对Eden和另一个Survivor进行清理.所以,平常可用的新生代大小为Eden的大小+一个Survivor的大小.</p> <h3><a name="t52"></a><a id="Major_GC_413"></a>Major GC</h3> <p>在老年代中的GC则为Major GC.</p> <h3><a name="t53"></a><a id="Full_GC_417"></a>Full GC</h3> <p>通常是和Major GC等价的,针对整个新生代,老年代,元空间metaspace(java8以上版本取代perm gen)的全局范围的GC.</p> <p>关于GC的类型,其实依赖于不同的垃圾回收器.可以具体查看相关垃圾回收器的实现.</p> <h3><a name="t54"></a><a id="_423"></a>新生代进入老年代</h3> <ul><li>分配担保机制:当Minor GC时,新生代存活的对象大于Survivor的大小时,这时一个Survivor装不下它们,那么它们就会进入老年代.</li><li>如果设置了-XX：PretenureSizeThreshold5M 那么大于5M的对象就会直接就进入老年代.</li><li>在新生代的每一次Minor GC 都会给在新生代中的对象+1岁,默认到15岁时就会从新生代进入老年代,可以通过-XX：MaxTenuringThreshold来设置这个临界点</li></ul><h2><a name="t55"></a><a id="_429"></a>常见的垃圾回收算法有哪些?简述其原理.</h2> <p>垃圾回收从理论上非常容易理解,具体的方法有以下几种:</p> <ol><li>标记-清除</li><li>标记-复制</li><li>标记-整理</li><li>分代回收<br> 更详细的内容参见<a href="http://blog.csdn.net/dd864140130/article/details/50084471">深入理解垃圾回收算法</a></li></ol><h2><a name="t56"></a><a id="_438"></a>如何判断一个对象是否应该被回收?</h2> <p>这就是所谓的对象存活性判断,常用的方法有两种:</p> <ul><li> <p>引用计数法</p> </li><li> <p>对象可达性分析</p> <p>由于引用计数法存在互相引用导致无法进行GC的问题,所以目前JVM虚拟机多使用对象可达性分析算法.</p> </li></ul><h2><a name="t57"></a><a id="GC_Root_448"></a>哪些对象可以做GC Root?</h2> <p>主要由以下四种:</p> <ul><li>JVM方法栈中引用的对象</li><li>本地方法栈中引用的对象</li><li>方法区常量引用的对象</li><li>方法区类属性引用的对象</li></ul><h2><a name="t58"></a><a id="Systemgc_458"></a>调用System.gc()会发生什么?</h2> <p>通知GC开始工作,但是GC真正开始的时间不确定.</p> <h2><a name="t59"></a><a id="java_461"></a>了解java当中的四种引用类型?他们之间的区别是什么?</h2> <p>在java中主要有以下四种引用类型:强引用,软引用,弱引用,虚引用.不同的引用类型主要体现在GC上:</p> <ul><li> <p>强引用:如果一个对象具有强引用,它就不会被垃圾回收器回收.即使当前内存空间不足,JVM也不会回收它.而是抛出 OutOfMemoryError 错误.使程序异常终止.如果想中断强引用和某个对象之间的关联.可以显式地将引用赋值为null,这样一来的话.JVM在合适的时间就会回收该对象.</p> </li><li> <p>软引用:在使用软引用时,如果内存的空间足够,软引用就能继续被使用而不会被垃圾回收器回收.只有在内存不足时,软引用才会被垃圾回收器回收.</p> </li><li> <p>弱引用:具有弱引用的对象拥有的生命周期更短暂.因为当 JVM 进行垃圾回收,一旦发现弱引用对象,无论当前内存空间是否充足,都会将弱引用回收.不过由于垃圾回收器是一个优先级较低的线程,所以并不一定能迅速发现弱引用对象.</p> </li><li> <p>虚引用:如果一个对象仅持有虚引用,那么它相当于没有引用,在任何时候都可能被垃圾回收器回收.</p> </li></ul><p>更多了解参见<a href="http://blog.csdn.net/dd864140130/article/details/49885811">深入对象引用</a></p> <h2><a name="t60"></a><a id="WeakReferenceSoftReference_475"></a>WeakReference与SoftReference的区别?</h2> <p>这点在四种引用类型中已经做了解释,这里在重复一下.虽然WeakReference与SoftReference都有利于提高 GC和内存的效率,但是 WeakReference ,一旦失去最后一个强引用,就会被 GC 回收,而软引用虽然不能阻止被回收,但是可以延迟到 JVM 内存不足的时候.</p> <h2><a name="t61"></a><a id="_479"></a>为什么要有不同的引用类型</h2> <p>不像C语言,我们可以控制内存的申请和释放,在Java中有时候我们需要适当的控制对象被回收的时机,因此就诞生了不同的引用类型,可以说不同的引用类型实则是对GC回收时机不可控的妥协.</p> <h1><a name="t62"></a><a id="_483"></a>进程,线程相关</h1> <h2><a name="t63"></a><a id="_485"></a>说说进程,线程之间的区别?</h2> <p>简而言之,进程是程序运行和资源分配的基本单位,一个程序至少有一个进程,一个进程至少有一个线程.进程在执行过程中拥有独立的内存单元,而多个线程共享内存资源,减少切换次数,从而效率更高.线程是进程的一个实体,是cpu调度和分派的基本单位,是比程序更小的能独立运行的基本单位.同一进程中的多个线程之间可以并发执行.在Linux中,进程也称为Task.</p> <h2><a name="t64"></a><a id="_489"></a>守护线程是什么?它和非守护线程有什么区别</h2> <p>程序运行完毕,jvm会等待非守护线程完成后关闭,但是jvm不会等待守护线程.守护线程最典型的例子就是GC线程.</p> <h2><a name="t65"></a><a id="_492"></a>什么是多线程上下文切换</h2> <p>多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程.</p> <h2><a name="t66"></a><a id="_495"></a>创建两种线程的方式?他们有什么区别?</h2> <p>通过实现java.lang.Runnable或者通过扩展java.lang.Thread类.相比扩展Thread,实现Runnable接口可能更优.原因有二:</p> <ol><li>Java不支持多继承.因此扩展Thread类就代表这个子类不能扩展其他类.而实现Runnable接口的类还可能扩展另一个类.</li><li>类可能只要求可执行即可,因此继承整个Thread类的开销过大.</li></ol><h2><a name="t67"></a><a id="CallableRunnable_501"></a>Callable和Runnable的区别是什么?</h2> <p>两者都能用来编写多线程,但实现Callable接口的任务线程能返回执行结果,而实现Runnable接口的任务线程不能返回结果.Callable通常需要和Future/FutureTask结合使用,用于获取异步计算结果.</p> <h2><a name="t68"></a><a id="Threadstartrun_505"></a>Thread类中的start()和run()方法有什么区别?</h2> <p>在<code>start(</code>)方法中最终要的是调用了Native方法<code>start0()</code>用来启动新创建的线程线程启动后会自动调用<code>run()</code>方法.如果我们直接调用其run()方法就和我们调用其他方法一样,不会在新的线程中执行.</p> <p>##怎么检测一个线程是否持有对象锁</p> <p>Thread类提供了一个Native方法<code>holdsLock(Object obj)</code>方法用于检测是否持有某个对象锁:当且仅当对象obj的锁被某线程持有的时候才会返回true.</p> <div class="hljs code-wrapper"><pre class="has" name="code"><code class="language-java hljs"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">holdsLock</span><span class="hljs-params">(Object obj)</span></span>;</code><div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}" onclick="hljs.copyCode(event)"></div></pre></div> <h2><a name="t69"></a>线程阻塞有哪些原因?</h2> <p>阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪），学过操作系统的同学对它一定已经很熟悉了。Java 提供了大量方法来支持阻塞，下面让我们逐一分析。</p> <div class="table-box"><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>sleep()</td><td>sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。 典型地，sleep() 被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止</td></tr><tr><td>suspend() 和 resume()</td><td>两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。</td></tr><tr><td>yield()</td><td>yield() 使当前线程放弃当前已经分得的CPU 时间，但不使当前线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程</td></tr><tr><td>wait() 和 notify()</td><td>两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用.</td></tr></tbody></table></div><h2><a name="t70"></a><a id="waitnotifysuspendresume_528"></a>wait(),notify()和suspend(),resume()之间的区别</h2> <p>初看起来它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法则相反。上述的核心区别导致了一系列的细节上的区别。</p> <p>首先，前面叙述的所有方法都隶属于 Thread 类，但是这一对却直接隶属于 Object 类，也就是说，所有对象都拥有这一对方法。初看起来这十分不可思议，但是实际上却是很自然的，因为这一对方法阻塞时要释放占用的锁，而锁是任何对象都具有的，调用任意对象的 wait() 方法导致线程阻塞，并且该对象上的锁被释放。而调用 任意对象的notify()方法则导致从调用该对象的 wait() 方法而阻塞的线程中随机选择的一个解除阻塞（但要等到获得锁后才真正可执行）。</p> <p>其次，前面叙述的所有方法都可在任何位置调用，但是这一对方法却必须在 synchronized 方法或块中调用，理由也很简单，只有在synchronized 方法或块中当前线程才占有锁，才有锁可以释放。同样的道理，调用这一对方法的对象上的锁必须为当前线程所拥有，这样才有锁可以释放。因此，这一对方法调用必须放置在这样的 synchronized 方法或块中，该方法或块的上锁对象就是调用这一对方法的对象。若不满足这一条件，则程序虽然仍能编译，但在运行时会出现IllegalMonitorStateException 异常。</p> <p>wait() 和 notify() 方法的上述特性决定了它们经常和synchronized关键字一起使用，将它们和操作系统进程间通信机制作一个比较就会发现它们的相似性：synchronized方法或块提供了类似于操作系统原语的功能，它们的执行不会受到多线程机制的干扰，而这一对方法则相当于 block 和wakeup 原语（这一对方法均声明为 synchronized）。它们的结合使得我们可以实现操作系统上一系列精妙的进程间通信的算法（如信号量算法），并用于解决各种复杂的线程间通信问题。</p> <p>关于 wait() 和 notify() 方法最后再说明两点：<br> 第一：调用 notify() 方法导致解除阻塞的线程是从因调用该对象的 wait() 方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。</p> <p>第二：除了 notify()，还有一个方法 notifyAll() 也可起到类似作用，唯一的区别在于，调用 notifyAll() 方法将把因调用该对象的 wait() 方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。</p> <p>谈到阻塞，就不能不谈一谈死锁，略一分析就能发现，suspend() 方法和不指定超时期限的 wait() 方法的调用都可能产生死锁。遗憾的是，Java 并不在语言级别上支持死锁的避免，我们在编程中必须小心地避免死锁。</p> <p>以上我们对 Java 中实现线程阻塞的各种方法作了一番分析，我们重点分析了 wait() 和 notify() 方法，因为它们的功能最强大，使用也最灵活，但是这也导致了它们的效率较低，较容易出错。实际使用中我们应该灵活使用各种方法，以便更好地达到我们的目的。</p> <h2><a name="t71"></a><a id="_546"></a>产生死锁的条件</h2> <p>1.互斥条件：一个资源每次只能被一个进程使用。<br> 2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br> 3.不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。<br> 4.循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p> <h2><a name="t72"></a><a id="waitnotifynotifyAll_553"></a>为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用</h2> <p>这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁</p> <h2><a name="t73"></a><a id="waitnotifynotifyAll_556"></a>wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别</h2> <p>wait()方法和notify()/notifyAll()方法在放弃对象监视器的时候的区别在于：wait()方法立即释放对象监视器，notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器。</p> <h2><a name="t74"></a><a id="waitsleep_559"></a>wait()与sleep()的区别</h2> <p>关于这两者已经在上面进行详细的说明,这里就做个概括好了:</p> <ul><li>sleep()来自Thread类，和wait()来自Object类.调用sleep()方法的过程中，线程不会释放对象锁。而 调用 wait 方法线程会释放对象锁</li><li>sleep()睡眠后不出让系统资源，wait让其他线程可以占用CPU</li><li>sleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒.而wait()需要配合notify()或者notifyAll()使用</li></ul><h2><a name="t75"></a><a id="waitnofitynofityAllThread_567"></a>为什么wait,nofity和nofityAll这些方法不放在Thread类当中</h2> <p>一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。</p> <p>##怎么唤醒一个阻塞的线程<br> 如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。</p> <p>##什么是多线程的上下文切换<br> 多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。</p> <h2><a name="t76"></a><a id="synchronizedReentrantLock_578"></a>synchronized和ReentrantLock的区别</h2> <p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：<br> （1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁<br> （2）ReentrantLock可以获取各种锁的信息<br> （3）ReentrantLock可以灵活地实现多路通知<br> 另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word.</p> <h2><a name="t77"></a><a id="FutureTask_585"></a>FutureTask是什么</h2> <p>这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。</p> <h2><a name="t78"></a><a id="_588"></a>一个线程如果出现了运行时异常怎么办?</h2> <p>如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放</p> <h2><a name="t79"></a><a id="Javasynchronized_591"></a>Java虚拟机对synchronized的优化</h2> <p>锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级.</p> <ol><li>偏向锁: 偏向锁是JDK 1.6之后加入的新锁，它是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁</li><li>轻量级锁:倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)，此时Mark Word 的结构也变为轻量级锁的结构。轻量级锁能够提升程序性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁</li><li>自旋锁: 轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。</li></ol><p>除此之外,锁消除也是一项非常重要的优化手段.Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间.</p> <h2><a name="t80"></a><a id="_601"></a>线程中断相关方法</h2> <p>当一个线程处于被阻塞状态或者试图执行一个阻塞操作时，使用<code>Thread.interrupt()</code>方式中断该线程，此时将会抛出一个InterruptedException的异常，同时中断状态将会被复位(由中断状态改为非中断状态).在Java中提供了以下三个与中断相关的方法:</p> <div class="hljs code-wrapper"><pre class="has" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:930px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">//中断线程（实例方法）</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> Thread.interrupt();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">//判断线程是否被中断（实例方法）</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> Thread.isInterrupted();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">//判断是否被中断并清除当前中断状态</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> Thread.interrupted();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}" onclick="hljs.copyCode(event)"></div></pre></div> <h2><a name="t81"></a>如何在两个线程间共享数据</h2> <p>通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的</p> <h2><a name="t82"></a><a id="waitifwhile_621"></a>如何正确的使用wait()?使用if还是while?</h2> <p>wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码：</p> <div class="hljs code-wrapper"><pre class="has" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:930px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> <span class="hljs-keyword">synchronized</span> (obj) &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">while</span> (condition does not hold)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      obj.wait(); <span class="hljs-comment">// (Releases lock, and reacquires on wakeup)</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      ... <span class="hljs-comment">// Perform action appropriate to condition</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> &#125;</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}" onclick="hljs.copyCode(event)"></div></pre></div> <h2><a name="t83"></a>什么是线程局部变量ThreadLocal</h2> <p>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p> <h2><a name="t84"></a><a id="ThreadLoal_635"></a>ThreadLoal的作用是什么?</h2> <p>简单说ThreadLocal就是一种以空间换时间的做法在每个Thread里面维护了一个ThreadLocal.ThreadLocalMap把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了.</p> <h2><a name="t85"></a><a id="_638"></a>生产者消费者模型的作用是什么?</h2> <p>（1）通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用<br> （2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约</p> <h2><a name="t86"></a><a id="_642"></a>写一个生产者-消费者队列</h2> <p>可以通过阻塞队列实现,也可以通过wait-notify来实现.</p> <h3><a name="t87"></a><a id="_645"></a>使用阻塞队列来实现</h3> <div class="hljs code-wrapper"><pre class="has" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:930px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">//消费者</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Integer&gt; queue;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Producer</span><span class="hljs-params">(BlockingQueue q)</span></span>&#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">this</span>.queue=q;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-meta">@Override</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">try</span> &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                Thread.sleep(<span class="hljs-number">1000</span>);<span class="hljs-comment">//模拟耗时</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                queue.put(produce());</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        &#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="18"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="19"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="20"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="21"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span> </span>&#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="22"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">int</span> n=<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">10000</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="23"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        System.out.println(<span class="hljs-string">"Thread:"</span> + Thread.currentThread().getId() + <span class="hljs-string">" produce:"</span> + n);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="24"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">return</span> n;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="25"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="26"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="27"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">//消费者</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="28"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="29"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Integer&gt; queue;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="30"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="31"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Consumer</span><span class="hljs-params">(BlockingQueue q)</span></span>&#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="32"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">this</span>.queue=q;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="33"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="34"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="35"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-meta">@Override</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="36"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="37"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="38"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">try</span> &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="39"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                Thread.sleep(<span class="hljs-number">2000</span>);<span class="hljs-comment">//模拟耗时</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="40"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                consume(queue.take());</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="41"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            &#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="42"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="43"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="44"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="45"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="46"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="47"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="48"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consume</span><span class="hljs-params">(Integer n)</span> </span>&#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="49"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        System.out.println(<span class="hljs-string">"Thread:"</span> + Thread.currentThread().getId() + <span class="hljs-string">" consume:"</span> + n);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="50"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="51"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="52"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="53"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">//测试</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="54"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="55"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="56"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="57"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        BlockingQueue&lt;Integer&gt; queue=<span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="hljs-number">100</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="58"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        Producer p=<span class="hljs-keyword">new</span> Producer(queue);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="59"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        Consumer c1=<span class="hljs-keyword">new</span> Consumer(queue);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="60"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        Consumer c2=<span class="hljs-keyword">new</span> Consumer(queue);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="61"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="62"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">new</span> Thread(p).start();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="63"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">new</span> Thread(c1).start();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="64"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">new</span> Thread(c2).start();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="65"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="66"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&#125;</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}" onclick="hljs.copyCode(event)"></div></pre></div> <h3><a name="t88"></a>使用wait-notify来实现</h3> <p>该种方式应该最经典,这里就不做说明了</p> <p>##如果你提交任务时,线程池队列已满,这时会发生什么</p> <p>如果使用的LinkedBlockingQueue,也就是无界队列的话,继续添加任务到阻塞队列中等待执行.因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列,可以无限存放任务;如果你使用的是有界队列比方说ArrayBlockingQueue的话,任务首先会被添加到ArrayBlockingQueue中,ArrayBlockingQueue满了,则会使用拒绝策略RejectedExecutionHandler处理满了的任务,默认是AbortPolicy.</p> <blockquote> </blockquote>                </div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>java-interview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java-review</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java hce</title>
    <link href="/2021/10/12/java-interview-1/"/>
    <url>/2021/10/12/java-interview-1/</url>
    
    <content type="html"><![CDATA[<h2 id="项目难点"><a href="#项目难点" class="headerlink" title="项目难点"></a>项目难点</h2><p>主要是在任务拆分的时候，会遇到一些困难，比如我们当时准备引入hashcat内核，掩码的形式计算密文的时候，他内核有一个keyspace参数表示总的行数，然后有skip和limit 表示开始和结束，类似于数据查询的分页，假设现在有一个密文是6位的，那就是95^6种结果，第一位是常数，后6位是秘文的也是95^6 次方种结果，但是在hashcat中，这俩的结果是一样的，就在分配任务时候，我们就无法正常使用了，所以我们引入了一个task的概念，也就是任务，每一个任务以 10050T 的计算速率跑5分钟，也就是将 keyspace 分割成多个任务，</p><p><code>一个task大小：1050ti跑5分钟 1050ti速度：5941.2MH/s</code></p><p>于是一个task的行数为：5941.2 * 1000 * 1000 * 60 * 5=1782360000000</p><p>掩码：?a?a?a?a?a 总行数：95^5=7737809375 由于7737809375小于1个task的大小，就1个task</p><p>掩码：?a?a?a?a?a?a?a?a 95^8 = 6634204312890625 6634204312890625/1782360000000=3,722.1460944426 task</p><ol><li>[0 8145062) </li><li>[8145062 8145062) </li><li>[8145062 + 8145062 8145062)</li><li>[8145062 * 3 8145062)</li><li>[8145062  *  4 8145062)</li><li>[8145062  *  5 8145062)</li><li>[8145062  *  6 8145062)</li><li>[8145062  *  7 8145062)</li><li>[8145062  *  8 8145062)</li><li>[8145062  *  9 8145063)</li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>java-interview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java-review</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux du</title>
    <link href="/2021/10/12/linux-du/"/>
    <url>/2021/10/12/linux-du/</url>
    
    <content type="html"><![CDATA[<h1 id="du查看某个文件或目录占用磁盘空间的大小"><a href="#du查看某个文件或目录占用磁盘空间的大小" class="headerlink" title="du查看某个文件或目录占用磁盘空间的大小"></a>du查看某个文件或目录占用磁盘空间的大小</h1><p>一、du的功能：<code>du</code> reports the amount of disk space used by the specified files and for each subdirectory (of directory arguments). with no arguments,<code>du</code> reports the disk space for the current directory。</p><p>　　很明显，与df不同，它用来查看文件或目录所占用的磁盘空间的大小。</p><p> 二、du常用的选项：</p><p>　　<strong>-h</strong>：以人类可读的方式显示(表示以恰当的K/M/G单位展示)</p><p>　　-a：显示目录占用的磁盘空间大小，还要显示其下目录和文件占用磁盘空间的大小</p><p>　　<strong>-s</strong>：(summarize)显示目录占用的磁盘空间大小，不要显示其下子目录和文件占用的磁盘空间大小(即算总和)</p><p>　　-c：显示几个目录或文件占用的磁盘空间大小，还要统计它们的总和</p><p>　　–apparent-size：显示目录或文件自身的大小</p><p>　　-l ：统计硬链接占用磁盘空间的大小</p><p>　　-L：统计符号链接所指向的文件占用的磁盘空间大小</p><p>　　一、du -h：这个就不多说了。</p><p>　　二、du -a：使用此选项时，显示目录和目录下子目录和文件占用磁盘空间的大小。</p><p>常用的命令</p><p>du -sh [指定文件或目录]: 查看当前目录总共占的容量。而不单独列出各子项占用的容量 </p><p>du -lh –max-depth=1 : 查看当前目录下一级子文件和子目录占用的磁盘容量。–max-depth 选项控制深度（从0、1…开始）</p><p>示例：</p><ol><li></li></ol><div class="hljs code-wrapper"><pre><code class="hljs mipsasm">du -<span class="hljs-keyword">sh </span>*</code></pre></div><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvmr8iuuo5j60fr04odgo02.jpg" alt="img"></p><p>2.</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">du</span> -ch <span class="hljs-regexp">*.tar.gz</span></code></pre></div><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvmr8ql12yj60g906dq4k02.jpg" alt="img"></p><p><code>-c</code>选项，是 –total 的缩写形式，它表示的是针对输出的各个对象来计算其磁盘使用量的总和 </p><p>3.</p><div class="hljs code-wrapper"><pre><code class="hljs gml">du -lh --<span class="hljs-built_in">max</span>-<span class="hljs-symbol">depth</span>=<span class="hljs-number">1</span></code></pre></div><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvmr8x7tyyj60ge06xt9y02.jpg" alt="img"></p><p>当–max-depth设定为0时, 只显示当前文件夹总大小</p><p>可见, –max-depth=0的作用, 相当于-s</p><p><strong>du和ls的区别</strong></p><ul><li>du 展示的是磁盘空间占用量。</li><li>ls 展示的是文件内容的大小。</li></ul><p>同时， du 和 ls 针对同一个文件，展示的大小是不一样的 (抽象说：磁盘占用=内容+包装)</p><p>因为大部分文件系统规定：</p><ol><li>一个数据块中最多存放一个文件的内容，当没存满时，剩余的空间不得被其他文件使用。</li><li>当一个文件的内容较大时，则可以存储到多个数据块中。</li></ol>]]></content>
    
    
    <categories>
      
      <category>system</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx</title>
    <link href="/2021/10/11/nginx-start/"/>
    <url>/2021/10/11/nginx-start/</url>
    
    <content type="html"><![CDATA[<h1 id="Nginx学习"><a href="#Nginx学习" class="headerlink" title="Nginx学习"></a>Nginx学习</h1><p><code>Nginx</code> 是开源、高性能、高可靠的 <code>Web</code> 和反向代理服务器，而且支持热部署，几乎可以做到 7 * 24 小时不间断运行，即使运行几个月也不需要重新启动，还能在不间断服务的情况下对软件版本进行热更新。性能是 <code>Nginx</code> 最重要的考量，其占用内存少、并发能力强、能支持高达 5w 个并发连接数，最重要的是， <code>Nginx</code> 是免费的并可以商业化，配置使用也比较简单。</p><p><strong>Nginx 特点</strong></p><ul><li>高并发、高性能；</li><li>模块化架构使得它的扩展性非常好；</li><li>异步非阻塞的事件驱动模型这点和 <code>Node.js</code> 相似；</li><li>相对于其它服务器来说它可以连续几个月甚至更长而不需要重启服务器使得它具有高可靠性；</li><li>热部署、平滑升级；</li><li>完全开源，生态繁荣；</li></ul><h1 id="Nginx-作用"><a href="#Nginx-作用" class="headerlink" title="Nginx 作用"></a>Nginx 作用</h1><p>Nginx 的最重要的几个使用场景：</p><ol><li>静态资源服务，通过本地文件系统提供服务；</li><li>反向代理服务，延伸出包括缓存、负载均衡等；</li><li><code>API</code> 服务， <code>OpenResty</code> ；</li></ol><p>对于前端来说 <code>Node.js</code> 并不陌生， <code>Nginx</code> 和 <code>Node.js</code> 的很多理念类似， <code>HTTP</code> 服务器、事件驱动、异步非阻塞等，且 <code>Nginx</code> 的大部分功能使用 <code>Node.js</code> 也可以实现，但 <code>Nginx</code> 和<code>Node.js</code> 并不冲突，都有自己擅长的领域。<code>Nginx</code> 擅长于底层服务器端资源的处理（静态资源处理转发、反向代理，负载均衡等）， <code>Node.js</code> 更擅长上层具体业务逻辑的处理，两者可以完美组合。</p><p>用一张图表示：</p><p><img src="https://i.loli.net/2021/05/12/cHgeKZTvGRlxbNs.png" alt="Image"></p><p><strong>Nginx 安装</strong></p><p>本文演示的是 <code>Linux</code> <code>centOS 7.x</code> 的操作系统上安装 <code>Nginx</code> ，至于在其它操作系统上进行安装可以网上自行搜索，都非常简单的。</p><p>使用 <code>yum</code> 安装 <code>Nginx</code> ：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">yum install nginx -y</code></pre></div><p>安装完成后，通过 <code>rpm \-ql nginx</code> 命令查看 <code>Nginx</code> 的安装信息：</p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># Nginx配置文件</span>/etc/nginx/nginx.conf <span class="hljs-comment"># nginx 主配置文件</span>/etc/nginx/nginx.conf.default<span class="hljs-comment"># 可执行程序文件</span>/usr/bin/nginx-upgrade/usr/sbin/nginx<span class="hljs-comment"># nginx库文件</span>/usr/lib/systemd/system/nginx.service <span class="hljs-comment"># 用于配置系统守护进程</span>/usr/lib64/nginx/modules <span class="hljs-comment"># Nginx模块目录</span><span class="hljs-comment"># 帮助文档</span>/usr/share/doc/nginx-1.16.1/usr/share/doc/nginx-1.16.1/CHANGES/usr/share/doc/nginx-1.16.1/README/usr/share/doc/nginx-1.16.1/README.dynamic/usr/share/doc/nginx-1.16.1/UPGRADE-NOTES-1.6-to-1.10<span class="hljs-comment"># 静态资源目录</span>/usr/share/nginx/html/404.html/usr/share/nginx/html/50x.html/usr/share/nginx/html/index.html<span class="hljs-comment"># 存放Nginx日志文件</span>/var/<span class="hljs-built_in">log</span>/nginx</code></pre></div><p>主要关注的文件夹有两个：</p><p><code>1. /etc/nginx/conf.d/</code> 是子配置项存放处， <code>/etc/nginx/nginx.conf</code> 主配置文件会默认把这个文件夹中所有子配置项都引入；</p><p><code>2. /usr/share/nginx/html/</code> 静态文件都放在这个文件夹，也可以根据你自己的习惯放在其他地方；</p><p><strong>Nginx 常用命令</strong></p><p><code>systemctl</code> 系统命令：</p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 开机配置</span>systemctl <span class="hljs-built_in">enable</span> nginx <span class="hljs-comment"># 开机自动启动</span>systemctl <span class="hljs-built_in">disable</span> nginx <span class="hljs-comment"># 关闭开机自动启动</span><span class="hljs-comment"># 启动Nginx</span>systemctl start nginx <span class="hljs-comment"># 启动Nginx成功后，可以直接访问主机IP，此时会展示Nginx默认页面</span><span class="hljs-comment"># 停止Nginx</span>systemctl stop nginx<span class="hljs-comment"># 重启Nginx</span>systemctl restart nginx<span class="hljs-comment"># 重新加载Nginx</span>systemctl reload nginx<span class="hljs-comment"># 查看 Nginx 运行状态</span>systemctl status nginx<span class="hljs-comment"># 查看Nginx进程</span>ps -ef | grep nginx<span class="hljs-comment"># 杀死Nginx进程</span><span class="hljs-built_in">kill</span> -9 pid <span class="hljs-comment"># 根据上面查看到的Nginx进程号，杀死Nginx进程，-9 表示强制结束进程</span></code></pre></div><p><code>Nginx</code> 应用程序命令：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">nginx -s reload <span class="hljs-comment"># 向主进程发送信号，重新加载配置文件，热重启</span>nginx -s reopen <span class="hljs-comment"># 重启 Nginx</span>nginx -s stop <span class="hljs-comment"># 快速关闭</span>nginx -s quit <span class="hljs-comment"># 等待工作进程处理完成后关闭</span>nginx -T <span class="hljs-comment"># 查看当前 Nginx 最终的配置</span>nginx -t <span class="hljs-comment"># 检查配置是否有问题</span></code></pre></div><h1 id="Nginx-核心配置"><a href="#Nginx-核心配置" class="headerlink" title="Nginx 核心配置"></a>Nginx 核心配置</h1><h2 id="配置文件结构"><a href="#配置文件结构" class="headerlink" title="配置文件结构"></a>配置文件结构</h2><p><code>Nginx</code> 的典型配置示例：</p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># main段配置信息</span>user  nginx; <span class="hljs-comment"># 运行用户，默认即是nginx，可以不进行设置</span>worker_processes  auto; <span class="hljs-comment"># Nginx 进程数，一般设置为和 CPU 核数一样</span>error_log  /var/<span class="hljs-built_in">log</span>/nginx/error.log warn; <span class="hljs-comment"># Nginx 的错误日志存放目录</span>pid        /var/run/nginx.pid; <span class="hljs-comment"># Nginx 服务启动时的 pid 存放位置</span><span class="hljs-comment"># events段配置信息</span>events &#123;    use epoll; <span class="hljs-comment"># 使用epoll的I/O模型(如果你不知道Nginx该使用哪种轮询方法，会自动选择一个最适合你操作系统的)</span>    worker_connections 1024; <span class="hljs-comment"># 每个进程允许最大并发数</span>&#125;<span class="hljs-comment"># http段配置信息</span><span class="hljs-comment"># 配置使用最频繁的部分，代理、缓存、日志定义等绝大多数功能和第三方模块的配置都在这里设置</span>http &#123;     <span class="hljs-comment"># 设置日志模式</span>    log_format  main <span class="hljs-string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span>                      <span class="hljs-string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span>                      <span class="hljs-string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;    access_log  /var/<span class="hljs-built_in">log</span>/nginx/access.log main; <span class="hljs-comment"># Nginx访问日志存放位置</span>    sendfile            on; <span class="hljs-comment"># 开启高效传输模式</span>    tcp_nopush          on; <span class="hljs-comment"># 减少网络报文段的数量</span>    tcp_nodelay         on;    keepalive_timeout   65; <span class="hljs-comment"># 保持连接的时间，也叫超时时间，单位秒</span>    types_hash_max_size 2048;    include             /etc/nginx/mime.types; <span class="hljs-comment"># 文件扩展名与类型映射表</span>    default_type        application/octet-stream; <span class="hljs-comment"># 默认文件类型</span>    include /etc/nginx/conf.d/*.conf; <span class="hljs-comment"># 加载子配置项</span>        <span class="hljs-comment"># server段配置信息</span>    server &#123;     listen       80; <span class="hljs-comment"># 配置监听的端口</span>     server_name  localhost; <span class="hljs-comment"># 配置的域名</span>           <span class="hljs-comment"># location段配置信息</span>     location / &#123;      root   /usr/share/nginx/html; <span class="hljs-comment"># 网站根目录</span>      index  index.html index.htm; <span class="hljs-comment"># 默认首页文件</span>      deny 172.168.22.11; <span class="hljs-comment"># 禁止访问的ip地址，可以为all</span>      allow 172.168.33.44；<span class="hljs-comment"># 允许访问的ip地址，可以为all</span>     &#125;          error_page 500 502 503 504 /50x.html; <span class="hljs-comment"># 默认50x对应的访问页面</span>     error_page 400 404 error.html; <span class="hljs-comment"># 同上</span>    &#125;&#125;</code></pre></div><ul><li> 全局配置，对全局生效；</li><li><code>events</code> 配置影响 <code>Nginx</code> 服务器与用户的网络连接；</li><li><code>http</code> 配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置；</li><li><code>server</code> 配置虚拟主机的相关参数，一个 <code>http</code> 块中可以有多个 <code>server</code> 块；</li><li><code>location</code> 用于配置匹配的 <code>uri</code> ；</li><li><code>upstream</code> 配置后端服务器具体地址，负载均衡配置不可或缺的部分；</li></ul><p>用一张图清晰的展示它的层级结构：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqgipd9lr4j304w0bd3ye.jpg" alt="Image"></p><h2 id="配置文件-main-段核心参数"><a href="#配置文件-main-段核心参数" class="headerlink" title="配置文件 main 段核心参数"></a>配置文件 main 段核心参数</h2><h2 id="user"><a href="#user" class="headerlink" title="user"></a>user</h2><p>指定运行 <code>Nginx</code> 的 <code>woker</code> 子进程的属主和属组，其中组可以不指定。</p><div class="hljs code-wrapper"><pre><code class="hljs bash">user USERNAME [GROUP]user nginx lion; <span class="hljs-comment"># 用户是nginx;组是lion</span></code></pre></div><p><strong>pid</strong></p><p>指定运行 <code>Nginx</code> <code>master</code> 主进程的 <code>pid</code> 文件存放路径。</p><div class="hljs code-wrapper"><pre><code class="hljs bash">pid /opt/nginx/logs/nginx.pid <span class="hljs-comment"># master主进程的的pid存放在nginx.pid的文件</span></code></pre></div><h3 id="worker-rlimit-nofile-number"><a href="#worker-rlimit-nofile-number" class="headerlink" title="worker_rlimit_nofile_number"></a>worker_rlimit_nofile_number</h3><p>指定 <code>worker</code> 子进程可以打开的最大文件句柄数。</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">worker_rlimit_nofile</span> <span class="hljs-number">20480</span>; <span class="hljs-comment"># 可以理解成每个worker子进程的最大连接数量。</span></code></pre></div><p><strong>worker_rlimit_core</strong></p><p>指定 <code>worker</code> 子进程异常终止后的 <code>core</code> 文件，用于记录分析问题。</p><div class="hljs code-wrapper"><pre><code class="hljs awk">worker_rlimit_core <span class="hljs-number">50</span>M; <span class="hljs-comment"># 存放大小限制</span>working_directory <span class="hljs-regexp">/opt/</span>nginx/tmp; <span class="hljs-comment"># 存放目录</span></code></pre></div><h3 id="worker-processes-number"><a href="#worker-processes-number" class="headerlink" title="worker_processes_number"></a>worker_processes_number</h3><p>指定 <code>Nginx</code> 启动的 <code>worker</code> 子进程数量。</p><div class="hljs code-wrapper"><pre><code class="hljs bash">worker_processes 4; <span class="hljs-comment"># 指定具体子进程数量</span>worker_processes auto; <span class="hljs-comment"># 与当前cpu物理核心数一致</span></code></pre></div><h3 id="worker-cpu-affinity"><a href="#worker-cpu-affinity" class="headerlink" title="worker_cpu_affinity"></a>worker_cpu_affinity</h3><p>将每个 <code>worker</code> 子进程与我们的 <code>cpu</code> 物理核心绑定。</p><div class="hljs code-wrapper"><pre><code class="hljs bash">worker_cpu_affinity 0001 0010 0100 1000; <span class="hljs-comment"># 4个物理核心，4个worker子进程</span></code></pre></div><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqgipukswcj30h20cj3yl.jpg" alt="Image"></p><p>将每个 <code>worker</code> 子进程与特定 <code>CPU</code> 物理核心绑定，优势在于，避免同一个 <code>worker</code> 子进程在不同的 <code>CPU</code> 核心上切换，缓存失效，降低性能。但其并不能真正的避免进程切换。</p><p><strong>worker_priority</strong></p><p>指定 <code>worker</code> 子进程的 <code>nice</code> 值，以调整运行 <code>Nginx</code> 的优先级，通常设定为负值，以优先调用<code>Nginx</code> 。</p><div class="hljs code-wrapper"><pre><code class="hljs bash">worker_priority -10; <span class="hljs-comment"># 120-10=110，110就是最终的优先级</span></code></pre></div><p><code>Linux</code> 默认进程的优先级值是120，值越小越优先；<code>nice</code> 定范围为 <code>-20</code> 到 <code>+19</code> 。</p><p>[备注] 应用的默认优先级值是120加上 <code>nice</code> 值等于它最终的值，这个值越小，优先级越高。</p><h3 id="worker-shutdown-timeout"><a href="#worker-shutdown-timeout" class="headerlink" title="worker_shutdown_timeout"></a>worker_shutdown_timeout</h3><p>指定 <code>worker</code> 子进程优雅退出时的超时时间。</p><div class="hljs code-wrapper"><pre><code class="hljs bash">worker_shutdown_timeout 5s;</code></pre></div><h3 id="timer-resolution"><a href="#timer-resolution" class="headerlink" title="timer_resolution"></a>timer_resolution</h3><p><code>worker</code> 子进程内部使用的计时器精度，调整时间间隔越大，系统调用越少，有利于性能提升；反之，系统调用越多，性能下降。</p><div class="hljs code-wrapper"><pre><code class="hljs bash">timer_resolution 100ms;</code></pre></div><p>在 <code>Linux</code> 系统中，用户需要获取计时器时需要向操作系统内核发送请求，有请求就必然会有开销，因此这个间隔越大开销就越小。</p><p><strong>daemon</strong></p><p>指定 <code>Nginx</code> 的运行方式，前台还是后台，前台用于调试，后台用于生产。</p><div class="hljs code-wrapper"><pre><code class="hljs bash">daemon off; <span class="hljs-comment"># 默认是on，后台运行模式</span></code></pre></div><h2 id="配置文件-events-段核心参数"><a href="#配置文件-events-段核心参数" class="headerlink" title="配置文件 events 段核心参数"></a>配置文件 events 段核心参数</h2><h3 id="use"><a href="#use" class="headerlink" title="use"></a>use</h3><p><code>Nginx</code> 使用何种事件驱动模型。</p><div class="hljs code-wrapper"><pre><code class="hljs bash">use method; <span class="hljs-comment"># 不推荐配置它，让nginx自己选择</span>method 可选值为：select、poll、kqueue、epoll、/dev/poll、eventport</code></pre></div><h3 id="worker-connections"><a href="#worker-connections" class="headerlink" title="worker_connections"></a>worker_connections</h3><p><code>worker</code> 子进程能够处理的最大并发连接数。</p><div class="hljs code-wrapper"><pre><code class="hljs bash">worker_connections 1024 <span class="hljs-comment"># 每个子进程的最大连接数为1024</span></code></pre></div><p><strong>accept_mutex</strong></p><p>是否打开负载均衡互斥锁。</p><div class="hljs code-wrapper"><pre><code class="hljs bash">accept_mutex on <span class="hljs-comment"># 默认是off关闭的，这里推荐打开</span></code></pre></div><p><strong>server_name 指令</strong></p><p>指定虚拟主机域名。</p><div class="hljs code-wrapper"><pre><code class="hljs bash">server_name name1 name2 name3<span class="hljs-comment"># 示例：</span>server_name www.nginx.com;</code></pre></div><p>域名匹配的四种写法：</p><ul><li>精确匹配：<code>server_name www.nginx.com</code> ;</li><li>左侧通配：<code>server_name *.nginx.com</code> ;</li><li>右侧统配：<code>server_name www.nginx.*</code> ;</li><li>正则匹配：<code>server_name ~^www\.nginx\.*$</code> ;</li></ul><p>匹配优先级：<strong>精确匹配 &gt; 左侧通配符匹配 &gt; 右侧通配符匹配 &gt; 正则表达式匹配</strong></p><p><code>server_name</code> 配置实例：</p><p>1、配置本地 <code>DNS</code> 解析 <code>vim /etc/hosts</code> （ <code>macOS</code> 系统）</p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 添加如下内容，其中 121.42.11.34 是阿里云服务器IP地址</span>121.42.11.34 www.nginx-test.com121.42.11.34 mail.nginx-test.com121.42.11.34 www.nginx-test.org121.42.11.34 doc.nginx-test.com121.42.11.34 www.nginx-test.cn121.42.11.34 fe.nginx-test.club</code></pre></div><p>[注意] 这里使用的是虚拟域名进行测试，因此需要配置本地 <code>DNS</code> 解析，如果使用阿里云上购买的域名，则需要在阿里云上设置好域名解析。</p><p>2、配置阿里云 <code>Nginx</code> ，<code>vim /etc/nginx/nginx.conf</code></p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 这里只列举了http端中的sever端配置</span><span class="hljs-comment"># 左匹配</span>server &#123; listen 80; server_name *.nginx-test.com; root /usr/share/nginx/html/nginx-test/left-match/; location / &#123;  index index.html; &#125;&#125;<span class="hljs-comment"># 正则匹配</span>server &#123; listen 80; server_name ~^.*\.nginx-test\..*$; root /usr/share/nginx/html/nginx-test/reg-match/; location / &#123;  index index.html; &#125;&#125;<span class="hljs-comment"># 右匹配</span>server &#123; listen 80; server_name www.nginx-test.*; root /usr/share/nginx/html/nginx-test/right-match/; location / &#123;  index index.html; &#125;&#125;<span class="hljs-comment"># 完全匹配</span>server &#123; listen 80; server_name www.nginx-test.com; root /usr/share/nginx/html/nginx-test/all-match/; location / &#123;  index index.html; &#125;&#125;</code></pre></div><p>3、访问分析</p><ul><li>当访问 <code>www.nginx-test.com</code> 时，都可以被匹配上，因此选择优先级最高的“完全匹配”；</li><li>当访问 <code>mail.nginx-test.com</code> 时，会进行“左匹配”；</li><li>当访问 <code>www.nginx-test.org</code> 时，会进行“右匹配”；</li><li>当访问 <code>doc.nginx-test.com</code> 时，会进行“左匹配”；</li><li>当访问 <code>www.nginx-test.cn</code> 时，会进行“右匹配”；</li><li>当访问 <code>fe.nginx-test.club</code> 时，会进行“正则匹配”；</li></ul><h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p>指定静态资源目录位置，它可以写在 <code>http</code> 、 <code>server</code> 、 <code>location</code> 等配置中。</p><div class="hljs code-wrapper"><pre><code class="hljs bash">root path例如：location /image &#123; root /opt/nginx/static;&#125;当用户访问 www.test.com/image/1.png 时，实际在服务器找的路径是 /opt/nginx/static/image/1.png</code></pre></div><p>[注意] <code>root</code> 会将定义路径与 <code>URI</code> 叠加， <code>alias</code> 则只取定义路径。</p><h2 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h2><p>它也是指定静态资源目录位置，它只能写在 <code>location</code> 中。</p><div class="hljs code-wrapper"><pre><code class="hljs awk">location /image &#123; alias <span class="hljs-regexp">/opt/</span>nginx<span class="hljs-regexp">/static/im</span>age/;&#125;当用户访问 www.test.com<span class="hljs-regexp">/image/</span><span class="hljs-number">1</span>.png 时，实际在服务器找的路径是 <span class="hljs-regexp">/opt/</span>nginx<span class="hljs-regexp">/static/im</span>age/<span class="hljs-number">1</span>.png</code></pre></div><p>[注意] 使用 alias 末尾一定要添加 <code>/</code> ，并且它只能位于 <code>location</code> 中。</p><p><strong>location</strong></p><p>配置路径。</p><div class="hljs code-wrapper"><pre><code class="hljs crmsh"><span class="hljs-keyword">location</span> <span class="hljs-title">[ = | ~ | ~* | ^~ ] uri</span> &#123; ...&#125;</code></pre></div><p>匹配规则：</p><ul><li><code>=</code> 精确匹配；</li><li><code>~</code> 正则匹配，区分大小写；</li><li><code>~*</code> 正则匹配，不区分大小写；</li><li><code>^~</code> 匹配到即停止搜索；</li></ul><p>匹配优先级：<code>=</code> &gt; <code>^~</code> &gt; <code>~</code> &gt; <code>~*</code> &gt; 不带任何字符。</p><p>实例：</p><div class="hljs code-wrapper"><pre><code class="hljs gradle">server &#123;  listen <span class="hljs-number">80</span>;  server_name www.nginx-test.com;    # 只有当访问 www.nginx-test.com<span class="hljs-regexp">/match_all/</span> 时才会匹配到<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html<span class="hljs-regexp">/match_all/i</span>ndex.html  location = <span class="hljs-regexp">/match_all/</span> &#123;      root <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html      index index.html  &#125;    # 当访问 www.nginx-test.com<span class="hljs-regexp">/1.jpg 等路径时会去 /u</span>sr<span class="hljs-regexp">/share/</span>nginx<span class="hljs-regexp">/images/</span><span class="hljs-number">1</span>.jpg 找对应的资源  location ~ \.(jpeg|jpg|png|svg)$ &#123;   root <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/im</span>ages;  &#125;    # 当访问 www.nginx-test.com<span class="hljs-regexp">/bbs/</span> 时会匹配上 <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html<span class="hljs-regexp">/bbs/i</span>ndex.html  location ^~ <span class="hljs-regexp">/bbs/</span> &#123;   root <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html;    index index.html index.htm;  &#125;&#125;</code></pre></div><p><strong>location 中的反斜线</strong></p><div class="hljs code-wrapper"><pre><code class="hljs crmsh"><span class="hljs-keyword">location</span> <span class="hljs-title">/test</span> &#123; ...&#125;<span class="hljs-keyword">location</span> <span class="hljs-title">/test</span>/ &#123; ...&#125;</code></pre></div><ul><li>不带 <code>/</code> 当访问 <code>www.nginx-test.com/test</code> 时， <code>Nginx</code> 先找是否有 <code>test</code> 目录，如果有则找<code>test</code> 目录下的 <code>index.html</code> ；如果没有 <code>test</code> 目录， <code>nginx</code> 则会找是否有 <code>test</code> 文件。</li><li>带 <code>/</code> 当访问 <code>www.nginx-test.com/test</code> 时， <code>Nginx</code> 先找是否有 <code>test</code> 目录，如果有则找<code>test</code> 目录下的 <code>index.html</code> ，如果没有它也不会去找是否存在 <code>test</code> 文件。</li></ul><h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><p>停止处理请求，直接返回响应码或重定向到其他 <code>URL</code> ；执行 <code>return</code> 指令后， <code>location</code> 中后续指令将不会被执行。</p><div class="hljs code-wrapper"><pre><code class="hljs crmsh">return code [text];return code URL;return URL;例如：<span class="hljs-keyword">location</span> <span class="hljs-title">/ &#123;</span><span class="hljs-title"> return</span> <span class="hljs-number">404</span>; <span class="hljs-comment"># 直接返回状态码</span>&#125;<span class="hljs-keyword">location</span> <span class="hljs-title">/ &#123;</span><span class="hljs-title"> return</span> <span class="hljs-number">404</span> <span class="hljs-string">&quot;pages not found&quot;</span>; <span class="hljs-comment"># 返回状态码 + 一段文本</span>&#125;<span class="hljs-keyword">location</span> <span class="hljs-title">/ &#123;</span><span class="hljs-title"> return</span> <span class="hljs-number">302</span> /bbs ; <span class="hljs-comment"># 返回状态码 + 重定向地址</span>&#125;<span class="hljs-keyword">location</span> <span class="hljs-title">/ &#123;</span><span class="hljs-title"> return</span> https://www.baidu.com ; <span class="hljs-comment"># 返回重定向地址</span>&#125;</code></pre></div><h2 id="rewrite"><a href="#rewrite" class="headerlink" title="rewrite"></a>rewrite</h2><p>根据指定正则表达式匹配规则，重写 <code>URL</code> 。</p><div class="hljs code-wrapper"><pre><code class="hljs awk">语法：rewrite 正则表达式 要替换的内容 [flag];上下文：server、location、<span class="hljs-keyword">if</span>示例：rewirte <span class="hljs-regexp">/images/</span>(.*\.jpg)$ <span class="hljs-regexp">/pic/</span><span class="hljs-variable">$1</span>; <span class="hljs-comment"># $1是前面括号(.*\.jpg)的反向引用</span></code></pre></div><p><code>flag</code> 可选值的含义：</p><ul><li><code>last</code> 重写后的 <code>URL</code> 发起新请求，再次进入 <code>server</code> 段，重试 <code>location</code> 的中的匹配；</li><li><code>break</code> 直接使用重写后的 <code>URL</code> ，不再匹配其它 <code>location</code> 中语句；</li><li><code>redirect</code> 返回302临时重定向；</li><li><code>permanent</code> 返回301永久重定向；</li></ul><div class="hljs code-wrapper"><pre><code class="hljs crmsh">server&#123;  listen <span class="hljs-number">80</span>;  server_name fe.lion.club; <span class="hljs-comment"># 要在本地hosts文件进行配置</span>  root html;  <span class="hljs-keyword">location</span> <span class="hljs-title">/search</span> &#123;   rewrite ^/(.*) https://www.baidu.com redirect;  &#125;    <span class="hljs-keyword">location</span> <span class="hljs-title">/images</span> &#123;   rewrite /images/(.*) /pics/$<span class="hljs-number">1</span>;  &#125;    <span class="hljs-keyword">location</span> <span class="hljs-title">/pics</span> &#123;   rewrite /pics/(.*) /photos/$<span class="hljs-number">1</span>;  &#125;    <span class="hljs-keyword">location</span> <span class="hljs-title">/photos</span> &#123;    &#125;&#125;</code></pre></div><p>按照这个配置我们来分析：</p><ul><li>当访问 <code>fe.lion.club/search</code> 时，会自动帮我们重定向到 <code>https://www.baidu.com</code>。</li><li>当访问 <code>fe.lion.club/images/1.jpg</code> 时，第一步重写 <code>URL</code> 为 <code>fe.lion.club/pics/1.jpg</code> ，找到 <code>pics</code> 的 <code>location</code> ，继续重写 <code>URL</code> 为 <code>fe.lion.club/photos/1.jpg</code> ，找到 <code>/photos</code> 的<code>location</code> 后，去 <code>html/photos</code> 目录下寻找 <code>1.jpg</code> 静态资源。</li></ul><h2 id="if-指令"><a href="#if-指令" class="headerlink" title="if 指令"></a>if 指令</h2><div class="hljs code-wrapper"><pre><code class="hljs nim">语法：<span class="hljs-keyword">if</span> (condition) <span class="hljs-meta">&#123;...&#125;</span>上下文：server、location示例：<span class="hljs-keyword">if</span>($http_user_agent ~ <span class="hljs-type">Chrome</span>)&#123;  rewrite /(.*)/browser/$<span class="hljs-number">1</span> <span class="hljs-keyword">break</span>;&#125;</code></pre></div><p><code>condition</code> 判断条件：</p><ul><li><code>$variable</code> 仅为变量时，值为空或以0开头字符串都会被当做 <code>false</code> 处理；</li><li><code>=</code> 或 <code>!=</code> 相等或不等；</li><li><code>~</code> 正则匹配；</li><li><code>! ~</code> 非正则匹配；</li><li><code>~*</code> 正则匹配，不区分大小写；</li><li><code>-f</code> 或 <code>! -f</code> 检测文件存在或不存在；</li><li><code>-d</code> 或 <code>! -d</code> 检测目录存在或不存在；</li><li><code>-e</code> 或 <code>! -e</code> 检测文件、目录、符号链接等存在或不存在；</li><li><code>-x</code> 或 <code>! -x</code> 检测文件可以执行或不可执行；</li></ul><p>实例：</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;  <span class="hljs-attribute">listen</span> <span class="hljs-number">8080</span>;  <span class="hljs-attribute">server_name</span> localhost;  <span class="hljs-attribute">root</span> html;    <span class="hljs-attribute">location</span> / &#123;   <span class="hljs-attribute">if</span> ( $uri = <span class="hljs-string">&quot;/images/&quot;</span> )&#123;     <span class="hljs-attribute">rewrite</span> (.*) /pics/ <span class="hljs-literal">break</span>;    &#125;  &#125;&#125;</code></pre></div><p>当访问 <code>localhost:8080/images/</code> 时，会进入 <code>if</code> 判断里面执行 <code>rewrite</code> 命令。</p><p><strong>autoindex</strong></p><p>用户请求以 <code>/</code> 结尾时，列出目录结构，可以用于快速搭建静态资源下载网站。</p><p><code>autoindex.conf</code> 配置信息：</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;  <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;  <span class="hljs-attribute">server_name</span> fe.lion-test.club;    <span class="hljs-attribute">location</span> /download/ &#123;    <span class="hljs-attribute">root</span> /opt/source;        <span class="hljs-attribute">autoindex</span> <span class="hljs-literal">on</span>; <span class="hljs-comment"># 打开 autoindex，，可选参数有 on | off</span>    <span class="hljs-attribute">autoindex_exact_size</span> <span class="hljs-literal">on</span>; <span class="hljs-comment"># 修改为off，以KB、MB、GB显示文件大小，默认为on，以bytes显示出⽂件的确切⼤⼩</span>    <span class="hljs-attribute">autoindex_format</span> html; <span class="hljs-comment"># 以html的方式进行格式化，可选参数有 html | json | xml</span>    <span class="hljs-attribute">autoindex_localtime</span> <span class="hljs-literal">off</span>; <span class="hljs-comment"># 显示的⽂件时间为⽂件的服务器时间。默认为off，显示的⽂件时间为GMT时间</span>  &#125;&#125;</code></pre></div><p>当访问 <code>fe.lion.com/download/</code> 时，会把服务器 <code>/opt/source/download/</code> 路径下的文件展示出来，如下图所示：</p><p><img src="https://i.loli.net/2021/05/13/xSXV4IvkreYuOa2.png" alt="Image"></p><p><strong>变量</strong></p><p><code>Nginx</code> 提供给使用者的变量非常多，但是终究是一个完整的请求过程所产生数据， <code>Nginx</code> 将这些数据以变量的形式提供给使用者。</p><p>下面列举些项目中常用的变量：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqgionqq4ij30k212ydkv.jpg" alt="Image"></p><p>实例演示 <code>var.conf</code> ：</p><div class="hljs code-wrapper"><pre><code class="hljs stata">server&#123; listen 8081; server_name <span class="hljs-keyword">var</span>.lion-<span class="hljs-keyword">test</span>.club; root /usr/share/nginx/html; location / &#123;  <span class="hljs-keyword">return</span> 200 &quot;remote_addr: <span class="hljs-variable">$remote_addr</span>remote_port: <span class="hljs-variable">$remote_port</span>server_addr: <span class="hljs-variable">$server_addr</span>server_port: <span class="hljs-variable">$server_port</span>server_protocol: <span class="hljs-variable">$server_protocol</span>binary_remote_addr: <span class="hljs-variable">$binary_remote_addr</span>connection: <span class="hljs-variable">$connection</span>uri: <span class="hljs-variable">$uri</span>request_uri: <span class="hljs-variable">$request_uri</span>scheme: <span class="hljs-variable">$scheme</span>request_method: <span class="hljs-variable">$request_method</span>request_length: <span class="hljs-variable">$request_length</span><span class="hljs-keyword">args</span>: <span class="hljs-variable">$args</span>arg_pid: <span class="hljs-variable">$arg_pid</span>is_args: <span class="hljs-variable">$is_args</span>query_string: <span class="hljs-variable">$query_string</span>host: <span class="hljs-variable">$host</span>http_user_agent: <span class="hljs-variable">$http_user_agent</span>http_referer: <span class="hljs-variable">$http_referer</span>http_via: <span class="hljs-variable">$http_via</span>request_time: <span class="hljs-variable">$request_time</span>https: <span class="hljs-variable">$https</span>request_filename: <span class="hljs-variable">$request_filename</span>document_root: <span class="hljs-variable">$document_root</span>&quot;; &#125;&#125;</code></pre></div><p>当我们访问 <code>http://var.lion-test.club:8081/test?pid=121414&amp;cid=sadasd</code> 时，由于 <code>Nginx</code>中写了 <code>return</code> 方法，因此 <code>chrome</code> 浏览器会默认为我们下载一个文件，下面展示的就是下载的文件内容：</p><div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-symbol">remote_addr:</span> <span class="hljs-number">27.16</span><span class="hljs-number">.220</span><span class="hljs-number">.84</span><span class="hljs-symbol">remote_port:</span> <span class="hljs-number">56838</span><span class="hljs-symbol">server_addr:</span> <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span><span class="hljs-symbol">server_port:</span> <span class="hljs-number">8081</span><span class="hljs-symbol">server_protocol:</span> HTTP/<span class="hljs-number">1.1</span><span class="hljs-symbol">binary_remote_addr:</span> 茉<span class="hljs-symbol">connection:</span> <span class="hljs-number">126</span><span class="hljs-symbol">uri:</span> <span class="hljs-meta-keyword">/test/</span><span class="hljs-symbol">request_uri:</span> <span class="hljs-meta-keyword">/test/</span>?pid=<span class="hljs-number">121414</span><span class="hljs-variable">&amp;cid</span>=sadasd<span class="hljs-symbol">scheme:</span> http<span class="hljs-symbol">request_method:</span> GET<span class="hljs-symbol">request_length:</span> <span class="hljs-number">518</span><span class="hljs-symbol">args:</span> pid=<span class="hljs-number">121414</span><span class="hljs-variable">&amp;cid</span>=sadasd<span class="hljs-symbol">arg_pid:</span> <span class="hljs-number">121414</span><span class="hljs-symbol">is_args:</span> ?<span class="hljs-symbol">query_string:</span> pid=<span class="hljs-number">121414</span><span class="hljs-variable">&amp;cid</span>=sadasd<span class="hljs-symbol">host:</span> var.lion-test.club<span class="hljs-symbol">http_user_agent:</span> Mozilla/<span class="hljs-number">5.0</span> (Macintosh; Intel Mac OS X <span class="hljs-number">10</span>_14_0) AppleWebKit/<span class="hljs-number">537.36</span> (KHTML, like Gecko) Chrome/<span class="hljs-number">88.0</span><span class="hljs-number">.4324</span><span class="hljs-number">.182</span> Safari/<span class="hljs-number">537.36</span><span class="hljs-symbol">http_referer:</span> <span class="hljs-symbol">http_via:</span> <span class="hljs-symbol">request_time:</span> <span class="hljs-number">0.000</span><span class="hljs-symbol">https:</span> <span class="hljs-symbol">request_filename:</span> <span class="hljs-meta-keyword">/usr/</span>share<span class="hljs-meta-keyword">/nginx/</span>html<span class="hljs-meta-keyword">/test/</span><span class="hljs-symbol">document_root:</span> <span class="hljs-meta-keyword">/usr/</span>share<span class="hljs-meta-keyword">/nginx/</span>html</code></pre></div><p><code>Nginx</code> 的配置还有非常多，以上只是罗列了一些常用的配置，在实际项目中还是要学会查阅文档。</p><p><strong>Nginx 应用核心概念</strong></p><p>代理是在服务器和客户端之间假设的一层服务器，代理将接收客户端的请求并将它转发给服务器，然后将服务端的响应转发给客户端。</p><p>不管是正向代理还是反向代理，实现的都是上面的功能。</p><p><img src="https://i.loli.net/2021/05/13/fSs4pyHmb5AQtiU.png" alt="Image"></p><p><strong>正向代理</strong></p><blockquote><p>正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。</p></blockquote><p>正向代理是为我们服务的，即为客户端服务的，客户端可以根据正向代理访问到它本身无法访问到的服务器资源。</p><p>正向代理对我们是透明的，对服务端是非透明的，即服务端并不知道自己收到的是来自代理的访问还是来自真实客户端的访问。</p><p><strong>反向代理</strong></p><blockquote><ul><li>反向代理*（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</li></ul></blockquote><p>反向代理是为服务端服务的，反向代理可以帮助服务器接收来自客户端的请求，帮助服务器做请求转发，负载均衡等。</p><p>反向代理对服务端是透明的，对我们是非透明的，即我们并不知道自己访问的是代理服务器，而服务器知道反向代理在为他服务。</p><p>反向代理的优势：</p><ul><li>隐藏真实服务器；</li><li>负载均衡便于横向扩充后端动态服务；</li><li>动静分离，提升系统健壮性；</li></ul><p>那么“动静分离”是什么？负载均衡又是什么？</p><p><strong>动静分离</strong></p><p>动静分离是指在 <code>web</code> 服务器架构中，将静态页面与动态页面或者静态内容接口和动态内容接口分开不同系统访问的架构设计方法，进而提示整个服务的访问性和可维护性。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image"></p><p>一般来说，都需要将动态资源和静态资源分开，由于 <code>Nginx</code> 的高并发和静态资源缓存等特性，经常将静态资源部署在 <code>Nginx</code> 上。如果请求的是静态资源，直接到静态资源目录获取资源，如果是动态资源的请求，则利用反向代理的原理，把请求转发给对应后台应用去处理，从而实现动静分离。</p><p>使用前后端分离后，可以很大程度提升静态资源的访问速度，即使动态服务不可用，静态资源的访问也不会受到影响。</p><p><strong>负载均衡</strong></p><p>一般情况下，客户端发送多个请求到服务器，服务器处理请求，其中一部分可能要操作一些资源比如数据库、静态资源等，服务器处理完毕后，再将结果返回给客户端。</p><p>这种模式对于早期的系统来说，功能要求不复杂，且并发请求相对较少的情况下还能胜任，成本也低。随着信息数量不断增长，访问量和数据量飞速增长，以及系统业务复杂度持续增加，这种做法已无法满足要求，并发量特别大时，服务器容易崩。</p><p>很明显这是由于服务器性能的瓶颈造成的问题，除了堆机器之外，最重要的做法就是负载均衡。</p><p>请求爆发式增长的情况下，单个机器性能再强劲也无法满足要求了，这个时候集群的概念产生了，单个服务器解决不了的问题，可以使用多个服务器，然后将请求分发到各个服务器上，将负载分发到不同的服务器，这就是负载均衡，核心是「分摊压力」。<code>Nginx</code> 实现负载均衡，一般来说指的是将请求转发给服务器集群。</p><p>举个具体的例子，晚高峰乘坐地铁的时候，入站口经常会有地铁工作人员大喇叭“请走 <code>B</code> 口， <code>B</code>口人少车空….”，这个工作人员的作用就是负载均衡。</p><p><img src="https://i.loli.net/2021/05/13/Wsy3nxX6OkcjU5f.png" alt="Image"></p><p><code>Nginx</code> 实现负载均衡的策略：</p><ul><li>轮询策略：默认情况下采用的策略，将所有客户端请求轮询分配给服务端。这种策略是可以正常工作的，但是如果其中某一台服务器压力太大，出现延迟，会影响所有分配在这台服务器下的用户。</li><li>最小连接数策略：将请求优先分配给压力较小的服务器，它可以平衡每个队列的长度，并避免向压力大的服务器添加更多的请求。</li><li>最快响应时间策略：优先分配给响应时间最短的服务器。</li><li>客户端 <code>ip</code> 绑定策略：来自同一个 <code>ip</code> 的请求永远只分配一台服务器，有效解决了动态网页存在的 <code>session</code> 共享问题。</li></ul><p><strong>Nginx 实战配置</strong></p><p>在配置反向代理和负载均衡等等功能之前，有两个核心模块是我们必须要掌握的，这两个模块应该说是 <code>Nginx</code> 应用配置中的核心，它们分别是：<code>upstream</code> 、<code>proxy_pass</code> 。</p><p><strong>upstream</strong></p><p>用于定义上游服务器（指的就是后台提供的应用服务器）的相关信息。</p><p><img src="https://i.loli.net/2021/05/13/L7Au6MSZ8NUcmeO.png" alt="Image"></p><div class="hljs code-wrapper"><pre><code class="hljs dust"><span class="xml">语法：upstream name </span><span class="hljs-template-variable">&#123;</span><span class="hljs-template-variable"> ...</span><span class="hljs-template-variable">&#125;</span><span class="xml">上下文：http</span><span class="xml">示例：</span><span class="xml">upstream back_end_server</span><span class="hljs-template-variable">&#123;</span><span class="hljs-template-variable">  server 192.168.100.33:8081</span><span class="hljs-template-variable">&#125;</span></code></pre></div><p>在 <code>upstream</code> 内可使用的指令：</p><ul><li><code>server</code> 定义上游服务器地址；</li><li><code>zone</code> 定义共享内存，用于跨 <code>worker</code> 子进程；</li><li><code>keepalive</code> 对上游服务启用长连接；</li><li><code>keepalive_requests</code> 一个长连接最多请求 <code>HTTP</code> 的个数；</li><li><code>keepalive_timeout</code> 空闲情形下，一个长连接的超时时长；</li><li><code>hash</code> 哈希负载均衡算法；</li><li><code>ip_hash</code> 依据 <code>IP</code> 进行哈希计算的负载均衡算法；</li><li><code>least_conn</code> 最少连接数负载均衡算法；</li><li><code>least_time</code> 最短响应时间负载均衡算法；</li><li><code>random</code> 随机负载均衡算法；</li></ul><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>定义上游服务器地址。</p><div class="hljs code-wrapper"><pre><code class="hljs css">语法：server <span class="hljs-selector-tag">address</span> <span class="hljs-selector-attr">[parameters]</span>上下文：upstream</code></pre></div><p><code>parameters</code> 可选值：</p><ul><li><code>weight=number</code> 权重值，默认为1；</li><li><code>max_conns=number</code> 上游服务器的最大并发连接数；</li><li><code>fail_timeout=time</code> 服务器不可用的判定时间；</li><li><code>max_fails=numer</code> 服务器不可用的检查次数；</li><li><code>backup</code> 备份服务器，仅当其他服务器都不可用时才会启用；</li><li><code>down</code> 标记服务器长期不可用，离线维护；</li></ul><h3 id="keepalive"><a href="#keepalive" class="headerlink" title="keepalive"></a>keepalive</h3><p>限制每个 <code>worker</code> 子进程与上游服务器空闲长连接的最大数量。</p><div class="hljs code-wrapper"><pre><code class="hljs abnf">keepalive connections<span class="hljs-comment">;</span>上下文：upstream示例：keepalive <span class="hljs-number">16</span><span class="hljs-comment">;</span></code></pre></div><h3 id="keepalive-requests"><a href="#keepalive-requests" class="headerlink" title="keepalive_requests"></a>keepalive_requests</h3><p>单个长连接可以处理的最多 <code>HTTP</code> 请求个数。</p><div class="hljs code-wrapper"><pre><code class="hljs abnf">语法：keepalive_requests number<span class="hljs-comment">;</span>默认值：keepalive_requests <span class="hljs-number">100</span><span class="hljs-comment">;</span>上下文：upstream</code></pre></div><p><strong>keepalive_timeout</strong></p><p>空闲长连接的最长保持时间。</p><div class="hljs code-wrapper"><pre><code class="hljs abnf">语法：keepalive_timeout time<span class="hljs-comment">;</span>默认值：keepalive_timeout <span class="hljs-number">60</span>s<span class="hljs-comment">;</span>上下文：upstream</code></pre></div><h3 id="配置实例"><a href="#配置实例" class="headerlink" title="配置实例"></a>配置实例</h3><div class="hljs code-wrapper"><pre><code class="hljs routeros">upstream back_end&#123;<span class="hljs-built_in"> server </span>127.0.0.1:8081 <span class="hljs-attribute">weight</span>=3 <span class="hljs-attribute">max_conns</span>=1000 <span class="hljs-attribute">fail_timeout</span>=10s <span class="hljs-attribute">max_fails</span>=2;  keepalive 32;  keepalive_requests 50;  keepalive_timeout 30s;&#125;</code></pre></div><h2 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a>proxy_pass</h2><p>用于配置代理服务器。</p><div class="hljs code-wrapper"><pre><code class="hljs awk">语法：proxy_pass URL;上下文：location、<span class="hljs-keyword">if</span>、limit_except示例：proxy_pass http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8081</span>proxy_pass http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8081</span>/proxy</code></pre></div><p><code>URL</code> 参数原则</p><p><code>1. URL</code> 必须以 <code>http</code> 或 <code>https</code> 开头；</p><p><code>2. URL</code> 中可以携带变量；</p><p><code>3. URL</code> 中是否带 <code>URI</code> ，会直接影响发往上游请求的 <code>URL</code> ；</p><p>接下来让我们来看看两种常见的 <code>URL</code> 用法：</p><ol><li><code>proxy_pass http://192.168.100.33:8081</code></li><li><code>proxy_pass http://192.168.100.33:8081/</code></li></ol><p>这两种用法的区别就是带 <code>/</code> 和不带 <code>/</code> ，在配置代理时它们的区别可大了：</p><ul><li>不带 <code>/</code> 意味着 <code>Nginx</code> 不会修改用户 <code>URL</code> ，而是直接透传给上游的应用服务器；</li><li>带 <code>/</code> 意味着 <code>Nginx</code> 会修改用户 <code>URL</code> ，修改方法是将 <code>location</code> 后的 <code>URL</code> 从用户 <code>URL</code> 中删除；</li></ul><p>不带 <code>/</code> 的用法：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">location <span class="hljs-regexp">/bbs/</span>&#123;  proxy_pass http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8080</span>;&#125;</code></pre></div><p>分析：</p><p>\1. 用户请求 <code>URL</code> ：<code>/bbs/abc/test.html</code></p><p>\2. 请求到达 <code>Nginx</code> 的 <code>URL</code> ：<code>/bbs/abc/test.html</code></p><p>3 .请求到达上游应用服务器的 <code>URL</code> ：<code>/bbs/abc/test.html</code></p><p>带 <code>/</code> 的用法：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">location <span class="hljs-regexp">/bbs/</span>&#123;  proxy_pass http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8080</span>/;&#125;</code></pre></div><p>分析：</p><p>\1. 用户请求 <code>URL</code> ：<code>/bbs/abc/test.html</code></p><p>\2. 请求到达 <code>Nginx</code> 的 <code>URL</code> ：<code>/bbs/abc/test.html</code></p><p>\3. 请求到达上游应用服务器的 <code>URL</code> ：<code>/abc/test.html</code></p><p>并没有拼接上 <code>/bbs</code> ，这点和 <code>root</code> 与 <code>alias</code> 之间的区别是保持一致的。</p><p><strong>配置反向代理</strong></p><p>这里为了演示更加接近实际，作者准备了两台云服务器，它们的公网 <code>IP</code> 分别是：<code>121.42.11.34</code>与 <code>121.5.180.193</code> 。</p><p>我们把 <code>121.42.11.34</code> 服务器作为上游服务器，做如下配置：</p><div class="hljs code-wrapper"><pre><code class="hljs gradle"># <span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/conf.d/</span>proxy.confserver&#123;  listen <span class="hljs-number">8080</span>;  server_name localhost;    location <span class="hljs-regexp">/proxy/</span> &#123;    root <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html/proxy;    index index.html;  &#125;&#125;# <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html<span class="hljs-regexp">/proxy/i</span>ndex.html&lt;h1&gt; <span class="hljs-number">121.42</span>.<span class="hljs-number">11.34</span> proxy html &lt;/h1&gt;</code></pre></div><p>配置完成后重启 <code>Nginx</code> 服务器 <code>nginx \-s reload</code> 。</p><p>把 <code>121.5.180.193</code> 服务器作为代理服务器，做如下配置：</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-comment"># /etc/nginx/conf.d/proxy.conf</span><span class="hljs-attribute">upstream</span> back_end &#123;  <span class="hljs-attribute">server</span> <span class="hljs-number">121.42.11.34:8080</span> weight=<span class="hljs-number">2</span> max_conns=<span class="hljs-number">1000</span> fail_timeout=<span class="hljs-number">10s</span> max_fails=<span class="hljs-number">3</span>;  <span class="hljs-attribute">keepalive</span> <span class="hljs-number">32</span>;  <span class="hljs-attribute">keepalive_requests</span> <span class="hljs-number">80</span>;  <span class="hljs-attribute">keepalive_timeout</span> <span class="hljs-number">20s</span>;&#125;<span class="hljs-section">server</span> &#123;  <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;  <span class="hljs-attribute">server_name</span> proxy.lion.club;  <span class="hljs-attribute">location</span> /proxy &#123;   <span class="hljs-attribute">proxy_pass</span> http://back_end/proxy;  &#125;&#125;</code></pre></div><p>本地机器要访问 <code>proxy.lion.club</code> 域名，因此需要配置本地 <code>hosts</code> ，通过命令：<code>vim /etc/hosts</code>进入配置文件，添加如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs accesslog"><span class="hljs-number">121.5.180.193</span> proxy.lion.club</code></pre></div><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqgio8wopaj30ry054glt.jpg" alt="Image"></p><p>分析：</p><p>当访问 <code>proxy.lion.club/proxy</code> 时通过 <code>upstream</code> 的配置找到 <code>121.42.11.34:8080</code> ；</p><p>因此访问地址变为 <code>http://121.42.11.34:8080/proxy</code> ；</p><p>连接到 <code>121.42.11.34</code> 服务器，找到 <code>8080</code> 端口提供的 <code>server</code> ；</p><p>通过 <code>server</code> 找到 <code>/usr/share/nginx/html/proxy/index.html</code> 资源，最终展示出来。</p><h2 id="配置负载均衡"><a href="#配置负载均衡" class="headerlink" title="配置负载均衡"></a>配置负载均衡</h2><p>配置负载均衡主要是要使用 <code>upstream</code> 指令。</p><p>我们把 <code>121.42.11.34</code> 服务器作为上游服务器，做如下配置（ <code>/etc/nginx/conf.d/balance.conf</code>）：</p><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">server</span>&#123;  <span class="hljs-keyword">listen</span> <span class="hljs-number">8020</span>;  <span class="hljs-keyword">location</span> / &#123;   <span class="hljs-keyword">return</span> <span class="hljs-number">200</span> <span class="hljs-string">&#x27;return 8020 \n&#x27;</span>;  &#125;&#125;<span class="hljs-keyword">server</span>&#123;  <span class="hljs-keyword">listen</span> <span class="hljs-number">8030</span>;  <span class="hljs-keyword">location</span> / &#123;   <span class="hljs-keyword">return</span> <span class="hljs-number">200</span> <span class="hljs-string">&#x27;return 8030 \n&#x27;</span>;  &#125;&#125;<span class="hljs-keyword">server</span>&#123;  <span class="hljs-keyword">listen</span> <span class="hljs-number">8040</span>;  <span class="hljs-keyword">location</span> / &#123;   <span class="hljs-keyword">return</span> <span class="hljs-number">200</span> <span class="hljs-string">&#x27;return 8040 \n&#x27;</span>;  &#125;&#125;</code></pre></div><p>配置完成后：</p><p><code>1. nginx -t</code> 检测配置是否正确；</p><p><code>2. nginx -s reload</code> 重启 <code>Nginx</code> 服务器；</p><p>\3. 执行 <code>ss -nlt</code> 命令查看端口是否被占用，从而判断 <code>Nginx</code> 服务是否正确启动。</p><p>把 <code>121.5.180.193</code> 服务器作为代理服务器，做如下配置（ <code>/etc/nginx/conf.d/balance.conf</code>）：</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">upstream</span> demo_server &#123;  <span class="hljs-attribute">server</span> <span class="hljs-number">121.42.11.34:8020</span>;  <span class="hljs-attribute">server</span> <span class="hljs-number">121.42.11.34:8030</span>;  <span class="hljs-attribute">server</span> <span class="hljs-number">121.42.11.34:8040</span>;&#125;<span class="hljs-section">server</span> &#123;  <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;  <span class="hljs-attribute">server_name</span> balance.lion.club;    <span class="hljs-attribute">location</span> /balance/ &#123;   <span class="hljs-attribute">proxy_pass</span> http://demo_server;  &#125;&#125;</code></pre></div><p>配置完成后重启 <code>Nginx</code> 服务器。并且在需要访问的客户端配置好 <code>ip</code> 和域名的映射关系。</p><div class="hljs code-wrapper"><pre><code class="hljs accesslog"># /etc/hosts<span class="hljs-number">121.5.180.193</span> balance.lion.club</code></pre></div><p>在客户端机器执行 <code>curl http://balance.lion.club/balance/</code> 命令：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqgiu2hh9mj30ip06675k.jpg" alt="Image"></p><p>不难看出，负载均衡的配置已经生效了，每次给我们分发的上游服务器都不一样。就是通过简单的轮询策略进行上游服务器分发。</p><p>接下来，我们再来了解下 <code>Nginx</code> 的其它分发策略。</p><p><strong>hash 算法</strong></p><p>通过制定关键字作为 <code>hash key</code> ，基于 <code>hash</code> 算法映射到特定的上游服务器中。关键字可以包含有变量、字符串。</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">upstream</span> demo_server &#123;  <span class="hljs-attribute">hash</span> $request_uri;  <span class="hljs-attribute">server</span> <span class="hljs-number">121.42.11.34:8020</span>;  <span class="hljs-attribute">server</span> <span class="hljs-number">121.42.11.34:8030</span>;  <span class="hljs-attribute">server</span> <span class="hljs-number">121.42.11.34:8040</span>;&#125;<span class="hljs-section">server</span> &#123;  <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;  <span class="hljs-attribute">server_name</span> balance.lion.club;    <span class="hljs-attribute">location</span> /balance/ &#123;   <span class="hljs-attribute">proxy_pass</span> http://demo_server;  &#125;&#125;</code></pre></div><p><code>hash $request_uri</code> 表示使用 <code>request_uri</code> 变量作为 <code>hash</code> 的 <code>key</code> 值，只要访问的 <code>URI</code> 保持不变，就会一直分发给同一台服务器。</p><p><strong>ip_hash</strong></p><p>根据客户端的请求 <code>ip</code> 进行判断，只要 <code>ip</code> 地址不变就永远分配到同一台主机。它可以有效解决后台服务器 <code>session</code> 保持的问题。</p><div class="hljs code-wrapper"><pre><code class="hljs pgsql">upstream demo_server &#123;  ip_hash;  <span class="hljs-keyword">server</span> <span class="hljs-number">121.42</span><span class="hljs-number">.11</span><span class="hljs-number">.34</span>:<span class="hljs-number">8020</span>;  <span class="hljs-keyword">server</span> <span class="hljs-number">121.42</span><span class="hljs-number">.11</span><span class="hljs-number">.34</span>:<span class="hljs-number">8030</span>;  <span class="hljs-keyword">server</span> <span class="hljs-number">121.42</span><span class="hljs-number">.11</span><span class="hljs-number">.34</span>:<span class="hljs-number">8040</span>;&#125;<span class="hljs-keyword">server</span> &#123;  <span class="hljs-keyword">listen</span> <span class="hljs-number">80</span>;  server_name balance.lion.club;    <span class="hljs-keyword">location</span> /balance/ &#123;   proxy_pass http://demo_server;  &#125;&#125;</code></pre></div><h3 id="最少连接数算法"><a href="#最少连接数算法" class="headerlink" title="最少连接数算法"></a>最少连接数算法</h3><p>各个 <code>worker</code> 子进程通过读取共享内存的数据，来获取后端服务器的信息。来挑选一台当前已建立连接数最少的服务器进行分配请求。</p><div class="hljs code-wrapper"><pre><code class="hljs abnf">语法：least_conn<span class="hljs-comment">;</span>上下文：upstream<span class="hljs-comment">;</span></code></pre></div><p>示例：</p><div class="hljs code-wrapper"><pre><code class="hljs pgsql">upstream demo_server &#123;  <span class="hljs-type">zone</span> test <span class="hljs-number">10</span>M; # <span class="hljs-type">zone</span>可以设置共享内存空间的名字和大小  least_conn;  <span class="hljs-keyword">server</span> <span class="hljs-number">121.42</span><span class="hljs-number">.11</span><span class="hljs-number">.34</span>:<span class="hljs-number">8020</span>;  <span class="hljs-keyword">server</span> <span class="hljs-number">121.42</span><span class="hljs-number">.11</span><span class="hljs-number">.34</span>:<span class="hljs-number">8030</span>;  <span class="hljs-keyword">server</span> <span class="hljs-number">121.42</span><span class="hljs-number">.11</span><span class="hljs-number">.34</span>:<span class="hljs-number">8040</span>;&#125;<span class="hljs-keyword">server</span> &#123;  <span class="hljs-keyword">listen</span> <span class="hljs-number">80</span>;  server_name balance.lion.club;    <span class="hljs-keyword">location</span> /balance/ &#123;   proxy_pass http://demo_server;  &#125;&#125;</code></pre></div><p>最后你会发现，负载均衡的配置其实一点都不复杂。</p><p><strong>配置缓存</strong></p><p>缓存可以非常有效的提升性能，因此不论是客户端（浏览器），还是代理服务器（ <code>Nginx</code> ），乃至上游服务器都多少会涉及到缓存。可见缓存在每个环节都是非常重要的。下面让我们来学习<code>Nginx</code> 中如何设置缓存策略。</p><p><strong>proxy_cache</strong></p><p>存储一些之前被访问过、而且可能将要被再次访问的资源，使用户可以直接从代理服务器获得，从而减少上游服务器的压力，加快整个访问速度。</p><div class="hljs code-wrapper"><pre><code class="hljs pgsql">语法：proxy_cache <span class="hljs-type">zone</span> | <span class="hljs-keyword">off</span> ; # <span class="hljs-type">zone</span> 是共享内存的名称默认值：proxy_cache <span class="hljs-keyword">off</span>;上下文：http、<span class="hljs-keyword">server</span>、<span class="hljs-keyword">location</span></code></pre></div><p><strong>proxy_cache_path</strong></p><p>设置缓存文件的存放路径。</p><div class="hljs code-wrapper"><pre><code class="hljs routeros">语法：proxy_cache_path path [<span class="hljs-attribute">level</span>=levels] <span class="hljs-built_in">..</span>.可选参数省略，下面会详细列举默认值：proxy_cache_path off上下文：http</code></pre></div><p>参数含义：</p><ul><li><code>path</code> 缓存文件的存放路径；</li><li><code>level path</code> 的目录层级；</li><li><code>keys_zone</code> 设置共享内存；</li><li><code>inactive</code> 在指定时间内没有被访问，缓存会被清理，默认10分钟；</li></ul><h3 id="proxy-cache-key"><a href="#proxy-cache-key" class="headerlink" title="proxy_cache_key"></a>proxy_cache_key</h3><p>设置缓存文件的 <code>key</code> 。</p><div class="hljs code-wrapper"><pre><code class="hljs tcl">语法：proxy_cache_key默认值：proxy_cache_key <span class="hljs-variable">$scheme</span><span class="hljs-variable">$proxy_host</span><span class="hljs-variable">$request_uri</span>;上下文：<span class="hljs-keyword">http</span>、server、location</code></pre></div><p><strong>proxy_cache_valid</strong></p><p>配置什么状态码可以被缓存，以及缓存时长。</p><div class="hljs code-wrapper"><pre><code class="hljs crmsh">语法：proxy_cache_valid [code...] time;上下文：http、server、location配置示例：proxy_cache_valid <span class="hljs-number">200</span> <span class="hljs-number">304</span> <span class="hljs-number">2m</span>;; <span class="hljs-comment"># 说明对于状态为200和304的缓存文件的缓存时间是2分钟</span></code></pre></div><h3 id="proxy-no-cache"><a href="#proxy-no-cache" class="headerlink" title="proxy_no_cache"></a>proxy_no_cache</h3><p>定义相应保存到缓存的条件，如果字符串参数的至少一个值不为空且不等于“ 0”，则将不保存该响应到缓存。</p><div class="hljs code-wrapper"><pre><code class="hljs crmsh">语法：proxy_no_cache <span class="hljs-keyword">string</span>;上下文：http、server、location示例：proxy_no_cache $http_pragma    $http_authorization;</code></pre></div><h3 id="proxy-cache-bypass"><a href="#proxy-cache-bypass" class="headerlink" title="proxy_cache_bypass"></a>proxy_cache_bypass</h3><p>定义条件，在该条件下将不会从缓存中获取响应。</p><div class="hljs code-wrapper"><pre><code class="hljs crmsh">语法：proxy_cache_bypass <span class="hljs-keyword">string</span>;上下文：http、server、location示例：proxy_cache_bypass $http_pragma    $http_authorization;</code></pre></div><h3 id="upstream-cache-status-变量"><a href="#upstream-cache-status-变量" class="headerlink" title="upstream_cache_status 变量"></a>upstream_cache_status 变量</h3><p>它存储了缓存是否命中的信息，会设置在响应头信息中，在调试中非常有用。</p><div class="hljs code-wrapper"><pre><code class="hljs avrasm"><span class="hljs-symbol">MISS:</span> 未命中缓存HIT：命中缓存<span class="hljs-symbol">EXPIRED:</span> 缓存过期<span class="hljs-symbol">STALE:</span> 命中了陈旧缓存<span class="hljs-symbol">REVALIDDATED:</span> Nginx验证陈旧缓存依然有效<span class="hljs-symbol">UPDATING:</span> 内容陈旧，但正在更新<span class="hljs-symbol">BYPASS:</span> <span class="hljs-built_in">X</span>响应从原始服务器获取</code></pre></div><h3 id="配置实例-1"><a href="#配置实例-1" class="headerlink" title="配置实例"></a>配置实例</h3><p>我们把 <code>121.42.11.34</code> 服务器作为上游服务器，做如下配置（ <code>/etc/nginx/conf.d/cache.conf</code>）：</p><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">server</span> &#123;  <span class="hljs-keyword">listen</span> <span class="hljs-number">1010</span>;  root /usr/<span class="hljs-keyword">share</span>/nginx/html/<span class="hljs-number">1010</span>;  <span class="hljs-keyword">location</span> / &#123;   <span class="hljs-keyword">index</span> <span class="hljs-keyword">index</span>.html;  &#125;&#125;<span class="hljs-keyword">server</span> &#123;  <span class="hljs-keyword">listen</span> <span class="hljs-number">1020</span>;  root /usr/<span class="hljs-keyword">share</span>/nginx/html/<span class="hljs-number">1020</span>;  <span class="hljs-keyword">location</span> / &#123;   <span class="hljs-keyword">index</span> <span class="hljs-keyword">index</span>.html;  &#125;&#125;</code></pre></div><p>把 <code>121.5.180.193</code> 服务器作为代理服务器，做如下配置（ <code>/etc/nginx/conf.d/cache.conf</code> ）：</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">proxy_cache_path</span> /etc/nginx/cache_temp levels=<span class="hljs-number">2</span>:<span class="hljs-number">2</span> keys_zone=cache_zone:<span class="hljs-number">30m</span> max_size=<span class="hljs-number">2g</span> inactive=<span class="hljs-number">60m</span> use_temp_path=<span class="hljs-literal">off</span>;<span class="hljs-attribute">upstream</span> cache_server&#123;  <span class="hljs-attribute">server</span> <span class="hljs-number">121.42.11.34:1010</span>;  <span class="hljs-attribute">server</span> <span class="hljs-number">121.42.11.34:1020</span>;&#125;<span class="hljs-section">server</span> &#123;  <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;  <span class="hljs-attribute">server_name</span> cache.lion.club;  <span class="hljs-attribute">location</span> / &#123;    <span class="hljs-attribute">proxy_cache</span> cache_zone; <span class="hljs-comment"># 设置缓存内存，上面配置中已经定义好的</span>    <span class="hljs-attribute">proxy_cache_valid</span> <span class="hljs-number">200</span> <span class="hljs-number">5m</span>; <span class="hljs-comment"># 缓存状态为200的请求，缓存时长为5分钟</span>    <span class="hljs-attribute">proxy_cache_key</span> $request_uri; <span class="hljs-comment"># 缓存文件的key为请求的URI</span>    <span class="hljs-attribute">add_header</span> Nginx-Cache-Status $upstream_cache_status <span class="hljs-comment"># 把缓存状态设置为头部信息，响应给客户端</span>    proxy_pass http://cache_server; <span class="hljs-comment"># 代理转发</span>  &#125;&#125;</code></pre></div><p>缓存就是这样配置，我们可以在 <code>/etc/nginx/cache_temp</code> 路径下找到相应的缓存文件。</p><p><strong>对于一些实时性要求非常高的页面或数据来说，就不应该去设置缓存，下面来看看如何配置不缓存的内容。</strong></p><div class="hljs code-wrapper"><pre><code class="hljs awk">...server &#123;  listen <span class="hljs-number">80</span>;  server_name cache.lion.club;  <span class="hljs-comment"># URI 中后缀为 .txt 或 .text 的设置变量值为 &quot;no cache&quot;</span>  <span class="hljs-keyword">if</span> (<span class="hljs-variable">$request_uri</span> ~ \.(txt|text)$) &#123;   set <span class="hljs-variable">$cache_name</span> <span class="hljs-string">&quot;no cache&quot;</span>  &#125;    location / &#123;    proxy_no_cache <span class="hljs-variable">$cache_name</span>; <span class="hljs-comment"># 判断该变量是否有值，如果有值则不进行缓存，如果没有值则进行缓存</span>    proxy_cache cache_zone; <span class="hljs-comment"># 设置缓存内存</span>    proxy_cache_valid <span class="hljs-number">200</span> <span class="hljs-number">5</span>m; <span class="hljs-comment"># 缓存状态为200的请求，缓存时长为5分钟</span>    proxy_cache_key <span class="hljs-variable">$request_uri</span>; <span class="hljs-comment"># 缓存文件的key为请求的URI</span>    add_header Nginx-Cache-Status <span class="hljs-variable">$upstream_cache_status</span> <span class="hljs-comment"># 把缓存状态设置为头部信息，响应给客户端</span>    proxy_pass http:<span class="hljs-regexp">//</span>cache_server; <span class="hljs-comment"># 代理转发</span>  &#125;&#125;</code></pre></div><p><strong>HTTPS</strong></p><p>在学习如何配置 <code>HTTPS</code> 之前，我们先来简单回顾下 <code>HTTPS</code> 的工作流程是怎么样的？它是如何进行加密保证安全的？</p><p><strong>HTTPS 工作流程</strong></p><p>\1. 客户端（浏览器）访问 <code>https://www.baidu.com</code> 百度网站；</p><p>\2. 百度服务器返回 <code>HTTPS</code> 使用的 <code>CA</code> 证书；</p><p>\3. 浏览器验证 <code>CA</code> 证书是否为合法证书；</p><p>\4. 验证通过，证书合法，生成一串随机数并使用公钥（证书中提供的）进行加密；</p><p>\5. 发送公钥加密后的随机数给百度服务器；</p><p>\6. 百度服务器拿到密文，通过私钥进行解密，获取到随机数（公钥加密，私钥解密，反之也可以）；</p><p>\7. 百度服务器把要发送给浏览器的内容，使用随机数进行加密后传输给浏览器；</p><p>\8. 此时浏览器可以使用随机数进行解密，获取到服务器的真实传输内容；</p><p>这就是 <code>HTTPS</code> 的基本运作原理，使用对称加密和非对称机密配合使用，保证传输内容的安全性。</p><p>关于HTTPS更多知识，可以查看作者的另外一篇文章《学习 HTTP 协议》。</p><h3 id="配置证书"><a href="#配置证书" class="headerlink" title="配置证书"></a>配置证书</h3><p>下载证书的压缩文件，里面有个 <code>Nginx</code> 文件夹，把 <code>xxx.crt</code> 和 <code>xxx.key</code> 文件拷贝到服务器目录，再进行如下配置：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">server &#123;  listen <span class="hljs-number">443</span> ssl http2 default_server; <span class="hljs-comment"># SSL 访问端口号为 443</span>  server_name lion.club; <span class="hljs-comment"># 填写绑定证书的域名(我这里是随便写的)</span>  ssl_certificate <span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/https/</span>lion.club_bundle.crt; <span class="hljs-comment"># 证书地址</span>  ssl_certificate_key <span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/https/</span>lion.club.key; <span class="hljs-comment"># 私钥地址</span>  ssl_session_timeout <span class="hljs-number">10</span>m;  ssl_protocols TLSv1 TLSv1.<span class="hljs-number">1</span> TLSv1.<span class="hljs-number">2</span>; <span class="hljs-comment"># 支持ssl协议版本，默认为后三个，主流版本是[TLSv1.2]</span>   location / &#123;    root         <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html;    index        index.html index.htm;  &#125;&#125;</code></pre></div><p>如此配置后就能正常访问 <code>HTTPS</code> 版的网站了。</p><p><strong>配置跨域 CORS</strong></p><p>先简单回顾下跨域究竟是怎么回事。</p><p><strong>跨域的定义</strong></p><p>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。通常不允许不同源间的读操作。</p><p><strong>同源的定义</strong></p><p>如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。</p><p>下面给出了与 URL <code>http://store.company.com/dir/page.html</code> 的源进行对比的示例:</p><div class="hljs code-wrapper"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>store.company.com<span class="hljs-regexp">/dir2/</span>other.html 同源https:<span class="hljs-regexp">//</span>store.company.com/secure.html 不同源，协议不同http:<span class="hljs-regexp">//</span>store.company.com:<span class="hljs-number">81</span><span class="hljs-regexp">/dir/</span>etc.html 不同源，端口不同http:<span class="hljs-regexp">//</span>news.company.com<span class="hljs-regexp">/dir/</span>other.html 不同源，主机不同</code></pre></div><p>不同源会有如下限制：</p><ul><li><code>Web</code> 数据层面，同源策略限制了不同源的站点读取当前站点的 <code>Cookie</code> 、 <code>IndexDB</code> 、<code>LocalStorage</code> 等数据。</li><li><code>DOM</code> 层面，同源策略限制了来自不同源的 <code>JavaScript</code> 脚本对当前 <code>DOM</code> 对象读和写的操作。</li><li>网络层面，同源策略限制了通过 <code>XMLHttpRequest</code> 等方式将站点的数据发送给不同源的站点。</li></ul><h3 id="Nginx-解决跨域的原理"><a href="#Nginx-解决跨域的原理" class="headerlink" title="Nginx 解决跨域的原理"></a>Nginx 解决跨域的原理</h3><p>例如：</p><ul><li>前端 <code>server</code> 的域名为：<code>fe.server.com</code></li><li>后端服务的域名为：<code>dev.server.com</code></li></ul><p>现在我在 <code>fe.server.com</code> 对 <code>dev.server.com</code> 发起请求一定会出现跨域。</p><p>现在我们只需要启动一个 <code>Nginx</code> 服务器，将 <code>server_name</code> 设置为 <code>fe.server.com</code> 然后设置相应的 <code>location</code> 以拦截前端需要跨域的请求，最后将请求代理回 <code>dev.server.com</code> 。如下面的配置：</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123; <span class="hljs-attribute">listen</span>      <span class="hljs-number">80</span>; <span class="hljs-attribute">server_name</span>  fe.server.com; <span class="hljs-attribute">location</span> / &#123;  <span class="hljs-attribute">proxy_pass</span> dev.server.com; &#125;&#125;</code></pre></div><p>这样可以完美绕过浏览器的同源策略：<code>fe.server.com</code> 访问 <code>Nginx</code> 的 <code>fe.server.com</code> 属于同源访问，而 <code>Nginx</code> 对服务端转发的请求不会触发浏览器的同源策略。</p><p><strong>配置开启 gzip 压缩</strong></p><p><code>GZIP</code> 是规定的三种标准 <code>HTTP</code> 压缩格式之一。目前绝大多数的网站都在使用 <code>GZIP</code> 传输 <code>HTML</code>、<code>CSS</code> 、 <code>JavaScript</code> 等资源文件。</p><p>对于文本文件， <code>GZiP</code> 的效果非常明显，开启后传输所需流量大约会降至 <code>1/4~1/3</code> 。</p><p>并不是每个浏览器都支持 <code>gzip</code> 的，如何知道客户端是否支持 <code>gzip</code> 呢，请求头中的 <code>Accept-Encoding</code> 来标识对压缩的支持。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image"></p><p>启用 <code>gzip</code> 同时需要客户端和服务端的支持，如果客户端支持 <code>gzip</code> 的解析，那么只要服务端能够返回 <code>gzip</code> 的文件就可以启用 <code>gzip</code> 了,我们可以通过 <code>Nginx</code> 的配置来让服务端支持 <code>gzip</code> 。下面的 <code>respone</code> 中 <code>content-encoding:gzip</code> ，指服务端开启了 <code>gzip</code> 的压缩方式。</p><p><img src="https://i.loli.net/2021/05/13/2InKAg9biCSdoPj.png" alt="Image"></p><p>在 <code>/etc/nginx/conf.d/</code> 文件夹中新建配置文件 <code>gzip.conf</code> ：</p><div class="hljs code-wrapper"><pre><code class="hljs applescript"><span class="hljs-comment"># # 默认off，是否开启gzip</span>gzip <span class="hljs-keyword">on</span>; <span class="hljs-comment"># 要采用 gzip 压缩的 MIME 文件类型，其中 text/html 被系统强制启用；</span>gzip_types <span class="hljs-built_in">text</span>/plain <span class="hljs-built_in">text</span>/css <span class="hljs-built_in">application</span>/json <span class="hljs-built_in">application</span>/x-javascript <span class="hljs-built_in">text</span>/xml <span class="hljs-built_in">application</span>/xml <span class="hljs-built_in">application</span>/xml+rss <span class="hljs-built_in">text</span>/javascript;<span class="hljs-comment"># ---- 以上两个参数开启就可以支持Gzip压缩了 ---- #</span><span class="hljs-comment"># 默认 off，该模块启用后，Nginx 首先检查是否存在请求静态文件的 gz 结尾的文件，如果有则直接返回该 .gz 文件内容；</span>gzip_static <span class="hljs-keyword">on</span>;<span class="hljs-comment"># 默认 off，nginx做为反向代理时启用，用于设置启用或禁用从代理服务器上收到相应内容 gzip 压缩；</span>gzip_proxied any;<span class="hljs-comment"># 用于在响应消息头中添加 Vary：Accept-Encoding，使代理服务器根据请求头中的 Accept-Encoding 识别是否启用 gzip 压缩；</span>gzip_vary <span class="hljs-keyword">on</span>;<span class="hljs-comment"># gzip 压缩比，压缩级别是 1-9，1 压缩级别最低，9 最高，级别越高压缩率越大，压缩时间越长，建议 4-6；</span>gzip_comp_level <span class="hljs-number">6</span>;<span class="hljs-comment"># 获取多少内存用于缓存压缩结果，16 8k 表示以 8k*16 为单位获得；</span>gzip_buffers <span class="hljs-number">16</span> <span class="hljs-number">8</span>k;<span class="hljs-comment"># 允许压缩的页面最小字节数，页面字节数从header头中的 Content-Length 中进行获取。默认值是 0，不管页面多大都压缩。建议设置成大于 1k 的字节数，小于 1k 可能会越压越大；</span><span class="hljs-comment"># gzip_min_length 1k;</span><span class="hljs-comment"># 默认 1.1，启用 gzip 所需的 HTTP 最低版本；</span>gzip_http_version <span class="hljs-number">1.1</span>;</code></pre></div><p>其实也可以通过前端构建工具例如 <code>webpack</code> 、<code>rollup</code> 等在打生产包时就做好 <code>Gzip</code> 压缩，然后放到 <code>Nginx</code> 服务器中，这样可以减少服务器的开销，加快访问速度。</p><p>关于 <code>Nginx</code> 的实际应用就学习到这里，相信通过掌握了 <code>Nginx</code> 核心配置以及实战配置，之后再遇到什么需求，我们也能轻松应对。接下来，让我们再深入一点学习下 <code>Nginx</code> 的架构。</p><p><strong>Nginx 架构</strong></p><p><strong>进程结构</strong></p><p>多进程结构 <code>Nginx</code> 的进程模型图：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqgj9dsw29j30rn0aj74h.jpg" alt="Image"></p><p>多进程中的 <code>Nginx</code> 进程架构如下图所示，会有一个父进程（ <code>Master Process</code> ），它会有很多子进程（ <code>Child Processes</code> ）。</p><ul><li><p><code>Master Process</code> 用来管理子进程的，其本身并不真正处理用户请求。</p></li><li><ul><li>某个子进程 <code>down</code> 掉的话，它会向 <code>Master</code> 进程发送一条消息，表明自己不可用了，此时 <code>Master</code> 进程会去新起一个子进程。</li><li>某个配置文件被修改了 <code>Master</code> 进程会去通知 <code>work</code> 进程获取新的配置信息，这也就是我们所说的热部署。</li></ul></li><li><p>子进程间是通过共享内存的方式进行通信的。</p></li></ul><h2 id="配置文件重载原理"><a href="#配置文件重载原理" class="headerlink" title="配置文件重载原理"></a>配置文件重载原理</h2><p><code>reload</code> 重载配置文件的流程：</p><p>\1. 向 <code>master</code> 进程发送 <code>HUP</code> 信号（ <code>reload</code> 命令）；</p><p><code>2. master</code> 进程检查配置语法是否正确；</p><p><code>3. master</code> 进程打开监听端口；</p><p><code>4. master</code> 进程使用新的配置文件启动新的 <code>worker</code> 子进程；</p><p><code>5. master</code> 进程向老的 <code>worker</code> 子进程发送 <code>QUIT</code> 信号；</p><p>\6. 老的 <code>worker</code> 进程关闭监听句柄，处理完当前连接后关闭进程；</p><p>\7. 整个过程 <code>Nginx</code> 始终处于平稳运行中，实现了平滑升级，用户无感知；</p><h2 id="Nginx-模块化管理机制"><a href="#Nginx-模块化管理机制" class="headerlink" title="Nginx 模块化管理机制"></a>Nginx 模块化管理机制</h2><p><code>Nginx</code> 的内部结构是由核心部分和一系列的功能模块所组成。这样划分是为了使得每个模块的功能相对简单，便于开发，同时也便于对系统进行功能扩展。<code>Nginx</code> 的模块是互相独立的,低耦合高内聚。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqgil28gi4j30u00kudje.jpg" alt="Image"></p>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux chmod</title>
    <link href="/2021/10/09/linux-chmod/"/>
    <url>/2021/10/09/linux-chmod/</url>
    
    <content type="html"><![CDATA[<h1 id="权限简介"><a href="#权限简介" class="headerlink" title="权限简介"></a>权限简介</h1><ul><li>Linux系统上对文件的权限有着严格的控制，用于如果相对某个文件执行某种操作，必须具有对应的权限方可执行成功。</li><li>Linux下文件的权限类型一般包括读，写，执行。对应字母为 r、w、x。</li><li>Linux下权限的粒度有 <strong>拥有者 、群组 、其它组</strong> 三种。每个文件都可以针对三个粒度，设置不同的rwx(读写执行)权限。通常情况下，一个文件只能归属于一个用户和组， 如果其它的用户想有这个文件的权限，则可以将该用户加入具备权限的群组，一个用户可以同时归属于多个组。</li><li>Linux上通常使用chmod命令对文件的权限进行设置和更改。</li></ul><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="更改文件权限-（chmod命令）"><a href="#更改文件权限-（chmod命令）" class="headerlink" title="更改文件权限 （chmod命令）"></a>更改文件权限 （chmod命令）</h3><p>一般使用格式</p><blockquote><p>chmod [可选项] <mode> &lt;file…&gt;</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs bash">参数说明： [可选项]  -c, --changes          like verbose but report only when a change is made (若该档案权限确实已经更改，才显示其更改动作)  -f, --silent, --quiet  suppress most error messages  （若该档案权限无法被更改也不要显示错误讯息）  -v, --verbose          output a diagnostic <span class="hljs-keyword">for</span> every file processed（显示权限变更的详细资料）       --no-preserve-root  <span class="hljs-keyword">do</span> not treat <span class="hljs-string">&#x27;/&#x27;</span> specially (the default)       --preserve-root    fail to operate recursively on <span class="hljs-string">&#x27;/&#x27;</span>       --reference=RFILE  use RFILE<span class="hljs-string">&#x27;s mode instead of MODE values</span><span class="hljs-string">  -R, --recursive        change files and directories recursively （以递归的方式对目前目录下的所有档案与子目录进行相同的权限变更)</span><span class="hljs-string">       --help        显示此帮助信息</span><span class="hljs-string">       --version        显示版本信息</span><span class="hljs-string">[mode] </span><span class="hljs-string">    权限设定字串，详细格式如下 ：</span><span class="hljs-string">    [ugoa...][[+-=][rwxX]...][,...]，</span><span class="hljs-string">    其中</span><span class="hljs-string">    [ugoa...]</span><span class="hljs-string">    u 表示该档案的拥有者，g 表示与该档案的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示所有（包含上面三者）。</span><span class="hljs-string">    [+-=]</span><span class="hljs-string">    + 表示增加权限，- 表示取消权限，= 表示唯一设定权限。</span><span class="hljs-string">    [rwxX]</span><span class="hljs-string">    r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该档案是个子目录或者该档案已经被设定过为可执行。</span><span class="hljs-string">     </span><span class="hljs-string">[file...]</span><span class="hljs-string">    文件列表（单个或者多个文件、文件夹）</span></code></pre></div><p> 范例：``</p><ul><li>设置所有用户可读取文件 a.conf</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash">chmod ugo+r a.conf 或 chmod a+r  a.conf</code></pre></div><ul><li>设置 <a href="http://c.sh/">c.sh</a> 只有 拥有者可以读写及执行</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash">chmod u+rwx c.sh</code></pre></div><ul><li>设置文件 a.conf 与 b.xml 权限为拥有者与其所属同一个群组 可读写，其它组可读不可写</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash">chmod a+r,ug+w,o-w a.conf b.xml</code></pre></div><ul><li>设置当前目录下的所有档案与子目录皆设为任何人可读写</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash">chmod -R a+rw *</code></pre></div><h3 id="数字权限使用格式"><a href="#数字权限使用格式" class="headerlink" title="数字权限使用格式"></a>数字权限使用格式</h3><p>在这种使用方式中，首先我们需要了解数字如何表示权限。 首先，我们规定 数字 4 、2 和 1表示读、写、执行权限（具体原因可见下节权限详解内容），即 r=4，w=2，x=1 。此时其他的权限组合也可以用其他的八进制数字表示出来，</p><p>如：</p><div class="hljs code-wrapper"><pre><code class="hljs tex">rwx = 4 + 2 + 1 = 7rw = 4 + 2 = 6rx = 4 +1 = 5</code></pre></div><p>即</p><p>若要同时设置 rwx (可读写运行） 权限则将该权限位 设置 为 4 + 2 + 1 = 7</p><p>若要同时设置 rw- （可读写不可运行）权限则将该权限位 设置 为 4 + 2 = 6</p><p>若要同时设置 r-x （可读可运行不可写）权限则将该权限位 设置 为 4 +1 = 5</p><p>上面我们提到，每个文件都可以针对三个粒度，设置不同的rwx(读写执行)权限。即我们可以用用三个8进制数字分别表示 拥有者 、群组 、其它组( u、 g 、o)的权限详情，并用chmod直接加三个8进制数字的方式直接改变文件权限。语法格式为 ：</p><blockquote><p>chmod <abc> file…</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs bash">其中a,b,c各为一个数字，分别代表User、Group、及Other的权限。相当于简化版的chmod u=权限,g=权限,o=权限 file...而此处的权限将用8进制的数字来表示User、Group、及Other的读、写、执行权限</code></pre></div><p>范例：</p><ul><li>设置所有人可以读写及执行</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash">chmod 777 file  (等价于  chmod u=rwx,g=rwx,o=rwx file 或  chmod a=rwx file)</code></pre></div><ul><li>设置拥有者可读写，其他人不可读写执行</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash">chmod 600 file (等价于  chmod u=rw,g=---,o=--- file 或 chmod u=rw,go-rwx file )</code></pre></div><h2 id="更改文件拥有者（chown命令）"><a href="#更改文件拥有者（chown命令）" class="headerlink" title="更改文件拥有者（chown命令）"></a>更改文件拥有者（chown命令）</h2><p>linux/Unix 是多人多工作业系统，每个的文件都有拥有者（所有者），如果我们想变更文件的拥有者（利用 chown 将文件拥有者加以改变），一般只有系统管理员(root)拥有此操作权限，而普通用户则没有权限将自己或者别人的文件的拥有者设置为别人。</p><p>语法格式：</p><blockquote><p>chown [可选项] user[:group] file…</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs bash">使用权限：root说明：[可选项] : 同上文chmoduser : 新的文件拥有者的使用者 group : 新的文件拥有者的使用者群体(group)</code></pre></div><p>范例：</p><ul><li>设置文件 d.key、e.scrt的拥有者设为 users 群体的 tom</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash">chown tom:users file d.key e.scrt</code></pre></div><ul><li>设置当前目录下与子目录下的所有文件的拥有者为 users 群体的 James</li></ul><div class="hljs code-wrapper"><pre><code class="hljs dockerfile">chown -R James:users  *<span class="hljs-keyword">Copy</span></code></pre></div><h1 id="二、Linux权限详解"><a href="#二、Linux权限详解" class="headerlink" title="二、Linux权限详解"></a>二、Linux权限详解</h1><p>Linux系统上对文件的权限有着严格的控制，用于如果相对某个文件执行某种操作，必须具有对应的权限方可执行成功。这也是Linux有别于Windows的机制，也是基于这个权限机制，Linux可以有效防止病毒自我运行，因为运行的条件是必须要有运行的权限，而这个权限在Linux是用户所赋予的。</p><p>Linux的文件权限有以下设定：</p><ul><li>Linux下文件的权限类型一般包括读，写，执行。对应字母为 r、w、x。</li><li>Linux下权限的属组有 <strong>拥有者 、群组 、其它组</strong> 三种。每个文件都可以针对这三个属组（粒度），设置不同的rwx(读写执行)权限。</li><li>通常情况下，一个文件只能归属于一个用户和组， 如果其它的用户想有这个文件的权限，则可以将该用户加入具备权限的群组，一个用户可以同时归属于多个组。</li></ul><p>如果我们要表示一个文件的所有权限详情，有两种方式：</p><ul><li>第一种是十位二进制表示法 ，(三个属组的每个权限使用一个二进制位，再加一个最高位共十位)，可简化为三个八进制数字形式（如 755）</li><li>另外一种十二位二进制表示法(十二个二进制位)，可简化为四个八进制数字形式（如4755）</li></ul><h2 id="十位权限表示"><a href="#十位权限表示" class="headerlink" title="十位权限表示"></a>十位权限表示</h2><p>常见的权限表示形式有：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">-rw------- (600)    只有拥有者有读写权限。-rw-r--r-- (644)    只有拥有者有读写权限；而属组用户和其他用户只有读权限。-rwx------ (700)    只有拥有者有读、写、执行权限。-rwxr-xr-x (755)    拥有者有读、写、执行权限；而属组用户和其他用户只有读、执行权限。-rwx--x--x (711)    拥有者有读、写、执行权限；而属组用户和其他用户只有执行权限。-rw-rw-rw- (666)    所有用户都有文件读、写权限。-rwxrwxrwx (777)    所有用户都有读、写、执行权限。</code></pre></div><p>后九位解析： 我们知道Linux权限总共有三个属组，这里我们给每个属组使用三个位置来定义三种操作（读、写、执行）权限，合起来则是权限的后九位。 上面我们用字符表示权限，其中 -代表无权限，r代表读权限，w代表写权限，x代表执行权限。（后九位的前3位对应拥有者权限、4-6位对应群组权限、7-9对应其他组权限）</p><p>实际上，后九位每个位置的意义（代表某个属组的某个权限）都是固定的，如果我们将各个位置权限的有无用二进制数 1和 0来代替，则只读、只写、只执行权限，可以用三位二进制数表示为</p><div class="hljs code-wrapper"><pre><code class="hljs bash">r-- = 100-w- = 010--x = 001--- = 000</code></pre></div><p>转换成八进制数，则为 r=4, w=2, x=1, -=0（这也就是用数字设置权限时为何是4代表读，2代表写，1代表执行）</p><p>实际上，我们可以将所有的权限用二进制形式表现出来，并进一步转变成八进制数字：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">rwx = 111 = 7rw- = 110 = 6r-x = 101 = 5r-- = 100 = 4-wx = 011 = 3-w- = 010 = 2--x = 001 = 1--- = 000 = 0</code></pre></div><p>由上可以得出，每个属组的所有的权限都可以用一位八进制数表示，每个数字都代表了不同的权限（权值）。如 最高的权限为是7，代表可读，可写，可执行。</p><p>故 如果我们将每个属组的权限都用八进制数表示，则文件的权限可以表示为三位八进制数</p><div class="hljs code-wrapper"><pre><code class="hljs bash">-rw------- =  600-rw-rw-rw- =  666-rwxrwxrwx =  777</code></pre></div><p>关于第一位最高位的解释： 上面我们说到了权限表示中后九位的含义，剩下的第一位代表的是文件的类型，类型可以是下面几个中的一个：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">d代表的是目录(directroy)-代表的是文件(regular file)s代表的是套字文件(socket)p代表的管道文件(pipe)或命名管道文件(named pipe)l代表的是符号链接文件(symbolic link)b代表的是该文件是面向块的设备文件(block-oriented device file)c代表的是该文件是面向字符的设备文件(charcter-oriented device file)</code></pre></div><h2 id="十二位权限（Linux附加权限）"><a href="#十二位权限（Linux附加权限）" class="headerlink" title="十二位权限（Linux附加权限）"></a>十二位权限（Linux附加权限）</h2><h3 id="附加权限相关概念"><a href="#附加权限相关概念" class="headerlink" title="附加权限相关概念"></a>附加权限相关概念</h3><p>linux除了设置正常的读写操作权限外，还有关于一类设置也是涉及到权限，叫做Linxu附加权限。包括 SET位权限（suid，sgid）和粘滞位权限（sticky）。</p><p>SET位权限：</p><p>suid/sgid是为了使“没有取得特权用户要完成一项必须要有特权才可以执行的任务”而产生的。 一般用于给可执行的程序或脚本文件进行设置，其中SUID表示对属主用户增加SET位权限，SGID表示对属组内用户增加SET位权限。执行文件被设置了SUID、SGID权限后，任何用户执行该文件时，将获得该文件属主、属组账号对应的身份。在许多环境中，suid 和 sgid 很管用，但是不恰当地使用这些位可能使系统的安全遭到破坏。所以应该尽量避免使用SET位权限程序。（passwd 命令是为数不多的必须使用“suid”的命令之一）。</p><ul><li>suid(set User ID,set UID)的意思是进程执行一个文件时通常保持进程拥有者的UID。然而，如果设置了可执行文件的suid位，进程就获得了该文件拥有者的UID。</li><li>sgid(set Group ID,set GID)意思也是一样，只是把上面的进程拥有者改成进程组就好了。</li></ul><p>SET位权限表示形式（10位权限）：</p><p>如果一个文件被设置了suid或sgid位，会分别表现在所有者或同组用户的权限的可执行位上；如果文件设置了suid还设置了x（执行）位，则相应的执行位表示为s(小写)。但是，如果没有设置x位，它将表示为S(大写)。如：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">1、-rwsr-xr-x 表示设置了suid，且拥有者有可执行权限2、-rwSr--r-- 表示suid被设置，但拥有者没有可执行权限3、-rwxr-sr-x 表示sgid被设置，且群组用户有可执行权限4、-rw-r-Sr-- 表示sgid被设置，但群组用户没有可执行权限</code></pre></div><p>设置方式：</p><p>SET位权限可以通过chmod命令设置，给文件加suid和sgid的命令如下(类似于上面chmod赋予一般权限的命令)：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">chmod u+s filename     设置suid位chmod u-s filename     去掉suid设置chmod g+s filename     设置sgid位chmod g-s filename     去掉sgid设置</code></pre></div><p>粘滞位权限：</p><p>粘滞位权限即sticky。一般用于为目录设置特殊的附加权限，当目录被设置了粘滞位权限后，即便用户对该目录有写的权限，也不能删除该目录中其他用户的文件数据。设置了粘滞位权限的目录，是用ls查看其属性时，其他用户权限处的x将变为t。 使用chmod命令设置目录权限时，+t、-t权限模式可分别用于添加、移除粘滞位权限。</p><p>粘滞位权限表示形式（10位权限）：</p><p>一个文件或目录被设置了粘滞位权限，会表现在其他组用户的权限的可执行位上。如果文件设置了sticky还设置了x（执行）位，其他组用户的权限的可执行位为t(小写)。但是，如果没有设置x位，它将表示为T(大写)。如：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">1、-rwsr-xr-t 表示设置了粘滞位且其他用户组有可执行权限2、-rwSr--r-T 表示设置了粘滞位但其他用户组没有可执行权限</code></pre></div><p>设置方式：</p><p>sticky权限同样可以通过chmod命令设置：</p><blockquote><p>chmod +t &lt;文件列表..&gt;</p></blockquote><h3 id="十二位的权限表示方法"><a href="#十二位的权限表示方法" class="headerlink" title="十二位的权限表示方法"></a>十二位的权限表示方法</h3><p>附加权限除了用十位权限形式表示外，还可以用用十二位字符表示。</p><div class="hljs code-wrapper"><pre><code class="hljs bash">11 10 9 8 7 6 5 4 3 2 1 0S  G  T r w x r w x r w x</code></pre></div><p>SGT分别表示SUID权限、SGID权限、和 粘滞位权限，这十二位分别对应关系如下：</p><p>第11位为SUID位，第10位为SGID位，第9位为sticky位，第8-0位对应于上面的三组rwx位（后九位）。</p><p>在这十二位的每一位上都置值。如果有相应的权限则为1， 没有此权限则为0。</p><div class="hljs code-wrapper"><pre><code class="hljs bash">-rw-r-sr-- 的值为： 0 1 0  1 1 0  1 0 0  1 0 0-rwsr-xr-x 的值为： 1 0 0  1 1 1  1 0 1  1 0 1-rwsr-sr-x 的值为： 1 1 0  1 1 1  1 0 1  1 0 1 -rwsr-sr-t 的值为： 1 1 1  1 1 1  1 0 1  1 0 1</code></pre></div><p>如果将则前三位SGT也转换成一个二进制数，则</p><ul><li>suid 的八进制数字是4</li><li>sgid 的代表数字是 2</li><li>sticky 位代表数字是1</li></ul><p>这样我们就可以将十二位权限三位三位的转化为4个八进制数。其中</p><ul><li>最高的一位八进制数就是suid，sgdi，sticky的权值。</li><li>第二位为 拥有者的权值</li><li>第三位为 所属组的权值</li><li>最后一位为 其他组的权值</li></ul><h3 id="附加权限的八进制形式"><a href="#附加权限的八进制形式" class="headerlink" title="附加权限的八进制形式"></a>附加权限的八进制形式</h3><p>通过上面，我们知道，正常权限和附加权限可以用4位八进制数表示。类似于正常权限的数字权限赋值模式（使用三位八进制数字赋值）</p><blockquote><p>chmod <abc> file…</p></blockquote><p>我们可以进一步使用4位八进制数字同时赋值正常权限和附加权限。</p><blockquote><p>chmod <sabc> file…</p></blockquote><p>其中s是表示附加权限的把八进制数字，abc与之前一致，分别是对应User、Group、及Other（拥有者、群组、其他组）的权限。因为SUID对应八进制数字是4，SGID对于八进制数字是2，则“4755”表示设置SUID权限，“6755”表示同时设置SUID、SGID权限。</p><p>我们进一步将上小节的例子中的二进制数转变为八进制表示形式，则</p><div class="hljs code-wrapper"><pre><code class="hljs bash">-rw-r-sr-- = 0 1 0 1 1 0 1 0 0 1 0 0 = 2644 -rwsr-xr-x = 1 0 0 1 1 1 1 0 1 1 0 1 = 4755-rwsr-sr-x = 1 1 0 1 1 1 1 0 1 1 0 1 = 6755-rwsr-sr-t = 1 1 1 1 1 1 1 0 1 1 0 1 = 7755</code></pre></div><p>对比范例：</p><ul><li>设置 netlogin 的权限为拥有者可读写执行，群组和其他权限为可读可执行</li></ul><div class="hljs code-wrapper"><pre><code class="hljs zsh">chmod 755 netlogin</code></pre></div><ul><li>设置 netlogin 的权限为拥有者可读写执行，群组和其他权限为可读可执行，并且设置suid</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash">chmod 4755 netlogin</code></pre></div><p>chmod 4755与chmod 755对比多了附加权限值4，这个4表示其他用户执行文件时，具有与所有者同样的权限（设置了SUID）。</p><blockquote><p>为什么要设置4755 而不是 755？<br>假设netlogin是root用户创建的一个上网认证程序，如果其他用户要上网也要用到这个程序，那就需要root用户运行chmod 755 netlogin命令使其他用户也能运行netlogin。但假如netlogin执行时需要访问一些只有root用户才有权访问的文件，那么其他用户执行netlogin时可能因为权限不够还是不能上网。这种情况下，就可以用 chmod 4755 netlogin 设置其他用户在执行netlogin也有root用户的权限，从而顺利上网。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>system</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jvm_tuning</title>
    <link href="/2021/08/26/jvm-properties/"/>
    <url>/2021/08/26/jvm-properties/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA-启动参数"><a href="#JAVA-启动参数" class="headerlink" title="JAVA 启动参数"></a>JAVA 启动参数</h1><p>/opt/vdian/java/bin/java<br>-Djava.util.logging.config.file=/home/www/fenxiao-core/.server/conf/logging.propertie</p><p>-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager </p><p>-Djdk.tls.ephemeralDHKeySize=2048  TLS ephemeral diffie-hellman keys大小</p><p>-server 启用-server时新生代默认采用并行收集，其他情况下，默认不启用。-server策略为：新生代使用并行清除，年老代使用单线程Mark-Sweep-Compact的垃圾收集器。<br>-Xms8g 初始堆大小 默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.<br>-Xmx8g 最大堆大小 默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制<br>-XX:PermSize=256m 设置持久代(perm gen)初始值(物理内存的1/64)<br>-XX:MaxPermSize=256m 设置持久代最大值(物理内存的1/4)<br>-Xmn4g 年轻代大小 注意：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小. 增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8<br>-XX:MaxDirectMemorySize=512m DirectMemory是java nio引入的，直接以native的方式分配内存，不受jvm管理。这种方式是为了提高网络和文件IO的效率，避免多余的内存拷贝而出现的。 DirectMemory占用的大小没有直接的工具或者API可以查看</p><p>-XX:SurvivorRatio=8 Eden区与Survivor区的大小比值, 设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10<br>-XX:+UseConcMarkSweepGC 设置年老代为并发收集(使用CMS内存收集)<br>-XX:+UseCMSCompactAtFullCollection 年老代使用CMS，默认是不会整理堆碎片的。设置此配置打开对年老代的压缩，即执行FullGC后对内存进行整理压缩，免得产生内存碎片，但有可能会影响性能</p><p>-XX:CMSMaxAbortablePrecleanTime=5000 指定CMS-concurrent-abortable-preclean阶段执行的时间，该阶段主要是执行一些预清理，减少应用暂停的时间。但在JDK 5.0+、6.0+的版本中有可能会由于JDK的bug29导致CMS在remark完毕后很久才触发sweeping动作。通过设置-XX: CMSMaxAbortablePrecleanTime=5（单位为ms）来避免，</p><p><strong>注：Concurrent Abortable Preclean(并发可取消的预清理).</strong> 此阶段也不停止应用线程. 本阶段尝试在 STW 的 Final Remark 之前尽可能地多做一些工作。本阶段的具体时间取决于多种因素, 因为它循环做同样的事情,直到满足某个退出条件( 如迭代次数, 有用工作量, 消耗的系统时间,等等)。</p><p>-XX:+CMSClassUnloadingEnabled 对永久代区启用类回收<br>-XX:CMSInitiatingOccupancyFraction=80 使用cms作为垃圾回收,使用80％后开始CMS收集<br>-XX:+UseCMSInitiatingOccupancyOnly 使用手动定义初始化定义开始CMS收集,禁止hotspot（JVM）自行触发CMS GC</p><p>-XX:+ExplicitGCInvokesConcurrent 触发full gc 只不过在CMS在full gc 效率比较高。<br><a href="http://www.liuinsect.com/2014/05/12/whats-explicitgcinvokesconcurrent-used-for/">http://www.liuinsect.com/2014/05/12/whats-explicitgcinvokesconcurrent-used-for/</a></p><div class="hljs code-wrapper"><pre><code class="hljs bash">-Dsun.rmi.dgc.server.gcInterval=2592000000 存在rmi调用时gc的时间间隔。-Dsun.rmi.dgc.client.gcInterval=2592000000-XX:ParallelGCThreads=4 并行收集器的线程数,此值最好配置与处理器数目相等 同样适用于CMS-Xloggc:/home/www/fenxiao-core/logs/gc.log 把相关日志信息记录到文件以便分析.与上面几个配合使用-XX:+PrintGCDetails 开关，可以详细了解GC中的变化。-XX:+PrintGCDateStamps GC发生的时间信息-XX:+HeapDumpOnOutOfMemoryError JVM会在遇到OutOfMemoryError时拍摄一个“堆转储快照”，并将其保存在一个文件中。-XX:HeapDumpPath=/home/www/fenxiao-core/logs/java.hprof dump文件路径-Djava.awt.headless=<span class="hljs-literal">true</span>-Dsun.net.client.defaultConnectTimeout=10000 连接主机的超时时间（单位：毫秒）-Dsun.net.client.defaultReadTimeout=30000 从主机读取数据的超时时间（单位：毫秒）-Dfile.encoding=UTF-8-Ddubbo.application.logger=slf4j-Dcom.sun.management.jmxremote-Dcom.sun.management.jmxremote.port=8082-Dcom.sun.management.jmxremote.ssl=<span class="hljs-literal">false</span>-Dcom.sun.management.jmxremote.authenticate=<span class="hljs-literal">false</span>-Djava.rmi.server.hostname=10.2.125.42-Dproject.name=fenxiao-core-Djava.endorsed.dirs=/opt/vdian/tomcat/endorsed-classpath /opt/vdian/tomcat/bin/bootstrap.[jar:/opt/vdian/tomcat/bin/tomcat-juli.jar](http://jar/opt/vdian/tomcat/bin/tomcat-juli.jar)-Dcatalina.base=/home/www/fenxiao-core/.server-Dcatalina.home=/opt/vdian/tomcat-Djava.io.tmpdir=/home/www/fenxiao-core/.server/temporg.apache.catalina.startup.Bootstrapstart</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jvm_tuning</title>
    <link href="/2021/08/26/jvm-tenance/"/>
    <url>/2021/08/26/jvm-tenance/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="内存区域划分"><a href="#内存区域划分" class="headerlink" title="内存区域划分"></a>内存区域划分</h2><p>限定商用虚拟机基本都采用<code>分代收集算法</code>进行垃圾回收。根据对象的生命周期的不同将内存划分为几块，然后根据各块的特点采用最适当的收集算法。大批对象死去、少量对象存活的，使用复制算法，复制成本低；对象存活率高、没有额外空间进行分配担保的，采用标记-清除算法或者标记-整理算法。</p><p><img src="https://images2017.cnblogs.com/blog/285952/201801/285952-20180131105449984-2130189134.png" alt="img"></p><p>从上面的图可以看出， JVM区域总体分两类，heap区和非heap区。 </p><p>1.heap区又分为： </p><ul><li>Eden Space（伊甸园）、 </li><li>Survivor Space(幸存者区)、 </li><li>Old Gen（老年代）。</li></ul><p>2.非heap区又分： </p><ul><li>Code Cache(代码缓存区)； </li><li>Perm Gen（永久代）； </li><li>Jvm Stack(java虚拟机栈)； </li><li>Local Method Statck(本地方法栈)；<br>关于java堆，新生代，老年代，Eden空间，From Survivor空间，To Survivor空间<br>java进程运行过程中创建的对象存放在堆中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。<br>堆的内存模型大致为：</li></ul><p>默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )，即：新生代 ( Young ) = 1/3 的堆空间大小。<br>老年代 ( Old ) = 2/3 的堆空间大小。其中，新生代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为 from 和 to，以示区分。<br>默认的，Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )，即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。<br>JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。<br>因此，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间。</p><p>新生代是 GC 收集垃圾的频繁区域。<br>当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳<br>( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 )，这些对象就会成为老年代。<br>但这也不是一定的，对于一些较大的对象 ( 即需要分配一块较大的连续内存空间 ) 则是直接进入到老年代。</p><p>From Survivor区域与To Survivor区域是交替切换空间，在同一时间内两者中只有一个不为空<br>2.内存区域介绍</p><h3 id="1-年轻代："><a href="#1-年轻代：" class="headerlink" title="1.年轻代："></a>1.年轻代：</h3><p>HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1,为啥默认会是这个比例，接下来我们会聊到。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。</p><p>因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。</p><p>在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</p><p><img src="https://images2017.cnblogs.com/blog/285952/201801/285952-20180131143358062-1502789309.png" alt="img"></p><p>有关年轻代的JVM参数</p><p>1)-XX:NewSize和-XX:MaxNewSize</p><p>用于设置年轻代的大小，建议设为整个堆大小的1/3或者1/4,两个值设为一样大。</p><p>2)-XX:SurvivorRatio</p><p>用于设置Eden和其中一个Survivor的比值，这个值也比较重要。</p><p>3)-XX:+PrintTenuringDistribution</p><p>这个参数用于显示每次Minor GC时Survivor区中各个年龄段的对象的大小。</p><p>4).-XX:InitialTenuringThreshol和-XX:MaxTenuringThreshold</p><p>用于设置晋升到老年代的对象年龄的最小值和最大值，每个对象在坚持过一次Minor GC之后，年龄就加1。</p><h3 id="2-old老年代"><a href="#2-old老年代" class="headerlink" title="2.old老年代"></a>2.old老年代</h3><p>老年代，用于存放新生代中经过多次垃圾回收仍然存活的对象，也有可能是新生代分配不了内存的大对象会直接进入老年代。经过多次垃圾回收都没有被回收的对象，这些对象的年代已经足够old了，就会放入到老年代。</p><p>当老年代被放满的之后，虚拟机会进行垃圾回收，称之为Major GC。由于Major GC除并发GC外均需对整个堆进行扫描和回收，因此又称为Full GC。</p><p>heap区即堆内存，整个堆大小=年轻代大小 + 老年代大小。堆内存默认为物理内存的1/64(&lt;1GB)；默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制，可以通过MinHeapFreeRatio参数进行调整；默认空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制，可以通过MaxHeapFreeRatio参数进行调整。</p><h3 id="3-Code-Cache代码缓存区"><a href="#3-Code-Cache代码缓存区" class="headerlink" title="3.Code Cache代码缓存区"></a>3.Code Cache代码缓存区</h3><p>它主要用于存放JIT所编译的热点代码。CodeCache代码缓冲区的大小在client模式下默认最大是32m，在server模式下默认是48m，这个值也是可以设置的，它所对应的JVM参数为ReservedCodeCacheSize 和 InitialCodeCacheSize，可以通过如下的方式来为Java程序设置。</p><p><code>-XX:ReservedCodeCacheSize=128m</code></p><p>CodeCache缓存区是可能被充满的，当CodeCache满时，后台会收到CodeCache is full的警告信息，如下所示：<br>“CompilerThread0” java.lang.OutOfMemoryError: requested 2854248 bytes for Chunk::new. Out of swap space?</p><h3 id="4-Perm-Gen-永久代-JDK1-8之后被元空间替代"><a href="#4-Perm-Gen-永久代-JDK1-8之后被元空间替代" class="headerlink" title="4.Perm Gen(永久代) (JDK1.8之后被元空间替代)"></a>4.Perm Gen(永久代) (JDK1.8之后被元空间替代)</h3><p>Perm Gen全称是Permanent Generation space，称之为永久代，其实指的就是这个方法区。不过方法区和“PermGen space”又有着本质的区别。前者是 JVM 的规范，而后者则是 JVM 规范的一种实现，并且只有 HotSpot 才有 “PermGen space”，而对于其他类型的虚拟机，如 JRockit（Oracle）、J9（IBM） 并没有“PermGen space”。</p><p>由于方法区主要存储类的相关信息，Class在被Load进入这个区域后，如果应用程序LOAD很多Class的话，就很可能会出现PermGen space错误，比如对于动态生成类的情况比较容易出现永久代的内存溢出。它的默认大小为物理内存的1/64。</p><h2 id="JVM分析"><a href="#JVM分析" class="headerlink" title="JVM分析"></a>JVM分析</h2><h4 id="jmap-heap-1234-查看进程号为1234的Java程序的整个jvm内存状态"><a href="#jmap-heap-1234-查看进程号为1234的Java程序的整个jvm内存状态" class="headerlink" title="jmap -heap 1234 查看进程号为1234的Java程序的整个jvm内存状态"></a>jmap -heap 1234 查看进程号为1234的Java程序的整个jvm内存状态</h4><h4 id="jmap-histo-1234-查找进程号为1234的java程序的jvm堆中对象详细占用情况"><a href="#jmap-histo-1234-查找进程号为1234的java程序的jvm堆中对象详细占用情况" class="headerlink" title="jmap -histo 1234 查找进程号为1234的java程序的jvm堆中对象详细占用情况"></a>jmap -histo 1234 查找进程号为1234的java程序的jvm堆中对象详细占用情况</h4><h4 id="jmap-dump-format-b-file-my-dump-1234-导出1234进程的java程序的整个JVM信息"><a href="#jmap-dump-format-b-file-my-dump-1234-导出1234进程的java程序的整个JVM信息" class="headerlink" title="jmap -dump:format=b,file=/my.dump 1234  导出1234进程的java程序的整个JVM信息"></a>jmap -dump:format=b,file=/my.dump 1234  导出1234进程的java程序的整个JVM信息</h4><h4 id="jhat-J-Xmx1024M-my-dump-启动web服务查看jmap导出的java程序的jvm信息。"><a href="#jhat-J-Xmx1024M-my-dump-启动web服务查看jmap导出的java程序的jvm信息。" class="headerlink" title="jhat -J-Xmx1024M /my.dump, 启动web服务查看jmap导出的java程序的jvm信息。"></a>jhat -J-Xmx1024M /my.dump, 启动web服务查看jmap导出的java程序的jvm信息。</h4><h4 id="jstack-1234-查看1234进程的所有堆栈信息。"><a href="#jstack-1234-查看1234进程的所有堆栈信息。" class="headerlink" title="jstack 1234 查看1234进程的所有堆栈信息。"></a>jstack 1234 查看1234进程的所有堆栈信息。</h4><h4 id="以上命令的功能都可以从jVisualVM程序获取，双击运行即可。"><a href="#以上命令的功能都可以从jVisualVM程序获取，双击运行即可。" class="headerlink" title="以上命令的功能都可以从jVisualVM程序获取，双击运行即可。"></a>以上命令的功能都可以从jVisualVM程序获取，双击运行即可。</h4><h2 id="jmap是java自带的工具"><a href="#jmap是java自带的工具" class="headerlink" title="jmap是java自带的工具"></a>jmap是java自带的工具</h2><p>查看整个JVM内存状态</p><p>jmap -heap [pid]</p><p>要注意的是在使用CMS GC 情况下，jmap -heap的执行有可能会导致JAVA 进程挂起</p><p>查看JVM堆中对象详细占用情况</p><p>jmap -histo [pid]</p><p>导出整个JVM 中内存信息</p><p>jmap -dump:format=b,file=文件名 [pid]</p><p>jhat是sun 1.6及以上版本中自带的一个用于分析JVM 堆DUMP 文件的工具，基于此工具可分析JVM HEAP 中对象的内存占用情况</p><p>jhat -J-Xmx1024M [file]  （此处的file指的是jmap -dump导出的内存数据文件）</p><p>执行后等待console 中输入start HTTP server on port 7000 即可使用浏览器访问 IP：7000</p><p>eclipse Memory Analyzer</p><p>Eclipse 提供的一个用于分析JVM 堆Dump文件的插件。借助这个插件可查看对象的内存占用状况，引用关系，分析内存泄露等。</p><p><a href="https://link.jianshu.com/?t=http://www.eclipse.org/mat/">http://www.eclipse.org/mat/</a></p><p>kill -3 [pid]</p><p>在Linux 上找到Java所在的进程号，然后执行以上命令，线程的相关信息就输出到console</p><h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h2><p>jstack 是sun JDK 自带的工具，通过该工具可以看到JVM 中线程的运行状况，包括锁等待，线程是否在运行</p><p>执行 jstack [pid] ,线程的所有堆栈信息</p><p>“http-8080-10” daemon prio=10 tid=x0a949bb60 nid=0x884 waiting for monitor entry […]</p><p>“http-8080-10” 这个线程处于等待状态。 waiting for monitor entry 如果在连续几次输出线程堆栈信息都存在于同一个或多个线程上时，则说明系统中有锁竞争激烈，死锁，或锁饿死的想象。</p><p>“http-8080-11” daemon prio=10 tix=xxx nid=xxx in object.wait() […]</p><p>java.lang.Thread.State:waiting (on object monitor)</p><p>该表示http-8080-11的线程处于对象的Wait 上，等待其他线程的唤醒，这也是线程池的常见用法。</p><p>“Low Memory Detector”daemon prio=10 tix=xx nid=xxx runnable […] java.lang.Thread.State:runnable</p><p>表示“Low Memory Detector” 的线程处于Runable状态，等待获取ＣＰＵ的使用权.</p><p>参考：<a href="https://link.jianshu.com/?t=http://zhumeng8337797.blog.163.com/blog/static/100768914201242410583187/">http://zhumeng8337797.blog.163.com/blog/static/100768914201242410583187/</a></p><h2 id="jvisualvm"><a href="#jvisualvm" class="headerlink" title="jvisualvm"></a>jvisualvm</h2><p><strong>一.Java VisualVM 概述</strong></p><p>对于使用命令行远程监控jvm 太麻烦 。 在jdk1.6 中 Oracle 提供了一个新的可视化的。 JVM 监控工具 Java VisualVM 。jvisualvm.exe 在JDK 的 bin 目录下。</p><p>双击启动 Java VisualVM 后可以看到窗口左侧 “应用程序 ”栏中有“ 本地 ”、“远程 ” 、“快照 ”三个项目。</p><p>“本地 ”下显示的是在 localhost 运行的 Java 程序的资源占用情况，如果本地有 Java 程序在运行的话启动 Java VisualVM 即可看到相应的程序名，点击程序名打开相应的资源监控菜单，以图形的形式列出程序所占用的 CPU 、 Heap 、 PermGen 、类、线程的 统计信息。</p><p>“远程” 项下列出的远程主机上的 Java 程序的资源占用情况，但需要在远程主机上运行 jstatd 守护程序</p><p>VisualVM分为 3 类， 本地 它会自动侦测到，并显示出来</p><p>双击Local 下的任一节点，看到右边的变化 ，你可以监控 CPU ，内存，类，线程等运行状况，实时监控服务器性能。</p><p>右键 VisualVM我们可以看到 Thread Dump, Heap Dump</p><p>做 Thread Dump 很快，马上就可以看到结果</p><p>Heap Dump要稍花费一些时间（可以看到当前 heap 里对象的数量及占用的比例，做 OOM 很好用）</p><p>对其功能不再做描述，可以查阅网上相关质量，我们主要讲的是如何使用 VisualVM 远程监控。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript equals</title>
    <link href="/2021/07/05/javascript-equls/"/>
    <url>/2021/07/05/javascript-equls/</url>
    
    <content type="html"><![CDATA[<h1 id="js中-和-区别"><a href="#js中-和-区别" class="headerlink" title="js中==和===区别"></a><a href="">js中==和===区别</a></h1><p>简单来说： == 代表相同， ===代表严格相同, 为啥这么说呢， </p><p>这么理解： 当进行双等号比较时候： 先检查两个操作数数据类型，如果相同， 则进行===比较， 如果不同， 则愿意为你进行一次类型转换， 转换成相同类型后再进行比较， 而===比较时， 如果类型不同，直接就是false.</p><p>操作数1 == 操作数2， 操作数1 === 操作数2</p><p>比较过程：</p><p>　　双等号==： </p><p>　　（1）如果两个值类型相同，再进行三个等号(===)的比较</p><p>　　（2）如果两个值类型不同，也有可能相等，需根据以下规则进行类型转换在比较：</p><p>　　　　1）如果一个是null，一个是undefined，那么相等</p><p>　　　　2）如果一个是字符串，一个是数值，把字符串转换成数值之后再进行比较</p><p>　　</p><p>　　三等号===:</p><p>　　（1）如果类型不同，就一定不相等</p><p>　　（2）如果两个都是数值，并且是同一个值，那么相等；如果其中至少一个是NaN，那么不相等。（判断一个值是否是NaN，只能使用isNaN( ) 来判断）</p><p>　　（3）如果两个都是字符串，每个位置的字符都一样，那么相等，否则不相等。</p><p>　　（4）如果两个值都是true，或是false，那么相等</p><p>　　（5）如果两个值都引用同一个对象或是函数，那么相等，否则不相等</p><p>　　（6）如果两个值都是null，或是undefined，那么相等</p>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mall attribute</title>
    <link href="/2021/06/23/other-mall-attr/"/>
    <url>/2021/06/23/other-mall-attr/</url>
    
    <content type="html"><![CDATA[<h1 id="商城业务流程分析"><a href="#商城业务流程分析" class="headerlink" title="商城业务流程分析"></a>商城业务流程分析</h1><h2 id="SKU和SPU属性分析"><a href="#SKU和SPU属性分析" class="headerlink" title="SKU和SPU属性分析"></a>SKU和SPU属性分析</h2><h4 id="iphone-xs-｜-iphone-xs-max-｜-iphon-x-gt-SPU包括-每款机型的像素，尺寸，分辨率。。。。"><a href="#iphone-xs-｜-iphone-xs-max-｜-iphon-x-gt-SPU包括-每款机型的像素，尺寸，分辨率。。。。" class="headerlink" title="iphone xs ｜ iphone xs max ｜ iphon x  -&gt;SPU包括 每款机型的像素，尺寸，分辨率。。。。"></a>iphone xs ｜ iphone xs max ｜ iphon x  -&gt;SPU包括 每款机型的像素，尺寸，分辨率。。。。</h4><h4 id="不同版本对应SKU，具体的某个版本-内存-颜色，即讲SPU的参数构建成一个机型"><a href="#不同版本对应SKU，具体的某个版本-内存-颜色，即讲SPU的参数构建成一个机型" class="headerlink" title="不同版本对应SKU，具体的某个版本-内存-颜色，即讲SPU的参数构建成一个机型"></a>不同版本对应SKU，具体的某个版本-内存-颜色，即讲SPU的参数构建成一个机型</h4><h3 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grrxujysilj30d90ayq48.jpg" alt="image-20210623092252195"></p><h3 id="销售属性"><a href="#销售属性" class="headerlink" title="销售属性"></a>销售属性</h3><h4 id="不同版本-销售属性不同"><a href="#不同版本-销售属性不同" class="headerlink" title="不同版本 销售属性不同"></a>不同版本 销售属性不同</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grry9g6vozj30c6054ta0.jpg" alt="image-20210623093716694"></p><h4 id="左边参数名称为SPU，右边具体参数为SKU"><a href="#左边参数名称为SPU，右边具体参数为SKU" class="headerlink" title="左边参数名称为SPU，右边具体参数为SKU"></a>左边参数名称为SPU，右边具体参数为SKU</h4><ul><li>同一个SPU商品，共享  商品介绍，规格于包装</li><li>属性都是与三级分类组织，每一个分类一个属性列表，列表包含许多组，每一个组包含具体某一个参数，例如，手机-&gt;iphonx-&gt;64G &amp;&amp; 银色-&gt;{主芯片，存储}</li><li>规格参数中，部分属性提供检索</li></ul><h2 id="品牌关联分类"><a href="#品牌关联分类" class="headerlink" title="品牌关联分类"></a>品牌关联分类</h2><h3 id="每新增一个品牌就会固定一个分类，或者多个分类，一次关联一次数据pms-category-brand-relation"><a href="#每新增一个品牌就会固定一个分类，或者多个分类，一次关联一次数据pms-category-brand-relation" class="headerlink" title="每新增一个品牌就会固定一个分类，或者多个分类，一次关联一次数据pms_category_brand_relation"></a>每新增一个品牌就会固定一个分类，或者多个分类，一次关联一次数据pms_category_brand_relation</h3><h2 id="物品属性"><a href="#物品属性" class="headerlink" title="物品属性"></a>物品属性</h2><h3 id="属性列表查询"><a href="#属性列表查询" class="headerlink" title="属性列表查询"></a>属性列表查询</h3><h5 id="三级分类Id获取属性列表-如果Id为0表示查询所有"><a href="#三级分类Id获取属性列表-如果Id为0表示查询所有" class="headerlink" title="三级分类Id获取属性列表,如果Id为0表示查询所有"></a>三级分类Id获取属性列表,如果Id为0表示查询所有</h5><ul><li>存在三级分类Id</li><li>每次点击三级分类的标签，动态更新物品属性信息</li><li>并且附带检索条件-&gt;描述或者组Id</li></ul><h3 id="新增属性组"><a href="#新增属性组" class="headerlink" title="新增属性组"></a>新增属性组</h3><ul><li>@JsonInclude——ALWAYS——NOT_EMPTY 字段根据条件判断是否返回数据</li></ul><h3 id="属性组列表查询"><a href="#属性组列表查询" class="headerlink" title="属性组列表查询"></a>属性组列表查询</h3><ul><li><p>attrGroupId 查询三级分类完整路径-&gt; 查询该属性组是那个具体分类，根据分类Id查询父级</p></li><li><p>会有一个三级分类选择当前属性是那个三级分类的，需要用到三级选择器-&gt;根据组id查询三级完整路径</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>project</category>
      
      <category>mall</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mall</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git-clean</title>
    <link href="/2021/06/17/basic-git-clean/"/>
    <url>/2021/06/17/basic-git-clean/</url>
    
    <content type="html"><![CDATA[<h1 id="Git仓库删除大文件"><a href="#Git仓库删除大文件" class="headerlink" title="Git仓库删除大文件"></a>Git仓库删除大文件</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>当用Git久了，难免会手误或临时添加一些大文件到仓库中，即使以后添加进了.gitignore，甚至做了git rm，但是Git为了保证版本可回退，history pack里面依然会存储这些对象，这个时候我们就要为Git仓库进行瘦身。</p><p>或者不是大文件的情况，有时我们需要删除掉一些敏感信息文件，比如password.txt，即使回退也无法找到敏感文件，要实现这个要求，也要对history pack进行清理。</p><p><strong>清理主要做如下一些事情：</strong></p><ol><li>寻找想要彻底清理的文件路径</li><li>查询这个文件第一次出现的提交</li><li>从第一次出现的提交开始清理，重写之后的所有提交，保证该文件在history中完全抹除</li><li>清理掉相关的引用，以及log信息</li><li>重新打包所有对象</li><li>推送至远程仓库以应用更新</li></ol><p>所以做完了清理之后，既能够保证Git还可以正常回溯，分支，tag，历史变更这些都还保留；又能够完全清理掉指定的文件。</p><h3 id="操作思路"><a href="#操作思路" class="headerlink" title="操作思路"></a>操作思路</h3><p>下面有2种途径达到目的</p><ol><li>可以使用BFG工具，操作简单，链接为：<a href="https://rtyley.github.io/bfg-repo-cleaner/">https://rtyley.github.io/bfg-repo-cleaner/</a></li><li>如果喜欢自己倒腾，可以使用原生git命令组合实现，主要用到git filter-branch，其实BFG也是对该命令的封装</li></ol><h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h3><p>以第2种途径来达成目的，亲测可用，场景为 我在几个月前推送了一批镜像文件到仓库中，虽然git rm移除了，但history pack中依然保留了数据 。汗…</p><p>以下步骤均在工程根目录下操作</p><ol><li>寻找大文件是哪些</li></ol><p>镜像已经移除掉了，我需要寻找到它们曾经在哪里。以下命令罗列出整个仓库中前10个最大文件对象。该命令运行需要等待一段时间</p><div class="hljs code-wrapper"><pre><code class="hljs dns">$ git verify-pack -v .git/objects/pack/pack-<span class="hljs-number">43035</span>f03d78ed39da647d4685e427bd126209bdb.idx | sort -k <span class="hljs-number">3</span> -n | tail -<span class="hljs-number">10</span>e28b267b24de7d5b32ed2391669df8a72e24257d blob   <span class="hljs-number">162449408</span> <span class="hljs-number">62757122</span> <span class="hljs-number">757958127</span>c32c8b1da1c6283b250402aa31cde35051a52b3d blob   <span class="hljs-number">177733120</span> <span class="hljs-number">59785053</span> <span class="hljs-number">1360726301</span><span class="hljs-number">711</span>c9b581771981c54b4637497ceeb4bb23012bd blob   <span class="hljs-number">188976128</span> <span class="hljs-number">70107988</span> <span class="hljs-number">2347396900</span>d5cb26ac04328a255e922a24ea271ee50901c59d blob   <span class="hljs-number">196414976</span> <span class="hljs-number">74351707</span> <span class="hljs-number">1500585499</span>f93b48272597886796fc03d54e281f2403bea5ed blob   <span class="hljs-number">199080448</span> <span class="hljs-number">44716221</span> <span class="hljs-number">1455869278</span><span class="hljs-number">247</span>b35b36ef4c9f980c8cf967712788539980e5d blob   <span class="hljs-number">244180480</span> <span class="hljs-number">88897974</span> <span class="hljs-number">820715249</span><span class="hljs-number">71848</span>a6b5cb31639f8770553ddf6222573755d3d blob   <span class="hljs-number">414519296</span> <span class="hljs-number">140712921</span> <span class="hljs-number">100780869</span>d69f7af4727d15ee563aead6eff1d8baff61105d blob   <span class="hljs-number">1295518720</span> <span class="hljs-number">427812890</span> <span class="hljs-number">330145237</span>a3a36f25a9c3d610cb4d4eea381314ecf7b1510d blob   <span class="hljs-number">1324011520</span> <span class="hljs-number">443360428</span> <span class="hljs-number">909613223</span>c32670dfb49ae6a5948517fb6d19f78812a840ad blob   <span class="hljs-number">1802148352</span> <span class="hljs-number">617108853</span> <span class="hljs-number">1730288047</span></code></pre></div><p>2.查找对应路径</p><p>发现e28b267b24de7d5b32ed2391669开头的对象最大，我们来看看它指代了哪个路径</p><div class="hljs code-wrapper"><pre><code class="hljs gradle">$ git rev-list --objects --all | <span class="hljs-keyword">grep</span> e28b267b24de7d5b32ed2391669e28b267b24de7d5b32ed2391669df8a72e24257d backEnd<span class="hljs-regexp">/vendor/</span>history<span class="hljs-regexp">/dockerimages/</span>fabric-baseos</code></pre></div><p>3.查找第一次出现该文件的log</p><p>从上个命令找到了大文件的曾经存在过的路径，现在查找log看看第一次提交该文件的版本号，结果列表里面最下面一个即为第一次，例如下面的722113f8a88。其实这一步不是必须的，因为清理可以从头清理到尾，全面覆盖。</p><div class="hljs code-wrapper"><pre><code class="hljs pgsql">$ git <span class="hljs-keyword">log</span> <span class="hljs-comment">--pretty=oneline --branches -- backEnd/vendor/history/dockerimages/fabric-baseos</span><span class="hljs-number">486</span>eac3085e25e9cec8c2de35c1e09cf79a5134e <span class="hljs-keyword">update</span><span class="hljs-number">5</span>fb74121be3fe311428068dd02837406a5d8f173 <span class="hljs-keyword">update</span><span class="hljs-number">1380</span>ead7f038a4b23add4fd64e9b66cb678cd6b5 <span class="hljs-keyword">commit</span> somethinga49db09fb148aabf51223d73fbcdb71e103610a0 <span class="hljs-keyword">update</span><span class="hljs-number">722113</span>f8a88e03cafebe7bbfcb6de20ffb068387 push</code></pre></div><p>4.开始清理history</p><div class="hljs code-wrapper"><pre><code class="hljs asciidoc">$ git filter-branch --force --index-filter <span class="hljs-emphasis">&#x27;git rm --cached --ignore-unmatch backEnd/vendor/ILIOS/dockerimages/fabric-baseos&#x27;</span> --prune-empty --tag-name-filter cat -- --allRewrite 6aeecaec3cfb419313bfb5516048b0979a6f284f (236/251) (11 seconds passed, rRewrite 2e5b34a51afb5a43f6b5d3e4400bfa0400629a4e (236/251) (11 seconds passed, rRewrite 914c89a1ea1e325f8be990c47cb71eaf88c29649 (236/251) (11 seconds passed, remaining 0 predicted)<span class="hljs-symbol">WARNING: </span>Ref <span class="hljs-emphasis">&#x27;refs/heads/branch1&#x27;</span> is unchanged<span class="hljs-symbol">WARNING: </span>Ref <span class="hljs-emphasis">&#x27;refs/heads/master&#x27;</span> is unchangedRef <span class="hljs-emphasis">&#x27;refs/heads/branch2&#x27;</span> was rewritten<span class="hljs-symbol">WARNING: </span>Ref <span class="hljs-emphasis">&#x27;refs/remotes/origin/master&#x27;</span> is unchanged<span class="hljs-symbol">WARNING: </span>Ref <span class="hljs-emphasis">&#x27;refs/remotes/origin/branch1&#x27;</span> is unchanged<span class="hljs-symbol">WARNING: </span>Ref <span class="hljs-emphasis">&#x27;refs/remotes/origin/master&#x27;</span> is unchangedRef <span class="hljs-emphasis">&#x27;refs/remotes/origin/branch2&#x27;</span> was rewritten</code></pre></div><p>5.清理所有废弃的引用</p><div class="hljs code-wrapper"><pre><code class="hljs brainfuck"><span class="hljs-comment">git</span> <span class="hljs-comment">verify</span><span class="hljs-literal">-</span><span class="hljs-comment">pack</span> <span class="hljs-literal">-</span><span class="hljs-comment">v</span> <span class="hljs-string">.</span><span class="hljs-comment">git/objects/pack/pack</span><span class="hljs-literal">-</span><span class="hljs-comment">7b03cc896f31b2441f3a791ef760bd28495697e6</span><span class="hljs-string">.</span><span class="hljs-comment">idx</span> <span class="hljs-comment">\</span><span class="hljs-comment">|</span> <span class="hljs-comment">sort</span> <span class="hljs-literal">-</span><span class="hljs-comment">k</span> <span class="hljs-comment">3</span> <span class="hljs-literal">-</span><span class="hljs-comment">n</span> <span class="hljs-comment">\</span><span class="hljs-comment">|</span> <span class="hljs-comment">tail</span> <span class="hljs-literal">-</span><span class="hljs-comment">10</span><span class="hljs-comment">git</span> <span class="hljs-comment">rev</span><span class="hljs-literal">-</span><span class="hljs-comment">list</span> --<span class="hljs-comment">objects</span> --<span class="hljs-comment">all</span> <span class="hljs-comment">|</span> <span class="hljs-comment">grep</span> <span class="hljs-comment">185ab8d</span><span class="hljs-comment">git</span> <span class="hljs-comment">log</span> --<span class="hljs-comment">pretty=oneline</span> --<span class="hljs-comment">branches</span> -- <span class="hljs-comment">spark</span><span class="hljs-literal">-</span><span class="hljs-comment">assembly</span><span class="hljs-literal">-</span><span class="hljs-comment">1</span><span class="hljs-string">.</span><span class="hljs-comment">3</span><span class="hljs-string">.</span><span class="hljs-comment">1</span><span class="hljs-literal">-</span><span class="hljs-comment">hadoop2</span><span class="hljs-string">.</span><span class="hljs-comment">4</span><span class="hljs-string">.</span><span class="hljs-comment">0</span><span class="hljs-string">.</span><span class="hljs-comment">jar</span><span class="hljs-comment">git</span> <span class="hljs-comment">filter</span><span class="hljs-literal">-</span><span class="hljs-comment">branch</span> --<span class="hljs-comment">force</span> --<span class="hljs-comment">index</span><span class="hljs-literal">-</span><span class="hljs-comment">filter</span> <span class="hljs-comment">\</span><span class="hljs-comment">&#x27;git</span> <span class="hljs-comment">rm</span> --<span class="hljs-comment">cached</span> --<span class="hljs-comment">ignore</span><span class="hljs-literal">-</span><span class="hljs-comment">unmatch</span> <span class="hljs-comment">spark</span><span class="hljs-literal">-</span><span class="hljs-comment">assembly</span><span class="hljs-literal">-</span><span class="hljs-comment">1</span><span class="hljs-string">.</span><span class="hljs-comment">3</span><span class="hljs-string">.</span><span class="hljs-comment">1</span><span class="hljs-literal">-</span><span class="hljs-comment">hadoop2</span><span class="hljs-string">.</span><span class="hljs-comment">4</span><span class="hljs-string">.</span><span class="hljs-comment">0</span><span class="hljs-string">.</span><span class="hljs-comment">jar&#x27;</span> <span class="hljs-comment">\</span><span class="hljs-comment"></span>--<span class="hljs-comment">prune</span><span class="hljs-literal">-</span><span class="hljs-comment">empty</span> --<span class="hljs-comment">tag</span><span class="hljs-literal">-</span><span class="hljs-comment">name</span><span class="hljs-literal">-</span><span class="hljs-comment">filter</span> <span class="hljs-comment">cat</span> -- --<span class="hljs-comment">all</span><span class="hljs-comment">git</span> <span class="hljs-comment">for</span><span class="hljs-literal">-</span><span class="hljs-comment">each</span><span class="hljs-literal">-</span><span class="hljs-comment">ref</span> --<span class="hljs-comment">format=&#x27;delete</span> <span class="hljs-comment">%(refname)&#x27;</span> <span class="hljs-comment">refs/original</span> <span class="hljs-comment">|</span> <span class="hljs-comment">git</span> <span class="hljs-comment">update</span><span class="hljs-literal">-</span><span class="hljs-comment">ref</span> --<span class="hljs-comment">stdin</span><span class="hljs-comment">git</span> <span class="hljs-comment">reflog</span> <span class="hljs-comment">expire</span> --<span class="hljs-comment">expire=now</span> --<span class="hljs-comment">all</span><span class="hljs-comment">git</span> <span class="hljs-comment">gc</span> --<span class="hljs-comment">prune=now</span><span class="hljs-comment">git</span> <span class="hljs-comment">count</span><span class="hljs-literal">-</span><span class="hljs-comment">objects</span> <span class="hljs-literal">-</span><span class="hljs-comment">v</span><span class="hljs-comment">git</span> <span class="hljs-comment">push</span> <span class="hljs-comment">origin</span> --<span class="hljs-comment">force</span> --<span class="hljs-comment">all</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux command</title>
    <link href="/2021/06/05/linux-command/"/>
    <url>/2021/06/05/linux-command/</url>
    
    <content type="html"><![CDATA[<h1 id="关机-重启-注销"><a href="#关机-重启-注销" class="headerlink" title="关机/重启/注销"></a>关机/重启/注销</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>shutdown -h now</td><td>即刻关机</td></tr><tr><td>shutdown -h 10</td><td>10分钟后关机</td></tr><tr><td>shutdown -h 11:00</td><td>11：00关机</td></tr><tr><td>shutdown -h +10</td><td>预定时间关机（10分钟后）</td></tr><tr><td>shutdown -c</td><td>取消指定时间关机</td></tr><tr><td>shutdown -r now</td><td>重启</td></tr><tr><td>shutdown -r 10</td><td>10分钟之后重启</td></tr><tr><td>shutdown -r 11:00</td><td>定时重启</td></tr><tr><td>reboot</td><td>重启</td></tr><tr><td>init 6</td><td>重启</td></tr><tr><td>init 0</td><td>⽴刻关机</td></tr><tr><td>telinit 0</td><td>关机</td></tr><tr><td>poweroff</td><td>⽴刻关机</td></tr><tr><td>halt</td><td>关机</td></tr><tr><td>sync</td><td>buff数据同步到磁盘</td></tr><tr><td>logout</td><td>退出登录Shell</td></tr></tbody></table><h1 id="系统信息和性能查看"><a href="#系统信息和性能查看" class="headerlink" title="系统信息和性能查看"></a>系统信息和性能查看</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>uname -a</td><td>查看内核/OS/CPU信息</td></tr><tr><td>uname -r</td><td>查看内核版本</td></tr><tr><td>uname -m</td><td>查看处理器架构</td></tr><tr><td>arch</td><td>查看处理器架构</td></tr><tr><td>hostname</td><td>查看计算机名</td></tr><tr><td>who</td><td>显示当前登录系统的⽤户</td></tr><tr><td>who am i</td><td>显示登录时的⽤户名</td></tr><tr><td>whoami</td><td>显示当前⽤户名</td></tr><tr><td>cat /proc/version</td><td>查看linux版本信息</td></tr><tr><td>cat /proc/cpuinfo</td><td>查看CPU信息</td></tr><tr><td>cat /proc/interrupts</td><td>查看中断</td></tr><tr><td>cat /proc/loadavg</td><td>查看系统负载</td></tr><tr><td>uptime</td><td>查看系统运⾏时间、⽤户数、负载</td></tr><tr><td>env</td><td>查看系统的环境变量</td></tr><tr><td>lsusb -tv</td><td>查看系统USB设备信息</td></tr><tr><td>lspci -tv</td><td>查看系统PCI设备信息</td></tr><tr><td>lsmod</td><td>查看已加载的系统模块</td></tr><tr><td>grep MemTotal /proc/meminfo</td><td>查看内存总量</td></tr><tr><td>grep MemFree /proc/meminfo</td><td>查看空闲内存量</td></tr><tr><td>free -m</td><td>查看内存⽤量和交换区⽤量</td></tr><tr><td>date</td><td>显示系统⽇期时间</td></tr><tr><td>cal 2021</td><td>显示2021⽇历表</td></tr><tr><td>top</td><td>动态显示cpu/内存/进程等情况</td></tr><tr><td>vmstat 1 20</td><td>每1秒采⼀次系统状态，采20次</td></tr><tr><td>iostat</td><td>查看io读写/cpu使⽤情况</td></tr><tr><td>查看io读写/cpu使⽤情况</td><td>查询cpu使⽤情况（1秒⼀次，共10次）</td></tr><tr><td>sar -d 1 10</td><td>查询磁盘性能</td></tr></tbody></table><h1 id="磁盘和分区"><a href="#磁盘和分区" class="headerlink" title="磁盘和分区"></a>磁盘和分区</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>fdisk -l</td><td>查看所有磁盘分区</td></tr><tr><td>swapon -s</td><td>查看所有交换分区</td></tr><tr><td>df -h</td><td>查看磁盘使⽤情况及挂载点</td></tr><tr><td>df -hl</td><td>同上</td></tr><tr><td>du -sh /dir</td><td>查看指定某个⽬录的⼤⼩</td></tr><tr><td>du -sk * | sort -rn</td><td>从⾼到低依次显示⽂件和⽬录⼤⼩</td></tr><tr><td>mount /dev/hda2 /mnt/hda2</td><td>挂载hda2盘</td></tr><tr><td>mount -t ntfs /dev/sdc1 /mnt/usbhd1</td><td>指定⽂件系统类型挂载（如ntfs）</td></tr><tr><td>mount -o loop xxx.iso /mnt/cdrom</td><td>挂 载 iso ⽂ 件</td></tr><tr><td>umount -v /dev/sda1</td><td>通过设备名卸载</td></tr><tr><td>umount -v /mnt/mymnt</td><td>通过挂载点卸载</td></tr><tr><td>fuser -km /mnt/hda1</td><td>强制卸载(慎⽤)</td></tr></tbody></table><h1 id="⽤户和⽤户组"><a href="#⽤户和⽤户组" class="headerlink" title="⽤户和⽤户组"></a>⽤户和⽤户组</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>useradd codesheep</td><td>创建⽤户</td></tr><tr><td>userdel -r codesheep</td><td>删除⽤户</td></tr><tr><td>usermod -g group_name user_name</td><td>修改⽤户的组</td></tr><tr><td>usermod -aG group_name user_name</td><td>将⽤户添加到组</td></tr><tr><td>usermod -s /bin/ksh -d /home/codepig –g dev codesheep</td><td>修改⽤户codesheep的登录Shell、主⽬录以及⽤户组</td></tr><tr><td>groups test</td><td>查看test⽤户所在的组</td></tr><tr><td>groupadd group_name</td><td>创建⽤户组</td></tr><tr><td>groupdel group_name</td><td>删除⽤户组</td></tr><tr><td>groupmod -n new_name old_name</td><td>重命名⽤户组</td></tr><tr><td>su - user_name</td><td>su - user_name</td></tr><tr><td>passwd</td><td>修改⼝令</td></tr><tr><td>passwd codesheep</td><td>修改某⽤户的⼝令</td></tr><tr><td>w</td><td>查看活动⽤户</td></tr><tr><td>id codesheep</td><td>查看指定⽤户codesheep信息</td></tr><tr><td>last</td><td>查看⽤户登录⽇志</td></tr><tr><td>crontab -l</td><td>查看当前⽤户的计划任务</td></tr><tr><td>cut -d: -f1 /etc/passwd</td><td>查看系统所有⽤户</td></tr><tr><td>cut -d: -f1 /etc/group</td><td>查看系统所有组</td></tr></tbody></table><h1 id="⽹络和进程管理"><a href="#⽹络和进程管理" class="headerlink" title="⽹络和进程管理"></a>⽹络和进程管理</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>ifconfig</td><td>查看⽹络接⼝属性</td></tr><tr><td>ifconfig eth0</td><td>查看某⽹卡的配置</td></tr><tr><td>route -n</td><td>查看路由表</td></tr><tr><td>netstat -lntp</td><td>查看所有监听端⼝</td></tr><tr><td>netstat -antp</td><td>查看已经建⽴的TCP连接</td></tr><tr><td>netstat -lutp</td><td>查看TCP/UDP的状态信息</td></tr><tr><td>ifup eth0</td><td>启⽤eth0⽹络设备</td></tr><tr><td>ifdown eth0</td><td>禁⽤eth0⽹络设备</td></tr><tr><td>iptables -L</td><td>查看iptables规则</td></tr><tr><td>ifconfig eth0 192.168.1.1 netmask 255.255.255.0</td><td>配置ip地址</td></tr><tr><td>dhclient eth0</td><td>以dhcp模式启⽤eth0</td></tr><tr><td>route add -net 0/0 gw Gateway_IP</td><td>配置默认⽹关</td></tr><tr><td>route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1</td><td>配置静态路由到达⽹络’192.168.0.0/16’</td></tr><tr><td>route del 0/0 gw Gateway_IP</td><td>删除静态路由</td></tr><tr><td>hostname</td><td>查看主机名</td></tr><tr><td>host <a href="http://www.baidu.com/">www.baidu.com</a></td><td>解析主机名</td></tr><tr><td>nslookup <a href="http://www.baidu.com/">www.baidu.com</a></td><td>查询DNS记录，查看域名解析是否正常</td></tr><tr><td>ps -ef</td><td>查看所有进程</td></tr><tr><td>ps -ef | grep codesheep</td><td>过滤出你需要的进程</td></tr><tr><td>kill -s name</td><td>kill指定名称的进程</td></tr><tr><td>kill -s pid</td><td>kill指定pid的进程</td></tr><tr><td>top</td><td>实时显示进程状态</td></tr><tr><td>vmstat 1 20</td><td>每1秒采⼀次系统状态，采20次</td></tr><tr><td>iostat</td><td>iostat</td></tr><tr><td>sar -u 1 10</td><td>查询cpu使⽤情况（1秒⼀次，共10次）</td></tr><tr><td>sar -d 1 10</td><td>查询磁盘性能</td></tr></tbody></table><h1 id="常⻅系统服务命令"><a href="#常⻅系统服务命令" class="headerlink" title="常⻅系统服务命令"></a>常⻅系统服务命令</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>chkconfig –list</td><td>列出系统服务</td></tr><tr><td>service &lt;服务名&gt; status</td><td>查看某个服务</td></tr><tr><td>service &lt;服务名&gt; start</td><td>启动某个服务</td></tr><tr><td>service &lt;服务名&gt; stop</td><td>终⽌某个服务</td></tr><tr><td>service &lt;服务名&gt; restart</td><td>重启某个服务</td></tr><tr><td>systemctl status &lt;服务名&gt;</td><td>查看某个服务</td></tr><tr><td>systemctl start &lt;服务名&gt;</td><td>启动某个服务</td></tr><tr><td>systemctl stop &lt;服务名&gt;</td><td>终⽌某个服务</td></tr><tr><td>systemctl restart &lt;服务名&gt;</td><td>重启某个服务</td></tr><tr><td>systemctl enable &lt;服务名&gt;</td><td>关闭⾃启动</td></tr><tr><td>systemctl disable &lt;服务名&gt;</td><td>关闭⾃启动</td></tr></tbody></table><h1 id="⽂件和⽬录操作"><a href="#⽂件和⽬录操作" class="headerlink" title="⽂件和⽬录操作"></a>⽂件和⽬录操作</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>cd &lt;⽬录名&gt;</td><td>进⼊某个⽬录</td></tr><tr><td>cd ..</td><td>回上级⽬录</td></tr><tr><td>cd ../..</td><td>回上两级⽬录</td></tr><tr><td>cd</td><td>进个⼈主⽬录</td></tr><tr><td>cd -</td><td>回上⼀步所在⽬录</td></tr><tr><td>pwd</td><td>显示当前路径</td></tr><tr><td>ls</td><td>查看⽂件⽬录列表</td></tr><tr><td>ls -F</td><td>查看⽬录中内容（显示是⽂件还是⽬录）</td></tr><tr><td>ls -l</td><td>查看⽂件和⽬录的详情列表</td></tr><tr><td>ls -a</td><td>查看隐藏⽂件</td></tr><tr><td>ls -lh</td><td>查看⽂件和⽬录的详情列表（增强⽂件⼤⼩易读性）</td></tr><tr><td>ls -lSr</td><td>查看⽂件和⽬录列表（以⽂件⼤⼩升序查看）</td></tr><tr><td>tree</td><td>查看⽂件和⽬录的树形结构</td></tr><tr><td>mkdir &lt;⽬录名&gt;</td><td>创建⽬录</td></tr><tr><td>mkdir dir1 dir2</td><td>同时创建两个⽬录</td></tr><tr><td>mkdir -p /tmp/dir1/dir2</td><td>创建⽬录树</td></tr><tr><td>rm -f file1</td><td>删除’file1’⽂件</td></tr><tr><td>rmdir dir1</td><td>删除’dir1’⽬录</td></tr><tr><td>rm -rf dir1</td><td>删除’dir1’⽬录和其内容</td></tr><tr><td>rm -rf dir1 dir2</td><td>同时删除两个⽬录及其内容</td></tr><tr><td>mv old_dir new_dir</td><td>重命名/移动⽬录</td></tr><tr><td>cp file1 file2</td><td>复制⽂件</td></tr><tr><td>cp dir/* .</td><td>复制某⽬录下的所有⽂件⾄当前⽬录</td></tr><tr><td>cp -a dir1 dir2</td><td>复制⽬录</td></tr><tr><td>cp -a /tmp/dir1 .</td><td>复制⼀个⽬录⾄当前⽬录</td></tr><tr><td>ln -s file1 link1</td><td>创建指向⽂件/⽬录的软链接</td></tr><tr><td>ln file1 lnk1</td><td>创建指向⽂件/⽬录的物理链接</td></tr><tr><td>find / -name file1</td><td>从跟⽬录开始搜索⽂件/⽬录</td></tr><tr><td>find / -user user1</td><td>搜索⽤户user1的⽂件/⽬录</td></tr><tr><td>find /dir -name *.bin</td><td>在⽬录/dir中搜带有.bin后缀的⽂件</td></tr><tr><td>locate &lt;关键词&gt;</td><td>快速定位⽂件</td></tr><tr><td>locate *.mp4</td><td>寻找.mp4结尾的⽂件</td></tr><tr><td>whereis &lt;关键词&gt;</td><td>显示某⼆进制⽂件/可执⾏⽂件的路径</td></tr><tr><td>which &lt;关键词&gt;</td><td>查找系统⽬录下某的⼆进制⽂件</td></tr><tr><td>chmod ugo+rwx dir1</td><td>设置⽬录所有者(u)、群组(g)及其他⼈(o)的读（r）写(w)执⾏(x)权限</td></tr><tr><td>chmod go-rwx dir1</td><td>移除群组(g)与其他⼈(o)对⽬录的读写执⾏权限</td></tr><tr><td>chown user1 file1</td><td>改变⽂件的所有者属性</td></tr><tr><td>chown -R user1 dir1</td><td>改变⽬录的所有者属性</td></tr><tr><td>chgrp group1 file1</td><td>改变⽂件群组</td></tr><tr><td>chown user1:group1 file1</td><td>改变⽂件的所有⼈和群组</td></tr></tbody></table><h1 id="⽂件查看和处理"><a href="#⽂件查看和处理" class="headerlink" title="⽂件查看和处理"></a>⽂件查看和处理</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>cat file1</td><td>查看⽂件内容</td></tr><tr><td>cat -n file1</td><td>查看内容并标示⾏数</td></tr><tr><td>tac file1</td><td>从最后⼀⾏开始反看⽂件内容</td></tr><tr><td>more file1</td><td>more file1</td></tr><tr><td>less file1</td><td>类似more命令，但允许反向操作</td></tr><tr><td>head -2 file1</td><td>查看⽂件前两⾏</td></tr><tr><td>tail -2 file1</td><td>查看⽂件后两⾏</td></tr><tr><td>tail -f /log/msg</td><td>实时查看添加到⽂件中的内容</td></tr><tr><td>grep codesheep hello.txt</td><td>在⽂件hello.txt中查找关键词codesheep</td></tr><tr><td>grep ^sheep hello.txt</td><td>在⽂件hello.txt中查找以sheep开头的内容</td></tr><tr><td>grep [0-9] hello.txt</td><td>选择hello.txt⽂件中所有包含数字的⾏</td></tr><tr><td>sed ‘s/s1/s2/g’ hello.txt</td><td>将hello.txt⽂件中的s1替换成s2</td></tr><tr><td>sed ‘/^$/d’ hello.txt</td><td>从hello.txt⽂件中删除所有空⽩⾏</td></tr><tr><td>sed ‘/ *#/d; /^$/d’ hello.txt</td><td>从hello.txt⽂件中删除所有注释和空⽩⾏</td></tr><tr><td>sed -e ‘1d’ hello.txt</td><td>从⽂件hello.txt 中排除第⼀⾏</td></tr><tr><td>sed -n ‘/s1/p’ hello.txt</td><td>查看只包含关键词”s1”的⾏</td></tr><tr><td>sed -e ‘s/ *$//‘ hello.txt</td><td>删除每⼀⾏最后的空⽩字符</td></tr><tr><td>sed -e ‘s/s1//g’ hello.txt</td><td>从⽂档中只删除词汇s1并保留剩余全部</td></tr><tr><td>sed -n ‘1,5p;5q’ hello.txt</td><td>查看从第⼀⾏到第5⾏内容</td></tr><tr><td>sed -n ‘5p;5q’ hello.txt</td><td>查看第5⾏</td></tr><tr><td>paste file1 file2</td><td>合并两个⽂件或两栏的内容</td></tr><tr><td>paste -d ‘+’ file1 file2</td><td>合并两个⽂件或两栏的内容，中间⽤”+”区分</td></tr><tr><td>sort file1 file2</td><td>排序两个⽂件的内容</td></tr><tr><td>comm -1 file1 file2</td><td>⽐较两个⽂件的内容(去除’file1’所含内容)</td></tr><tr><td>comm -2 file1 file2</td><td>⽐较两个⽂件的内容(去除’file2’所含内容</td></tr><tr><td>comm -3 file1 file2</td><td>⽐较两个⽂件的内容(去除两⽂件共有部分)</td></tr></tbody></table><h1 id="打包和解压"><a href="#打包和解压" class="headerlink" title="打包和解压"></a>打包和解压</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>zip xxx.zip file</td><td>压缩⾄zip包</td></tr><tr><td>zip -r xxx.zip file1 file2 dir1</td><td>将多个⽂件+⽬录压成zip包</td></tr><tr><td>unzip xxx.zip</td><td>解压zip包</td></tr><tr><td>tar -cvf xxx.tar file</td><td>创建⾮压缩tar包</td></tr><tr><td>tar -cvf xxx.tar file1 file2 dir1</td><td>将多个⽂件+⽬录打tar包</td></tr><tr><td>tar -tf xxx.tar</td><td>查看tar包的内容</td></tr><tr><td>tar -xvf xxx.tar</td><td>解压tar包</td></tr><tr><td>tar -xvf xxx.tar -C /dir</td><td>将tar包解压⾄指定⽬录</td></tr><tr><td>tar -cvfj xxx.tar.bz2 dir</td><td>创建bz2压缩包</td></tr><tr><td>tar -jxvf xxx.tar.bz2</td><td>解压bz2压缩包</td></tr><tr><td>tar -cvfz xxx.tar.gz dir</td><td>创建gzip压缩包</td></tr><tr><td>tar -zxvf xxx.tar.gz</td><td>解压gzip压缩包</td></tr><tr><td>bunzip2 xxx.bz2</td><td>解压bz2压缩包</td></tr><tr><td>bzip2 filename</td><td>压缩⽂件</td></tr><tr><td>gunzip xxx.gz</td><td>解压gzip压缩包</td></tr><tr><td>gzip filename</td><td>压缩⽂件</td></tr><tr><td>gzip -9 filename</td><td>最⼤程度压缩</td></tr></tbody></table><h1 id="RPM包管理命令"><a href="#RPM包管理命令" class="headerlink" title="RPM包管理命令"></a>RPM包管理命令</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>rpm -qa</td><td>查看已安装的rpm包</td></tr><tr><td>rpm -q pkg_name</td><td>查询某个rpm包</td></tr><tr><td>rpm -q –whatprovides xxx</td><td>显示xxx功能是由哪个包提供的</td></tr><tr><td>rpm -q –whatrequires xxx</td><td>显示xxx功能被哪个程序包依赖的</td></tr><tr><td>rpm -q –changelog xxx</td><td>显示xxx包的更改记录</td></tr><tr><td>rpm -qi pkg_name</td><td>查看⼀个包的详细信息</td></tr><tr><td>rpm -qd pkg_name</td><td>查询⼀个包所提供的⽂档</td></tr><tr><td>rpm -qc pkg_name</td><td>查看已安装rpm包提供的配置⽂件</td></tr><tr><td>rpm -ql pkg_name</td><td>查看⼀个包安装了哪些⽂件</td></tr><tr><td>rpm -qf filename</td><td>查看某个⽂件属于哪个包</td></tr><tr><td>rpm -qR pkg_name</td><td>查询包的依赖关系</td></tr><tr><td>rpm -ivh xxx.rpm</td><td>安装rpm包</td></tr><tr><td>rpm -ivh –test xxx.rpm</td><td>测试安装rpm包</td></tr><tr><td>rpm -ivh –nodeps xxx.rpm</td><td>安装rpm包时忽略依赖关系</td></tr><tr><td>rpm -e xxx</td><td>卸载程序包</td></tr><tr><td>rpm -Fvh pkg_name</td><td>升级确定已安装的rpm包</td></tr><tr><td>rpm -Uvh pkg_name</td><td>升级rpm包(若未安装则会安装)</td></tr><tr><td>rpm -V pkg_name</td><td>RPM包详细信息校验</td></tr></tbody></table><h1 id="YUM包管理命令"><a href="#YUM包管理命令" class="headerlink" title="YUM包管理命令"></a>YUM包管理命令</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>yum repolist enabled</td><td>显示可⽤的源仓库</td></tr><tr><td>yum search pkg_name</td><td>搜索软件包</td></tr><tr><td>yum install pkg_name</td><td>下载并安装软件包</td></tr><tr><td>yum install –downloadonly pkg_name</td><td>只 下 载 不 安 装</td></tr><tr><td>yum list</td><td>显示所有程序包</td></tr><tr><td>yum list installed</td><td>查看当前系统已安装包</td></tr><tr><td>yum list updates</td><td>查看可以更新的包列表</td></tr><tr><td>yum check-update</td><td>查看可升级的软件包</td></tr><tr><td>yum update</td><td>更新所有软件包</td></tr><tr><td>yum update pkg_name</td><td>升级指定软件包</td></tr><tr><td>yum deplist pkg_name</td><td>列出软件包依赖关系</td></tr><tr><td>yum remove pkg_name</td><td>删除软件包</td></tr><tr><td>yum clean all</td><td>清除缓存</td></tr><tr><td>yum clean packages</td><td>清除缓存的软件包</td></tr><tr><td>yum clean headers</td><td>清除缓存的header</td></tr></tbody></table><h1 id="DPKG包管理命令"><a href="#DPKG包管理命令" class="headerlink" title="DPKG包管理命令"></a>DPKG包管理命令</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>dpkg -c xxx.deb</td><td>列出deb包的内容</td></tr><tr><td>dpkg -i xxx.deb</td><td>安装/更新deb包</td></tr><tr><td>dpkg -r pkg_name</td><td>移除deb包</td></tr><tr><td>dpkg -P pkg_name</td><td>移除deb包(不保留配置)</td></tr><tr><td>dpkg -l</td><td>查看系统中已安装deb包</td></tr><tr><td>dpkg -l pkg_name</td><td>显示包的⼤致信息</td></tr><tr><td>dpkg -L pkg_name</td><td>查看deb包安装的⽂件</td></tr><tr><td>dpkg -s pkg_name</td><td>查看包的详细信息</td></tr><tr><td>dpkg –unpack xxx.deb</td><td>解开deb包的内容</td></tr></tbody></table><h1 id="APT软件⼯具"><a href="#APT软件⼯具" class="headerlink" title="APT软件⼯具"></a>APT软件⼯具</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>apt-cache search pkg_name</td><td>搜索程序包</td></tr><tr><td>apt-cache show pkg_name</td><td>获取包的概览信息</td></tr><tr><td>apt-get install pkg_name</td><td>安装/升级软件包</td></tr><tr><td>apt-get purge pkg_name</td><td>卸载软件（包括配置）</td></tr><tr><td>apt-get remove pkg_name</td><td>卸载软件（不包括配置）</td></tr><tr><td>apt-get update</td><td>更新包索引信息</td></tr><tr><td>apt-get upgrade</td><td>更新已安装软件包</td></tr><tr><td>apt-get clean</td><td>清理缓存</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>system</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jvm_tuning</title>
    <link href="/2021/05/26/jvm-tuning/"/>
    <url>/2021/05/26/jvm-tuning/</url>
    
    <content type="html"><![CDATA[<h1 id="如何合理的规划一次jvm性能调优"><a href="#如何合理的规划一次jvm性能调优" class="headerlink" title="如何合理的规划一次jvm性能调优"></a>如何合理的规划一次jvm性能调优</h1><p>JVM性能调优涉及到方方面面的取舍，往往是牵一发而动全身，需要全盘考虑各方面的影响。但也有一些基础的理论和原则，理解这些理论并遵循这些原则会让你的性能调优任务将会更加轻松。为了更好的理解本篇所介绍的内容。你需要已经了解和遵循以下内容:</p><blockquote><p>1、已了解jvm 垃圾收集器</p><p>2、已了解jvm 性能监控常用工具</p><p>3、能够读懂gc日志</p><p>4、确信不为了调优而调优，jvm调优不能解决一切性能问题</p></blockquote><p>这些内容在之前的两篇文章已经介绍过了，如果有不了解的可以去点击上述连接进行回顾，如果对这些不了解不建议读本篇文章。</p><p>本篇文章基于jvm性能调优，结合jvm的各项参数对应用程序调优，主要内容有以下几个方面：</p><blockquote><p>1、jvm调优的一般流程</p><p>2、jvm调优所要关注的几个性能指标</p><p>3、jvm调优需要掌握的一些原则</p><p>4、调优策略&amp;示例</p></blockquote><h1 id="一、性能调优的层次"><a href="#一、性能调优的层次" class="headerlink" title="一、性能调优的层次"></a><strong>一、性能调优的层次</strong></h1><p>为了提升系统性能，我们需要对系统的各个角度和层次来进行优化，以下是需要优化的几个层次。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqw0ggfzvhj30n90dttad.jpg" alt="140720_0Ey6_1859679"></p><p>从上面我们可以看到，除了jvm调优以外，还有其他几个层面需要来处理，所以针对系统的调优不是只有jvm调优一项，而是需要针对系统来整体调优，才能提升系统的性能。本篇只针对jvm调优来讲解，其他几个方面，后续再介绍。</p><p>在进行jvm调优之前，我们假设项目的架构调优和代码调优已经进行过或者是针对当前项目是最优的。这两个是jvm调优的基础，并且架构调优是对系统影响最大的 ，我们不能指望一个系统架构有缺陷或者代码层次优化没有穷尽的应用，通过jvm调优令其达到一个质的飞跃，这是不可能的。</p><p>另外，在调优之前，必须得有明确的性能优化目标， 然后找到其性能瓶颈。之后针对瓶颈的优化，还需要对应用进行压力和基准测试，通过各种监控和统计工具，确认调优后的应用是否已经达到相关目标。</p><h1 id="二、jvm调优流程"><a href="#二、jvm调优流程" class="headerlink" title="二、jvm调优流程"></a><strong>二、jvm调优流程</strong></h1><p>调优的最终目的都是为了令应用程序使用最小的硬件消耗来承载更大的吞吐。jvm的调优也不例外，jvm调优主要是针对垃圾收集器的收集性能优化，令运行在虚拟机上的应用能够使用更少的内存以及延迟获取更大的吞吐量。当然这里的最少是最优的选择，而不是越少越好。</p><h2 id="1、性能定义"><a href="#1、性能定义" class="headerlink" title="1、性能定义"></a><strong>1、性能定义</strong></h2><p>要查找和评估器性能瓶颈，首先要知道性能定义，对于jvm调优来说，我们需要知道以下三个定义属性，依作为评估基础:</p><blockquote><ul><li>吞吐量：重要指标之一，是指不考虑垃圾收集引起的停顿时间或内存消耗，垃圾收集器能支撑应用达到的最高性能指标。</li><li>延迟：其度量标准是缩短由于垃圾啊收集引起的停顿时间或者完全消除因垃圾收集所引起的停顿，避免应用运行时发生抖动。</li><li>内存占用：垃圾收集器流畅运行所需要 的内存数量。</li></ul></blockquote><p>这三个属性中，其中一个任何一个属性性能的提高，几乎都是以另外一个或者两个属性性能的损失作代价，不可兼得，具体某一个属性或者两个属性的性能对应用来说比较重要，要基于应用的业务需求来确定。</p><h2 id="2、性能调优原则"><a href="#2、性能调优原则" class="headerlink" title="2、性能调优原则"></a><strong>2、性能调优原则</strong></h2><p>在调优过程中，我们应该谨记以下3个原则，以便帮助我们更轻松的完成垃圾收集的调优，从而达到应用程序的性能要求。</p><blockquote><p>\1. MinorGC回收原则： 每次minor GC 都要尽可能多的收集垃圾对象。以减少应用程序发生Full GC的频率。</p><p>\2. GC内存最大化原则：处理吞吐量和延迟问题时候，垃圾处理器能使用的内存越大，垃圾收集的效果越好，应用程序也会越来越流畅。</p><p>\3. GC调优3选2原则: 在性能属性里面，吞吐量、延迟、内存占用，我们只能选择其中两个进行调优，不可三者兼得。</p></blockquote><h2 id="3、性能调优流程"><a href="#3、性能调优流程" class="headerlink" title="3、性能调优流程"></a><strong>3、性能调优流程</strong></h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqw0gmes2jj30cm0powh1.jpg" alt="140848_xf95_1859679"></p><p>以上就是对应用程序进行jvm调优的基本流程，我们可以看到，jvm调优是根据性能测试结果不断优化配置而多次迭代的过程。在达到每一个系统需求指标之前，之前的每个步骤都有可能经历多次迭代。有时候为了达到某一方面的指标，有可能需要对之前的参数进行多次调整，进而需要把之前的所有步骤重新测试一遍。</p><p>另外调优一般是从满足程序的内存使用需求开始的，之后是时间延迟的要求，最后才是吞吐量的要求，要基于这个步骤来不断优化，每一个步骤都是进行下一步的基础，不可逆行之。以下我们针对每个步骤进行详细的示例讲解。</p><p>在JVM的运行模式方面，我们直接选择server模式，这也是jdk1.6以后官方推荐的模式。</p><p>在垃圾收集器方面，我们直接采用了jdk1.6-1.8 中默认的parallel收集器（新生代采用parallelGC,老生代采用parallelOldGC）。</p><h1 id="三、确定内存占用"><a href="#三、确定内存占用" class="headerlink" title="三、确定内存占用"></a><strong>三、确定内存占用</strong></h1><p>在确定内存占用之前，我们需要知道两个知识点：</p><blockquote><ol><li>应用程序的运行阶段</li><li>jvm内存分配</li></ol></blockquote><h2 id="1、运行阶段"><a href="#1、运行阶段" class="headerlink" title="1、运行阶段"></a><strong>1、运行阶段</strong></h2><p>应用程序的运行阶段，我可以划分为以下三个阶段:</p><blockquote><p>1、初始化阶段 : jvm加载应用程序，初始化应用程序的主要模块和数据。</p><p>2、稳定阶段:应用在此时运行了大多数时间，经历过压力测试的之后，各项性能参数呈稳定状态。核心函数被执行，已经被jit编译预热过。</p><p>3、总结阶段:最后的总结阶段，进行一些基准测试，生成响应的策报告。这个阶段我们可以不关注。</p></blockquote><p>确定内存占用以及活跃数据的大小，我们应该是在程序的稳定阶段来进行确定，而不是在项目起初阶段来进行确定，如何确定，我们先看以下jvm的内存分配。</p><h2 id="2、jvm内存分配-amp-参数"><a href="#2、jvm内存分配-amp-参数" class="headerlink" title="2、jvm内存分配&amp;参数"></a><strong>2、jvm内存分配&amp;参数</strong></h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqw0grnwrrj30ae02bjrg.jpg" alt="141029_qI9i_1859679"></p><p>jvm堆中主要的空间，就是以上新生代、老生代、永久代组成,整个堆大小=新生代大小 + 老生代大小 + 永久代大小。 具体的对象提升方式，这里不再过多介绍了，我们看下一些jvm命令参数，对堆大小的指定。如果不采用以下参数进行指定的话，虚拟机会自动选择合适的值，同时也会基于系统的开销自动调整。</p><table><thead><tr><th>分代</th><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>堆大小</td><td>-Xms</td><td>初始堆大小，默认为物理内存的1/64(&lt;1GB)</td></tr><tr><td></td><td>-Xmx</td><td>最大堆大小，默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</td></tr><tr><td>新生代</td><td>-XX:NewSize</td><td>新生代空间大小初始值</td></tr><tr><td></td><td>-XX:MaxNewSize</td><td>新生代空间大小最大值</td></tr><tr><td></td><td>-Xmn</td><td>新生代空间大小，此处的大小是(eden+2 survivor space)</td></tr><tr><td>永久代</td><td>-XX:PermSize</td><td>永久代空间的初始值&amp;最小值</td></tr><tr><td></td><td>-XX：MaxPermSize</td><td>永久代空间的最大值</td></tr><tr><td>老年代</td><td>老年代的空间大小会根据新生代的大小隐式设定</td><td></td></tr><tr><td></td><td>初始值=-Xmx减去-XX:NewSize的值</td><td></td></tr><tr><td></td><td>最小值=-Xmx值减去-XX:MaxNewSize的值</td><td></td></tr></tbody></table><p>在设置的时候，如果关注性能开销的话，应尽量把永久代的初始值与最大值设置为同一值，因为永久代的大小调整需要进行FullGC 才能实现。</p><h2 id="3、计算活跃数据大小"><a href="#3、计算活跃数据大小" class="headerlink" title="3、计算活跃数据大小"></a><strong>3、计算活跃数据大小</strong></h2><p>计算活跃数据大小应该遵循以下流程:</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqw0gvxnd9j30do0dhwfb.jpg" alt="141106_QwVB_1859679"></p><p>如前所述，活跃数据应该是基于应用程序稳定阶段时，观察长期存活与对象在java堆中占用的空间大小。</p><p>计算活跃数据时应该确保以下条件发生：</p><blockquote><p>1.测试时，启动参数采用jvm默认参数，不人为设置。</p><p>2.确保Full GC 发生时，应用程序正处于稳定阶段。</p></blockquote><p>采用jvm默认参数启动，是为了观察应用程序在稳定阶段的所需要的内存使用。</p><p><strong>如何才算稳定阶段？</strong></p><p>一定得需要产生足够的压力，找到应用程序和生产环境高峰符合状态类似的负荷，在此之后达到峰值之后，保持一个稳定的状态，才算是一个稳定阶段。所以要达到稳定阶段，压力测试是必不可少的，具体如何如何对应用压力测试，本篇不过多说明,后期会有专门介绍的篇幅。</p><p>在确定了应用出于稳定阶段的时候，要注意观察应用的GC日志，特别是Full GC 日志。</p><blockquote><p>GC日志指令: -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Xloggc:<filename></p><p>GC日志是收集调优所需信息的最好途径，即便是在生产环境，也可以开启GC日志来定位问题，开启GC日志对性能的影响极小，却可以提供丰富数据。</p></blockquote><p>必须得有FullGC 日志，如果没有的话，可以采用监控工具强制调用一次，或者采用以下命令，亦可以触发</p><blockquote><p>jmap -histo:live pid </p></blockquote><p>在稳定阶段触发了FullGC我们一般会拿到如下信息:</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqw0gymyuxj30g3090jth.jpg" alt="141203_akPQ_1859679"></p><p>从以上gc日志中，我们大概可以分析到，在发生fullGC之时，整个应用的堆占用以及GC时间，当然了，为了更加精确，应该多收集几次，获取一个平均值。或者是采用耗时最长的一次FullGC来进行估算。</p><p>在上图中，fullGC之后，老年代空间占用在93168kb（约93MB），我们以此定为老年代空间的活跃数据。</p><p><strong>其他堆空间的分配，基于以下规则来进行</strong>。</p><table><thead><tr><th>空间</th><th>命令参数</th><th>建议扩大倍数</th></tr></thead><tbody><tr><td>java heap</td><td>-Xms和-Xmx</td><td>3-4倍FullGC后的老年代空间占用</td></tr><tr><td>永久代</td><td>-XX:PermSize-XX:MaxPermSize</td><td>1.2-1.5倍FullGc后的永久带空间占用</td></tr><tr><td>新生代</td><td>-Xmn</td><td>1-1.5倍FullGC之后的老年代空间占用</td></tr><tr><td>老年代</td><td></td><td>2-3倍FullGC后的老年代空间占用</td></tr></tbody></table><p>基于以上规则和上图中的FullGC信息，我们现在可以规划的该应用堆空间为：</p><blockquote><p>java 堆空间: 373Mb (=老年代空间93168kb*4)</p><p>新生代空间:140Mb(=老年代空间93168kb*1.5)</p><p>永久代空间:5Mb(=永久代空间3135kb*1.5)</p><p>老年代空间: 233Mb=堆空间-新生代看空间=373Mb-140Mb</p></blockquote><p>对应的应用启动参数应该为:</p><div class="hljs code-wrapper"><pre><code class="hljs bash">java -Xms373m -Xmx373m -Xmn140m -XX:PermSize=5m -XX:MaxPermSize=5m</code></pre></div><h1 id="四、延迟调优"><a href="#四、延迟调优" class="headerlink" title="四、延迟调优"></a><strong>四、延迟调优</strong></h1><p>在确定了应用程序的活跃数据大小之后，我们需要再进行延迟性调优，因为对于此时堆内存大小，延迟性需求无法达到应用的需要，需要基于应用的情况来进行调试。</p><p>在这一步进行期间，我们可能会再次优化堆大小的配置，评估GC的持续时间和频率、以及是否需要切换到不同的垃圾收集器上。</p><h2 id="1、系统延迟需求"><a href="#1、系统延迟需求" class="headerlink" title="1、系统延迟需求"></a><strong>1、系统延迟需求</strong></h2><p>在调优之前，我们需要知道系统的延迟需求是那些，以及对应的延迟可调优指标是那些。</p><blockquote><ul><li>应用程序可接受的平均停滞时间: 此时间与测量的Minor GC持续时间进行比较。</li><li>可接受的Minor GC频率：Minor GC的频率与可容忍的值进行比较。</li><li>可接受的最大停顿时间: 最大停顿时间与最差情况下FullGC的持续时间进行比较。</li><li>可接受的最大停顿发生的频率：基本就是FullGC的频率。</li></ul></blockquote><p>以上中，平均停滞时间和最大停顿时间，对用户体验最为重要，可以多关注。</p><p>基于以上的要求，我们需要统计以下数据:</p><blockquote><ul><li>MinorGC的持续时间；</li><li>统计MinorGC的次数；</li><li>FullGC的最差持续时间；</li><li>最差情况下，FullGC的频率；</li></ul></blockquote><h2 id="2、优化新生代的大小"><a href="#2、优化新生代的大小" class="headerlink" title="2、优化新生代的大小"></a><strong>2、优化新生代的大小</strong></h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqw0h3taanj30hv08wjvg.jpg" alt="141420_DIoU_1859679"></p><p>比如如上的gc日志中，我们可以看到Minor GC的平均持续时间=0.069秒，MinorGC 的频率为0.389秒一次。</p><blockquote><p>如果，我们系统的设置的平均停滞时间为50ms，当前的69ms明显是太长了，就需要调整。</p><p>我们知道新生代空间越大，Minor GC的GC时间越长，频率越低。</p><p>如果想减少其持续时长，就需要减少其空间大小。</p><p>如果想减小其频率，就需要加大其空间大小。 </p></blockquote><p>为了降低改变新生代的大小对其他区域的最小影响。<strong>在改变新生代空间大小的时候，尽量保持老年代空间的大小。</strong></p><p>比如此次减少了新生代空间10%的大小，应该保持老年代和持代的大小不变化，第一步调优后的参数如下变化:</p><div class="hljs code-wrapper"><pre><code class="hljs bash">java -Xms359m -Xmx359m -Xmn126m -XX:PermSize=5m -XX:MaxPermSize=5m新生代的大小有140m变为126，堆大小顺应变化，此时老年代是没有变化的。</code></pre></div><h2 id="3、优化老年代的大小"><a href="#3、优化老年代的大小" class="headerlink" title="3、优化老年代的大小"></a><strong>3、优化老年代的大小</strong></h2><p>同上一步一样，在优化之前，也需要采集gc日志的数据。此次我们关注的是FullGC的持续时间和频率。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqw0h7an91j30i207nn0w.jpg" alt="141538_oPj2_1859679"></p><p>上图中，我们可以看到</p><div class="hljs code-wrapper"><pre><code class="hljs bash">FullGC 平均频率 =5.8sFullGC 平均持续时间=0.14s(以上为了测试，真实项目的fullGC 没有这么快)</code></pre></div><p><strong>如果没有FullGC的日志，有办法可以评估么？</strong></p><blockquote><p>我们可以通过对象提升率进行计算。</p></blockquote><h2 id="对象提升率"><a href="#对象提升率" class="headerlink" title="对象提升率"></a><strong>对象提升率</strong></h2><p>比如上述中启动参数中，我们的老年代大小=233Mb。</p><p>那么需要多久才能填满老年代中这233Mb的空闲空间取决于新生代到老年代的提升率。</p><blockquote><p>每次提升老年代占用量=每次MinorGC 之后 java堆占用情况 减去 MinorGC后新生代的空间占用</p><p>对象提升率=平均值（每次提升老年代占用量) 除以 老年代空间</p></blockquote><p>有了对象提升率，我们就可以算出填充满老年代空间需要多少次minorGC，大概一次fullGC的时间就可以计算出来了。</p><p>比如:</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqw0ha84akj30i008ujvi.jpg" alt="141659_dfML_1859679"></p><p>上图中:</p><div class="hljs code-wrapper"><pre><code class="hljs tex">第一次minor GC 之后，老年代空间:13740kb - 13732kb =8kb第二次minor GC 之后，老年代空间:22394kb - 17905kb =4489kb第三次minor GC 之后，老年代空间:34739kb - 17917kb =16822kb第四次minor GC 之后，老年代空间:48143kb - 17913kb =30230kb第五次minor GC 之后，老年代空间:62112kb - 17917kb =44195kb</code></pre></div><p>老年代每次minorGC提升率</p><div class="hljs code-wrapper"><pre><code class="hljs bash">4481kb 第二次和第一次minorGC之间12333kb 第3次和第2次minorGC之间13408kb 第4次和第3次minorGC之间13965kb 第5次和第4次minorGC之间</code></pre></div><p>我们可以测算出：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">每次minorGC 的平均提升为12211kb,约为12Mb上图中，平均minorGC的频率为 213ms/次提升率=12211kb/213ms=57kb/ms老年代空间233Mb ,占满大概需要233*1024/57=4185ms 约为4.185s。</code></pre></div><p>FullGC的预期最差频率时长可以通过以上两种方式估算出来，可以调整老年代的大小来调整FullGC的频率，当然了，如果FullGC持续时间过长，无法达到应用程序的最差延迟要求，就需要切换垃圾处理器了。具体如何切换，下篇再讲，比如切换为CMS，针对CMS的调优方式又有会细微的差别。</p><h1 id="五、吞吐量调优"><a href="#五、吞吐量调优" class="headerlink" title="五、吞吐量调优"></a><strong>五、吞吐量调优</strong></h1><p>经过上述漫长 调优过程，最终来到了调优的最后一步，这一步对上述的结果进行吞吐量测试，并进行微调。</p><p>吞吐量调优主要是基于应用程序的吞吐量要求而来的，应用程序应该有一个综合的吞吐指标，这个指标基于真个应用的需求和测试而衍生出来的。当有应用程序的吞吐量达到或者超过预期的吞吐目标，整个调优过程就可以圆满结束了。</p><p>如果出现调优后依然无法达到应用程序的吞吐目标，需要重新回顾吞吐要求，评估当前吞吐量和目标差距是否巨大，如果在20%左右，可以修改参数，加大内存，再次从头调试，如果巨大就需要从整个应用层面来考虑，设计以及目标是否一致了，重新评估吞吐目标。</p><p>对于垃圾收集器来说，提升吞吐量的性能调优的目标就是就是尽可能避免或者很少发生FullGC 或者Stop-The-World压缩式垃圾收集（CMS），因为这两种方式都会造成应用程序吞吐降低。尽量在MinorGC 阶段回收更多的对象，避免对象提升过快到老年代。</p><p> <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqw0hdn9xqj30go0a1abj.jpg" alt="141902_KuqW_1859679"></p><h1 id="六、最后"><a href="#六、最后" class="headerlink" title="六、最后"></a><strong>六、最后</strong></h1><p>据Plumbr公司对特定垃圾收集器使用情况进行了一次调查研究，研究数据使用了84936个案例。在明确指定垃圾收集器的13%的案例中，并发收集器（CMS）使用次数最多；但大多数案例没有选择最佳垃圾收集器。这个比例占用在87%左右。</p><p><code>JVM调优是一个系统而又复杂的工作，目前jvm下的自动调整已经做的比较优秀，基本的一些初始参数都可以保证一般的应用跑的比较稳定了，对部分团队来说，程序性能可能优先级不高，默认垃圾收集器已经够用了。调优要基于自己的情况而来。</code></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>http content</title>
    <link href="/2021/05/26/basic-http-content/"/>
    <url>/2021/05/26/basic-http-content/</url>
    
    <content type="html"><![CDATA[<h1 id="访问-www-taobao-com过程"><a href="#访问-www-taobao-com过程" class="headerlink" title="访问 www.taobao.com过程"></a>访问 <a href="http://www.taobao.com过程/">www.taobao.com过程</a></h1><p>首先是查找浏览器缓存，浏览器会保存一段时间你之前访问过的一些网址的DNS信息，不同浏览器保存的时常不等。</p><p>如果没有找到对应的记录，这个时候浏览器会尝试调用系统缓存来继续查找这个网址的对应DNS信息。</p><p>如果还是没找到对应的IP，那么接着会发送一个请求到路由器上，然后路由器在自己的路由器缓存上查找记录，路由器一般也存有DNS信息。</p><p>如果还是没有，这个请求就会被发送到ISP（注：Internet Service Provider，互联网服务提供商，就是那些拉网线到你家里的运营商，中国电信中国移动什么的），ISP也会有相应的ISP DNS服务器，一听中国电信就知道这个DNS服务器的规模肯定不会小，所以基本上都能在这里找得到。题外话：会跑到这里进行查询是因为你没有改动过”网络中心”的”ipv4”的DNS地址，万恶的电信联通可以改动了这个DNS服务器，换句话说他们可以让你的浏览器跳转到他们设定的页面上，这也就是人尽皆知的DNS和HTTP劫持，ISP们还美名曰“免费推送服务”。强烈鄙视这种霸王行为。我们也可以自行修改DNS服务器来防止DNS被ISP污染。</p><p>如果还是没有的话， 你的ISP的DNS服务器会将请求发向根域名服务器进行搜索。根域名服务器就是面向全球的顶级DNS服务器，共有13台逻辑上的服务器，从A到M命名，真正的实体服务器则有几百台，分布于全球各大洲。所以这些服务器有真正完整的DNS数据库。如果到了这里还是找不到域名的对应信息，那只能说明一个问题：这个域名本来就不存在，它没有在网上正式注册过。或者卖域名的把它回收掉了（通常是因为欠费）。</p><p>这也就是为什么打开一个新页面会有点慢，因为本地没什么缓存，要这样递归地查询下去。</p><p>多说一句，例如”mp3.baidu.com”，域名先是解析出这是个.com的域名，然后跑到管理.com域名的服务器上进行进一步查询，然后是.baidu，最后是mp3，</p><p>所以域名结构为：三级域名.二级域名.一级域名。</p><p>浏览器终于得到了IP以后，浏览器接着给这个IP的服务器发送了一个http请求，方式为get，例如访问nbut.cn</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqw0i0a87nj30fr0edgq3.jpg" alt="image-20201104211159011"></p><p>这个get请求包含了主机（host）、用户代理(User-Agent)，用户代理就是自己的浏览器，它是你的”代理人”，Connection（连接属性）中的keep-alive表示浏览器告诉对方服务器在传输完现在请求的内容后不要断开连接，不断开的话下次继续连接速度就很快了。其他的顾名思义就行了。还有一个重点是Cookies，Cookies保存了用户的登陆信息，在每次向服务器发送请求的时候会重复发送给服务器。Corome上的F12与Firefox上的firebug(快捷键shift+F5)均可查看这些信息。</p><p>发送完请求接下来就是等待回应了</p><p>当然了，服务器收到浏览器的请求以后（其实是WEB服务器接收到了这个请求，WEB服务器有iis、apache等），它会解析这个请求（读请求头），然后生成一个响应头和具体响应内容。接着服务器会传回来一个响应头和一个响应，响应头告诉了浏览器一些必要的信息，例如重要的Status Code，2开头如200表示一切正常，3开头表示重定向，4开头，如404，呵呵。响应就是具体的页面编码，就是那个<html>……</html>，浏览器先读了关于这个响应的说明书（响应头），然后开始解析这个响应并在页面上显示出来。在下一次CF的时候（不是穿越火线，是<a href="http://codeforces.com/%EF%BC%89%EF%BC%8C%E7%94%B1%E4%BA%8E%E7%BB%8F%E5%B8%B8%E9%9A%BE%E4%BB%A5%E6%89%BF%E5%8F%97%E5%87%A0%E5%8D%83%E4%BA%BA%E7%9A%84%E5%90%8C%E6%97%B6%E8%AE%BF%E9%97%AE%EF%BC%8C%E6%89%80%E4%BB%A5CF%E9%A1%B5%E9%9D%A2%E7%BB%8F%E5%B8%B8%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%B4%A9%E6%BA%83%E9%A1%B5%E9%9D%A2%EF%BC%8C%E5%88%B0%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E7%82%B9%E5%BC%80%E7%81%AB%E7%8B%90%E7%9A%84firebug%E6%88%96%E6%98%AFChrome%E7%9A%84F12%E7%9C%8B%E7%9C%8B%E7%8A%B6%E6%80%81%EF%BC%8C%E4%B8%8D%E8%BF%87%E8%BF%99%E6%97%B6%E5%80%99%E4%B8%80%E8%88%AC%E9%83%BD%E6%80%A5%E7%9D%80%E7%9C%8B%E9%A2%98%E5%92%8C%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%EF%BC%8C%E4%BC%BC%E4%B9%8E%E6%A0%B9%E6%9C%AC%E5%B0%B1%E6%B2%A1%E5%BF%83%E6%83%85%E7%90%86%E4%BC%9A%E8%BF%99%E4%B8%AA%E7%8A%B6%E6%80%81%E5%90%A7-.-%E3%80%82">http://codeforces.com/），由于经常难以承受几千人的同时访问，所以CF页面经常会出现崩溃页面，到时候可以点开火狐的firebug或是Chrome的F12看看状态，不过这时候一般都急着看题和提交代码，似乎根本就没心情理会这个状态吧-.-。</a></p><p>如果是个静态页面，那么基本上到这一步就没了，但是如今的网站几乎没有静态的了吧，基本全是动态的。所以这时候事情还没完，根据我们的经验，浏览器打开一个网址的时候会慢慢加载这个页面，一部分一部分的显示，直到完全显示，最后标签栏上的圈圈就不转了。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqw0i3qj8dj3085012wea.jpg" alt="image-20201104210542063"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqw0i7n737j307y00x3yb.jpg" alt="image-20201104210454136"></p><p>这是因为，主页（index）页面框架传送过来以后，浏览器还要继续向服务器发送请求，请求的内容是主页里面包含的一些资源，如图片，视频，css样式等等。这些”非静态”的东西要一点点地请求过来，所以标签栏转啊转，内容刷啊刷，最后全部请求并加载好了就终于好了。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqw0ia0qsaj30mq03i75c.jpg" alt="20140825115321699"></p><p>需要说明的是，对于静态的页面内容，浏览器通常会进行缓存，而对于动态的内容，浏览器通常不会进行缓存。缓存的内容通常也不会保存很久，因为难保网站不会被改动。</p>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>http</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>design_patterns</title>
    <link href="/2021/05/26/java-design-patterns/"/>
    <url>/2021/05/26/java-design-patterns/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="1-单例模式：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这-个实例。"><a href="#1-单例模式：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这-个实例。" class="headerlink" title="1. 单例模式：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这 个实例。"></a>1. 单例模式：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这 个实例。</h2><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//（1）懒汉式</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;      <span class="hljs-comment">/* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载  */</span>         <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance = <span class="hljs-keyword">null</span>;      <span class="hljs-comment">/* 私有构造方法，防止被实例化 */</span>          <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;        &#125;      <span class="hljs-comment">/* 1:懒汉式，静态工程方法，创建实例 */</span>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;                 <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;                     instance = <span class="hljs-keyword">new</span> Singleton();                 &#125;               <span class="hljs-keyword">return</span> instance;             &#125;      &#125;     （<span class="hljs-number">2</span>）饿汉式     <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;      <span class="hljs-comment">/* 持有私有静态实例，防止被引用 */</span>           <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance = <span class="hljs-keyword">new</span> Singleton();      <span class="hljs-comment">/* 私有构造方法，防止被实例化 */</span>          <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;       &#125;      <span class="hljs-comment">/* 1:懒汉式，静态工程方法，创建实例 */</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;             <span class="hljs-keyword">return</span> instance;         &#125;    &#125;</code></pre></div><p>使用场景： </p><ul><li>要求生成唯一序列号的环境； </li><li>在整个项目中需要一个共享访问点或共享数据，例如一个Web页面上的计数 器，可以不用把每次刷新都记录到数据库中，使用单例模式保持计数器的值，并 确保是线程安全的； </li><li>创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源； </li><li>需要定义大量的静态常量和静态方法（如工具类）的环境，可以采用单例模式 （当然，也可以直接声明为static的方式）。</li></ul><h2 id="2-工厂模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂-方法使一个类的实例化延迟到其子类。"><a href="#2-工厂模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂-方法使一个类的实例化延迟到其子类。" class="headerlink" title="2. 工厂模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂 方法使一个类的实例化延迟到其子类。"></a>2. 工厂模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂 方法使一个类的实例化延迟到其子类。</h2><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Fruit</span> </span>&#123;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;   &#125;   <span class="hljs-comment">//2个实现类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Fruit</span></span>&#123;      <span class="hljs-meta">@Override</span>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;               System.out.println(<span class="hljs-string">&quot;我是一个苹果&quot;</span>);        &#125;  &#125;   <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Orange</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Fruit</span></span>&#123;      <span class="hljs-meta">@Override</span>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;               System.out.println(<span class="hljs-string">&quot;我是一个橘子&quot;</span>);      &#125;  &#125;   <span class="hljs-comment">//工厂类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FruitFactory</span> </span>&#123;       <span class="hljs-function"><span class="hljs-keyword">public</span> Fruit <span class="hljs-title">produce</span><span class="hljs-params">(String type)</span></span>&#123;           <span class="hljs-keyword">if</span>(type.equals(<span class="hljs-string">&quot;apple&quot;</span>))&#123;               <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Apple();           &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type.equals(<span class="hljs-string">&quot;orange&quot;</span>))&#123;               <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Orange();           &#125;<span class="hljs-keyword">else</span>&#123;               System.out.println(<span class="hljs-string">&quot;请输入正确的类型!&quot;</span>);                 <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;       &#125;   &#125;</code></pre></div><p>使用场景：jdbc连接数据库，硬件访问，降低对象的产生和销毁</p><h2 id="3-抽象工厂模式：为创建一组相关或相互依赖的对象提供一个接口，而且无须指-定它们的具体类。"><a href="#3-抽象工厂模式：为创建一组相关或相互依赖的对象提供一个接口，而且无须指-定它们的具体类。" class="headerlink" title="3. 抽象工厂模式：为创建一组相关或相互依赖的对象提供一个接口，而且无须指 定它们的具体类。"></a>3. 抽象工厂模式：为创建一组相关或相互依赖的对象提供一个接口，而且无须指 定它们的具体类。</h2><p>相对于工厂模式，我们可以新增产品类（只需要实现产品接口），只需要同时新 增一个工厂类，客户端就可以轻松调用新产品的代码。 </p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">food</span></span>&#123;&#125; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">food</span></span>&#123;&#125; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">food</span></span>&#123;&#125; <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">produce</span></span>&#123; <span class="hljs-function">food <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;&#125; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryForA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">produce</span></span>&#123;     <span class="hljs-meta">@Override</span>     <span class="hljs-function"><span class="hljs-keyword">public</span> food <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> A();        &#125; &#125; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryForB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">produce</span></span>&#123;     <span class="hljs-meta">@Override</span>     <span class="hljs-function"><span class="hljs-keyword">public</span> food <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> B();     &#125; &#125; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractFactory</span> </span>&#123;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ClientCode</span><span class="hljs-params">(String name)</span></span>&#123;         food x= <span class="hljs-keyword">new</span> FactoryForA().get();         x = <span class="hljs-keyword">new</span> FactoryForB().get();     &#125; &#125;</code></pre></div><p>使用场景：一个对象族（或是一组没有任何关系的对象）都有相同的约束。 涉及不同操作系统的时候，都可以考虑使用抽象工厂模式 </p><h2 id="4-建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可-以创建不同的表示。"><a href="#4-建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可-以创建不同的表示。" class="headerlink" title="4.建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可 以创建不同的表示。"></a>4.建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可 以创建不同的表示。</h2><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Build</span> </span>&#123;     <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;     String name = <span class="hljs-keyword">null</span> ;         <span class="hljs-keyword">int</span> number = -<span class="hljs-number">1</span> ;         String sex = <span class="hljs-keyword">null</span> ;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(Builder builder)</span>         </span>&#123;     <span class="hljs-keyword">this</span>.name=builder.name;     <span class="hljs-keyword">this</span>.number=builder.number;     <span class="hljs-keyword">this</span>.sex=builder.sex;     &#125;         <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span></span>&#123;            String name = <span class="hljs-keyword">null</span> ;             <span class="hljs-keyword">int</span> number = -<span class="hljs-number">1</span> ;             String sex = <span class="hljs-keyword">null</span> ;             <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;                 <span class="hljs-keyword">this</span>.name=name;                 <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;             &#125;             <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">setNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>&#123;                 <span class="hljs-keyword">this</span>.number=number;                 <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;             &#125;             <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">setSex</span><span class="hljs-params">(String sex)</span></span>&#123;                 <span class="hljs-keyword">this</span>.sex=sex;                 <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;             &#125;             <span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">build</span><span class="hljs-params">()</span></span>&#123;                 <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Student(<span class="hljs-keyword">this</span>);            &#125; &#125;                 &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;     Student A=<span class="hljs-keyword">new</span> Student.Builder().setName(<span class="hljs-string">&quot;张 三&quot;</span>).setNumber(<span class="hljs-number">1</span>).build();     Student B=<span class="hljs-keyword">new</span> Student.Builder().setSex(<span class="hljs-string">&quot;男&quot;</span>).setName(<span class="hljs-string">&quot;李四&quot;</span>).build();      System.out.println(A.name+<span class="hljs-string">&quot; &quot;</span>+A.number+<span class="hljs-string">&quot; &quot;</span>+A.sex);         System.out.println(B.name+<span class="hljs-string">&quot; &quot;</span>+B.number+<span class="hljs-string">&quot; &quot;</span>+B.sex);     &#125; &#125;</code></pre></div><p> 使用场景：</p><ol><li>相同的方法，不同的执行顺序，产生不同的事件结果时，可以采用建造者模 式。 </li><li>多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同 时，则可以使用该模式。 </li><li>产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，这个时候 使用建造者模式非常合适。 </li></ol><h2 id="5-原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的-对象。"><a href="#5-原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的-对象。" class="headerlink" title="5. 原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的 对象。"></a>5. 原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的 对象。</h2><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Prototype</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span></span>&#123;     <span class="hljs-keyword">private</span> String name;     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;         <span class="hljs-keyword">return</span> name;     &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;         <span class="hljs-keyword">this</span>.name = name;     &#125;     <span class="hljs-meta">@Override</span>     <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span>   </span>&#123;         <span class="hljs-keyword">try</span> &#123;             <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.clone();         &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;             e.printStackTrace();         &#125;<span class="hljs-keyword">finally</span> &#123;             <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;         &#125;     &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">( String[] args)</span></span>&#123;         Prototype pro = <span class="hljs-keyword">new</span> Prototype();         Prototype pro1 = (Prototype)pro.clone();     &#125;&#125;</code></pre></div><p>原型模式实际上就是实现Cloneable接口，重写clone（）方法。 </p><p>使用原型模式的优点： </p><p>1.性能优良 </p><p>原型模式是在内存二进制流的拷贝，要比直接new一个对象性能好很多，特别是 要在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。 </p><p>2.逃避构造函数的约束 </p><p>这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的（参见 13.4节）。</p><p>使用场景： </p><p>资源优化场景 类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 </p><p>性能和安全要求的场景 通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模 式。 </p><p>一个对象多个修改者的场景 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可 以考虑使用原型模式拷贝多个对象供调用者使用。</p><p>浅拷贝和深拷贝：</p><p>浅拷贝：Object类提供的方法clone只是拷贝本对象，其对象内部的数组、引用 对象等都不拷贝，还是指向原生对象的内部元素地址，这种拷贝就叫做浅拷贝， 其他的原始类型比如int、long、char、string（当做是原始类型）等都会被拷 贝。 </p><p>注意：　使用原型模式时，引用的成员变量必须满足两个条件才不会被拷贝：一 是类的成员变量，而不是方法内变量；二是必须是一个可变的引用对象，而不是 一个原始类型或不可变对象。 </p><p>深拷贝：对私有的类变量进行独立的拷贝       </p><p>如：this.arrayList = (ArrayList)this.arrayList.clone();</p><h2 id="6-适配器模式：将一个类的接口变换成客户端所期待的另一种接口，从而使原本-因接口不匹配而无法在一起工作的两个类能够在一起工作。"><a href="#6-适配器模式：将一个类的接口变换成客户端所期待的另一种接口，从而使原本-因接口不匹配而无法在一起工作的两个类能够在一起工作。" class="headerlink" title="6. 适配器模式：将一个类的接口变换成客户端所期待的另一种接口，从而使原本 因接口不匹配而无法在一起工作的两个类能够在一起工作。"></a>6. 适配器模式：将一个类的接口变换成客户端所期待的另一种接口，从而使原本 因接口不匹配而无法在一起工作的两个类能够在一起工作。</h2><p>主要可分为3种： </p><ol><li>类适配：创建新类，继承源类，并实现新接口，例如  class  adapter extends oldClass  implements newFunc{} </li><li>对象适配：创建新类持源类的实例，并实现新接口，例如  class adapter implements newFunc { private oldClass oldInstance ;} </li><li>接口适配：创建新的抽象类实现旧接口方法。例如  abstract class adapter implements oldClassFunc { void newFunc();} </li></ol><p>使用场景： </p><p>你有动机修改一个已经投产中的接口时，适配器模式可能是适合你的模式。比 如系统扩展了，需要使用一个已有或新建立的类，但这个类又不符合系统的接 口，怎么办？使用适配器模式，这也是我们例子中提到的。</p><h2 id="7-装饰器模式：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰-器模式相比生成子类更为灵活-。"><a href="#7-装饰器模式：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰-器模式相比生成子类更为灵活-。" class="headerlink" title="7. 装饰器模式：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰 器模式相比生成子类更为灵活 。"></a>7. 装饰器模式：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰 器模式相比生成子类更为灵活 。</h2><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Source</span></span>&#123; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>;&#125; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Decorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Source</span></span>&#123;     <span class="hljs-keyword">private</span> Source source ;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decotate1</span><span class="hljs-params">()</span></span>&#123;         System.out.println(<span class="hljs-string">&quot;decorate&quot;</span>);     &#125;     <span class="hljs-meta">@Override</span>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;         decotate1();         source.method();     &#125; &#125;</code></pre></div><p>使用场景： </p><ol><li>需要扩展一个类的功能，或给一个类增加附加功能。</li><li>需要动态地给一个对象增加功能，这些功能可以再动态地撤销。 </li><li>需要为一批的兄弟类进行改装或加装功能，当然是首选装饰模式。 </li></ol><h2 id="8-代理模式：为其他对象提供一种代理以控制对这个对象的访问。"><a href="#8-代理模式：为其他对象提供一种代理以控制对这个对象的访问。" class="headerlink" title="8. 代理模式：为其他对象提供一种代理以控制对这个对象的访问。"></a>8. 代理模式：为其他对象提供一种代理以控制对这个对象的访问。</h2><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Source</span></span>&#123; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>;&#125; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OldClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Source</span></span>&#123;     <span class="hljs-meta">@Override</span>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;     &#125; &#125; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Source</span></span>&#123;     <span class="hljs-keyword">private</span> Source source = <span class="hljs-keyword">new</span> OldClass();     <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span>&#123;&#125;     <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;         <span class="hljs-keyword">new</span> Class1().Func1();         source.method();         <span class="hljs-keyword">new</span> Class2().Func2();         doSomething();     &#125; &#125;</code></pre></div><h2 id="9-中介者模式：用一个中介对象封装一系列的对象交互，中介者使各对象不需要-显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。"><a href="#9-中介者模式：用一个中介对象封装一系列的对象交互，中介者使各对象不需要-显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。" class="headerlink" title="9. 中介者模式：用一个中介对象封装一系列的对象交互，中介者使各对象不需要 显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。"></a>9. 中介者模式：用一个中介对象封装一系列的对象交互，中介者使各对象不需要 显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</h2><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mediator</span> </span>&#123;      <span class="hljs-comment">//定义同事类      </span><span class="hljs-keyword">protected</span> ConcreteColleague1 c1;      <span class="hljs-keyword">protected</span> ConcreteColleague2 c2;      <span class="hljs-comment">//通过getter/setter方法把同事类注入进来      </span><span class="hljs-function"><span class="hljs-keyword">public</span> ConcreteColleague1 <span class="hljs-title">getC1</span><span class="hljs-params">()</span> </span>&#123;              <span class="hljs-keyword">return</span> c1;      &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setC1</span><span class="hljs-params">(ConcreteColleague1 c1)</span> </span>&#123;                <span class="hljs-keyword">this</span>.c1 = c1;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> ConcreteColleague2 <span class="hljs-title">getC2</span><span class="hljs-params">()</span> </span>&#123;               <span class="hljs-keyword">return</span> c2; &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setC2</span><span class="hljs-params">(ConcreteColleague2 c2)</span> </span>&#123;         <span class="hljs-keyword">this</span>.c2 = c2;       &#125;      <span class="hljs-comment">//中介者模式的业务逻辑     </span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething1</span><span class="hljs-params">()</span></span>;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething2</span><span class="hljs-params">()</span></span>; &#125;</code></pre></div><p>使用场景： 中介者模式适用于多个对象之间紧密耦合的情况，紧密耦合的标准是：在类图中 出现了蜘蛛网状结构，即每个类都与其他的类有直接的联系。 </p><h2 id="10-命令模式：将一个请求封装成一个对象，从而让你使用不同的请求把客户端-参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。"><a href="#10-命令模式：将一个请求封装成一个对象，从而让你使用不同的请求把客户端-参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。" class="headerlink" title="10. 命令模式：将一个请求封装成一个对象，从而让你使用不同的请求把客户端 参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。"></a>10. 命令模式：将一个请求封装成一个对象，从而让你使用不同的请求把客户端 参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。</h2><p>Receiver接受者角色：该角色就是干活的角色，命令传递到这里是应该被执行的 </p><p>Command命令角色：需要执行的所有命令都在这里声明 </p><p>Invoker调用者角色：接收到命令，并执行命令 </p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//通用Receiver类 </span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Receiver</span> </span>&#123;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span>; &#125; <span class="hljs-comment">//具体Receiver类 </span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteReciver1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Receiver</span></span>&#123;      <span class="hljs-comment">//每个接收者都必须处理一定的业务逻辑      </span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span>&#123; &#125;  &#125; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteReciver2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Receiver</span></span>&#123;      <span class="hljs-comment">//每个接收者都必须处理一定的业务逻辑      </span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span>&#123; &#125;  &#125; <span class="hljs-comment">//抽象Command类 public abstract class Command &#123;     </span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span></span>; &#125; <span class="hljs-comment">//具体的Command类 </span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteCommand1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Command</span> </span>&#123;      <span class="hljs-comment">//对哪个Receiver类进行命令处理      </span><span class="hljs-keyword">private</span> Receiver receiver;   <span class="hljs-comment">//构造函数传递接收者   </span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteCommand1</span><span class="hljs-params">(Receiver _receiver)</span></span>&#123;   <span class="hljs-keyword">this</span>.receiver = _receiver;     &#125;  <span class="hljs-comment">//必须实现一个命令 </span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-comment">//业务处理        </span><span class="hljs-keyword">this</span>.receiver.doSomething();    &#125; &#125; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteCommand2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Command</span> </span>&#123;  <span class="hljs-comment">//哪个Receiver类进行命令处理   </span><span class="hljs-keyword">private</span> Receiver receiver; <span class="hljs-comment">//构造函数传递接收者</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteCommand2</span><span class="hljs-params">(Receiver _receiver)</span></span>&#123;    <span class="hljs-keyword">this</span>.receiver = _receiver;   &#125;     <span class="hljs-comment">//必须实现一个命令 </span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-comment">//业务处理      </span> <span class="hljs-keyword">this</span>.receiver.doSomething();  &#125;   &#125;  <span class="hljs-comment">//调用者Invoker类 public class Invoker &#123;   </span> <span class="hljs-keyword">private</span> Command command; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCommand</span><span class="hljs-params">(Command _command)</span></span>&#123;     <span class="hljs-keyword">this</span>.command = _command;   &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">action</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">this</span>.command.execute();  &#125; &#125; <span class="hljs-comment">//场景类 </span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;      Invoker invoker = <span class="hljs-keyword">new</span> Invoker();       Receiver receiver = <span class="hljs-keyword">new</span> ConcreteReceiver1();    Command command = <span class="hljs-keyword">new</span> ConcreteCommand1(receiver);         invoker.setCommand(command);         invoker.action();      &#125; &#125;</code></pre></div><p>使用场景： 认为是命令的地方就可以采用命令模式，例如，在GUI开发中，一个按钮的点击 是一个命令，可以采用命令模式；模拟DOS命令的时候，当然也要采用命令模<br>式；触发－反馈机制的处理等。</p><h2 id="11-责任链模式：使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。"><a href="#11-责任链模式：使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。" class="headerlink" title="11.责任链模式：使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。"></a>11.责任链模式：使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。</h2><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handler</span> </span>&#123;     <span class="hljs-keyword">private</span> Handler nextHandler;     <span class="hljs-comment">//每个处理者都必须对请求做出处理</span>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Response <span class="hljs-title">handleMessage</span><span class="hljs-params">(Request request)</span></span>&#123;             Response response = <span class="hljs-keyword">null</span>;               <span class="hljs-comment">//判断是否是自己的处理级别</span>             <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.getHandlerLevel().equals(request.getRequestLevel()))&#123;                    response = <span class="hljs-keyword">this</span>.echo(request);             &#125;<span class="hljs-keyword">else</span>&#123;  <span class="hljs-comment">//不属于自己的处理级别</span>                    <span class="hljs-comment">//判断是否有下一个处理者</span>                    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.nextHandler != <span class="hljs-keyword">null</span>)&#123;                            response = <span class="hljs-keyword">this</span>.nextHandler.handleMessage(request);                    &#125;<span class="hljs-keyword">else</span>&#123;                            <span class="hljs-comment">//没有适当的处理者，业务自行处理</span>                    &#125;             &#125;             <span class="hljs-keyword">return</span> response;     &#125;     <span class="hljs-comment">//设置下一个处理者是谁</span>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNext</span><span class="hljs-params">(Handler _handler)</span></span>&#123;             <span class="hljs-keyword">this</span>.nextHandler = _handler;     &#125;     <span class="hljs-comment">//每个处理者都有一个处理级别</span>     <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Level <span class="hljs-title">getHandlerLevel</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">//每个处理者都必须实现处理任务</span>     <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Response <span class="hljs-title">echo</span><span class="hljs-params">(Request request)</span></span>;&#125;</code></pre></div><h2 id="12-策略模式：定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。"><a href="#12-策略模式：定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。" class="headerlink" title="12.策略模式：定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。"></a>12.策略模式：定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。</h2><p>使用场景：</p><ol><li><p>多个类只有在算法或行为上稍有不同的场景。</p></li><li><p>算法需要自由切换的场景。</p></li><li><p>需要屏蔽算法规则的场景。</p></li></ol><h2 id="13-迭代器模式：它提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节。"><a href="#13-迭代器模式：它提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节。" class="headerlink" title="13.迭代器模式：它提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节。"></a>13.迭代器模式：它提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节。</h2><p>迭代器模式已经被淘汰，java中已经把迭代器运用到各个聚集类（collection）中了，使用java自带的迭代器就已经满足我们的需求了。</p><h2 id="14-组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。"><a href="#14-组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。" class="headerlink" title="14.组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。"></a>14.组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</h2><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Composite</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;     <span class="hljs-comment">//构件容器</span>     <span class="hljs-keyword">private</span> ArrayList componentArrayList = <span class="hljs-keyword">new</span> ArrayList();     <span class="hljs-comment">//增加一个叶子构件或树枝构件</span>     <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params">Component component</span>)</span>&#123;             <span class="hljs-built_in">this</span>.componentArrayList.add(component);     &#125;     <span class="hljs-comment">//删除一个叶子构件或树枝构件</span>     <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">remove</span>(<span class="hljs-params">Component component</span>)</span>&#123;<span class="hljs-built_in">this</span>.componentArrayList.remove(component);     &#125;     <span class="hljs-comment">//获得分支下的所有叶子构件和树枝构件</span>     <span class="hljs-keyword">public</span> ArrayList <span class="hljs-function"><span class="hljs-title">getChildren</span>(<span class="hljs-params"></span>)</span>&#123;             <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.componentArrayList;     &#125;&#125;</code></pre></div><p>使用场景：</p><ol><li><p>维护和展示部分-整体关系的场景，如树形菜单、文件和文件夹管理。</p></li><li><p>从一个整体中能够独立出部分模块或功能的场景。</p></li></ol><h2 id="15-观察者模式：定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。"><a href="#15-观察者模式：定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。" class="headerlink" title="15.观察者模式：定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。"></a>15.观察者模式：定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。</h2><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span> </span>&#123;     <span class="hljs-comment">//定义一个观察者数组</span>     <span class="hljs-keyword">private</span> Vector obsVector = <span class="hljs-keyword">new</span> Vector();     <span class="hljs-comment">//增加一个观察者</span>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addObserver</span><span class="hljs-params">(Observer o)</span></span>&#123;             <span class="hljs-keyword">this</span>.obsVector.add(o);     &#125;     <span class="hljs-comment">//删除一个观察者</span>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delObserver</span><span class="hljs-params">(Observer o)</span></span>&#123;             <span class="hljs-keyword">this</span>.obsVector.remove(o);     &#125;     <span class="hljs-comment">//通知所有观察者</span>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">()</span></span>&#123;             <span class="hljs-keyword">for</span>(Observer o:<span class="hljs-keyword">this</span>.obsVector)&#123;                     o.update();&#125;     &#125;&#125;</code></pre></div><p>使用场景：</p><ol><li><p>关联行为场景。需要注意的是，关联行为是可拆分的，而不是“组合”关系。</p></li><li><p>事件多级触发场景。</p></li><li><p>跨系统的消息交换场景，如消息队列的处理机制</p></li></ol><h2 id="16-门面模式：要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。"><a href="#16-门面模式：要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。" class="headerlink" title="16.门面模式：要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。"></a>16.门面模式：要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。</h2><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Facade</span> </span>&#123;    <span class="hljs-keyword">private</span> subSystem1 subSystem1 = <span class="hljs-keyword">new</span> subSystem1();    <span class="hljs-keyword">private</span> subSystem2 subSystem2 = <span class="hljs-keyword">new</span> subSystem2();    <span class="hljs-keyword">private</span> subSystem3 subSystem3 = <span class="hljs-keyword">new</span> subSystem3();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startSystem</span><span class="hljs-params">()</span></span>&#123;        subSystem1.start();        subSystem2.start();                 subSystem3.start();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stopSystem</span><span class="hljs-params">()</span></span>&#123;        subSystem1.stop();        subSystem2.stop();                 subSystem3.stop();    &#125;&#125;</code></pre></div><p>使用场景：</p><ol><li><p>为一个复杂的模块或子系统提供一个供外界访问的接口</p></li><li><p>子系统相对独立——外界对子系统的访问只要黑箱操作即可</p></li><li><p>预防低水平人员带来的风险扩散</p></li></ol><h2 id="17-备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。"><a href="#17-备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。" class="headerlink" title="17.备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。"></a>17.备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</h2><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Originator</span> </span>&#123;    <span class="hljs-keyword">private</span> String state;    <span class="hljs-comment">/**</span><span class="hljs-comment">*工厂方法，返回一个新的备忘录对象</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Memento <span class="hljs-title">createMemento</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Memento(state);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">*将发起人恢复到备忘录对象所记载的状态</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">restoreMemento</span><span class="hljs-params">(Memento memento)</span></span>&#123;        <span class="hljs-keyword">this</span>.state = memento.getState();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getState</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> state;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(String state)</span> </span>&#123;        <span class="hljs-keyword">this</span>.state = state;        System.out.println(<span class="hljs-string">&quot;当前状态：&quot;</span> + <span class="hljs-keyword">this</span>.state);    &#125;&#125;</code></pre></div><p>使用场景：</p><ol><li><p>需要保存和恢复数据的相关状态场景。</p></li><li><p>提供一个可回滚（rollback）的操作。</p></li><li><p>需要监控的副本场景中。</p></li><li><p>数据库连接的事务管理就是用的备忘录模式。</p></li></ol><h2 id="18-访问者模式：封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。"><a href="#18-访问者模式：封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。" class="headerlink" title="18.访问者模式：封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。"></a>18.访问者模式：封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。</h2><p>使用场景：</p><ol><li><p>一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作，也就说是用迭代器模式已经不能胜任的情景。</p></li><li><p>需要对一个对象结构中的对象进行很多不同并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。</p></li></ol><h2 id="19-状态模式：当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。"><a href="#19-状态模式：当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。" class="headerlink" title="19.状态模式：当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。"></a>19.状态模式：当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。</h2><p>使用场景：</p><ol><li><p>行为随状态改变而改变的场景这也是状态模式的根本出发点，例如权限设计，人员的状态不同即使执行相同的行为结果也会不同，在这种情况下需要考虑使用状态模式。</p></li><li><p>条件、分支判断语句的替代者</p></li></ol><h2 id="20-解释器模式：给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。"><a href="#20-解释器模式：给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。" class="headerlink" title="20.解释器模式：给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。"></a>20.解释器模式：给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。</h2><p>使用场景：</p><ol><li><p>重复发生的问题可以使用解释器模式</p></li><li><p>一个简单语法需要解释的场景</p></li></ol><h2 id="21-享元模式：使用共享对象的方法，用来尽可能减少内存使用量以及分享资讯。"><a href="#21-享元模式：使用共享对象的方法，用来尽可能减少内存使用量以及分享资讯。" class="headerlink" title="21.享元模式：使用共享对象的方法，用来尽可能减少内存使用量以及分享资讯。"></a>21.享元模式：使用共享对象的方法，用来尽可能减少内存使用量以及分享资讯。</h2><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">flywei</span></span>&#123; &#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Flyweight</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">flywei</span></span>&#123;    Object obj ;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Flyweight</span><span class="hljs-params">(Object obj)</span></span>&#123;        <span class="hljs-keyword">this</span>.obj = obj;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">FlyweightFactory</span></span>&#123;     <span class="hljs-keyword">private</span> HashMap data;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FlyweightFactory</span><span class="hljs-params">()</span></span>&#123; data = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Flyweight <span class="hljs-title">getFlyweight</span><span class="hljs-params">(Object object)</span></span>&#123;        <span class="hljs-keyword">if</span> ( data.containsKey(object))&#123;            <span class="hljs-keyword">return</span> data.get(object);        &#125;<span class="hljs-keyword">else</span> &#123;            Flyweight flyweight = <span class="hljs-keyword">new</span> Flyweight(object);            data.put(object,flyweight);            <span class="hljs-keyword">return</span> flyweight;        &#125;    &#125;&#125;</code></pre></div><p>使用场景：</p><ol><li><p>系统中存在大量的相似对象。</p></li><li><p>细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。</p></li><li><p>需要缓冲池的场景。</p></li></ol><h2 id="22-桥梁模式：将抽象和实现解耦，使得两者可以独立地变化。"><a href="#22-桥梁模式：将抽象和实现解耦，使得两者可以独立地变化。" class="headerlink" title="22.桥梁模式：将抽象和实现解耦，使得两者可以独立地变化。"></a>22.桥梁模式：将抽象和实现解耦，使得两者可以独立地变化。</h2><p>Circle类将DrwaApi与Shape类进行了桥接，</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DrawAPI</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawCircle</span><span class="hljs-params">(<span class="hljs-keyword">int</span> radius, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedCircle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DrawAPI</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawCircle</span><span class="hljs-params">(<span class="hljs-keyword">int</span> radius, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;Drawing Circle[ color: red, radius: &quot;</span>                + radius +<span class="hljs-string">&quot;, x: &quot;</span> +x+<span class="hljs-string">&quot;, &quot;</span>+ y +<span class="hljs-string">&quot;]&quot;</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GreenCircle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DrawAPI</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawCircle</span><span class="hljs-params">(<span class="hljs-keyword">int</span> radius, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;Drawing Circle[ color: green, radius: &quot;</span>                + radius +<span class="hljs-string">&quot;, x: &quot;</span> +x+<span class="hljs-string">&quot;, &quot;</span>+ y +<span class="hljs-string">&quot;]&quot;</span>);    &#125;&#125;<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> </span>&#123;    <span class="hljs-keyword">protected</span> DrawAPI drawAPI;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">Shape</span><span class="hljs-params">(DrawAPI drawAPI)</span></span>&#123;        <span class="hljs-keyword">this</span>.drawAPI = drawAPI;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> x, y, radius;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> radius, DrawAPI drawAPI)</span> </span>&#123;        <span class="hljs-keyword">super</span>(drawAPI);        <span class="hljs-keyword">this</span>.x = x;        <span class="hljs-keyword">this</span>.y = y;        <span class="hljs-keyword">this</span>.radius = radius;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;        drawAPI.drawCircle(radius,x,y);    &#125;&#125;<span class="hljs-comment">//客户端使用代码</span>Shape redCircle = <span class="hljs-keyword">new</span> Circle(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>, <span class="hljs-number">10</span>, <span class="hljs-keyword">new</span> RedCircle()); Shape greenCircle = <span class="hljs-keyword">new</span> Circle(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>, <span class="hljs-number">10</span>, <span class="hljs-keyword">new</span> GreenCircle()); redCircle.draw(); greenCircle.draw();</code></pre></div><p>使用场景：</p><ol><li><p>不希望或不适用使用继承的场景</p></li><li><p>接口或抽象类不稳定的场景</p></li><li><p>重用性要求较高的场景</p></li></ol><h2 id="23-模板方法模式：定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。"><a href="#23-模板方法模式：定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。" class="headerlink" title="23.模板方法模式：定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。"></a>23.模板方法模式：定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</h2><p>使用场景：</p><ol><li><p>多个子类有公有的方法，并且逻辑基本相同时。</p></li><li><p>重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。</p></li><li><p>重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数（见“模板方法模式的扩展”）约束其行为。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>date</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis config</title>
    <link href="/2021/05/18/redis-config/"/>
    <url>/2021/05/18/redis-config/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis配置"><a href="#Redis配置" class="headerlink" title="Redis配置"></a>Redis配置</h1><p>前言：本篇文章主要是对于Redis官方配置文件的翻译，主要目的是便于自己了解Redis及分析为初学者提供配置文件的中文翻译。<br>英语水平有限，因此文中有诸多不恰当的地方，欢迎指正，同时本文去掉了官方文档中一些个人认为不那么重要的配置内容。</p><h1 id="Redis配置文件示例"><a href="#Redis配置文件示例" class="headerlink" title="Redis配置文件示例"></a>Redis配置文件示例</h1><p>Redis在启动的时候必须将配置文件的路径作为启动的参数，以便于能够正确读取配置文件。</p><div class="hljs code-wrapper"><pre><code class="hljs awk">.<span class="hljs-regexp">/redis-server /</span>path<span class="hljs-regexp">/to/</span>redis.conf</code></pre></div><p>内存大小单位：所有配置文件中内存大小的表示单位，一般的表现形式如下：</p><div class="hljs code-wrapper"><pre><code class="hljs vala"><span class="hljs-meta"># 1k =&gt; 1000 bytes</span><span class="hljs-meta"># 1kb =&gt; 1024 bytes</span><span class="hljs-meta"># 1m =&gt; 1000000 bytes</span><span class="hljs-meta"># 1mb =&gt; 1024*1024 bytes</span><span class="hljs-meta"># 1g =&gt; 1000000000 bytes</span><span class="hljs-meta"># 1gb =&gt; 1024*1024*1024 bytes</span></code></pre></div><p>并且内存大小表示单位是内存不敏感的，<code>1GB 1Gb 1gB</code>表示的含义相同。</p><h1 id="1-配置文件详解"><a href="#1-配置文件详解" class="headerlink" title="1. 配置文件详解"></a>1. 配置文件详解</h1><h2 id="1-INCLUDES"><a href="#1-INCLUDES" class="headerlink" title="1. INCLUDES"></a>1. INCLUDES</h2><p>一个配置文件中可以包含一个或者多个其他的配置文件，主要是便于管理，类似于Spring中分为各个细的配置文件。<br>如果每个redis服务器有一个的标准配置模板，并且还需要为某些服务器设置特定的配置，则文件的相互包含十分有效。A包含B，B也可以包含C</p><p>被包含的文件不会被因为<code>CONFIG REWRITE</code>命令而重写。因为 Redis 始终使用最后一个处理过的命令行作为配置指令，因此最好将 被包含文件放在此文件的开头来避免在运行将配置覆盖。</p><p>相反，如果真的想使用 include 来覆盖配置选项，则最好使用 include 作为最后一行。</p><div class="hljs code-wrapper"><pre><code class="hljs pgsql"># <span class="hljs-keyword">include</span> /<span class="hljs-type">path</span>/<span class="hljs-keyword">to</span>/<span class="hljs-keyword">local</span>.conf# <span class="hljs-keyword">include</span> /<span class="hljs-type">path</span>/<span class="hljs-keyword">to</span>/other.conf</code></pre></div><h2 id="2-MODULES"><a href="#2-MODULES" class="headerlink" title="2.MODULES"></a>2.MODULES</h2><p>启动时加载模块。如果服务器无法加载模块，该模块将会被废弃，也可以使用多个加载模块命令。<br>做redis功能扩展使用</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-comment"># loadmodule /path/to/my_module.so</span><span class="hljs-comment"># loadmodule /path/to/other_module.so</span></code></pre></div><h2 id="3-NETWORK"><a href="#3-NETWORK" class="headerlink" title="3. NETWORK"></a>3. NETWORK</h2><p>默认情况下，如果未指定”bind”具体的配置指令，Redis将监听来自服务器上所有可用网络接口的连接请求。</p><p>可以使用”bind”配置指令仅监听一个或多个选定的接口，然后被一个或多个 特定的IP 地址连接。</p><p>默认情况下，如果不配置具体的ip，则链接服务器所有的网络接口，如果具体指出，则只连接具体的某一个ip。如果不绑定特定的ip，则会造成连接的不安全性。</p><div class="hljs code-wrapper"><pre><code class="hljs dns"># bind <span class="hljs-number">192.168.1.100</span> <span class="hljs-number">10.0.0.1</span># bind <span class="hljs-number">127.0.0.1</span> <span class="hljs-number">::1</span></code></pre></div><p>注意点：如果运行redis的计算机直接对所有的网络开放，会使服务器十分危险，者会将服务器直接暴露给所有的互联网用户。<br>因此，默认情况下，会设置如下绑定指令，这将强制 Redis 仅侦听 IPv4接口地址（这意味着 Redis 只能接受来自运行在同一台计算机的客户端连接）</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">bind</span> <span class="hljs-number">127.0.0.1</span> ::<span class="hljs-number">1</span>                      // 注释这一行将会允许redis被所有计算机连接</code></pre></div><h3 id="设置连接模式是否安全"><a href="#设置连接模式是否安全" class="headerlink" title="设置连接模式是否安全"></a>设置连接模式是否安全</h3><p>保护模式是一层安全保护，以避免在 Redis 实例被 Internet 上所有用户访问和利用。</p><p>以下两种情况会导致保护模式开启：</p><ol><li>redis服务器没有直接绑定任何的地址</li><li>没有设置登录密码</li></ol><p>保护模式默认是开启的，如果确认想关闭时，则只需要将保护模式设置为no</p><div class="hljs code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-keyword">protected</span>-mode yes</code></pre></div><h3 id="设置redis连接端口号"><a href="#设置redis连接端口号" class="headerlink" title="设置redis连接端口号"></a>设置redis连接端口号</h3><p>设置可以连接的特定端口号，默认的端口是6379</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">port</span> <span class="hljs-number">6379</span></code></pre></div><h3 id="设置TCP连接的监听日志"><a href="#设置TCP连接的监听日志" class="headerlink" title="设置TCP连接的监听日志"></a>设置TCP连接的监听日志</h3><p>设置Tcp的backlog，backlog其实是一个连接队列，backlog队列总和=未完成的三次握手队列+已完成的三次握手队列<br>在高并发下需要一个高backlog来避免慢客户端连接问题，linux内核会将这个值减少到<code>/proc/sys/net/core/somaxconn</code><br>所以为了确保能保证得到想要结果，需要确认增大<code>somaxconn</code>和 <code>tcp_max_syn_backlog</code></p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">tcp</span>-backlog <span class="hljs-number">511</span><span class="hljs-attribute">1</span></code></pre></div><h3 id="设置自动断开连接的时间"><a href="#设置自动断开连接的时间" class="headerlink" title="设置自动断开连接的时间"></a>设置自动断开连接的时间</h3><p>当客户端空闲多久时会自动断开连接，如果设置为0，则不会自动断开。</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">timeout</span> <span class="hljs-number">0</span></code></pre></div><h3 id="设置否是长连接"><a href="#设置否是长连接" class="headerlink" title="设置否是长连接"></a>设置否是长连接</h3><p>如果该值不设置为非零，在没有通信的情况下利用<code>SO_KEEPALIVE</code>发送tcp acks信息 给客户端，这样做的理由如下：</p><ol><li>检测已经挂掉的客户端</li><li>从中间的网络设备的角度保证连接不中断。</li></ol><p>在linux系统中，一定时间段内发送ACKS的数据量是特定的，<br>如果设置为0则不会进行keyalive检测，建议设置成300s</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">tcp</span>-keepalive <span class="hljs-number">300</span></code></pre></div><h2 id="4-GENERAL-通用设置"><a href="#4-GENERAL-通用设置" class="headerlink" title="4. GENERAL(通用设置)"></a>4. GENERAL(通用设置)</h2><h3 id="设置是否后台运行"><a href="#设置是否后台运行" class="headerlink" title="设置是否后台运行"></a>设置是否后台运行</h3><p>默认情况下，Redis不在后台运行，如果需要开启后台运行，则将下值设置为yes。<br>在后台运行的时候，Redis会写入到特定的pid文件，默认的文件地址为：<code>/usr/local/var/run/redis.pid</code>，如果关闭后台运行，则不写入该文件中。<br>设置是否后台程序，是否允许关闭doc窗口redis继续提供服务</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"> <span class="hljs-attribute">daemonize</span> <span class="hljs-literal">no</span><span class="hljs-number">1</span></code></pre></div><h3 id="设置监控模式"><a href="#设置监控模式" class="headerlink" title="设置监控模式"></a>设置监控模式</h3><p>如果将redis运行模式设置为<code>upstart</code>或者<code>systemd</code>模式，则redis可以与监控系统进行交互。<br>该参数可以设置的值为：</p><ol><li>supervised no - 不设置监控模式</li><li>supervised upstart - signal upstart by putting Redis into SIGSTOP mode</li><li>supervised systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET</li><li>supervised auto - detect upstart or systemd method based on UPSTART_JOB or NOTIFY_SOCKET environment variables</li></ol><p>设置是否需要监控，默认不开启监控模式</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">supervised</span> <span class="hljs-literal">no</span></code></pre></div><h3 id="指定pid文件的地址"><a href="#指定pid文件的地址" class="headerlink" title="指定pid文件的地址"></a>指定pid文件的地址</h3><p>如果指定pid文件的路径，Redis启动的时候会向该文件中写入信息，退出时则会删除该文件。<br>当redis服务器设置为不可以在后台运行，则启动的时候不会创建pid文件。如果redis服务器设置为后台运行，及时不指定pid文件的文件路径，也会按照默认的地址创建路径。如果不手动指定，则将其放置在<code>/usr/local/var/run/redis.pid</code><br>创建pid文件是很有必要的：</p><p>如果redis不可以创建该文件，但没有其他坏事发生，redis服务器还是可以正常启动和运行。</p><div class="hljs code-wrapper"><pre><code class="hljs awk">pidfile <span class="hljs-regexp">/var/</span>run/redis_6379.pid<span class="hljs-number">1</span></code></pre></div><h3 id="指定服务器详细日志级别"><a href="#指定服务器详细日志级别" class="headerlink" title="指定服务器详细日志级别"></a>指定服务器详细日志级别</h3><p>具体的设置可以有:</p><ol><li>debug (大量信息，有利于开发和测试)</li><li>verbose (很多相对有用的信息，但是日志量没有dug多)</li><li>notice (一般详细的信息，一般是生产中可能用到的) 默认级别</li><li>warning (只是监控一些非常重要或者关键的信息)</li></ol><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">loglevel</span> <span class="hljs-literal">notice</span></code></pre></div><h3 id="指定日志文件的名称"><a href="#指定日志文件的名称" class="headerlink" title="指定日志文件的名称"></a>指定日志文件的名称</h3><p>指定日志文件的名称，会强制redis将日志按照标准输出到该文件中。如果后台按照标准文件的格式输出到日志文件，日志文件会默认放到<code>/dev/null</code>文件下</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">logfile</span> <span class="hljs-string">&quot;6381.log&quot;</span><span class="hljs-number">1</span></code></pre></div><h3 id="是否开启系统日志"><a href="#是否开启系统日志" class="headerlink" title="是否开启系统日志"></a>是否开启系统日志</h3><p>如果想要打印系统日志，只需要将该值设置为yes即可，</p><div class="hljs code-wrapper"><pre><code class="hljs coffeescript">syslog-enabled <span class="hljs-literal">no</span></code></pre></div><h3 id="指定系统日志标志"><a href="#指定系统日志标志" class="headerlink" title="指定系统日志标志"></a>指定系统日志标志</h3><div class="hljs code-wrapper"><pre><code class="hljs coq">syslog-<span class="hljs-keyword">ident</span> redis</code></pre></div><h3 id="指定系统日志用途"><a href="#指定系统日志用途" class="headerlink" title="指定系统日志用途"></a>指定系统日志用途</h3><p>指定系统日志用途,必须是<code>USER</code>或者是<code>LOCAL0-LOCAL7</code></p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">syslog</span>-facility local<span class="hljs-number">0</span></code></pre></div><h3 id="设置数据库的数量"><a href="#设置数据库的数量" class="headerlink" title="设置数据库的数量"></a>设置数据库的数量</h3><p>默认选择的数据库是<code>select 0</code>，选择的数据库必须数据<code>(0,&#39;databases&#39;-1)</code></p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">databases</span> <span class="hljs-number">16</span></code></pre></div><h3 id="是否展示启动时候的艺术log"><a href="#是否展示启动时候的艺术log" class="headerlink" title="是否展示启动时候的艺术log"></a>是否展示启动时候的艺术log</h3><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">always</span>-<span class="hljs-keyword">show</span>-logo yes</code></pre></div><h2 id="5-SNAPSHOTTING-快照"><a href="#5-SNAPSHOTTING-快照" class="headerlink" title="5. SNAPSHOTTING(快照)"></a>5. SNAPSHOTTING(快照)</h2><p>主要是保证数据的持久化。<br>将数据保存到磁盘中，具体的设置模式<br>设置存储数据库的周期<br>设置的格式</p><div class="hljs code-wrapper"><pre><code class="hljs xml">save <span class="hljs-tag">&lt;<span class="hljs-name">seconds</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">changes</span>&gt;</span></code></pre></div><p>只要设置的任意一种情况发生，都会将redis中存储的数据写入到磁盘中</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">save</span> <span class="hljs-number">900</span> <span class="hljs-number">1</span>                  <span class="hljs-number">900</span>s中有一个key发生变化<span class="hljs-attribute">save</span> <span class="hljs-number">300</span> <span class="hljs-number">10</span>                 <span class="hljs-number">300</span>s内有<span class="hljs-number">10</span>个key发生变化<span class="hljs-attribute">save</span> <span class="hljs-number">60</span> <span class="hljs-number">10000</span>               <span class="hljs-number">60</span>s内有<span class="hljs-number">10000</span>个key发生变化</code></pre></div><p>如果想禁用RDB，则需要设置成，并且注释掉上面的三个默认设置：</p><div class="hljs code-wrapper"><pre><code class="hljs maxima"><span class="hljs-built_in">save</span> <span class="hljs-string">&quot;&quot;</span></code></pre></div><h3 id="持久化出问题时是否允许写操作"><a href="#持久化出问题时是否允许写操作" class="headerlink" title="持久化出问题时是否允许写操作"></a>持久化出问题时是否允许写操作</h3><p>在快照后台保存失败情况下，默认停止写操作，让用户意识到故障，否则没有注意到问题回到值故障产生。<br>如果已经建立的适当的监控，即使在后台快照备份失败时也执行写操作，则需要将其设置为no。</p><div class="hljs code-wrapper"><pre><code class="hljs routeros">stop-writes-on-bgsave-<span class="hljs-builtin-name">error</span> <span class="hljs-literal">yes</span>1</code></pre></div><h3 id="是否压缩rdb文件"><a href="#是否压缩rdb文件" class="headerlink" title="是否压缩rdb文件"></a>是否压缩rdb文件</h3><p>设置是否压缩<code>dump .rdb</code>文件，推荐开启，否则文件会越来越大。如果不想消耗cpu内存，则可以设置为no，但是这样的话日志文件会越来越大。</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">rdbcompression</span> <span class="hljs-literal">yes</span></code></pre></div><h3 id="是否开启数据校验"><a href="#是否开启数据校验" class="headerlink" title="是否开启数据校验"></a>是否开启数据校验</h3><p>设置rdb checkSum是否跳过，是否进行数据校验。</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">rdbchecksum</span> <span class="hljs-literal">yes</span></code></pre></div><h3 id="设置rdb文件名"><a href="#设置rdb文件名" class="headerlink" title="设置rdb文件名"></a>设置rdb文件名</h3><p>设置数据库dump文件的名称,每个操作都会记录到dump.rds中，重启服务器，客户端连接时会重新写入</p><div class="hljs code-wrapper"><pre><code class="hljs gradle">dbfilename <span class="hljs-keyword">dump</span>.rdb</code></pre></div><h3 id="设置工作目录"><a href="#设置工作目录" class="headerlink" title="设置工作目录"></a>设置工作目录</h3><p>在该目录中，会存储数据库的写操作的rdb文件及AOF文件，这里只是指定文件夹路径，而不是具体的文件名称。</p><div class="hljs code-wrapper"><pre><code class="hljs awk">dir <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/var/</span>db<span class="hljs-regexp">/redis/</span></code></pre></div><h2 id="6-REPLICATION-主从复制"><a href="#6-REPLICATION-主从复制" class="headerlink" title="6. REPLICATION (主从复制)"></a>6. REPLICATION (主从复制)</h2><p>对于redis的复制需要理解以下几点：<br>master主要接受写，slaver是对于master的精确复制。</p><ol><li>redis主从同步是异步的，但是可以让在没有指定slave连接的情况下使master停止写入数据。</li><li>连接中断一定时间内，如果复制缺失了一段时间内的数据，slave可以执行部分数据重新同步。</li><li>同步是自动的，不需要人工接入，slave可以自动重连并且自动同步数据。</li></ol><div class="hljs code-wrapper"><pre><code class="hljs xml">replicaof <span class="hljs-tag">&lt;<span class="hljs-name">masterip</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">masterport</span>&gt;</span></code></pre></div><h3 id="设置master的链接密码"><a href="#设置master的链接密码" class="headerlink" title="设置master的链接密码"></a>设置master的链接密码</h3><p>如果master链接需要密码(这个是通过<code>requirepass</code>控制)，则在创建slaver链接master时，在同步之前，需要确认密码，否则master服务器将会具体slaver的链接。</p><div class="hljs code-wrapper"><pre><code class="hljs xml">masterauth <span class="hljs-tag">&lt;<span class="hljs-name">master-password</span>&gt;</span></code></pre></div><h3 id="当slaver与master失去连接时，从机表现情况？"><a href="#当slaver与master失去连接时，从机表现情况？" class="headerlink" title="当slaver与master失去连接时，从机表现情况？"></a>当slaver与master失去连接时，从机表现情况？</h3><p>当一个slave失去和master的连接，或者同步正在进行中，slave的行为有两种可能：</p><ol><li>如果 <code>slave-serve-stale-data</code> 设置为 “yes” (默认值)，slave会继续响应客户端请求，可能是正常数据，也可能是还没获得值的空数据。</li><li>如果 <code>slave-serve-stale-data</code> 设置为 “no”，slave会回复”正在从master同步（SYNC with master in progress）”来处理除了以下的其他各种请求：<br><code>INFO, replicaOF, AUTH, PING, SHUTDOWN, REPLCONF, ROLE, CONFIG, SUBSCRIBE, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB, COMMAND, POST, HOST: and LATENCY.</code></li></ol><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">replica</span>-serve-stale-data yes</code></pre></div><h3 id="配置slave是否接受写操作"><a href="#配置slave是否接受写操作" class="headerlink" title="配置slave是否接受写操作"></a>配置slave是否接受写操作</h3><p>可写的slave实例可能对存储临时数据比较有用(因为写入salve# 的数据在同master同步之后将很容被删除)，但是如果客户端由于配置错误在写入时也可能产生一些问题。</p><p>从redis 2.6 之后所有的slave都是只读的。</p><p>注：只读副本不会暴露给互联网上不受信任的客户端，防止redis被无用，加强保护。</p><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">replica</span>-<span class="hljs-keyword">read</span>-<span class="hljs-keyword">only</span> yes</code></pre></div><h3 id="副本同步策略"><a href="#副本同步策略" class="headerlink" title="副本同步策略"></a>副本同步策略</h3><p><strong>非磁盘复制目前处于试验阶段</strong><br>针对于新的slave或者重新链接的slave因为连接发生变化，无法继续备份过程，需要进行全同步的过程。从master同步到slave又两种方式：</p><ol><li>Disk-backed(磁盘备份)：master创建一个新的进程专门用于将数据库写入到磁盘中，稍后通过父进程将该文件复制到slave节点中。</li><li>Diskless(非磁盘)：master创建一个新进程直接将RDB文件写入到slave中，不必在磁盘中创建文件。</li></ol><p>设置同步的策略,默认为磁盘策略</p><div class="hljs code-wrapper"><pre><code class="hljs vim">repl-diskless-<span class="hljs-keyword">sync</span> <span class="hljs-keyword">no</span></code></pre></div><h3 id="设置非磁盘同步的延迟时间"><a href="#设置非磁盘同步的延迟时间" class="headerlink" title="设置非磁盘同步的延迟时间"></a>设置非磁盘同步的延迟时间</h3><p>如果非磁盘同步方式开启，可以配置同步延迟时间，以等待master产生子进程通过socket传输RDB数据给slave。</p><p>默认值为5秒，设置为0秒则每次传输无延迟。</p><div class="hljs code-wrapper"><pre><code class="hljs ada">repl-diskless-sync-<span class="hljs-keyword">delay</span> <span class="hljs-number">5</span></code></pre></div><h3 id="slaver给master发送ping请求的时间间隔"><a href="#slaver给master发送ping请求的时间间隔" class="headerlink" title="slaver给master发送ping请求的时间间隔"></a>slaver给master发送ping请求的时间间隔</h3><p>slave根据指定的时间间隔向master发送ping请求。默认10秒</p><div class="hljs code-wrapper"><pre><code class="hljs pgsql">repl-ping-<span class="hljs-keyword">replica</span>-period <span class="hljs-number">10</span></code></pre></div><h3 id="复制的超时时间"><a href="#复制的超时时间" class="headerlink" title="复制的超时时间"></a>复制的超时时间</h3><p>下列操作可能导致同步的超时：</p><ol><li>slave在与master SYNC期间有大量数据传输，造成超时</li><li>从slave观察，master超时，包括数据、ping等</li><li>在master观察，slave超时，当master发送<code>REPLCONF ACK pings</code></li></ol><p>设置超时时间，该值不易设置过小，需要大于指定的repl-ping-slave-period，否则即使复制数据量不大时，也容易频繁出现超时情况。</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">repl</span>-timeout <span class="hljs-number">60</span></code></pre></div><h3 id="是否在slave套接字发送SYNC之后禁用-TCP-NODELAY？"><a href="#是否在slave套接字发送SYNC之后禁用-TCP-NODELAY？" class="headerlink" title="是否在slave套接字发送SYNC之后禁用 TCP_NODELAY？"></a>是否在slave套接字发送SYNC之后禁用 TCP_NODELAY？</h3><div class="hljs code-wrapper"><pre><code class="hljs pgsql">repl-<span class="hljs-keyword">disable</span>-tcp-nodelay <span class="hljs-keyword">no</span></code></pre></div><ol><li>如果选择yes，Redis将使用更少的TCP包和带宽来向slaves发送数据。但是这将使数据传输到slave上有延迟，Linux内核的默认配置会达到40毫秒。</li><li>如果选择no，数据传输到salve的延迟将会减少但要使用更多的带宽。</li><li>默认我们会为<strong>低延迟做优化</strong>，但高流量情况或主从之间的跳数过多时，可以设置为“yes”。</li></ol><h3 id="设置数据备份的backlog大小"><a href="#设置数据备份的backlog大小" class="headerlink" title="设置数据备份的backlog大小"></a>设置数据备份的backlog大小</h3><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">repl</span>-backlog-size <span class="hljs-number">1</span>mb</code></pre></div><ol><li>backlog是一个slave在一段时间内断开连接时记录salve数据的缓冲，所以一个slave在重新连接时，不必要全量的同步，而是一个增量同步，将在断开连接的这段时间内把slave丢失的部分数据传送给它。</li><li>同步的backlog越大，slave能够进行增量同步并且允许断开连接的时间就越长。</li><li>backlog只分配一次并且至少需要一个slave连接。</li></ol><h2 id="设置缓冲backlog超时时间"><a href="#设置缓冲backlog超时时间" class="headerlink" title="设置缓冲backlog超时时间"></a>设置缓冲backlog超时时间</h2><p>当master在一段时间内不再与任何slave连接，backlog将会释放。以下选项配置了从最后一个slave断开开始计时多少秒后，backlog缓冲将会释放。</p><p>0表示永不释放backlog</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">repl</span>-backlog-ttl <span class="hljs-number">3600</span></code></pre></div><h3 id="设置每个slave的优先级别"><a href="#设置每个slave的优先级别" class="headerlink" title="设置每个slave的优先级别"></a>设置每个slave的优先级别</h3><p>salver的优先级别是由Redis配置信息决定的整数，主要目的是：当master挂掉之后哨兵选择优先级别最低的slave去替换master，默认的优先级别为100。</p><p>例如有三个slave优先级分别为10，100，25，sentinel将挑选优先级最小数字为10的slave</p><p>然而，0作为一个特殊的优先级，标识这个slave不能作为master，所以一个优先级为0的slave永远不会被哨兵挑选提升为master。</p><p>系统默认的优先级别是100.</p><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">replica</span>-priority <span class="hljs-number">100</span></code></pre></div><h3 id="设置主机中断写操作的条件"><a href="#设置主机中断写操作的条件" class="headerlink" title="设置主机中断写操作的条件"></a>设置主机中断写操作的条件</h3><p>如果master少于N个连接，延时小于等于M秒的已连接slave，就可以停止接收写操作。</p><p>例如至少需要3个延时小于等于10秒的slave用下面的指令</p><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">min</span>-replicas-<span class="hljs-built_in">to</span>-<span class="hljs-built_in">write</span> <span class="hljs-number">3</span><span class="hljs-built_in">min</span>-replicas-<span class="hljs-built_in">max</span>-lag <span class="hljs-number">10</span></code></pre></div><p>两者之一设置为0将禁用这个功能，<br>两个值的默认值分别是：<br>默认<code>min-slaves-to-write</code> 值是0, 默认<code>min-slaves-max-lag</code>值是10。</p><h3 id="设置slave-ip及port"><a href="#设置slave-ip及port" class="headerlink" title="设置slave ip及port"></a>设置slave ip及port</h3><p>可以通过不同的方式查看Redis master服务器所连接的slaver的ip地址及端口号。<br><code>INFO replication</code>命令可以查看主机及从机的集群信息;或者可以通过<code>ROLE</code>命令查看主机的一些配置。</p><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">replica</span>-announce-ip <span class="hljs-number">5.5</span><span class="hljs-number">.5</span><span class="hljs-number">.5</span><span class="hljs-keyword">replica</span>-announce-port <span class="hljs-number">1234</span></code></pre></div><h2 id="7-SECURITY-安全"><a href="#7-SECURITY-安全" class="headerlink" title="7. SECURITY(安全)"></a>7. SECURITY(安全)</h2><p>一旦设置了密码，则需要再连接前先进行授权<code>AUTH &lt;PASSWORD&gt;</code>，但是大部分情况下都不需要设置密码的，因为Redis主要目的是保证性能。</p><h3 id="查看设置的密码"><a href="#查看设置的密码" class="headerlink" title="查看设置的密码"></a>查看设置的密码</h3><div class="hljs code-wrapper"><pre><code class="hljs routeros">CONFIG <span class="hljs-builtin-name">GET</span> requirepass</code></pre></div><h3 id="设置客户端连接的密码"><a href="#设置客户端连接的密码" class="headerlink" title="设置客户端连接的密码"></a>设置客户端连接的密码</h3><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">requirepass foobared</span></code></pre></div><h3 id="通过命令的方式设置密码"><a href="#通过命令的方式设置密码" class="headerlink" title="通过命令的方式设置密码"></a>通过命令的方式设置密码</h3><div class="hljs code-wrapper"><pre><code class="hljs arduino">config set requirepass <span class="hljs-string">&quot;password&quot;</span></code></pre></div><h3 id="如果设置了密码则需要先通过如下命令认证"><a href="#如果设置了密码则需要先通过如下命令认证" class="headerlink" title="如果设置了密码则需要先通过如下命令认证"></a>如果设置了密码则需要先通过如下命令认证</h3><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">auth password</span></code></pre></div><h3 id="设置是否为命令重命名"><a href="#设置是否为命令重命名" class="headerlink" title="设置是否为命令重命名"></a>设置是否为命令重命名</h3><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">rename</span>-command CONFIG b<span class="hljs-number">840</span>fc<span class="hljs-number">02</span>d<span class="hljs-number">524045429941</span>cc<span class="hljs-number">15</span>f<span class="hljs-number">59</span>e<span class="hljs-number">41</span>cb<span class="hljs-number">7</span>be<span class="hljs-number">6</span>c<span class="hljs-number">52</span></code></pre></div><p>或者通过以下设置直接警用某些命令</p><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">rename</span>-<span class="hljs-keyword">command</span> <span class="hljs-title">CONFIG</span> <span class="hljs-string">&quot;&quot;</span></code></pre></div><p>请注意：改变命令名字被记录到AOF文件或被传送到从服务器可能产生问题。</p><h2 id="8-CLIENTS-客户端"><a href="#8-CLIENTS-客户端" class="headerlink" title="8. CLIENTS(客户端)"></a>8. CLIENTS(客户端)</h2><h3 id="设置可以同时连接的最大客户端数"><a href="#设置可以同时连接的最大客户端数" class="headerlink" title="设置可以同时连接的最大客户端数"></a>设置可以同时连接的最大客户端数</h3><p>默认为10000，一旦达到了最大连接数，Redis会关闭所有先的连接请求，并且发送错误日志<code>max number of clients reached</code></p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">maxclients</span> <span class="hljs-number">10000</span></code></pre></div><h2 id="9-MEMORY-MANAGEMENT-内存管理"><a href="#9-MEMORY-MANAGEMENT-内存管理" class="headerlink" title="9. MEMORY MANAGEMENT(内存管理)"></a>9. MEMORY MANAGEMENT(内存管理)</h2><h3 id="设置最大使用内存"><a href="#设置最大使用内存" class="headerlink" title="设置最大使用内存"></a>设置最大使用内存</h3><p>不要使用比设置的上限更多的内存。<br>一旦内存使用达到上限，Redis会根据选定的回收策略删除key（参见：maxmemmory-policy）</p><p>如果Redis根据回收策略不能够删除key，Redis则会只处理读请求(比如get)，而写请求会直接报错(SET、LPUSH等等)</p><p>注意：</p><p>总之，如果你需要附加多个slave，建议你设置一个稍小maxmemory限制，这样系统就会有空闲的内存作为slave的输出缓存区(但是如果最大内存策略设置为”noeviction”的话就没必要了)</p><div class="hljs code-wrapper"><pre><code class="hljs xml">maxmemory <span class="hljs-tag">&lt;<span class="hljs-name">bytes</span>&gt;</span></code></pre></div><h3 id="内存管理策略"><a href="#内存管理策略" class="headerlink" title="内存管理策略"></a>内存管理策略</h3><p>当内存达到最大时，如何删除key，根据以下策略</p><ol><li>volatile-lru -&gt; 根据LRU算法只删除设置过过期时间的key</li><li>allkeys-lru -&gt; 根据LRU算法删除任何key</li><li>allkeys-lfu -&gt; 根据LFU算法删除任何key</li><li>allkeys-random -&gt; 随机移除任何key</li><li>volatile-ttl -&gt; 移除最近刚过期的key</li><li>noeviction -&gt; 不移除任何key，只返回一个写错误</li></ol><p><strong>LRU means Least Recently Used<br>LFU means Least Frequently Used</strong></p><p>系统默认的内存管理策略：</p><div class="hljs code-wrapper"><pre><code class="hljs cmake">maxmemory-<span class="hljs-keyword">policy</span> noeviction</code></pre></div><h3 id="设置内存管理检查策略"><a href="#设置内存管理检查策略" class="headerlink" title="设置内存管理检查策略"></a>设置内存管理检查策略</h3><p>LRU和最小TTL算法的实现都不是很精确，但是很接近算法（为了省内存），所以你可以用样本量做检测。</p><p>例如：默认Redis会检查5个key然后取最旧的那个，你可以通过下面的配置指令来设置样本的个数。默认值为5，数字越大结果越精确但是会消耗更多CPU。</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">maxmemory</span>-samples <span class="hljs-number">5</span></code></pre></div><h3 id="设置slave是否忽略最大内存限制"><a href="#设置slave是否忽略最大内存限制" class="headerlink" title="设置slave是否忽略最大内存限制"></a>设置slave是否忽略最大内存限制</h3><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">replica</span>-ignore-maxmemory yes</code></pre></div><h2 id="10-LAZY-FREEING"><a href="#10-LAZY-FREEING" class="headerlink" title="10 .LAZY FREEING"></a>10 .LAZY FREEING</h2><p>redis删除key有两个方法</p><ol><li><code>DEL</code>，该命令是一个阻塞式。服务器停止处理新的命令，以便以同步方式回收与对象关联的所有内存，如果被删除的key与小对象相关联，则DEL命令需要时间和其他redis命令一样短，基本上属于O(1) or O(log_N)。相反，如果key关联的对象较大，则执行该命令所需时间较长。</li><li>非阻塞命令。<code>UNLINK (non blocking DEL)、FLUSHALL、FLUSHDB</code> 执行该操作需要常量的时间，其他线程会在后台增量的释放内存。</li></ol><p>上述的命令都是用户控制的，但是redis服务器在执行其他命令时可能会触发<code>DEL</code>或者<code>flush</code>，以下是几种常见的场景：</p><ol><li>由于最大内存策略，超过最大内存时为了给新数据提供内存，会删除key。</li><li>key过期而造成的删除。</li><li>由于存储一些已经存在的key而造成的删除。比如<code>RENAME</code>命令，可能会删除旧的key。</li><li>在主从复制期间，当副本与其主服务器执行完全重新同步时，将删除整个数据库的内容，以便加载刚刚传输的RDB文件。</li></ol><p>上述的四个操作删除操作都是阻塞式的，可以在配置文件中为每种情况配置非阻塞式的删除操作。</p><div class="hljs code-wrapper"><pre><code class="hljs pgsql">lazyfree-lazy-eviction <span class="hljs-keyword">no</span>lazyfree-lazy-expire <span class="hljs-keyword">no</span>lazyfree-lazy-<span class="hljs-keyword">server</span>-del <span class="hljs-keyword">no</span><span class="hljs-keyword">replica</span>-lazy-flush <span class="hljs-keyword">no</span></code></pre></div><h2 id="11-APPEND-ONLY-MODE-AOF方式持久化"><a href="#11-APPEND-ONLY-MODE-AOF方式持久化" class="headerlink" title="11. APPEND ONLY MODE(AOF方式持久化)"></a>11. APPEND ONLY MODE(AOF方式持久化)</h2><p>默认情况下，Redis以异步方式将数据集存储到磁盘上。这种模式在很多应用里已经足够好，但Redis进程出问题或断电时可能造成一段时间的写操作丢失(这取决于配置的save指令)。</p><p>AOF是一种提供了更可靠的替代持久化模式，例如使用默认的数据写入文件策略（参见后面的配置）。在遇到像服务器断电或单写情况下Redis自身进程出问题但操作系统仍正常运行等突发事件时，Redis能只丢失1秒的写操作。</p><p>AOF和RDB持久化能同时启动并且不会有问题。如果AOF开启，那么在启动时Redis将加载AOF文件，它更能保证数据的可靠性，如果aof文件损坏，则redis则会启动失败。</p><h3 id="开启AOF"><a href="#开启AOF" class="headerlink" title="开启AOF"></a>开启AOF</h3><p>可以通过以下方式开启AOF</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">appendonly</span> <span class="hljs-literal">yes</span></code></pre></div><h3 id="设置aof文件名"><a href="#设置aof文件名" class="headerlink" title="设置aof文件名"></a>设置aof文件名</h3><p>默认为<code>appendonly.aof</code></p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">appendfilename</span> <span class="hljs-string">&quot;appendonly.aof&quot;</span></code></pre></div><h3 id="设置备份数据到磁盘的频率"><a href="#设置备份数据到磁盘的频率" class="headerlink" title="设置备份数据到磁盘的频率"></a>设置备份数据到磁盘的频率</h3><p>fsync() 系统调用告诉操作系统把数据写到磁盘上，而不是等更多的数据进入输出缓冲区。有些操作系统会真的把数据马上刷到磁盘上；有些则会尽快去尝试这么做。</p><p>Redis支持三种不同的模式：</p><ol><li>no：不要立刻存储，只有在操作系统需要刷的时候再存储。比较快。</li><li>always：每次写操作都立刻写入到aof文件。慢，但是最安全。</li><li>everysec：每秒写一次。折中方案。</li></ol><p>默认的 “everysec” 通常来说能在速度和数据安全性之间取得比较好的平衡。</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">appendfsync</span> alwaysappendfsync everysecappendfsync <span class="hljs-literal">no</span></code></pre></div><h3 id="同步时重写"><a href="#同步时重写" class="headerlink" title="同步时重写"></a>同步时重写</h3><p>如果AOF的同步策略设置成 “always” 或者 “everysec”，并且后台的存储进程（后台存储或写入AOF 日志）会产生很多磁盘I/O开销。某些Linux的配置下会使Redis因为 fsync()系统调用而阻塞很久。注意，目前对这个情况还没有完美修正，甚至不同线程的 fsync() 会阻塞我们同步的write(2)调用。</p><p>为了缓解这个问题，可以用下面这个选项。它可以在 <code>BGSAVE</code> 或<code>BGREWRITEAOF</code> 处理时阻止<code>fsync()</code>。</p><p>这就意味着如果有子进程在进行保存操作，那么<code>Redis</code>就处于”不可同步”的状态。这实际上是说，在最差的情况下可能会丢掉30秒钟的日志数据。（默认<code>Linux</code>设定）</p><p>如果把这个设置成”yes”带来了延迟问题，保存持久数据的最安全的方式将下面命令设置为no，</p><div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-literal">no</span>-appendfsync-<span class="hljs-literal">on</span>-rewrite <span class="hljs-literal">no</span><span class="hljs-number">1</span></code></pre></div><h3 id="何时自动重写AOF文件"><a href="#何时自动重写AOF文件" class="headerlink" title="何时自动重写AOF文件"></a>何时自动重写AOF文件</h3><p>如果AOF日志文件增大到指定百分比，Redis能够通过 <code>BGREWRITEAOF</code> 自动重写AOF日志文件。</p><p>工作原理：Redis记住上次重写时AOF文件的大小（如果重启后还没有写操作，就直接用启动时的AOF大小）</p><p>这个基准大小和当前大小做比较。如果当前大小超过指定比例，就会触发重写操作。你还需要指定被重写日志的最小内存，这样有利于避免达到指定百分比但仍然很小的情况还要重写。</p><p>指定百分比为0时，会禁用AOF自动重写特性。</p><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">auto</span>-aof-rewrite-percentage <span class="hljs-number">100</span><span class="hljs-keyword">auto</span>-aof-rewrite-min-size <span class="hljs-number">64</span>mb</code></pre></div><h3 id="被截断的aof文件是否允许启动"><a href="#被截断的aof文件是否允许启动" class="headerlink" title="被截断的aof文件是否允许启动"></a>被截断的aof文件是否允许启动</h3><p>如果设置为yes，如果一个因异常被截断的AOF文件被redis启动时加载进内存，redis将会发送日志通知用户。如果设置为no，redis将会拒绝启动。此时需要用”redis-check-aof”工具修复文件。</p><div class="hljs code-wrapper"><pre><code class="hljs coffeescript">aof-load-truncated <span class="hljs-literal">yes</span></code></pre></div><h2 id="12-LUA脚本"><a href="#12-LUA脚本" class="headerlink" title="12. LUA脚本"></a>12. LUA脚本</h2><p>Lua脚本的最长执行时间（以毫秒为单位）</p><div class="hljs code-wrapper"><pre><code class="hljs maxima">lua-<span class="hljs-built_in">time</span>-<span class="hljs-built_in">limit</span> <span class="hljs-number">5000</span></code></pre></div><h2 id="13-REDIS-CLUSTER（REDIS集群）"><a href="#13-REDIS-CLUSTER（REDIS集群）" class="headerlink" title="13. REDIS CLUSTER（REDIS集群）"></a>13. REDIS CLUSTER（REDIS集群）</h2><h3 id="是否开启集群"><a href="#是否开启集群" class="headerlink" title="是否开启集群"></a>是否开启集群</h3><p>正常的Redis实例不会成为Redis集群的一部分。只有开启了以下选项，redis才能成为集群服务的一部分</p><div class="hljs code-wrapper"><pre><code class="hljs coffeescript">cluster-enabled <span class="hljs-literal">yes</span></code></pre></div><h3 id="设置集群的配置文件"><a href="#设置集群的配置文件" class="headerlink" title="设置集群的配置文件"></a>设置集群的配置文件</h3><p>每个集群节点都有一个集群配置文件，配置redis自动生成的集群配置文件名。确保同一系统中运行的各redis实例该配置文件不要重名。</p><div class="hljs code-wrapper"><pre><code class="hljs stata"><span class="hljs-keyword">cluster</span>-config-<span class="hljs-keyword">file</span> nodes-6379.<span class="hljs-keyword">conf</span>1</code></pre></div><h3 id="集群节点超时毫秒数。"><a href="#集群节点超时毫秒数。" class="headerlink" title="集群节点超时毫秒数。"></a>集群节点超时毫秒数。</h3><p>超时的节点将被视为不可用状态。</p><div class="hljs code-wrapper"><pre><code class="hljs crmsh">cluster-<span class="hljs-keyword">node</span><span class="hljs-title">-timeout</span> <span class="hljs-number">15000</span></code></pre></div><p>如果数据太旧，集群中的不可用master的slave节点会避免成为备用master。如果slave和master失联时间超过:</p><p><code>(node-timeout * slave-validity-factor) + repl-ping-slave-period</code>则不会被提升为master。</p><p><em>如node-timeout为30秒，slave-validity-factor为10, 默认default repl-ping-slave-period为10秒,失联时间超过310秒slave就不会成为master。</em></p><p>较大的slave-validity-factor值可能允许包含过旧数据的slave成为master，同时较小的值可能会阻止集群选举出新master</p><p>为了达到最大限度的高可用性，可以设置为0，即slave不管和master失联多久都可以提升为master</p><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">cluster</span>-<span class="hljs-keyword">replica</span>-validity-factor <span class="hljs-number">10</span></code></pre></div><h3 id="设置在工作slave为多少个的时候可以提升为master"><a href="#设置在工作slave为多少个的时候可以提升为master" class="headerlink" title="设置在工作slave为多少个的时候可以提升为master"></a>设置在工作slave为多少个的时候可以提升为master</h3><p>只有在之前master有其它指定数量的工作状态下的slave节点时，slave节点才能提升为master。默认为1（即该集群至少有3个节点，1 master＋2 slaves，master宕机，仍有另外1个slave的情况下其中1个slave可以提升）</p><p>测试环境可设置为0，生成环境中至少设置为1</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">cluster</span>-migration-barrier <span class="hljs-number">1</span></code></pre></div><h3 id="自动检测恢复机制"><a href="#自动检测恢复机制" class="headerlink" title="自动检测恢复机制"></a>自动检测恢复机制</h3><p>默认情况下如果redis集群如果检测到至少有1个hash slot不可用，集群将停止查询数据。</p><p>如果所有slot恢复则集群自动恢复。</p><p>如果需要剩余集群部分可用情况下仍可提供查询服务，设置为no。</p><div class="hljs code-wrapper"><pre><code class="hljs coffeescript">cluster-<span class="hljs-built_in">require</span>-full-coverage <span class="hljs-literal">yes</span></code></pre></div><h2 id="14-CLUSTER-DOCKER-NAT-support"><a href="#14-CLUSTER-DOCKER-NAT-support" class="headerlink" title="14. CLUSTER DOCKER/NAT support"></a>14. CLUSTER DOCKER/NAT support</h2><p>在某些部署中，Redis群集节点地址发现失败，因为地址是NAT或由于端口被转发（典型情况是Docker和其他容器）。</p><p>为了保证在这种环境下redis集群可用，一个静态配置使每个节点都需要知道它的公共地址。 以下两个选项用于此范围，并且是：</p><div class="hljs code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>cluster-announce-ip<span class="hljs-bullet">* </span>cluster-announce-port<span class="hljs-bullet">* </span>cluster-announce-bus-port</code></pre></div><p>如果未使用上述选项，则将使用正常的Redis群集自动检测。</p><p>请注意，重新映射时，总线端口可能不在固定偏移量处客户端端口+ 10000，因此您可以指定任何端口和总线端口如何重新映射它们。 如果未设置总线端口，则固定偏移量为通常会使用10000。</p><div class="hljs code-wrapper"><pre><code class="hljs bash">cluster-announce-ip 10.1.1.5cluster-announce-port 6379cluster-announce-bus-port 6380</code></pre></div><h2 id="15-慢查询日志-SLOW-LOG"><a href="#15-慢查询日志-SLOW-LOG" class="headerlink" title="15. 慢查询日志(SLOW LOG)"></a>15. 慢查询日志(SLOW LOG)</h2><p>慢查询日志记录超过特定时间的执行命令，执行时间不包括I/O操作的时间，比如：连接客户端、返回响应等等，而是命令真正的执行时间。<br>redis中慢查询日志配置参数包括两个，一个是判断Redis执行的时间，单位是微秒；另一个参数是慢查询日志记录的长度，类似于一个队列，新的记录被插入时会删除最老的日志。</p><ol><li>redis查询执行的时间。单位微秒</li></ol><div class="hljs code-wrapper"><pre><code class="hljs bash">slowlog-log-slower-than 10000</code></pre></div><ol><li>日志长度的大小。可以通过<code>SLOWLOG RESET</code>重置</li></ol><div class="hljs code-wrapper"><pre><code class="hljs bash">slowlog-max-len 128</code></pre></div><h2 id="16-LATENCY-MONITOR-延时监控"><a href="#16-LATENCY-MONITOR-延时监控" class="headerlink" title="16.LATENCY MONITOR(延时监控)"></a>16.LATENCY MONITOR(延时监控)</h2><p>系统仅记录在等于或大于通过指定的毫秒数量的时间内执行的操作latency-monitor-threshold配置指令。 当其值设置为零时，将关闭延迟监视器。</p><p>默认情况下关闭延时监控，</p><div class="hljs code-wrapper"><pre><code class="hljs bash">latency-monitor-threshold 0</code></pre></div><h2 id="17-EVENT-NOTIFICATION（事件通知）"><a href="#17-EVENT-NOTIFICATION（事件通知）" class="headerlink" title="17. EVENT NOTIFICATION（事件通知）"></a>17. EVENT NOTIFICATION（事件通知）</h2><p>主要是用于订阅与发布。</p><p>一旦key值发生变化时，Redis可以通知 Pub/Sub客户端。<br>如果键值空间通知开启时，可以通过Pub/Sub两种方式发布信息：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">PUBLISH __keyspace@0__:foo delPUBLISH __keyevent@0__:del foo</code></pre></div><p>可以在一组类中选择Redis进行事件的通知，每个类都由一个字符标识：</p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#  K     Keyspace events, published with __keyspace@&lt;db&gt;__ prefix.</span><span class="hljs-comment">#  E     Keyevent events, published with __keyevent@&lt;db&gt;__ prefix.</span><span class="hljs-comment">#  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...</span><span class="hljs-comment">#  $     String commands</span><span class="hljs-comment">#  l     List commands</span><span class="hljs-comment">#  s     Set commands</span><span class="hljs-comment">#  h     Hash commands</span><span class="hljs-comment">#  z     Sorted set commands</span><span class="hljs-comment">#  x     Expired events (events generated every time a key expires)</span><span class="hljs-comment">#  e     Evicted events (events generated when a key is evicted for maxmemory)</span><span class="hljs-comment">#  A     Alias for g$lshzxe, so that the &quot;AKE&quot; string means all the events.</span></code></pre></div><h2 id="18-ADVANCED-CONFIG-高级配置"><a href="#18-ADVANCED-CONFIG-高级配置" class="headerlink" title="18. ADVANCED CONFIG(高级配置)"></a>18. ADVANCED CONFIG(高级配置)</h2><p>当哈希值具有少量条目时，使用内存有效数据结构对哈希进行编码，并且最大条目不超过给定阈值。 可以使用以下指令配置这些阈值。</p><div class="hljs code-wrapper"><pre><code class="hljs bash">hash-max-ziplist-entries 512hash-max-ziplist-value 64</code></pre></div><p>列表也以特殊方式编码以节省大量空间。每个内部列表节点允许的条目数可以指定为固定的最大大小或最大元素数。<br>该值一般在-5到-1之间</p><div class="hljs code-wrapper"><pre><code class="hljs processing"><span class="hljs-number">-5</span>: <span class="hljs-built_in">max</span> <span class="hljs-built_in">size</span>: <span class="hljs-number">64</span> Kb  &lt;-- not recommended <span class="hljs-keyword">for</span> <span class="hljs-built_in">normal</span> workloads<span class="hljs-number">-4</span>: <span class="hljs-built_in">max</span> <span class="hljs-built_in">size</span>: <span class="hljs-number">32</span> Kb  &lt;-- not recommended<span class="hljs-number">-3</span>: <span class="hljs-built_in">max</span> <span class="hljs-built_in">size</span>: <span class="hljs-number">16</span> Kb  &lt;-- probably not recommended<span class="hljs-number">-2</span>: <span class="hljs-built_in">max</span> <span class="hljs-built_in">size</span>: <span class="hljs-number">8</span> Kb   &lt;-- good<span class="hljs-number">-1</span>: <span class="hljs-built_in">max</span> <span class="hljs-built_in">size</span>: <span class="hljs-number">4</span> Kb   &lt;-- good</code></pre></div><p>正数表示存储每个列表节点的_exactly_元素数</p><div class="hljs code-wrapper"><pre><code class="hljs bash">list-max-ziplist-size -2</code></pre></div><p>设置list是否被压缩</p><div class="hljs code-wrapper"><pre><code class="hljs bash">list-compress-depth 0</code></pre></div><p>不同数值的含义</p><div class="hljs code-wrapper"><pre><code class="hljs bash">0: 所有的list都不压缩1: depth 1 means <span class="hljs-string">&quot;don&#x27;t start compressing until after 1 node into the list,</span><span class="hljs-string">    going from either the head or tail&quot;</span>    So: [head]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[tail]    [head], [tail] will always be uncompressed; inner nodes will compress.2: [head]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[tail]    2 here means: don<span class="hljs-string">&#x27;t compress head or head-&gt;next or tail-&gt;prev or tail,</span><span class="hljs-string">    but compress all nodes between them.</span><span class="hljs-string">3: [head]-&gt;[next]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[prev]-&gt;[tail]</span></code></pre></div><p>设置set压缩参数</p><p>集合在下面情况下有一个特殊的编码：当一个集合只是在64位有符号整数范围内恰好是基数为10的整数的字符串时</p><div class="hljs code-wrapper"><pre><code class="hljs bash">set-max-intset-entries 512</code></pre></div><p>设置set多大时开启压缩</p><div class="hljs code-wrapper"><pre><code class="hljs bash">zset-max-ziplist-entries 128zset-max-ziplist-value 64</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>middle-component</category>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java bin</title>
    <link href="/2021/05/18/java-bin/"/>
    <url>/2021/05/18/java-bin/</url>
    
    <content type="html"><![CDATA[<h1 id="Java的bin等目录说明"><a href="#Java的bin等目录说明" class="headerlink" title="Java的bin等目录说明"></a><a href="">Java的bin等目录说明</a></h1><ul><li><strong>javac：</strong>Java编译器，将Java源代码换成字节代</li><li><strong>java：</strong>Java解释器，直接从类文件执行Java应用程序代码</li><li><strong>appletviewer(小程序浏览器)：</strong>一种执行HTML文件上的Java小程序类的Java浏览器</li><li><strong>javadoc：</strong>根据Java源代码及其说明语句生成的HTML文档</li><li><strong>jdb：</strong>Java调试器，可以逐行地执行程序、设置断点和检查变量</li><li><strong>javah：</strong>产生可以调用Java过程的C过程，或建立能被Java程序调用的C过程的头文件</li><li><strong>Javap：</strong>Java反汇编器，显示编译类文件中的可访问功能和数据，同时显示字节代码含义</li><li><strong>jar：</strong>多用途的存档及压缩工具，是个java应用程序，可将多个文件合并为单个JAR归档文件。</li><li><strong>htmlConverter</strong>——命令转换工具。</li><li><strong>native2ascii</strong>——将含有不是Unicode或Latinl字符的的文件转换为Unicode编码字符的文件。</li><li><strong>serialver</strong>——返回serialverUID。语法：serialver [show] 命令选项show是用来显示一个简单的界面。输入完整的类名按Enter键或”显示”按钮，可显示serialverUID。</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash">补充详细：**javac.exe**用法：javac &lt;选项&gt; &lt;源文件&gt;可能的选项包括：-g 生成所有调试信息-g:none 生成无调试信息-g:&#123;lines,vars,<span class="hljs-built_in">source</span>&#125; 生成只有部分调试信息-O 优化；可能妨碍调试或者增大类文件-nowarn 生成无警告-verbose 输出关于编译器正在做的信息-deprecation 输出使用了不鼓励使用的API的源程序位置-classpath &lt;路径&gt; 指定用户类文件的位置-sourcepath &lt;路径&gt; 指定输入源文件的位置-bootclasspath &lt;路径&gt; 覆盖自举类文件的位置-extdirs &lt;目录(多个)&gt; 覆盖安装的扩展类的位置-d &lt;目录&gt; 指定输出类文件的位置-encoding &lt;编码&gt; 指定源文件中所用的字符集编码-target &lt;版本&gt; 生成指定虚拟机版本的类文件-<span class="hljs-built_in">help</span> Print a synopsis of standard options</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs bash">**appletviewer.exe**用法：appletviewer &lt;options&gt; url其中，&lt;options&gt; 包括：-debug 在 Java 调试器中启动 applet 小程序查看器-encoding &lt;encoding&gt; 指定由 HTML 文件使用的字符编码-J&lt;runtime flag&gt; 向 Java 解释器传递参数-J 选项不是标准选项，如有更改，不另行通知。</code></pre></div><p>====================</p><div class="hljs code-wrapper"><pre><code class="hljs bash">**jar.exe**用法：jar &#123;ctxu&#125;[vfm0M] [jar-文件] [manifest-文件] [-C 目录] 文件名 ...选项：-c 创建新的存档-t 列出存档内容的列表-x 展开存档中的命名的（或所有的〕文件-u 更新已存在的存档-v 生成详细输出到标准输出上-f 指定存档文件名-m 包含来自标明文件的标明信息-0 只存储方式；未用ZIP压缩格式-M 不产生所有项的清单（manifest〕文件-i 为指定的jar文件产生索引信息-C 改变到指定的目录，并且包含下列文件：如果一个文件名是一个目录，它将被递归处理。清单（manifest〕文件名和存档文件名都需要被指定，按<span class="hljs-string">&#x27;m&#x27;</span> 和 <span class="hljs-string">&#x27;f&#x27;</span>标志指定的相同顺序。示例1：将两个class文件存档到一个名为 <span class="hljs-string">&#x27;classes.jar&#x27;</span> 的存档文件中：jar cvf classes.jar Foo.class Bar.class示例2：用一个存在的清单（manifest）文件 <span class="hljs-string">&#x27;mymanifest&#x27;</span> 将 foo/ 目录下的所有文件存档到一个名为 <span class="hljs-string">&#x27;classes.jar&#x27;</span> 的存档文件中：jar cvfm classes.jar mymanifest -C foo/ .</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs bash">**javadoc.exe**用法：javadoc [options] [packagenames] [sourcefiles] [classnames] [@files]-overview &lt;file&gt; 读取 HTML 格式的概述文档-public 仅显示 public 类和成员-protected 显示 protected/public 类和成员（缺省）-package 显示 package/protected/public 类和成员-private 显示所有类和成员-<span class="hljs-built_in">help</span> 显示命令行选项-doclet &lt;class&gt; 通过候选 doclet 生成输出-docletpath &lt;path&gt; 指定 doclet 类文件的查找位置-sourcepath &lt;pathlist&gt; 指定源文件的查找位置-classpath &lt;pathlist&gt; 指定用户类文件的查找位置-exclude &lt;pkglist&gt; Specify a list of packages to exclude-subpackages &lt;subpkglist&gt; Specify subpackages to recursively load-breakiterator Compute 1st sentence with BreakIterator-bootclasspath &lt;pathlist&gt; 覆盖自举类加载器所加载的类文件的位置-<span class="hljs-built_in">source</span> &lt;release&gt; Provide <span class="hljs-built_in">source</span> compatibility with specified release-extdirs &lt;dirlist&gt; 覆盖已安装的扩展的位置-verbose 有关 Javadoc 所做工作的输出信息-locale &lt;name&gt; 所用的 Locale，例如 en_US 或 en_US_WIN-encoding &lt;name&gt; 源文件编码名称-J&lt;flag&gt; 将 &lt;flag&gt; 直接传给运行时系统</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs bash">由标准 doclet 提供：-d &lt;directory&gt; 输出文件的目标目录-use 创建类和包的用法页-version 包含 @version 段-author 包含 @author 段-docfilessubdirs Recursively copy doc-file subdirectories-splitindex 将索引分为每个字母对应一个文件-windowtitle &lt;text&gt; 文档的浏览器窗口标题-doctitle &lt;html-code&gt; 包含包索引页（首页）的标题-header &lt;html-code&gt; 包含每一页的页眉文本-footer &lt;html-code&gt; 包含每一页的页脚文本-bottom &lt;html-code&gt; 包含每一页的页底文本-link &lt;url&gt; Create links to javadoc output at &lt;url&gt;-linkoffline &lt;url&gt; &lt;url2&gt; Link to docs at &lt;url&gt; using package list at &lt;url2&gt;-excludedocfilessubdir &lt;name1&gt;:.. Exclude any doc-files subdirectories with given name.-group &lt;name&gt; &lt;p1&gt;:&lt;p2&gt;.. Group specified packages together <span class="hljs-keyword">in</span> overview page-nocomment Supress description and tags, generate only declarations.-nodeprecated 不包含 @deprecated 信息-noqualifier &lt;name1&gt;:&lt;name2&gt;:... Exclude the list of qualifiers from the output.-nosince Do not include @since information-nodeprecatedlist 不生成不鼓励使用的列表-notree 不生成类层次-noindex 不生成索引-nohelp 不生成帮助链接-nonavbar 不生成导航栏-quiet Do not display status messages to screen-serialwarn Generate warning about @serial tag-tag &lt;name&gt;:&lt;locations&gt;:&lt;header&gt; Specify single argument custom tags-taglet The fully qualified name of Taglet to register-tagletpath The path to Taglets-charset &lt;charset&gt; Charset <span class="hljs-keyword">for</span> cross-platform viewing of generated documentation.-helpfile &lt;file&gt; 包含帮助链接功能链接到目标的文件-linksource Generate <span class="hljs-built_in">source</span> <span class="hljs-keyword">in</span> HTML-stylesheetfile &lt;path&gt; 改变所生成文档的样式的文件-docencoding &lt;name&gt; 输出编码名称</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs bash"> **javah.exe**用法：javah [options] &lt;classes&gt;其中 [options] 包括：-<span class="hljs-built_in">help</span> 打印该帮助信息-classpath &lt;path&gt; 类的加载路径-bootclasspath &lt;path&gt; 自举类的加载路径-d &lt;dir&gt; 输出目录-o &lt;file&gt; 输出文件（仅能使用 -d 或 -o 之一）-jni 生成 JNI 风格的头文件（缺省）-old 生成 JDK1.0 风格的头文件-stubs 生成 stubs 文件-version 打印版本信息-verbose 输出有关本命令所做工作的信息-force 始终写输出文件指定 &lt;classes&gt; 时必须使用全名（例如 java.lang.Object）。</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs bash">**javaw.exe**====================HtmlConverter.exe用法：HtmlConverter [-option1 value1 [-option2 value2 [...]]] [-simulate] [filespecs]其中，选项包括：-<span class="hljs-built_in">source</span>: 获取源文件的路径。 缺省值： &lt;userdir&gt;-dest: 写入已转换文件的路径。 缺省值： &lt;userdir&gt;-backup: 写备份文件的路径。 缺省值： &lt;dirname&gt;_BAK-f: 强制覆写备份文件。-subdirs: 应处理子目录中的文件。-template: 模板文件的路径。 如果不确定，请使用缺省值。-<span class="hljs-built_in">log</span>: 写日志的路径。 如果没有提供，则不会写入任何日志。-progress: 转换时显示进度。 缺省值： <span class="hljs-literal">true</span>-simulate: 在没有进行转换时显示特定于转换的信息。-latest: 使用最新的 JRE 支持发行版 mimetype。-gui: 显示转换程序的图形用户界面。filespecs: 用空格分开的文件说明列表。 缺省值： <span class="hljs-string">&quot;*.html *.htm&quot;</span> （需要引号）</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs bash">**orbd.exe**用法：orbd &lt;选项&gt;其中，&lt;选项&gt; 包括：-port 启动 ORBD 的激活端口，缺省值为 1049 (可选)-defaultdb ORBD 文件的目录，缺省值为 <span class="hljs-string">&quot;./orb.db&quot;</span> (可选)-serverid ORBD 的服务器标识符，缺省值为 1 (可选)-ORBInitialPort 初始端口（必需）-ORBInitialHost 初始主机名称（必需）====================policytool.exe用法：policytool [选项][-file &lt;file&gt;] 规则文件位置====================rmic.exe用法：rmic &lt;选项&gt; &lt;类名&gt;其中 &lt;选项&gt; 包括：-keep 不删除中间生成的源文件-keepgenerated （同 <span class="hljs-string">&quot;-keep&quot;</span>)-v1.1 为 1.1 stub 协议版本创建 stubs/skeleton-vcompat （缺省）创建与 1.1 和1.2 stub 协议版本兼容的 stubs/skeleton-v1.2 仅为 1.2 stub 协议版本创建 stubs-iiop 为 IIOP 创建 stubs。当使用该选项时，&lt;选项&gt;还应包括：-always 总创建 stubs （即使在它们同时出现时〕-alwaysgenerate (同 <span class="hljs-string">&quot;-always&quot;</span>)-nolocalstubs 不创建为同一进程优化的 stubs-idl 创建 IDL。当使用该选项时，&lt;选项&gt;还应包括：-noValueMethods 不生成值类型的方法-always 总创建 IDL （即使在它们同时出现时〕-alwaysgenerate (同 <span class="hljs-string">&quot;-always&quot;</span>)-g 一般调试信息-depend 以递归方式重编译过期的文件-nowarn 不警告-nowrite 不将编译过的类写入到文件系统-verbose 输出有关编译器所做工作的信息-classpath &lt;path&gt; 指定输入源和类文件的查找位置-sourcepath &lt;path&gt; 指定用户源文件的查找位置-bootclasspath &lt;path&gt; 覆盖自举类文件的位置-extdirs &lt;path&gt; 覆盖安装扩展类的位置-d &lt;directory&gt; 指定所生成类文件的放置位置-J&lt;runtime flag&gt; 将参数传给 java 解释程序====================**rmid.exe**用法：rmid &lt;option&gt;其中，&lt;option&gt; 包括:-port &lt;option&gt; 指定供 rmid 使用的端口-<span class="hljs-built_in">log</span> &lt;directory&gt; 指定 rmid 将日志写入的目录-stop 停止当前的 rmid 调用（对指定端口）-C&lt;runtime 标记&gt; 向每个子进程传递参数（激活组）-J&lt;runtime 标记&gt; 向 java 解释程序传递参数====================rmiregistry.exe用法： rmiregistry &lt;选项&gt; &lt;端口&gt;其中，&lt;选项&gt; 包括：-J&lt;runtime 标记&gt; 将参数传递到 java 解释程序====================serialver.exe用法：serialver [-classpath classpath] [-show] [classname...]====================**servertool.exe**欢迎使用 Java IDL 服务器工具请在提示处输入命令servertool &gt; <span class="hljs-built_in">help</span>可用命令：\-------------------register - 注册一个可激活的服务器unregister - 取消服务器注册getserverid - 返回应用程序名称的服务器标识符list - 列举所有已注册服务器listappnames - 列举当前定义的应用程序名称listactive - 列举当前活动的服务器locate - 将已注册服务器定位在特定类型的端口locateperorb - 为已注册服务器的特定对象请求代理程序定位端口。orblist - 对象请求代理程序 (orb) 名称及其映射列表shutdown - 关闭一个已注册服务器startup - 启动一个已注册服务器<span class="hljs-built_in">help</span> - 取得帮助</code></pre></div><h2 id="quit-退出此工具"><a href="#quit-退出此工具" class="headerlink" title="quit - 退出此工具"></a>quit - 退出此工具</h2><div class="hljs code-wrapper"><pre><code class="hljs bash">**rmic**功能说明：rmic 为远程对象生成 stub 和 skeleton。语法：rmic [ options ] package-qualified-class-name(s)补充说明：rmic 编译器根据编译后的 Java 类（含有远程对象实现）名，为远程对象生成 stub 和 skeleton（远程对象是指实现 java.rmi.Remote 接口的对象）。在 rmic 命令中所给的类必须是经 javac 命令成功编译且是完全包限定的类。命令选项-classpath[路径] 指定 rmic 用于查询类的路径。如果设置了该选项，它将覆盖缺省值或 CLASSPATH 环境变量。目录用冒号分隔。-d[目录] 指定类层次的根目录。此选项可用来指定 stub 和 skeleton 文件的目标目录。-depend 使编译器考虑重新编译从其它类引用的类。 一般来说，它只重新编译从源代码引用的遗漏或过期的类。-g 允许生成调试表格。调试表格含有行号和局部变量的有关信息，即 Java 调试工具所使用的信息。缺省情况下，只生成行号。-J 与 -D 选项联用，它将紧跟其后的选项（ -J 与 -D 之间无空格）传给 java 解释器。-keepgenerated 为 stub 和 skeleton 文件保留所生成的 .java 源文件，并将这些源文件写到与 .class 文件相同的目录中，如果要指定目录，则使用 -d 选项。-nowarn 关闭警告。如果使用该选项，则编译器不输出任何警告信息。-show 显示 rmic 编译器的 GUI（图形用户界面）。输入一个或多个包限定类名（以空格分隔），并按回车键或“显示”按钮，创建 stub 和 skeleton。-vcompat （缺省值）创建与 JDK 1.1 和 1.2 stub 协议版本都兼容的 stub 和 skeleton。-verbose 使编译器和链接器输出关于正在编译哪些类和正在加载哪些类文件的信息。-v1.1 创建 JDK 1.1 stub 协议版本的 stub 和 skeleton。-v1.2 只创建 JDK 1.2 stub 协议版本的 stub。=================================rmid功能说明：rmid 启动激活系统守护进程，以便能够在 Java 虚拟机上注册和激活对象。语法：rmid [-port port] [-<span class="hljs-built_in">log</span> dir]补充说明：rmid 工具启动激活系统守护进程。必须先启动激活系统守护进程，才能向激活系统注册可被激活的对象或在 Java 虚拟机上激活可被激活的对象。命令选项-C&lt;某些命令行选项&gt; 指定一个选项，在创建每个 rmid 的子守护进程（激活组）时，该选项以命令行参数的形式传给该子守护进程。-<span class="hljs-built_in">log</span>[目录] 指定目录的名称，激活系统守护进程在该目录中写入其数据库及相关信息。缺省状态下，将在执行 rmid 命令的目录中创建一个 <span class="hljs-built_in">log</span> 目录。-port[端口] 指定 rmid 的注册服务程序所使用的端口。激活系统守护进程将 ActivationSystem 与该注册服务程序中的名称java.rmi.activation.ActivationSystem 捆绑在一起。-stop 停止 -port 选项所指定端口上的当前 rmid 调用。若未指定端口，则将停止在端口 1098 上运行的 rmid。=============================rmiregistry功能说明：rmiregistry 命令可在当前主机的指定端口上启动远程对象注册服务程序。语法：rmiregistry [port]补充说明：rmiregistry 命令在当前主机的指定 port 上创建并启动远程对象注册服务程序。如果省略 port，则注册服务程序将在 1099 端口上启动。rmiregistry 命令不产生任何输出而且一般在后台运行。远程对象注册服务程序是自举命名服务。主机上的 RMI 服务器将利用它将远程对象绑定到名字上。客户机即可查询远程对象并进行远程方法调用。注册服务程序一般用于定位应用程序需调用其方法的第一个远程对象。该对象反过来对各应用程序提供相应的支持，用于查找其它对象。java.rmi.registry.LocateRegistry 类的方法可用于在某台主机或主机和端口上获取注册服务程序操作。java.rmi.Naming 类的基于 URL 的方法将对注册服务程序进行操作，并可用于查询远程对象、将简单（字符串）名称绑定到远程对象、将新名称重新绑定到远程对象（覆盖旧绑定）、取消远程对象的绑定以及列出绑定在注册服务程序上的 URL。=============================serialver功能说明：serialver 命令返回 serialVersionUID。语法：serialver [ 命令选项 ]补充说明：serialver 以适于复制到演变类的形式返回一个或多个类的 serialVersionUID。不带参数调用时，它输出用法行。命令选项-show 显示一个简单的用户界面。输入完整的类名并按回车键或“显示”按钮可显示 serialVersionUID。================================jarsigner功能说明：为 Java 归档 (JAR) 文件产生签名，并校验已签名的 JAR 文件的签名。语法：jarsigner [ 命令选项 ] jar-file <span class="hljs-built_in">alias</span>jarsigner -verify [ 命令选项 ] jar-file补充说明：jarsigner 工具用于两个目的：1:为 Java 归档 (JAR) 文件签名2:校验已签名的 JAR 文件的签名和完整性命令选项-keystore[url] 指定密钥仓库的 URL。缺省值是用户的宿主目录中的 .keystore 文件，它由系统属性“user.home”决定。-storetype[storetype] 指定要被实例化的密钥仓库类型。默认的密钥仓库类型是安全属性文件中 <span class="hljs-string">&quot;keystore.type&quot;</span> 属性值所指定的那个类型，由 java.security.KeyStore 中的静态方法 getDefaultType 返回。-storepass[password] 指定访问密钥仓库所需的口令。这仅在签名（不是校验）JAR 文件时需要。在这种情况下，如果命令行中没有提供 -storepass 选项，用户将被提示输入口令。-keypass[password] 指定用于保护密钥仓库项（由命令行中指定的别名标出）的私钥的口令。使用 jarsigner 为 JAR 文件签名时需要该口令。如果命令行中没有提供口令，且所需的口令与密钥仓库的口令不同，则将提示用户输入它。-sigfile[file] 指定用于生成 .SF 和 .DSA 文件的基本文件名。-signedjar[file] 指定用于已签名的 JAR 文件的名称。-verify 如果它出现在命令行中，则指定的 JAR 文件将被校验，而不是签名。如果校验成功，将显示“jar verified”。如果试图校验未签名的 JAR 文件，或校验被不支持的算法（例如未安装 RSA 提供者时使用的 RSA）签名的 JAR 文件，则将有如下显示： <span class="hljs-string">&quot;jar is unsigned. (signatures missing or not parsable)&quot;</span> 。-certs 如果它与 -verify 和 -verbose 选项一起出现在命令行中，则输出将包括 JAR 文件的每个签名人的证书信息。-verbose 如果它出现在命令行中，则代表“verbose”模式，它使 jarsigner 在 JAR 签名或校验过程中输出额外信息。-internalsf 过去，JAR 文件被签名时产生的 .DSA（签名块）文件包含一个同时产生的 .SF 文件（签名文件）的完整编码副本。这种做法已被更改。为了减小输出 JAR 文件的整个大小，缺省情况下 .DSA 文件不再包含 .SF 文件的副本。但是如果 -internalsf 出现在命令行中，将采用旧的做法。该选项主要在测试时有用；实际上不应使用它，因为这样将消除有用的优化。-sectionsonly 如果它出现在命令行中，则 JAR 文件被签名时生成的 .SF 文件（签名文件）将不包括含有整个清单文件的散列的头。它仅包含 与 JAR 中每个单独的源文件相关的信息和散列。该选项主要在测试时有用；实际上不应使用它，因为这样将消除有用的优化。-J[javaoption] 将指定的 javaoption 串直接传递到 Java 解释器。(（jarsigner 实际上是解释器的一个 “wrapper”）。该选项不应含有任何空格。它有助于调整执行环境或内存使用。要获得可用的解释器选项的清单，可在命令行键入 java -h 或 java -X。========================keytool功能说明：管理由私钥和认证相关公钥的 X.509 证书链组成的密钥仓库（数据库）。还管理来自可信任实体的证书。语法：keytool [ 命令 ]补充说明：keytool 是个密钥和证书管理工具。它使用户能够管理自己的公钥/私钥对及相关证书，用于（通过数字签名）自我认证（用户向别的用户/服务认证自己）或数据完整性以及认证服务。它还允许用户储存他们的通信对等者的公钥（以证书形式）。=======================native2ascii功能说明：将含有本地编码字符（既非 Latin1 又非 Unicode 字符）的文件转换为 Unicode 编码字符的文件。语法：native2ascii [options] [inputfile [outputfile]]补充说明：Java 编译器和其它 Java 工具只能处理含有 Latin-1 和/或 Unicode 编码（udddd 记号）字符的文件。native2ascii 将含有其它字符编码的文件转换成含 Latin-1 和/或 Unicode 编码字符的文件。若省略 outputfile，则使用标准输出设备输出。此外，如果也省略 inputfile，则使用标准输入设备输入。命令选项-reverse 执行相反的操作：将含 Latin-1 和/或 Unicode 编码字符的文件转换成含本地编码字符的文件。-encoding[encoding_name] 指定转换过程使用的编码名称。缺省的编码从系统属性 file.encoding 中得到。=======================appletviewer功能说明：Java applet 浏览器。appletviewer 命令可在脱离万维网浏览器环境的情况下运行 applet。语法：appletviewer [ threads flag ] [ 命令选项 ] urls ...补充说明：appletviewer 命令连接到 url 所指向的文档或资源上，并在其自身的窗口中显示文档引用的每个 applet。注意：如果 url 所指向的文档不引用任何带有 OBJECT、EMBED 或 APPLET 标记的 applet，那么 appletviewer 就不做任何事情。命令选项-debug 在 Java 调试器 jdb 中启动 appletviewer，使您可以调试文档中的 applet。-encoding[编码名称] 指定输入 HTML 文件的编码名称。-J[javaoption] 将 javaoption 字符串作为单个参数传给运行 appletviewer 的 Java 解释器。参数不能含有空格。由多重参数组成的字符串，其中的每个参数都必须以前缀 -J 开头，该前缀以后将被除去。这在调整编译器的执行环境或内存使用时将很有用。=========================extcheck功能说明：extcheck 检测目标 jar 文件与当前安装方式扩展 jar 文件间的版本冲突。语法：extcheck [ -verbose ] targetfile.jar补充说明：extcheck 实用程序检查指定 Jar 文件的标题和版本与 JDK TM 软件中所安装的扩展是否有冲突。在安装某个扩展前，可以用该实用程序查看是否已安装了该扩展的相同版本或更高的版本。extcheck 实用程序将 targetfile.jar 文件清单的 specification-title 和 specification-version 头与当前安装在扩展目录下所有 Jar 文件的相对应的头进行比较（缺省扩展目录为 jre/lib/ext）。extcheck 实用程序比较版本号的方式与 java.lang.Package.isCompatibleWith 方法相同。若未检测到冲突，则返回代码为 0。如果扩展目录中任何一个 jar 文件的清单有相同的 specification-title 和相同的或更新的 specification-version 号，则返回非零错误代码。如果 targetfile.jar 的清单中没有 specification-title 或 specification-version 属性，则同样返回非零错误代码。命令选项-verbose 对扩展目录中的 Jar 文件进行检查时，列出文件。此外，还报告目标 jar 文件的清单属性及所有冲突的 jar 文件。=====================jar功能说明：Java归档工具语法：jar [ 命令选项 ] [manifest] destination input-file [input-files]补充说明：jar工具是个java应用程序，可将多个文件合并为单个JAR归档文件。jar是个多用途的存档及压缩工具，它基于ZIP和ZLIB压缩格式。然而，设计jar的主要目的是便于将java applet或应用程序打包成单个归档文件。将applet或应用程序的组件(.class 文件、图像和声音)合并成单个归档文件时，可以用java代理(如浏览器)在一次HTTP事务处理过程中对它们进行下载，而不是对每个组件都要求一个新连接。这大大缩短了下载时间。jar还能压缩文件，从而进一步提高了下载速度。此外，它允许applet的作者对文件中的各个项进行签名，因而可认证其来源。jar工具的语法基本上与tar命令的语法相同。命令选项-c 在标准输出上创建新归档或空归档。-t 在标准输出上列出内容表。-x[file] 从标准输入提取所有文件，或只提取指定的文件。如果省略了file，则提取所有文件；否则只提取指定文件。-f 第二个参数指定要处理的jar文件。在-c(创建)情形中，第二个参数指的是要创建的jar文件的名称(不是在标准输出上)。在-t(表(或-x(抽取)这两种情形中，第二个参数指定要列出或抽取的jar文件。-v 在标准错误输出设备上生成长格式的输出结果。-m 包括指定的现有清单文件中的清单信息。用法举例：“jar cmf myManifestFile myJarFile *.class”-0 只储存，不进行 ZIP 压缩。-M 不创建项目的清单文件。-u 通过添加文件或更改清单来更新现有的 JAR 文件。例如：“jar -uf foo.jar foo.class”将文件 foo.class 添加到现有的JAR文件foo.jar中，而“jar umf manifest foo.jar”则用manifest中的信息更新foo.jar的清单。-C 在执行 jar 命令期间更改目录。例如：“jar -uf foo.jar -C classes *”将classes目录内的所有文件加到foo.jar中，但不添加类目录本身。程序示例1:将当前目录下所有CLASS文件打包成新的JAR文件：jar cf file.jar *.class2:显示一个JAR文件中的文件列表jar tf file.jar3:将当前目录下的所有文件增加到一个已经存在的JAR文件中jar cvf file.jar *========================javadoc功能说明Java API文档生成器从Java源文件生成API文档HTML页。语法：javadoc [ 命令选项 ] [ 包名 ] [ 源文件名 ] [ @files ]其中[ 包名 ]为用空格分隔的一系列包的名字，包名不允许使用通配符，如（*）。[ 源文件名 ]为用空格分</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>javabin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java-bin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java-线程池</title>
    <link href="/2021/05/18/java-thread-pool/"/>
    <url>/2021/05/18/java-thread-pool/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA-线程池"><a href="#JAVA-线程池" class="headerlink" title="JAVA 线程池"></a>JAVA 线程池</h1><p>在《阿里巴巴java开发手册》中指出了线程资源必须通过线程池提供，不允许在应用中自行显示的创建线程，这样一方面是线程的创建更加规范，可以合理控制开辟线程的数量；另一方面线程的细节管理交给线程池处理，优化了资源的开销。而线程池不允许使用Executors去创建，而要通过ThreadPoolExecutor方式，这一方面是由于jdk中Executor框架虽然提供了如newFixedThreadPool()、newSingleThreadExecutor()、newCachedThreadPool()等创建线程池的方法，但都有其局限性，不够灵活；另外由于前面几种方法内部也是通过ThreadPoolExecutor方式实现，使用ThreadPoolExecutor有助于大家明确线程池的运行规则，创建符合自己的业务场景需要的线程池，避免资源耗尽的风险。</p><p>下面我们就对ThreadPoolExecutor的使用方法进行一个详细的概述。</p><blockquote><p>首先看下ThreadPoolExecutor的构造函数</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">long</span> keepAliveTime,</span></span><span class="hljs-function"><span class="hljs-params">                          TimeUnit unit,</span></span><span class="hljs-function"><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><span class="hljs-function"><span class="hljs-params">                          ThreadFactory threadFactory,</span></span><span class="hljs-function"><span class="hljs-params">                          RejectedExecutionHandler handler)</span> </span>&#123;    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||        maximumPoolSize &lt; corePoolSize ||        keepAliveTime &lt; <span class="hljs-number">0</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-keyword">null</span> || threadFactory == <span class="hljs-keyword">null</span> || handler == <span class="hljs-keyword">null</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    <span class="hljs-keyword">this</span>.acc = System.getSecurityManager() == <span class="hljs-keyword">null</span> ?            <span class="hljs-keyword">null</span> :            AccessController.getContext();    <span class="hljs-keyword">this</span>.corePoolSize = corePoolSize;    <span class="hljs-keyword">this</span>.maximumPoolSize = maximumPoolSize;    <span class="hljs-keyword">this</span>.workQueue = workQueue;    <span class="hljs-keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);    <span class="hljs-keyword">this</span>.threadFactory = threadFactory;    <span class="hljs-keyword">this</span>.handler = handler;&#125;</code></pre></div><p>构造函数的参数含义如下：</p><blockquote><p><strong>corePoolSize:指定了线程池中的线程数量，它的数量决定了添加的任务是开辟新的线程去执行，还是放到*<em>workQueue任务队列中去；*</em></strong></p><p><strong>maximumPoolSize:指定了线程池中的最大线程数量，这个参数会根据你使用的*<em>workQueue任务队列的类型，决定线程池会开辟的最大线程数量；*</em></strong></p><p><strong>keepAliveTime:当线程池中空闲线程数量超过corePoolSize时，多余的线程会在多长时间内被销毁；</strong></p><p><strong>unit:keepAliveTime的单位</strong></p><p><strong>workQueue:任务队列，被添加到线程池中，但尚未被执行的任务；它一般分为直接提交队列、有界任务队列、无界任务队列、优先任务队列几种；</strong></p><p><strong>threadFactory:线程工厂，用于创建线程，一般用默认即可；</strong></p><p><strong>handler:拒绝策略；当任务太多来不及处理时，如何拒绝任务；</strong></p></blockquote><p>接下来我们对其中比较重要参数做进一步的了解：</p><p>一、<strong>workQueue任务队列</strong></p><p>上面我们已经介绍过了，<strong>它一般分为直接提交队列、有界任务队列、无界任务队列、优先任务队列；</strong></p><p>1、<strong>直接提交队列</strong>：设置为SynchronousQueue队列，SynchronousQueue是一个特殊的BlockingQueue，它没有容量，没执行一个插入操作就会阻塞，需要再执行一个删除操作才会被唤醒，反之每一个删除操作也都要等待对应的插入操作。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPool</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ExecutorService pool;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">( String[] args )</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-comment">//maximumPoolSize设置为2 ，拒绝策略为AbortPolic策略，直接抛出异常</span>        pool = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS, <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),Executors.defaultThreadFactory(),<span class="hljs-keyword">new</span> ThreadPoolExecutor.AbortPolicy());        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++) &#123;            pool.execute(<span class="hljs-keyword">new</span> ThreadTask());        &#125;       &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadTask</span><span class="hljs-params">()</span> </span>&#123;            &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(Thread.currentThread().getName());    &#125;&#125;</code></pre></div><p>输出结果为</p><div class="hljs code-wrapper"><pre><code class="hljs java">pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.util.concurrent.RejectedExecutionException: Task com.hhxx.test.ThreadTask@55f96302 rejected from java.util.concurrent.ThreadPoolExecutor@3d4eac69[Running, pool size = <span class="hljs-number">2</span>, active threads = <span class="hljs-number">0</span>, queued tasks = <span class="hljs-number">0</span>, completed tasks = <span class="hljs-number">2</span>]    at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(Unknown Source)    at java.util.concurrent.ThreadPoolExecutor.reject(Unknown Source)    at java.util.concurrent.ThreadPoolExecutor.execute(Unknown Source)    at com.hhxx.test.ThreadPool.main(ThreadPool.java:<span class="hljs-number">17</span>)</code></pre></div><p>可以看到，当任务队列为SynchronousQueue，创建的线程数大于maximumPoolSize时，直接执行了拒绝策略抛出异常。</p><p>使用SynchronousQueue队列，提交的任务不会被保存，总是会马上提交执行。如果用于执行任务的线程数量小于maximumPoolSize，则尝试创建新的进程，如果达到maximumPoolSize设置的最大值，则根据你设置的handler执行拒绝策略。因此这种方式你提交的任务不会被缓存起来，而是会被马上执行，在这种情况下，你需要对你程序的并发量有个准确的评估，才能设置合适的maximumPoolSize数量，否则很容易就会执行拒绝策略；</p><p>2、<strong>有界的任务队列</strong>：有界的任务队列可以使用ArrayBlockingQueue实现，如下所示</p><div class="hljs code-wrapper"><pre><code class="hljs java">pool = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS, <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">10</span>),Executors.defaultThreadFactory(),<span class="hljs-keyword">new</span> ThreadPoolExecutor.AbortPolicy());</code></pre></div><p>使用ArrayBlockingQueue有界任务队列，若有新的任务需要执行时，线程池会创建新的线程，直到创建的线程数量达到corePoolSize时，则会将新的任务加入到等待队列中。若等待队列已满，即超过ArrayBlockingQueue初始化的容量，则继续创建线程，直到线程数量达到maximumPoolSize设置的最大线程数量，若大于maximumPoolSize，则执行拒绝策略。在这种情况下，线程数量的上限与有界任务队列的状态有直接关系，如果有界队列初始容量较大或者没有达到超负荷的状态，线程数将一直维持在corePoolSize以下，反之当任务队列已满时，则会以maximumPoolSize为最大线程数上限。</p><p>3、<strong>无界的任务队列</strong>：有界任务队列可以使用LinkedBlockingQueue实现，如下所示</p><div class="hljs code-wrapper"><pre><code class="hljs java">pool = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS, <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),Executors.defaultThreadFactory(),<span class="hljs-keyword">new</span> ThreadPoolExecutor.AbortPolicy());</code></pre></div><p>使用无界任务队列，线程池的任务队列可以无限制的添加新的任务，而线程池创建的最大线程数量就是你corePoolSize设置的数量，也就是说在这种情况下maximumPoolSize这个参数是无效的，哪怕你的任务队列中缓存了很多未执行的任务，当线程池的线程数达到corePoolSize后，就不会再增加了；若后续有新的任务加入，则直接进入队列等待，当使用这种任务队列模式时，一定要注意你任务提交与处理之间的协调与控制，不然会出现队列中的任务由于无法及时处理导致一直增长，直到最后资源耗尽的问题。</p><p>4<strong>、优先任务队列：</strong>优先任务队列通过PriorityBlockingQueue实现，下面我们通过一个例子演示下</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPool</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ExecutorService pool;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">( String[] args )</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-comment">//优先任务队列</span>        pool = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS, <span class="hljs-keyword">new</span> PriorityBlockingQueue&lt;Runnable&gt;(),Executors.defaultThreadFactory(),<span class="hljs-keyword">new</span> ThreadPoolExecutor.AbortPolicy());                  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">20</span>;i++) &#123;            pool.execute(<span class="hljs-keyword">new</span> ThreadTask(i));        &#125;        &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span>,<span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">ThreadTask</span>&gt;</span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> priority;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getPriority</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> priority;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPriority</span><span class="hljs-params">(<span class="hljs-keyword">int</span> priority)</span> </span>&#123;        <span class="hljs-keyword">this</span>.priority = priority;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadTask</span><span class="hljs-params">()</span> </span>&#123;            &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadTask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> priority)</span> </span>&#123;        <span class="hljs-keyword">this</span>.priority = priority;    &#125;    <span class="hljs-comment">//当前对象和其他对象做比较，当前优先级大就返回-1，优先级小就返回1,值越小优先级越高</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(ThreadTask o)</span> </span>&#123;         <span class="hljs-keyword">return</span>  <span class="hljs-keyword">this</span>.priority&gt;o.priority?-<span class="hljs-number">1</span>:<span class="hljs-number">1</span>;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//让线程阻塞，使后续任务进入缓存队列</span>            Thread.sleep(<span class="hljs-number">1000</span>);            System.out.println(<span class="hljs-string">&quot;priority:&quot;</span>+<span class="hljs-keyword">this</span>.priority+<span class="hljs-string">&quot;,ThreadName:&quot;</span>+Thread.currentThread().getName());        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            <span class="hljs-comment">// TODO Auto-generated catch block</span>            e.printStackTrace();        &#125;        &#125;&#125;</code></pre></div><p>我们来看下执行的结果情况</p><div class="hljs code-wrapper"><pre><code class="hljs java">priority:<span class="hljs-number">0</span>,ThreadName:pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>priority:<span class="hljs-number">9</span>,ThreadName:pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>priority:<span class="hljs-number">8</span>,ThreadName:pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>priority:<span class="hljs-number">7</span>,ThreadName:pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>priority:<span class="hljs-number">6</span>,ThreadName:pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>priority:<span class="hljs-number">5</span>,ThreadName:pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>priority:<span class="hljs-number">4</span>,ThreadName:pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>priority:<span class="hljs-number">3</span>,ThreadName:pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>priority:<span class="hljs-number">2</span>,ThreadName:pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>priority:<span class="hljs-number">1</span>,ThreadName:pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span></code></pre></div><p>大家可以看到除了第一个任务直接创建线程执行外，其他的任务都被放入了优先任务队列，按优先级进行了重新排列执行，且线程池的线程数一直为corePoolSize，也就是只有一个。</p><p>通过运行的代码我们可以看出PriorityBlockingQueue它其实是一个特殊的无界队列，它其中无论添加了多少个任务，线程池创建的线程数也不会超过corePoolSize的数量，只不过其他队列一般是按照先进先出的规则处理任务，而PriorityBlockingQueue队列可以自定义规则根据任务的优先级顺序先后执行。</p><p><strong>二、拒绝策略</strong></p><p>一般我们创建线程池时，为防止资源被耗尽，任务队列都会选择创建有界任务队列，但种模式下如果出现任务队列已满且线程池创建的线程数达到你设置的最大线程数时，这时就需要你指定ThreadPoolExecutor的RejectedExecutionHandler参数即合理的拒绝策略，来处理线程池”超载”的情况。ThreadPoolExecutor自带的拒绝策略如下：</p><blockquote><p><strong>1、AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作；</strong></p><p><strong>2、CallerRunsPolicy策略：如果线程池的线程数量达到上限，该策略会把任务队列中的任务放在调用者线程当中运行；</strong></p><p><strong>3、DiscardOledestPolicy策略：该策略会丢弃任务队列中最老的一个任务，也就是当前任务队列中最先被添加进去的，马上要被执行的那个任务，并尝试再次提交；</strong></p><p><strong>4、DiscardPolicy策略：该策略会默默丢弃无法处理的任务，不予任何处理。当然使用此策略，业务场景中需允许任务的丢失；</strong></p></blockquote><p>**以上内置的策略均实现了*<em>RejectedExecutionHandler接口，*<em>当然你也可以自己扩展RejectedExecutionHandler接口，定义自己的拒绝策略，我们看下示例代码：</em></em></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPool</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ExecutorService pool;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">( String[] args )</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-comment">//自定义拒绝策略</span>        pool = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS, <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">5</span>),                Executors.defaultThreadFactory(), <span class="hljs-keyword">new</span> RejectedExecutionHandler() &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;                System.out.println(r.toString()+<span class="hljs-string">&quot;执行了拒绝策略&quot;</span>);                            &#125;        &#125;);                  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) &#123;            pool.execute(<span class="hljs-keyword">new</span> ThreadTask());        &#125;        &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//让线程阻塞，使后续任务进入缓存队列</span>            Thread.sleep(<span class="hljs-number">1000</span>);            System.out.println(<span class="hljs-string">&quot;ThreadName:&quot;</span>+Thread.currentThread().getName());        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            <span class="hljs-comment">// TODO Auto-generated catch block</span>            e.printStackTrace();        &#125;        &#125;&#125;</code></pre></div><p>输出结果：</p><div class="hljs code-wrapper"><pre><code class="hljs java">com.hhxx.test.ThreadTask@<span class="hljs-number">33909752</span>执行了拒绝策略com.hhxx.test.ThreadTask@55f96302执行了拒绝策略com.hhxx.test.ThreadTask@3d4eac69执行了拒绝策略ThreadName:pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>ThreadName:pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>ThreadName:pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>ThreadName:pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>ThreadName:pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>ThreadName:pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>ThreadName:pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span></code></pre></div><p>可以看到由于任务加了休眠阻塞，执行需要花费一定时间，导致会有一定的任务被丢弃，从而执行自定义的拒绝策略；</p><p><strong>三、ThreadFactory自定义线程创建</strong></p><p> 线程池中线程就是通过ThreadPoolExecutor中的ThreadFactory，线程工厂创建的。那么通过自定义ThreadFactory，可以按需要对线程池中创建的线程进行一些特殊的设置，如命名、优先级等，下面代码我们通过ThreadFactory对线程池中创建的线程进行记录与命名</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPool</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ExecutorService pool;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">( String[] args )</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-comment">//自定义线程工厂</span>        pool = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS, <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">5</span>),                <span class="hljs-keyword">new</span> ThreadFactory() &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;                System.out.println(<span class="hljs-string">&quot;线程&quot;</span>+r.hashCode()+<span class="hljs-string">&quot;创建&quot;</span>);                <span class="hljs-comment">//线程命名</span>                Thread th = <span class="hljs-keyword">new</span> Thread(r,<span class="hljs-string">&quot;threadPool&quot;</span>+r.hashCode());                <span class="hljs-keyword">return</span> th;            &#125;        &#125;, <span class="hljs-keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());                  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) &#123;            pool.execute(<span class="hljs-keyword">new</span> ThreadTask());        &#125;        &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//输出执行线程的名称</span>        System.out.println(<span class="hljs-string">&quot;ThreadName:&quot;</span>+Thread.currentThread().getName());    &#125;&#125;</code></pre></div><p>我们看下输出结果</p><div class="hljs code-wrapper"><pre><code class="hljs java">线程<span class="hljs-number">118352462</span>创建线程<span class="hljs-number">1550089733</span>创建线程<span class="hljs-number">865113938</span>创建ThreadName:threadPool1550089733ThreadName:threadPool118352462线程<span class="hljs-number">1442407170</span>创建ThreadName:threadPool1550089733ThreadName:threadPool1550089733ThreadName:threadPool1550089733ThreadName:threadPool865113938ThreadName:threadPool865113938ThreadName:threadPool118352462ThreadName:threadPool1550089733ThreadName:threadPool1442407170</code></pre></div><p>可以看到线程池中，每个线程的创建我们都进行了记录输出与命名。</p><p><strong>四、ThreadPoolExecutor扩展</strong></p><p>ThreadPoolExecutor扩展主要是围绕beforeExecute()、afterExecute()和terminated()三个接口实现的，</p><p><strong>1、beforeExecute：线程池中任务运行前执行</strong></p><p><strong>2、afterExecute：线程池中任务运行完毕后执行</strong></p><p><strong>3、terminated：线程池退出后执行</strong></p><p>通过这三个接口我们可以监控每个任务的开始和结束时间，或者其他一些功能。下面我们可以通过代码实现一下</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPool</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ExecutorService pool;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">( String[] args )</span> <span class="hljs-keyword">throws</span> InterruptedException</span><span class="hljs-function">    </span>&#123;        <span class="hljs-comment">//实现自定义接口</span>        pool = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS, <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">5</span>),                <span class="hljs-keyword">new</span> ThreadFactory() &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;                System.out.println(<span class="hljs-string">&quot;线程&quot;</span>+r.hashCode()+<span class="hljs-string">&quot;创建&quot;</span>);                <span class="hljs-comment">//线程命名</span>                Thread th = <span class="hljs-keyword">new</span> Thread(r,<span class="hljs-string">&quot;threadPool&quot;</span>+r.hashCode());                <span class="hljs-keyword">return</span> th;            &#125;        &#125;, <span class="hljs-keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy()) &#123;                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeExecute</span><span class="hljs-params">(Thread t,Runnable r)</span> </span>&#123;                System.out.println(<span class="hljs-string">&quot;准备执行：&quot;</span>+ ((ThreadTask)r).getTaskName());            &#125;                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterExecute</span><span class="hljs-params">(Runnable r,Throwable t)</span> </span>&#123;                System.out.println(<span class="hljs-string">&quot;执行完毕：&quot;</span>+((ThreadTask)r).getTaskName());            &#125;                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">terminated</span><span class="hljs-params">()</span> </span>&#123;                System.out.println(<span class="hljs-string">&quot;线程池退出&quot;</span>);            &#125;        &#125;;                  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) &#123;            pool.execute(<span class="hljs-keyword">new</span> ThreadTask(<span class="hljs-string">&quot;Task&quot;</span>+i));        &#125;            pool.shutdown();    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;        <span class="hljs-keyword">private</span> String taskName;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTaskName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> taskName;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTaskName</span><span class="hljs-params">(String taskName)</span> </span>&#123;        <span class="hljs-keyword">this</span>.taskName = taskName;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadTask</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.setTaskName(name);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//输出执行线程的名称</span>        System.out.println(<span class="hljs-string">&quot;TaskName&quot;</span>+<span class="hljs-keyword">this</span>.getTaskName()+<span class="hljs-string">&quot;---ThreadName:&quot;</span>+Thread.currentThread().getName());    &#125;&#125;</code></pre></div><p>我看下输出结果</p><div class="hljs code-wrapper"><pre><code class="hljs java">线程<span class="hljs-number">118352462</span>创建线程<span class="hljs-number">1550089733</span>创建准备执行：Task0准备执行：Task1TaskNameTask0---ThreadName:threadPool118352462线程<span class="hljs-number">865113938</span>创建执行完毕：Task0TaskNameTask1---ThreadName:threadPool1550089733执行完毕：Task1准备执行：Task3TaskNameTask3---ThreadName:threadPool1550089733执行完毕：Task3准备执行：Task2准备执行：Task4TaskNameTask4---ThreadName:threadPool1550089733执行完毕：Task4准备执行：Task5TaskNameTask5---ThreadName:threadPool1550089733执行完毕：Task5准备执行：Task6TaskNameTask6---ThreadName:threadPool1550089733执行完毕：Task6准备执行：Task8TaskNameTask8---ThreadName:threadPool1550089733执行完毕：Task8准备执行：Task9TaskNameTask9---ThreadName:threadPool1550089733准备执行：Task7执行完毕：Task9TaskNameTask2---ThreadName:threadPool118352462TaskNameTask7---ThreadName:threadPool865113938执行完毕：Task7执行完毕：Task2线程池退出</code></pre></div><p>可以看到通过对beforeExecute()、afterExecute()和terminated()的实现，我们对线程池中线程的运行状态进行了监控，在其执行前后输出了相关打印信息。另外使用shutdown方法可以比较安全的关闭线程池， 当线程池调用该方法后，线程池中不再接受后续添加的任务。但是，此时线程池不会立刻退出，直到添加到线程池中的任务都已经处理完成，才会退出。</p><p><strong>五、线程池线程数量</strong></p><p>线程吃线程数量的设置没有一个明确的指标，根据实际情况，只要不是设置的偏大和偏小都问题不大，结合下面这个公式即可</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Nthreads=CPU数量</span><span class="hljs-comment"> * Ucpu=目标CPU的使用率，0&lt;=Ucpu&lt;=1</span><span class="hljs-comment"> * W/C=任务等待时间与任务计算时间的比率</span><span class="hljs-comment"> */</span>Nthreads = Ncpu*Ucpu*(<span class="hljs-number">1</span>+W/C)</code></pre></div><p>以上就是对ThreadPoolExecutor类从构造函数、拒绝策略、自定义线程创建等方面介绍了其详细的使用方法，从而我们可以根据自己的需要，灵活配置和使用线程池创建线程，其中如有不足与不正确的地方还望指出与海涵。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>javabin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>video</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jRebel</title>
    <link href="/2021/05/18/idea-jrebel/"/>
    <url>/2021/05/18/idea-jrebel/</url>
    
    <content type="html"><![CDATA[<h1 id="JRebel激活方案"><a href="#JRebel激活方案" class="headerlink" title="JRebel激活方案"></a>JRebel激活方案</h1><h2 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h2><p><code>Jrebel</code>可快速实现热部署，节省了大量重启时间，提高了个人开发效率。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="安装Jrebel"><a href="#安装Jrebel" class="headerlink" title="安装Jrebel"></a>安装Jrebel</h3><p>通过<code>Idea</code>的偏好设置找到插件框，输入<code>Jrebel and XRebel for IntelliJ</code>安装插件，通过偏好设置找到<code>JRebel &amp; XRebel</code>然后选择激活插件，打开<code>jrebel</code>激活面板，选择Team URL(connect to online licensing service)</p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>激活网站：<a href="https://links.jianshu.com/go?to=http://jrebel.cicoding.cn/">http://jrebel.cicoding.cn/</a>，通过浏览器打开得到如下内容:</p><div class="hljs code-wrapper"><pre><code class="hljs swift"><span class="hljs-type">Hello</span>,<span class="hljs-type">This</span> <span class="hljs-keyword">is</span> a <span class="hljs-type">Jrebel</span> &amp; <span class="hljs-type">JetBrains</span> <span class="hljs-type">License</span> <span class="hljs-type">Server</span>!</code></pre></div><p>打开浏览器访问网址：<a href="https://links.jianshu.com/go?to=http://jrebel.cicoding.cn/guid">http://jrebel.cicoding.cn/guid</a>得到如下内容</p><div class="hljs code-wrapper"><pre><code class="hljs undefined">GUID : 9CA7F155-A655-7233-02FE-6406A133313D</code></pre></div><p>拷贝内容：9CA7F155-A655-7233-02FE-6406A133313D</p><p>此时生成激活URL,格式如下：<a href="https://links.jianshu.com/go?to=http://jrebel.cicoding.cn/GUID">http://jrebel.cicoding.cn/GUID</a></p><blockquote><p><a href="https://links.jianshu.com/go?to=http://jrebel.cicoding.cn/4B068EB5-0941-4645-1E98-FC077D530A61">http://jrebel.cicoding.cn/4B068EB5-0941-4645-1E98-FC077D530A61</a></p></blockquote><p>在第一行输入上述地址，第二行输入一个符合邮箱格式的邮箱地址（随便输入一个就可以，不需要是真实邮箱），勾选<code>I agree with the terms &amp; conditions of the License Agreement</code>即可完成激活，激活完成后选择<code>Work offline</code>。</p><blockquote><p>绿色的Valid表示是有效的</p><p>Work offline是为了防止授权过期</p></blockquote><p>对Idea的Jrebel插件设置生效时间（Time Saved Statistics）通过鼠标勾选1分钟</p><p>通过偏好设置找到<code>构建、执行、部署</code>=&gt;<code>编译器</code> 勾选自动构建项目[Build project automatically]</p><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>GUID生成：<a href="https://links.jianshu.com/go?to=https://www.guidgen.com/">https://www.guidgen.com/</a></p><p>激活URL :<a href="https://links.jianshu.com/go?to=https://jrebel.qekang.com/GUID">https://jrebel.qekang.com/GUID</a></p><h2 id="方案验证"><a href="#方案验证" class="headerlink" title="方案验证"></a>方案验证</h2><p>工程启动有如下四个图标：</p><ul><li>绿色三角形按钮：IDEA自带的启动按钮；</li><li>绿色虫子按钮：IDEA自带的 Debug 启动按钮；</li><li>火箭带字体JR按钮：热部署JRebel 正常启动；</li><li>虫子带字体JR按钮:热部署JRebel Debug启动。</li></ul><blockquote><p><strong>要想使用热部署插件 JRebel ，必须要使用后两个启动按钮，切记！</strong></p></blockquote><p>Jrebel有一个Pannel面板，勾选对应需要热更新的模块，如果源码修改后没有生效，则可以点击类似锤子的构建按钮就行构建，然后就会自动热更新了,默认情况下，JRebel 热部署插件在你修改完已经编译好的 Java 文件失去焦点的时候，自动会将修改后 Java 文件编译，并替换掉旧的 Class 文件,<strong>一般情况下，在使用热部署插件 JRebel 启动项目时，修改某个Java文件，手动的对项目进行热部署操作 Build -&gt; Build Project</strong></p><blockquote><p>Mac:Command+F9</p><p>Windows:Ctrl+F9</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>idea</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idea</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>macos-profile</title>
    <link href="/2021/05/17/macos-profile/"/>
    <url>/2021/05/17/macos-profile/</url>
    
    <content type="html"><![CDATA[<h1 id="macOS-环境变量配置教程"><a href="#macOS-环境变量配置教程" class="headerlink" title="macOS 环境变量配置教程"></a>macOS 环境变量配置教程</h1><h3 id="如果只是寻找设置方法，请按照如下方法操作："><a href="#如果只是寻找设置方法，请按照如下方法操作：" class="headerlink" title="如果只是寻找设置方法，请按照如下方法操作："></a>如果只是寻找设置方法，请按照如下方法操作：</h3><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$echo</span> <span class="hljs-variable">$PATH</span><span class="hljs-variable">$sudo</span> vi ~/.bash_profile</code></pre></div><p><em>Tips: 以上操作为显示当前已设置环境变量路径，如果没有要添加的程序，则使用vi 命令进行操作添加。</em><br> 在 文件中 输入 </p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$export</span> PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$PATH</span>:&#x27;pwd&#x27;/xxxx/bin&quot;</span></code></pre></div><p><em>Tips: 以上命令中将  pwd  替换为当前程序文件所在目录，XXXX替换为程序名称。</em><br> <em>或者在应用程序根目录处执行以上命令</em><br> 编辑完成后，按ESC键，输入:wq 保存退出。<br> 如果需要立即生效</p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$source</span> <span class="hljs-string">&#x27;fileName&#x27;</span></code></pre></div><p><em>Tips: 以上命令中： ‘fileName’ 参数为要操作的文件名。</em></p><h2 id="一、环境变量（environment-variables）"><a href="#一、环境变量（environment-variables）" class="headerlink" title="一、环境变量（environment variables）"></a>一、环境变量（environment variables）</h2><p>环境变量一般是指在操作系统中用来制定操作系统运行环境的一些参数。环境变量是在操作系统中一个具有特定名字的对象，它包含了一个或者多个应用程序所使用到的信息。</p><p>当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应该到path中指定的路径中去寻找。用户通过设置环境变量，来更好的运行进程。</p><h2 id="二、主要作用"><a href="#二、主要作用" class="headerlink" title="二、主要作用"></a>二、主要作用</h2><h3 id="设置参数"><a href="#设置参数" class="headerlink" title="设置参数"></a>设置参数</h3><p>环境变量相当于给系统或用户应用程序设置的一些参数，具体起什么作用这当然和具体的环境变量有关。比如 path，是告诉系统，当需要系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应该到哪些目录下去寻找。</p><h2 id="常见环境变量"><a href="#常见环境变量" class="headerlink" title="常见环境变量"></a>常见环境变量</h2><h3 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h3><p>macOS  一般使用bash作为默认shell</p><p>Mac系统的环境变量，加载顺序为：<br> /etc/profile  /etc/paths  ~/.bash_profile  ~/.bash_login  ~/.profile   ~/.bashrc</p><p>其中 /etc/profile 和 /etc/paths 是系统级别的,系统启动就会加载，后面几个是当前用户级的环境变量。后面三个按照从前往后的顺序读取，如果 ~/.bash_profile 文件存在，则后面的几个文件就会被忽略，若不存在才会依次读取。 而 ~/.bashrc 没有上述规则，它是 bash shell 打开的时候载入的。</p><h4 id="设置方法"><a href="#设置方法" class="headerlink" title="设置方法"></a>设置方法</h4><div class="hljs code-wrapper"><pre><code class="hljs ruby"><span class="hljs-comment">#中间用冒号隔开 最好不要有空格</span>    export PATH=<span class="hljs-variable">$PATH</span><span class="hljs-symbol">:&lt;PATH</span> <span class="hljs-number">1</span>&gt;<span class="hljs-symbol">:&lt;PATH</span> <span class="hljs-number">2</span>&gt;<span class="hljs-symbol">:&lt;PATH</span> <span class="hljs-number">3</span>&gt;<span class="hljs-symbol">:---</span><span class="hljs-symbol">:&lt;PATH</span> N&gt;</code></pre></div><p>(一) 全局变量<br> 下面的几个文件是全局的，修改时需要先获取权限</p><ol><li>/etc/paths<br> 编辑 paths 时，将环境变量添加到 paths 文件中即可，一行一个路径</li></ol><p>2）/etc/profile (建议不修改此文件)<br> 全局（公有）配置，不管是哪个用户，登录时都会读取该文件。</p><ol><li>/etc/bashrc (一般在此文件中添加系统级环境变量)<br> 全局（公有）配置，bash shell 执行时，不管是何种方式，读取此文件。</li></ol><p>(二)单个用户设置</p><p>1）~/bash_profile (任意一个文件中添加用户级环境变量)<br> （<em>tips</em>: Linux里面是 .bashrc 而Mac下是 .bash_profile）</p><p>若 bash shell 是以 login 方式执行时，才会读取此文件。该文件仅仅执行一次，默认情况下，他设置一些环境变量设置命令别名 alias ll= ‘ls -la’</p><ol><li>若需要立即生效，需要执行  $source .bash_profile ,否则一般重启后生效。</li></ol><h3 id="WINDOWS系统"><a href="#WINDOWS系统" class="headerlink" title="WINDOWS系统"></a>WINDOWS系统</h3><table><thead><tr><th align="center">名称</th><th align="left">作用</th></tr></thead><tbody><tr><td align="center">%ALLUSERSPROFILE%</td><td align="left">局部 返回所有“用户配置文件”的位置。</td></tr><tr><td align="center">%APPDATA%</td><td align="left">局部 返回默认情况下应用程序存储数据的位置。</td></tr><tr><td align="center">%CD%</td><td align="left">局部 返回当前目录字符串。</td></tr><tr><td align="center">%CMDCMDLINE%</td><td align="left">局部 返回用来启动当前的 Cmd.exe 的准确命令行。</td></tr><tr><td align="center">%CMDEXTVERSION%</td><td align="left">系统 返回当前的“命令处理程序扩展”的版本号。</td></tr><tr><td align="center">%COMPUTERNAME%</td><td align="left">系统 返回计算机的名称。</td></tr><tr><td align="center">%COMSPEC%</td><td align="left">系统 返回命令行解释器可执行程序的准确路径。</td></tr><tr><td align="center">%DATE%</td><td align="left">系统 返回当前日期。使用与 date /t 命令相同的格式。由 Cmd.exe 生成。有关 date 命令的详细信息，请参阅 Date。</td></tr><tr><td align="center">%ERRORLEVEL%</td><td align="left">系统 返回使用过的命令的错误代码。通常用非零值表示错误。</td></tr><tr><td align="center">%HOMEDRIVE%</td><td align="left">系统 返回连接到用户主目录的本地工作站驱动器号。基于主目录值的设置。用户主目录是在“本地用户和组”中指定的。</td></tr><tr><td align="center">%HOMEPATH%</td><td align="left">系统 返回用户主目录的完整路径。基于主目录值的设置。用户主目录是在“本地用户和组”中指定的。</td></tr><tr><td align="center">%HOMESHARE%</td><td align="left">系统 返回用户的共享主目录的网络路径。基于主目录值的设置。用户主目录是在“本地用户和组”中指定的。</td></tr><tr><td align="center">%LOGONSEVER%</td><td align="left">局部 返回验证当前登录会话的域控制器的名称。</td></tr><tr><td align="center">%NUMBER_OF_PROCESSORS%</td><td align="left">系统 指定安装在计算机上的处理器的数目。</td></tr><tr><td align="center">%OS%</td><td align="left">系统 返回操作系统的名称。Windows 2000 将操作系统显示为 Windows_NT。</td></tr><tr><td align="center">%PATH%</td><td align="left">系统 指定可执行文件的搜索路径。</td></tr><tr><td align="center">%PATHEXT%</td><td align="left">系统 返回操作系统认为可执行的文件扩展名的列表。</td></tr><tr><td align="center">%PROCESSOR_ARCHITECTURE%</td><td align="left">系统 返回处理器的芯片体系结构。值: x86，IA64。</td></tr><tr><td align="center">%PROCESSOR_IDENTIFIER%</td><td align="left">系统 返回处理器说明。</td></tr><tr><td align="center">%PROCESSOR_LEVEL%</td><td align="left">系统 返回计算机上安装的处理器的型号。</td></tr><tr><td align="center">%PROCESSOR_REVISION%</td><td align="left">系统 返回处理器修订号的系统变量。</td></tr><tr><td align="center">%PROMPT%</td><td align="left">局部 返回当前解释程序的命令提示符设置。由 Cmd.exe 生成。</td></tr><tr><td align="center">%RANDOM%</td><td align="left">系统 返回 0 到 32767 之间的任意十进制数字。由 Cmd.exe 生成。</td></tr><tr><td align="center">%SYSTEMDRIVE%</td><td align="left">系统 返回包含 Windows XP 根目录（即系统根目录）的驱动器。</td></tr><tr><td align="center">%SYSTEMROOT%</td><td align="left">系统 返回 Windows XP 根目录的位置。</td></tr><tr><td align="center">%TEMP% and %TMP%</td><td align="left">系统和用户 返回对当前登录用户可用的应用程序所使用的默认临时目录。有些应用程序需要 TEMP，而其它应用程序则需要 TMP。</td></tr><tr><td align="center">%TIME%</td><td align="left">系统 返回当前时间。使用与 time /t 命令相同的格式。由 Cmd.exe 生成。有关 time 命令的详细信息，请参阅 Time。</td></tr><tr><td align="center">%USERDOMAIN%</td><td align="left">局部 返回包含用户帐户的域的名称。</td></tr><tr><td align="center">%USERNAME%</td><td align="left">局部 返回当前登录的用户的名称。</td></tr><tr><td align="center">%UserProfile%</td><td align="left">局部 返回当前用户的配置文件的位置。</td></tr><tr><td align="center">%WINDIR%</td><td align="left">系统 返回操作系统目录的位置。</td></tr></tbody></table><h3 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h3><p>shell 环境依赖于多个文件的设置。当 shell 被调用时，它从两个初始文件读取命令。 /etc/profile 包含了系统变量，它由系统管理员维护，由系统管理员设置本地系统变量和特殊命令。普通用户的启动信息文件($HOME/.bash_project)由各用户自己维护，该文件可以被修改以实现任何特定的系统初始化。</p><p>只有在特定的情况下才读取 profile 文件，确切的说是在用户登录的时候。当运行shell脚本或者 subshell 以后，就无需再读 profile。虽然所有 profile 都是可选的，但是基本上所有系统都有 /etc/profile.</p><p>如果定义了变量 ENV 且已经传递到环境中，则所有的 bash shell 都要读取并调用由这个变量制定的文件所包含的命令。这个文件用来定义所有 bash shell 的特性，而不仅仅是登录到 shell。这个文件的典型的名字是 ‘$HOME/,bashrc’。</p><p>当新建用户是，.bash_profile、bashrc 和其他公共的环境文件模板将复制到 /etc/skel 这个目录下面。可以编辑这些初始化设置，也可以在此目录下添加附加的文件。</p><table><thead><tr><th align="center">一个典型的系统profile(/etc/profile):</th></tr></thead><tbody><tr><td align="center">PATH=$PATH:/usr/qa/tools/bin</td></tr><tr><td align="center">ENV==$HOME/.bashrc</td></tr><tr><td align="center">ORACLE_HOME=/dbs/oracle</td></tr><tr><td align="center">ORACLE_SID=qadb</td></tr><tr><td align="center">Export PATH ENV ORACLE_HOME ORCAL_SID</td></tr><tr><td align="center">Cat /etc/motd</td></tr></tbody></table><table><thead><tr><th align="center">一个典型的用户profile(.bashrc)</th></tr></thead><tbody><tr><td align="center">PATH=<img src="https://math.jianshu.com/math?formula=PATH:" alt="PATH:">HOME/bin</td></tr><tr><td align="center">TEAM=uvt1224 export TERM</td></tr><tr><td align="center">sttyintr ^C</td></tr><tr><td align="center">cal</td></tr><tr><td align="center">mesg n</td></tr></tbody></table><table><thead><tr><th align="center">一个典型的用户 bashrc file (.bashrc):</th></tr></thead><tbody><tr><td align="center">alias dir=ls lf=’ls -FC’</td></tr><tr><td align="center">PSI=’$PWS[!]&gt;’</td></tr><tr><td align="center">set -o vi</td></tr></tbody></table><p><em>tips:</em> 别名和其他bash专用的定义应该放在.bashrc文件（不应在.bash_profile) 中定义；否则会导致找不到某些命令。</p><p> 应该记住profile文件和.bashrc文件的区别：两个profile都只在系统启动时被读取一次，而.bashrc在系统启动和每次调用shell的时候都要被读取。</p>]]></content>
    
    
    <categories>
      
      <category>system</category>
      
    </categories>
    
    
    <tags>
      
      <tag>macos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jackson</title>
    <link href="/2021/05/16/java-jackson/"/>
    <url>/2021/05/16/java-jackson/</url>
    
    <content type="html"><![CDATA[<h1 id="Jackson-使用篇"><a href="#Jackson-使用篇" class="headerlink" title="Jackson 使用篇"></a>Jackson 使用篇</h1><h2 id="【简介】"><a href="#【简介】" class="headerlink" title="【简介】"></a>【简介】</h2><p>日常开发过程中经常会使用json进行数据的传输，这就涉及到了对象和json的相互转化，常用的解决方案有：Jackson（推荐）、谷歌的Gson、阿里的Fastjson，详情见 Json【汇总】</p><p>因为SpringBoot默认的json解析格式就是Jackson，所以不需要额外的引入依赖</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqkjtgzf0lj30jh0bjgm5.jpg" alt="在这里插入图片描述"></p><h2 id="【常见配置】"><a href="#【常见配置】" class="headerlink" title="【常见配置】"></a>【常见配置】</h2><h3 id="方式一：yml配置"><a href="#方式一：yml配置" class="headerlink" title="方式一：yml配置"></a>方式一：yml配置</h3><div class="hljs code-wrapper"><pre><code class="hljs java">spring.jackson.date-format指定日期格式，比如yyyy-MM-dd HH:mm:ss，或者具体的格式化类的全限定名spring.jackson.time-zone指定日期格式化时区，比如America/Los_Angeles或者GMT+<span class="hljs-number">10.</span>spring.jackson.deserialization是否开启Jackson的反序列化spring.jackson.generator是否开启json的generators.spring.jackson.joda-date-time-format指定Joda date/time的格式，比如yyyy-MM-ddHH:mm:ss). 如果没有配置的话，dateformat会作为backupspring.jackson.locale指定json使用的Locale.spring.jackson.mapper是否开启Jackson通用的特性.spring.jackson.parser是否开启jackson的parser特性.spring.jackson.property-naming-strategy指定PropertyNamingStrategy(CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES)或者指定PropertyNamingStrategy子类的全限定类名.spring.jackson.serialization是否开启jackson的序列化.spring.jackson.serialization-inclusion指定序列化时属性的inclusion方式，具体查看JsonInclude.Include枚举.</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">jackson:</span>    <span class="hljs-comment">#日期格式化</span>    <span class="hljs-attr">date-format:</span> <span class="hljs-string">yyyy-MM-dd</span> <span class="hljs-string">HH:mm:ss</span>    <span class="hljs-attr">time-zone:</span> <span class="hljs-string">GMT+8</span>    <span class="hljs-comment">#设置空如何序列化</span>    <span class="hljs-attr">default-property-inclusion:</span> <span class="hljs-string">non_null</span>        <span class="hljs-attr">serialization:</span>       <span class="hljs-comment">#格式化输出 </span>      <span class="hljs-attr">indent_output:</span> <span class="hljs-literal">true</span>      <span class="hljs-comment">#忽略无法转换的对象</span>      <span class="hljs-attr">fail_on_empty_beans:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">deserialization:</span>      <span class="hljs-comment">#允许对象忽略json中不存在的属性</span>      <span class="hljs-attr">fail_on_unknown_properties:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">parser:</span>      <span class="hljs-comment">#允许出现特殊字符和转义符</span>      <span class="hljs-attr">allow_unquoted_control_chars:</span> <span class="hljs-literal">true</span>      <span class="hljs-comment">#允许出现单引号</span>      <span class="hljs-attr">allow_single_quotes:</span> <span class="hljs-literal">true</span></code></pre></div><h3 id="方式二：重新注入ObjectMapper"><a href="#方式二：重新注入ObjectMapper" class="headerlink" title="方式二：重新注入ObjectMapper"></a>方式二：重新注入ObjectMapper</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@Primary</span><span class="hljs-meta">@ConditionalOnMissingBean(ObjectMapper.class)</span><span class="hljs-function"><span class="hljs-keyword">public</span> ObjectMapper <span class="hljs-title">jacksonObjectMapper</span><span class="hljs-params">(Jackson2ObjectMapperBuilder builder&#123;</span></span><span class="hljs-function"><span class="hljs-params">   ObjectMapper objectMapper = builder.createXmlMapper(<span class="hljs-keyword">false</span>)</span>.<span class="hljs-title">build</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">// 通过该方法对mapper对象进行设置，所有序列化的对象都将按改规则进行系列化</span>   <span class="hljs-comment">// Include.Include.ALWAYS 默认</span>   <span class="hljs-comment">// Include.NON_DEFAULT 属性为默认值不序列化</span>   <span class="hljs-comment">// Include.NON_EMPTY 属性为 空（&quot;&quot;） 或者为 NULL 都不序列化，则返回的json是没有这个字段的。这样对移动端会更省流量</span>   <span class="hljs-comment">// Include.NON_NULL 属性为NULL 不序列化</span>   objectMapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);   objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="hljs-keyword">false</span>);   <span class="hljs-comment">// 允许出现特殊字符和转义符</span>   objectMapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS, <span class="hljs-keyword">true</span>);   <span class="hljs-comment">// 允许出现单引号</span>   objectMapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, <span class="hljs-keyword">true</span>);   <span class="hljs-comment">// 字段保留，将null值转为&quot;&quot;</span>   objectMapper.getSerializerProvider().setNullValueSerializer(<span class="hljs-keyword">new</span> JsonSerializer&lt;Object&gt;()   &#123;       <span class="hljs-meta">@Override</span>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serialize</span><span class="hljs-params">(Object o, JsonGenerator jsonGenerator,</span></span><span class="hljs-function"><span class="hljs-params">                             SerializerProvider serializerProvider)</span></span><span class="hljs-function">               <span class="hljs-keyword">throws</span> IOException</span><span class="hljs-function">       </span>&#123;           jsonGenerator.writeString(<span class="hljs-string">&quot;&quot;</span>);       &#125;   &#125;);   <span class="hljs-keyword">return</span> objectMapper;&#125;</code></pre></div><h2 id="【常用-API】"><a href="#【常用-API】" class="headerlink" title="【常用 API】"></a>【常用 API】</h2><p>因为日常开发最常用的api就是对象的序列化和反序列化，这里封装一个工具类，这里只展示部分API，其他API可参考 <a href="https://github.com/czy1024/luna-json-util/tree/master/json-jackson">JSON解析-Jackson</a></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JsonUtils</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-comment">// 对于空的对象转json的时候不抛出错误</span>        mapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);        <span class="hljs-comment">// 允许属性名称没有引号</span>        mapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, <span class="hljs-keyword">true</span>);        <span class="hljs-comment">// 允许单引号</span>        mapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, <span class="hljs-keyword">true</span>);        <span class="hljs-comment">// 设置输入时忽略在json字符串中存在但在java对象实际没有的属性</span>        mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);        <span class="hljs-comment">// 设置输出时包含属性的风格</span>        mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 序列化，将对象转化为json字符串</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">toJsonString</span><span class="hljs-params">(Object data)</span> </span>&#123;        <span class="hljs-keyword">if</span> (data == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        String json = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            json = mapper.writeValueAsString(data);        &#125; <span class="hljs-keyword">catch</span> (JsonProcessingException e) &#123;            log.error(<span class="hljs-string">&quot;[&#123;&#125;] toJsonString error：&#123;&#123;&#125;&#125;&quot;</span>, data.getClass().getSimpleName(), e);        &#125;        <span class="hljs-keyword">return</span> json;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 反序列化，将json字符串转化为对象</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> json</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> clazz</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt;</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">parse</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> String json, Class&lt;T&gt; clazz)</span> </span>&#123;        T t = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            t = mapper.readValue(json, clazz);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            log.error(<span class="hljs-string">&quot; parse json [&#123;&#125;] to class [&#123;&#125;] error：&#123;&#123;&#125;&#125;&quot;</span>, json, clazz.getSimpleName(), e);        &#125;        <span class="hljs-keyword">return</span> t;    &#125;&#125;</code></pre></div><h4 id="定义一个Bean"><a href="#定义一个Bean" class="headerlink" title="定义一个Bean"></a>定义一个Bean</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@Builder</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-keyword">private</span> Date birthday;&#125;</code></pre></div><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JacksonTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        User user = User.builder()                .id(<span class="hljs-number">1L</span>)                .name(<span class="hljs-string">&quot;tom&quot;</span>)                .age(<span class="hljs-number">23</span>)                .birthday(<span class="hljs-keyword">new</span> Date())                .build();        String json = JsonUtils.toJsonString(user);        log.info(<span class="hljs-string">&quot;obj toJsonString:[&#123;&#125;]&quot;</span>, json);        User u = JsonUtils.parse(json, User.class);        log.info(<span class="hljs-string">&quot;parse json to obj: [&#123;&#125;]&quot;</span>, u);    &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs bash">16:44:01.871 [main] INFO com.it.jackson.test.JacksonTest - obj toJsonString:[&#123;<span class="hljs-string">&quot;id&quot;</span>:1,<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>:23,<span class="hljs-string">&quot;birthday&quot;</span>:1587890641047&#125;]16:44:01.941 [main] INFO com.it.jackson.test.JacksonTest - parse json to obj: [User(id=1, name=tom, age=23, birthday=Sun Apr 26 16:44:01 CST 2020)]</code></pre></div><h2 id="【常用-注解】"><a href="#【常用-注解】" class="headerlink" title="【常用 注解】"></a>【常用 注解】</h2><h3 id="【-JsonProperty】类似于sql里字段的别名，用于序列化，使用注解字段属性，替代原字段属性"><a href="#【-JsonProperty】类似于sql里字段的别名，用于序列化，使用注解字段属性，替代原字段属性" class="headerlink" title="【@JsonProperty】类似于sql里字段的别名，用于序列化，使用注解字段属性，替代原字段属性"></a>【@JsonProperty】类似于sql里字段的别名，用于序列化，使用注解字段属性，替代原字段属性</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@JsonProperty(&quot;userName&quot;)</span><span class="hljs-keyword">private</span> String name;</code></pre></div><h4 id="序列化结果为：在序列化的json串中，userName替代了name"><a href="#序列化结果为：在序列化的json串中，userName替代了name" class="headerlink" title="序列化结果为：在序列化的json串中，userName替代了name"></a>序列化结果为：在序列化的json串中，userName替代了name</h4><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;userName&quot;</span>:<span class="hljs-string">&quot;tom&quot;</span>&#125;</code></pre></div><h3 id="【-JsonIgnore】在序列化时忽略该字段"><a href="#【-JsonIgnore】在序列化时忽略该字段" class="headerlink" title="【@JsonIgnore】在序列化时忽略该字段"></a>【@JsonIgnore】在序列化时忽略该字段</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@Builder</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-meta">@JsonIgnore</span>    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-meta">@JsonProperty(&quot;userName&quot;)</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-meta">@JsonIgnore</span>    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-meta">@JsonIgnore</span>    <span class="hljs-keyword">private</span> Date birthday;&#125;</code></pre></div><h4 id="序列化结果为："><a href="#序列化结果为：" class="headerlink" title="序列化结果为："></a>序列化结果为：</h4><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;userName&quot;</span>:<span class="hljs-string">&quot;tom&quot;</span>&#125;</code></pre></div><h3 id="【-JsonIgnoreProperties】"><a href="#【-JsonIgnoreProperties】" class="headerlink" title="【@JsonIgnoreProperties】"></a>【@JsonIgnoreProperties】</h3><p>1、序列化@JsonIgnoreProperties与@JsonIgnore类似，用于类上，注解使用的是字段别名</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@Builder</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@JsonIgnoreProperties(&#123;&quot;id&quot;,&quot;userName&quot;,&quot;birthday&quot;&#125;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-meta">@JsonProperty(&quot;userName&quot;)</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-keyword">private</span> Date birthday;&#125;</code></pre></div><h4 id="序列化结果为：-1"><a href="#序列化结果为：-1" class="headerlink" title="序列化结果为："></a>序列化结果为：</h4><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;age&quot;</span>:<span class="hljs-number">23</span>&#125;</code></pre></div><p>2、@JsonIgnoreProperties(ignoreUnknown = true)用于忽略字段不匹配情况，相当于mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);</p><h3 id="【-JsonTypeName-JsonTypeInfo】用在类上，在序列化时增加一层"><a href="#【-JsonTypeName-JsonTypeInfo】用在类上，在序列化时增加一层" class="headerlink" title="【@JsonTypeName @JsonTypeInfo】用在类上，在序列化时增加一层"></a>【@JsonTypeName @JsonTypeInfo】用在类上，在序列化时增加一层</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@Builder</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@JsonTypeName(value = &quot;user&quot;)</span><span class="hljs-meta">@JsonTypeInfo(include = JsonTypeInfo.As.WRAPPER_OBJECT, use = JsonTypeInfo.Id.NAME)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-meta">@JsonProperty(&quot;userName&quot;)</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-keyword">private</span> Date birthday;&#125;</code></pre></div><p>序列化结果：</p><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;user&quot;</span>:&#123;<span class="hljs-attr">&quot;id&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">&quot;age&quot;</span>:<span class="hljs-number">23</span>,<span class="hljs-attr">&quot;birthday&quot;</span>:<span class="hljs-number">1587891781603</span>,<span class="hljs-attr">&quot;userName&quot;</span>:<span class="hljs-string">&quot;tom&quot;</span>&#125;&#125;</code></pre></div><h3 id="【-JsonRootName】"><a href="#【-JsonRootName】" class="headerlink" title="【@JsonRootName】"></a>【@JsonRootName】</h3><p>组合在序列化上等于类上注解@JsonRootName(“user”) 和 mapper.enable(SerializationFeature.WRAP_ROOT_VALUE),反序列化无用;</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@Builder</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-meta">@JsonProperty(&quot;userName&quot;)</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss:SSS&quot;, timezone = &quot;GMT+8&quot;)</span>    <span class="hljs-keyword">private</span> Date birthday;&#125;</code></pre></div><p>序列化结果：</p><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;id&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">&quot;age&quot;</span>:<span class="hljs-number">23</span>,<span class="hljs-attr">&quot;birthday&quot;</span>:<span class="hljs-string">&quot;2020-04-26 17:09:32:818&quot;</span>,<span class="hljs-attr">&quot;userName&quot;</span>:<span class="hljs-string">&quot;tom&quot;</span>&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>json</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RestTemplate</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>binner</title>
    <link href="/2021/05/16/java-binner-pic/"/>
    <url>/2021/05/16/java-binner-pic/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-binner"><a href="#Java-binner" class="headerlink" title="Java binner"></a>Java binner</h1><p>这么秀的代码，你能写出来吗？</p><p>技术主管来了都不好使，main函数里第一个函数必须是这个。</p><p>佛祖保佑版：</p><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">void godBless<span class="hljs-params">(void)</span>&#123;<span class="hljs-string">//</span>                              _ooOoo_<span class="hljs-string">//</span>                             o8888888o<span class="hljs-string">//</span>                             88<span class="hljs-string">&quot; . &quot;</span>88<span class="hljs-string">//</span>                             <span class="hljs-params">(| -_- |)</span><span class="hljs-string">//</span>                              O\ = <span class="hljs-string">/O</span><span class="hljs-string">//</span>                           ____/`<span class="hljs-params">---</span>&#x27;\____<span class="hljs-string">//</span>                        .   &#x27; \\| |<span class="hljs-string">//</span> `.<span class="hljs-string">//</span>                         / \\||| : |||<span class="hljs-string">//</span> \<span class="hljs-string">//</span>                        / _||||| -<span class="hljs-function">:-</span> |||||- \<span class="hljs-string">//</span>                         | | \\\ - <span class="hljs-string">///</span> | |<span class="hljs-string">//</span>                       | \_| &#x27;&#x27;\<span class="hljs-params">---/</span>&#x27;&#x27; | |<span class="hljs-string">//</span>                        \ <span class="hljs-string">.-</span>\__ `-` ___/-. /<span class="hljs-string">//</span>                    ___`. .&#x27; <span class="hljs-string">/--.--</span>\ `. . __<span class="hljs-string">//</span>                  .<span class="hljs-string">&quot;&quot;</span> &#x27;&lt; `<span class="hljs-string">.___</span>\_&lt;|&gt;_/___.&#x27; &gt;&#x27;<span class="hljs-string">&quot;&quot;</span>.<span class="hljs-string">//</span>                 | | : `- \`.;`\ _ /`;.`/ - ` : | |<span class="hljs-string">//</span>                    \ \ `-. \_ __\ <span class="hljs-string">/__</span> _/ <span class="hljs-string">.-</span>` / /<span class="hljs-string">//</span>           ======`-<span class="hljs-string">.____</span>`-<span class="hljs-string">.___</span>\_____/___.-`____.-&#x27;======<span class="hljs-string">//</span>                              `=<span class="hljs-params">---=</span>&#x27;<span class="hljs-string">//</span><span class="hljs-string">//</span>           <span class="hljs-string">.............................................</span><span class="hljs-string">//</span>                     佛祖保佑             永无BUG<span class="hljs-string">//</span>            佛曰:<span class="hljs-string">//</span>                     写字楼里写字间，写字间里程序员；<span class="hljs-string">//</span>                     程序人员写程序，又拿程序换酒钱。<span class="hljs-string">//</span>                     酒醒只在网上坐，酒醉还来网下眠；<span class="hljs-string">//</span>                     酒醉酒醒日复日，网上网下年复年。<span class="hljs-string">//</span>                     但愿老死电脑间，不愿鞠躬老板前；<span class="hljs-string">//</span>                     奔驰宝马贵者趣，公交自行程序员。<span class="hljs-string">//</span>                     别人笑我忒疯癫，我笑自己命太贱；<span class="hljs-string">//</span>                     不见满街漂亮妹，哪个归得程序员？&#125;</code></pre></div><p>佛主保佑版2：</p><div class="hljs code-wrapper"><pre><code class="hljs perl">void foZuBaoYou(void)&#123;    //<span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span>//                          _ooOoo<span class="hljs-number">_</span>                               ////                         o8888888o                              ////                         <span class="hljs-number">88</span><span class="hljs-string">&quot; . &quot;</span><span class="hljs-number">88</span>                              ////                         (| ^<span class="hljs-number">_</span>^ |)                              ////                         O\  =  <span class="hljs-regexp">/O                              /</span>///                      ___<span class="hljs-number">_</span>/<span class="hljs-string">`---&#x27;\____                           //</span><span class="hljs-string">//                    .&#x27;  \\|     |//  `</span>.                         ////                   <span class="hljs-regexp">/  \\|||  :  |||/</span><span class="hljs-regexp">/  \                        /</span>///                  <span class="hljs-regexp">/  _||||| -:- |||||-  \                       /</span>///                  |   | \\\  -  <span class="hljs-regexp">//</span><span class="hljs-regexp">/ |   |                       /</span>///                  | \<span class="hljs-number">_</span>|  <span class="hljs-string">&#x27;&#x27;</span>\---<span class="hljs-regexp">/&#x27;&#x27;  |   |                       /</span>///                  \  .-\_<span class="hljs-number">_</span>  <span class="hljs-string">`-`</span>  __<span class="hljs-number">_</span>/-. /                       <span class="hljs-regexp">//</span>//                __<span class="hljs-number">_</span><span class="hljs-string">`. .&#x27;  /--.--\  `</span>. . __<span class="hljs-number">_</span>                     ////              .<span class="hljs-string">&quot;&quot;</span> <span class="hljs-string">&#x27;&lt;  `.___\_&lt;|&gt;_/___.&#x27;</span>  &gt;<span class="hljs-string">&#x27;&quot;&quot;.                  //</span><span class="hljs-string">//            | | :  `- \`.;`\ _ /`;.`/ - ` : | |                 //</span><span class="hljs-string">//            \  \ `-.   \_ __\ /__ _/   .-` /  /                 //</span><span class="hljs-string">//      ========`-.____`-.___\_____/___.-`____.-&#x27;</span>========         <span class="hljs-regexp">//</span>//                           <span class="hljs-string">`=---=&#x27;                              //</span><span class="hljs-string">//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^        //</span><span class="hljs-string">//                  佛祖保佑       永不宕机     永无BUG              //</span><span class="hljs-string">////////////////////////////////////////////////////////////////////</span><span class="hljs-string">    </span><span class="hljs-string">&#125;</span></code></pre></div><p>再更新几个吧</p><blockquote><p>素材均来源于网络，本人只用过佛祖保佑版，就是第一个。</p></blockquote><p>佛祖不行了版：</p><div class="hljs code-wrapper"><pre><code class="hljs gherkin">void godFailed(void)&#123;        /<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span> <span class="hljs-symbol">*</span> _ooOoo_ <span class="hljs-symbol">*</span> o8888888o <span class="hljs-symbol">*</span> 88<span class="hljs-string">&quot; . &quot;</span>88 <span class="hljs-symbol">*</span> (|<span class="hljs-string"> -_- </span>|<span class="hljs-string">)</span><span class="hljs-string"> *  O\ = /O</span><span class="hljs-string"> * ___/`---&#x27;\____</span><span class="hljs-string"> * .   &#x27; \\</span>|<span class="hljs-string"> </span>|<span class="hljs-string">// `.</span><span class="hljs-string"> * / \\</span>|||<span class="hljs-string"> : </span>|||<span class="hljs-string">// \</span><span class="hljs-string"> * / _</span>|||||<span class="hljs-string"> -:- </span>|||||<span class="hljs-string">- \</span><span class="hljs-string"> * </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> \\\ - /// </span>|<span class="hljs-string"> </span>| <span class="hljs-symbol">*</span> |<span class="hljs-string"> \_</span>|<span class="hljs-string"> &#x27;&#x27;\---/&#x27;&#x27; </span>|<span class="hljs-string"> </span>| <span class="hljs-symbol">*</span> \ .-\__ `-` ___/-. / <span class="hljs-symbol">*</span> ___`. .&#x27; /--.--\ `. . __ <span class="hljs-symbol">*</span> .<span class="hljs-string">&quot;&quot;</span> &#x27;<span class="hljs-variable">&lt; `.___\_&lt;|&gt;</span>_/___.&#x27; &gt;&#x27;<span class="hljs-string">&quot;&quot;</span>. <span class="hljs-symbol">*</span> |<span class="hljs-string"> </span>|<span class="hljs-string"> : `- \`.;`\ _ /`;.`/ - ` : </span>|<span class="hljs-string"> </span>| <span class="hljs-symbol">*</span> \ \ `-. \_ __\ /__ _/ .-` / / <span class="hljs-symbol">*</span> ======`-.____`-.___\_____/___.-`____.-&#x27;====== <span class="hljs-symbol">*</span> `=---=&#x27; <span class="hljs-symbol">*</span>          ............................................. <span class="hljs-symbol">*</span>           佛曰：bug泛滥，我已瘫痪！ <span class="hljs-symbol">*</span>/&#125;</code></pre></div><p>海贼王版：</p><div class="hljs code-wrapper"><pre><code class="hljs gherkin">void kingOfPirateBless(void)&#123;    /<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>   <span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>   <span class="hljs-symbol">*</span>                                                            <span class="hljs-symbol">*</span>   <span class="hljs-symbol">*</span>    .=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-.      <span class="hljs-symbol">*</span>   <span class="hljs-symbol">*</span>    |<span class="hljs-string">                 ______________                 </span>|<span class="hljs-string">      * </span><span class="hljs-string"> *    </span>|<span class="hljs-string">                </span>|<span class="hljs-string">              </span>|<span class="hljs-string">                </span>|<span class="hljs-string">      *</span><span class="hljs-string"> *    </span>|<span class="hljs-string">               </span>|<span class="hljs-string">                </span>|<span class="hljs-string">               </span>|<span class="hljs-string">      * </span><span class="hljs-string"> *    </span>|<span class="hljs-string">       _______</span>|<span class="hljs-string">__________________</span>|<span class="hljs-string">________      </span>|<span class="hljs-string">      *  </span><span class="hljs-string"> *    </span>|<span class="hljs-string">                  .-&quot;      &quot;-.                  </span>|<span class="hljs-string">      *  </span><span class="hljs-string"> *    </span>|<span class="hljs-string">                 /            \                 </span>|<span class="hljs-string">      *  </span><span class="hljs-string"> *    </span>|<span class="hljs-string">     _          </span>|<span class="hljs-string">              </span>|<span class="hljs-string">          _     </span>|<span class="hljs-string">      *  </span><span class="hljs-string"> *    </span>|<span class="hljs-string">    ( \         </span>|<span class="hljs-string">,  .-.  .-.  ,</span>|<span class="hljs-string">         / )    </span>|<span class="hljs-string">      *  </span><span class="hljs-string"> *    </span>|<span class="hljs-string">     &gt; &quot;=._     </span>|<span class="hljs-string"> )(__/  \__)( </span>|<span class="hljs-string">     _.=&quot; &lt;     </span>|<span class="hljs-string">      *  </span><span class="hljs-string"> *    </span>|<span class="hljs-string">    (_/&quot;=._&quot;=._ </span>|<span class="hljs-string">/     /\     \</span>|<span class="hljs-string"> _.=&quot;_.=&quot;\_)    </span>|<span class="hljs-string">      *  </span><span class="hljs-string"> *    </span>|<span class="hljs-string">           &quot;=._&quot;(_     ^^     _)&quot;_.=&quot;           </span>|<span class="hljs-string">      *  </span><span class="hljs-string"> *    </span>|<span class="hljs-string">               &quot;=\__</span>|<span class="hljs-string">IIIIII</span>|<span class="hljs-string">__/=&quot;               </span>|<span class="hljs-string">      *  </span><span class="hljs-string"> *    </span>|<span class="hljs-string">              _.=&quot;</span>|<span class="hljs-string"> \IIIIII/ </span>|<span class="hljs-string">&quot;=._              </span>|<span class="hljs-string">      *  </span><span class="hljs-string"> *    </span>|<span class="hljs-string">    _     _.=&quot;_.=&quot;\          /&quot;=._&quot;=._     _    </span>|<span class="hljs-string">      *  </span><span class="hljs-string"> *    </span>|<span class="hljs-string">   ( \_.=&quot;_.=&quot;     `--------`     &quot;=._&quot;=._/ )   </span>|<span class="hljs-string">      *  </span><span class="hljs-string"> *    </span>|<span class="hljs-string">    &gt; _.=&quot;                            &quot;=._ &lt;    </span>|<span class="hljs-string">      *  </span><span class="hljs-string"> *    </span>|<span class="hljs-string">   (_/                                    \_)   </span>|<span class="hljs-string">      *  </span><span class="hljs-string"> *    </span>|<span class="hljs-string">                                                </span>|<span class="hljs-string">      *  </span><span class="hljs-string"> *    &#x27;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=&#x27;      *  </span><span class="hljs-string"> *                                                            *  </span><span class="hljs-string"> *                      1,500,000,000$                        *  </span><span class="hljs-string"> **************************************************************  </span><span class="hljs-string"> */</span><span class="hljs-string">&#125;</span></code></pre></div><p>杰瑞鼠版：</p><div class="hljs code-wrapper"><pre><code class="hljs gcode">void jerryBless<span class="hljs-comment">(void)</span>&#123;    <span class="hljs-comment">/**********/</span>**********<span class="hljs-comment">/**********/</span><span class="hljs-comment">/**********/</span><span class="hljs-comment">/**********/</span><span class="hljs-comment">/**********/</span><span class="hljs-comment">/**********/</span>  .--,       .--, <span class="hljs-comment">( (  \.---./  )</span> )  <span class="hljs-string">&#x27;.__/o   o\__.&#x27;</span>     &#123;=  ^  =&#125;      &gt;  -  &lt;     /       \    <span class="hljs-comment">//       \\</span>   <span class="hljs-comment">//|   .   |\\</span>   <span class="hljs-string">&quot;&#x27;\       /&#x27;&quot;</span>_.-~^`<span class="hljs-string">&#x27;-.</span><span class="hljs-string">      \  _  /--&#x27;</span>         `    ___)<span class="hljs-comment">( )</span><span class="hljs-comment">(___</span><span class="hljs-comment">   (((__)</span> <span class="hljs-comment">(__)</span>))    高山仰止,景行行止.虽不能至,心向往之。<span class="hljs-comment">/**********/</span>**********<span class="hljs-comment">/**********/</span><span class="hljs-comment">/**********/</span><span class="hljs-comment">/**********/</span><span class="hljs-comment">/**********/</span><span class="hljs-comment">/**********/</span>  &#125;</code></pre></div><p>神兽版：</p><div class="hljs code-wrapper"><pre><code class="hljs vala"><span class="hljs-keyword">void</span>  CNMBless(<span class="hljs-keyword">void</span>)&#123;<span class="hljs-meta">#code is far away from bug with the animal protecting</span><span class="hljs-meta">#    ┏┓   ┏┓</span><span class="hljs-meta">#   ┏┛┻━━━┛┻┓</span><span class="hljs-meta">#   ┃       ┃</span><span class="hljs-meta">#   ┃   ━   ┃</span><span class="hljs-meta">#   ┃ ┳┛ ┗┳ ┃</span><span class="hljs-meta">#   ┃       ┃</span><span class="hljs-meta">#   ┃   ┻   ┃</span><span class="hljs-meta">#   ┃       ┃</span><span class="hljs-meta">#   ┗━┓   ┏━┛Codes are far away from bugs with the animal protecting</span><span class="hljs-meta">#     ┃   ┃    神兽保佑,代码无bug</span><span class="hljs-meta">#     ┃   ┃</span><span class="hljs-meta">#     ┃   ┗━━━┓</span><span class="hljs-meta">#     ┃         ┣┓</span><span class="hljs-meta">#     ┃          ┏┛</span><span class="hljs-meta">#     ┗┓┓┏━┳┓┏┛</span><span class="hljs-meta">#      ┃┫┫ ┃┫┫</span><span class="hljs-meta">#      ┗┻┛ ┗┻┛</span>    <span class="hljs-meta">#code is far away from bug with the animal protecting</span><span class="hljs-meta">#    ┏┓   ┏┓</span><span class="hljs-meta">#   ┏┛┻━━━┛┻┓</span><span class="hljs-meta">#   ┃       ┃  </span><span class="hljs-meta">#   ┃   ━   ┃</span><span class="hljs-meta">#   ┃ ＞   ＜  ┃</span><span class="hljs-meta">#   ┃       ┃</span><span class="hljs-meta">#   ┃    . ⌒ .. ┃</span><span class="hljs-meta">#   ┃       ┃</span><span class="hljs-meta">#   ┗━┓   ┏━┛</span><span class="hljs-meta">#     ┃   ┃ Codes are far away from bugs with the animal protecting       </span><span class="hljs-meta">#     ┃   ┃ 神兽保佑,代码无bug</span><span class="hljs-meta">#     ┃   ┃           </span><span class="hljs-meta">#     ┃   ┃       </span><span class="hljs-meta">#     ┃   ┃</span><span class="hljs-meta">#     ┃   ┃           </span><span class="hljs-meta">#     ┃   ┗━━━┓</span><span class="hljs-meta">#     ┃       ┣┓</span><span class="hljs-meta">#     ┃       ┏┛</span><span class="hljs-meta">#     ┗┓┓┏━┳┓┏┛</span><span class="hljs-meta">#      ┃┫┫ ┃┫┫</span><span class="hljs-meta">#      ┗┻┛ ┗┻┛</span>    <span class="hljs-meta">#code is far away from bug with the animal protecting</span><span class="hljs-meta">#        ┏┓   ┏┓+ +</span><span class="hljs-meta">#   ┏┛┻━━━┛┻┓ + +</span><span class="hljs-meta">#   ┃       ┃  </span><span class="hljs-meta">#   ┃   ━   ┃ ++ + + +</span><span class="hljs-meta">#    ┃ ████━████  ┃+</span><span class="hljs-meta">#   ┃       ┃ +</span><span class="hljs-meta">#   ┃   ┻   ┃</span><span class="hljs-meta">#   ┃       ┃ + +</span><span class="hljs-meta">#   ┗━┓   ┏━┛</span><span class="hljs-meta">#     ┃   ┃           </span><span class="hljs-meta">#     ┃   ┃ + + + +</span><span class="hljs-meta">#     ┃   ┃    Codes are far away from bugs with the animal protecting   </span><span class="hljs-meta">#     ┃   ┃ +     神兽保佑,代码无bug  </span><span class="hljs-meta">#     ┃   ┃</span><span class="hljs-meta">#     ┃   ┃  +         </span><span class="hljs-meta">#     ┃    ┗━━━┓ + +</span><span class="hljs-meta">#     ┃        ┣┓</span><span class="hljs-meta">#     ┃        ┏┛</span><span class="hljs-meta">#     ┗┓┓┏━┳┓┏┛ + + + +</span><span class="hljs-meta">#      ┃┫┫ ┃┫┫</span><span class="hljs-meta">#      ┗┻┛ ┗┻┛+ + + +</span><span class="hljs-meta">#code is far away from bug with the animal protecting</span><span class="hljs-meta">#  ┏┓   ┏┓</span><span class="hljs-meta">#┏┛┻━━━┛┻┓</span><span class="hljs-meta">#┃       ┃  </span><span class="hljs-meta">#┃   ━   ┃</span><span class="hljs-meta">#┃ ┳┛ ┗┳ ┃</span><span class="hljs-meta">#┃       ┃</span><span class="hljs-meta">#┃   ┻   ┃</span><span class="hljs-meta">#┃       ┃</span><span class="hljs-meta">#┗━┓   ┏━┛</span><span class="hljs-meta">#  ┃   ┃神兽保佑</span><span class="hljs-meta">#  ┃   ┃代码无BUG！</span><span class="hljs-meta">#  ┃   ┗━━━┓</span><span class="hljs-meta">#  ┃       ┣┓</span><span class="hljs-meta">#  ┃       ┏┛</span><span class="hljs-meta">#  ┗┓┓┏━┳┓┏┛</span><span class="hljs-meta">#   ┃┫┫ ┃┫┫</span><span class="hljs-meta">#   ┗┻┛ ┗┻┛ </span><span class="hljs-meta">#   </span><span class="hljs-meta">#code is far away from bug with the animal protecting</span><span class="hljs-meta">#         ┌─┐       ┌─┐</span><span class="hljs-meta">#      ┌──┘ ┴───────┘ ┴──┐</span><span class="hljs-meta">#      │                 │</span><span class="hljs-meta">#      │       ───       │</span><span class="hljs-meta">#      │  ─┬┘       └┬─  │</span><span class="hljs-meta">#      │                 │</span><span class="hljs-meta">#      │       ─┴─       │</span><span class="hljs-meta">#      │                 │</span><span class="hljs-meta">#      └───┐         ┌───┘</span><span class="hljs-meta">#          │         │</span><span class="hljs-meta">#          │         │</span><span class="hljs-meta">#          │         │</span><span class="hljs-meta">#          │         └──────────────┐</span><span class="hljs-meta">#          │                        │</span><span class="hljs-meta">#          │                        ├─┐</span><span class="hljs-meta">#          │                        ┌─┘</span><span class="hljs-meta">#          │                        │</span><span class="hljs-meta">#          └─┐  ┐  ┌───────┬──┐  ┌──┘</span><span class="hljs-meta">#            │ ─┤ ─┤       │ ─┤ ─┤</span><span class="hljs-meta">#            └──┴──┘       └──┴──┘</span><span class="hljs-meta">#                神兽保佑</span><span class="hljs-meta">#                代码无BUG!    </span>&#125;</code></pre></div><p>真正的神兽版：</p><div class="hljs code-wrapper"><pre><code class="hljs vala"><span class="hljs-keyword">void</span> mythicalAnimalBless(<span class="hljs-keyword">void</span>)&#123;<span class="hljs-meta">#code is far away from bug with the animal protecting</span><span class="hljs-meta">#                  ___====-_  _-====___</span><span class="hljs-meta">#            _--^^^#####//      \\#####^^^--_</span><span class="hljs-meta">#         _-^##########// (    ) \\##########^-_</span><span class="hljs-meta">#        -############//  |\^^/|  \\############-</span><span class="hljs-meta">#      _/############//   (@::@)   \\############\_</span><span class="hljs-meta">#     /#############((     \\//     ))#############\</span><span class="hljs-meta">#    -###############\\    (oo)    //###############-</span><span class="hljs-meta">#   -#################\\  / VV \  //#################-</span><span class="hljs-meta">#  -###################\\/      \//###################-</span><span class="hljs-meta"># _#/|##########/\######(   /\   )######/\##########|\#_</span><span class="hljs-meta"># |/ |#/\#/\#/\/  \#/\##\  |  |  /##/\#/  \/\#/\#/\#| \|</span><span class="hljs-meta"># `  |/  V  V  `   V  \#\| |  | |/#/  V   &#x27;  V  V  \|  &#x27;</span><span class="hljs-meta">#    `   `  `      `   / | |  | | \   &#x27;      &#x27;  &#x27;   &#x27;</span><span class="hljs-meta">#                     (  | |  | |  )</span><span class="hljs-meta">#                    __\ | |  | | /__</span><span class="hljs-meta">#                   (vvv(VVV)(VVV)vvv)</span><span class="hljs-meta">#                  神兽保佑</span><span class="hljs-meta">#                代码无BUG!</span><span class="hljs-meta">#                                                    __----~~~~~~~~~~~------___</span><span class="hljs-meta">#                                   .  .   ~~//====......          __--~ ~~</span><span class="hljs-meta">#                   -.            \_|//     |||\\  ~~~~~~::::... /~</span><span class="hljs-meta">#                ___-==_       _-~o~  \/    |||  \\            _/~~-</span><span class="hljs-meta">#        __---~~~.==~||\=_    -_--~/_-~|-   |\\   \\        _/~</span><span class="hljs-meta">#    _-~~     .=~    |  \\-_    &#x27;-~7  /-   /  ||    \      /</span><span class="hljs-meta">#  .~       .~       |   \\ -_    /  /-   /   ||      \   /</span><span class="hljs-meta"># /  ____  /         |     \\ ~-_/  /|- _/   .||       \ /</span><span class="hljs-meta"># |~~    ~~|--~~~~--_ \     ~==-/   | \~--===~~        .\</span><span class="hljs-meta">#          &#x27;         ~-|      /|    |-~\~~       __--~~</span><span class="hljs-meta">#                      |-~~-_/ |    |   ~\_   _-~            /\</span><span class="hljs-meta">#                           /  \     \__   \/~                \__</span><span class="hljs-meta">#                       _--~ _/ | .-~~____--~-/                  ~~==.</span><span class="hljs-meta">#                      ((-&gt;/~   &#x27;.|||&#x27; -_|    ~~-/ ,              . _||</span><span class="hljs-meta">#                                 -_     ~\      ~~---l__i__i__i--~~_/</span><span class="hljs-meta">#                                 _-~-__   ~)  \--______________--~~</span><span class="hljs-meta">#                               //.-~~~-~_--~- |-------~~~~~~~~</span><span class="hljs-meta">#                                      //.-~~~--\</span><span class="hljs-meta">#                  神兽保佑</span><span class="hljs-meta">#                代码无BUG!</span>&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>date</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring-bean</title>
    <link href="/2021/05/11/spring-bean/"/>
    <url>/2021/05/11/spring-bean/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring基于XML方式的使用"><a href="#Spring基于XML方式的使用" class="headerlink" title="Spring基于XML方式的使用"></a><a href="">Spring基于XML方式的使用</a></h1><p><strong>目录</strong></p><ul><li>一、IoC配置<ul><li><a href="">1、bean标签介绍</a></li><li><a href="">2、bean的实例化</a></li></ul></li><li>二、DI配置<ul><li><a href="">1、依赖注入的方式</a></li><li><a href="">2、不同属性依赖注入</a></li></ul></li></ul><hr><p><a href="https://www.cnblogs.com/liuyi6/p/10217096.html#_labelTop">回到顶部</a></p><h2 id="一、IoC配置"><a href="#一、IoC配置" class="headerlink" title="一、IoC配置"></a>一、IoC配置</h2><p>IoC的配置是通过Spring的xml文件的<strong>bean标签</strong>进行的。</p><h3 id="1、bean标签介绍"><a href="#1、bean标签介绍" class="headerlink" title="1、bean标签介绍"></a>1、bean标签介绍</h3><p>bean标签一般是在xml文件进行配置的，xml文件一般样式如下：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span><span class="hljs-tag">    <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><p>可在其中进行bean标签的配置。</p><h4 id="1-1、bean标签的作用"><a href="#1-1、bean标签的作用" class="headerlink" title="1.1、bean标签的作用"></a>1.1、bean标签的作用</h4><p>bean标签用于配置被spring容器管理的bean的信息</p><p><strong>注意</strong>：bean标签配置的bean的创建默认是调用无参数的构造方法，若没有无参构造方法则不能创建成功。</p><h4 id="1-2、bean标签属性"><a href="#1-2、bean标签属性" class="headerlink" title="1.2、bean标签属性"></a>1.2、bean标签属性</h4><ul><li>id：给对象在<strong>容器中</strong>提供一个唯一标识。用于获取对象。</li><li>class：指定类的全限定名。用于反射创建对象。默认情况下<strong>调用无参构造函数</strong>。</li><li>scope：指定对象的作用范围。<ul><li>singleton：<strong>默认值</strong>，单例的（在整个容器中只有一个对象）.</li><li>prototype：多例的</li><li>request：将Spring 创建的 Bean 对象存入到 request 域中.</li><li>session：将Spring 创建的 Bean 对象存入到 session 域中.</li><li>global session：WEB 项目中,应用在 Portlet 环境.如果没有 Portlet 环境那么globalSession 相当于 session。</li></ul></li><li><strong>init-method</strong>：指定类中的初始化方法名称。</li><li><strong>destroy-method</strong>：指定类中销毁方法名称。比如DataSource的配置中一般需要指定destroy-method=“close”。</li><li><strong>lazy-init</strong>：ApplicationContext实现的默认行为就是在启动时将所有 singleton bean进行实例化。lazy-init可以延迟初始化，设置<code>lazy-init=&quot;true&quot;</code>使得Ioc容器在第一次需要bean的时候进行实例化。</li></ul><p>示例xml代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span><span class="hljs-tag">    <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;wanger&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.luis.dto.Person&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;zhangsan&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.luis.dto.Person&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;init&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;over&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;lisi&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.luis.dto.Person&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;prototype&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;lazy&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.luis.dto.Person&quot;</span> <span class="hljs-attr">lazy-init</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.luis.dto.Address&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><p><strong>注意：id和name的区别</strong></p><p>Bean标签提供了两种标识Bean的Attribute：id和name</p><ul><li>id用来标识bean，是唯一的，且只有一个，只允许以字母开头，其后只能为字母或数字或”-“。</li><li>name定义的是bean的alias，可以有多个，并可能与其他的bean重名，name允许特殊字符。</li><li>当多个重名的name同时存在时，先产生的bean会被后产生的bean覆盖</li><li>当id和name的值相同，通过值获取bean得到的是name对应的bean。</li></ul><p>示例代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.luis.dto.Student&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.luis.dto.Teacher&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-comment">&lt;!-- factory.getBean(“person”)返回的是Teacher对象--&gt;</span></code></pre></div><p>若置bean的时候并没有声明ID属性，则采用全类限定名作为bean的id，此时称为<strong>匿名bean</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.learnSpring.hellWorld&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.learnSpring.hellWorld&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.learnSpring.hellWorld&quot;</span>/&gt;</span></code></pre></div><p>如果存在多个class属性都是一样的匿名的Bean，则根据Spring读取配置文件的顺序生成id。</p><div class="hljs code-wrapper"><pre><code class="hljs xml">&quot;com.learnSpring.hellWorld&quot;&quot;com.learnSpring.hellWorld#0&quot;&quot;com.learnSpring.hellWorld#1&quot;</code></pre></div><h4 id="1-3、bena标签作用范围"><a href="#1-3、bena标签作用范围" class="headerlink" title="1.3、bena标签作用范围"></a>1.3、bena标签作用范围</h4><p>我们可在xml文件中通过bean标签的scope属性指定作用域，其取值区别如下表：</p><table><thead><tr><th align="center">作用域</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">singleton</td><td align="left">单例模式，singleton是默认的作用域，当定义Bean时没有指定scope配置项，Bean的作用域被默认为singleton。singleton属于单例模式，在整个系统上下文环境中，仅有一个Bean实例。</td></tr><tr><td align="center">prototype</td><td align="left">原型模式，当一个Bean的作用域被定义prototype时，程序每次从IOC容器获取的Bean都是一个新的实例。</td></tr><tr><td align="center">request</td><td align="left">http请求，bean作用于HTTP request生命周期，每个request有通过bean创建的实例。</td></tr><tr><td align="center">session</td><td align="left">会话，bean作用于session生命周期。</td></tr><tr><td align="center">global-session</td><td align="left">全局会话，bean作用于全局的session生命周期。</td></tr></tbody></table><p>参考了：<a href="https://www.cnblogs.com/best/p/5727935.html">https://www.cnblogs.com/best/p/5727935.html</a></p><p>这里主要对单例对象与多例对象进行说明：</p><ul><li>单例对象：<code>scope=&quot;singleton&quot;</code><ul><li>一个应用只用一个实例对象</li><li>生命周期与容器相关，当容器创建时对象产生，当对象销毁时对象销毁。</li></ul></li><li>多例对象：<code>scope=&quot;prototype&quot;</code><ul><li>每次访问对象时，都会重新创建对象实例。</li><li>生命周期与使用有关，当需要使用时创建对象，当对象长时间不使用，则被垃圾回收机制进行回收。</li></ul></li></ul><h3 id="2、bean的实例化"><a href="#2、bean的实例化" class="headerlink" title="2、bean的实例化"></a>2、bean的实例化</h3><p>bean有三种实例化方式：无参构造、静态工厂、实例工厂</p><h4 id="2-1、无参构造"><a href="#2-1、无参构造" class="headerlink" title="2.1、无参构造"></a>2.1、无参构造</h4><p>默认情况下会根据无参构造方法进行对象的实例化。</p><p>若没有无参构造方法则会创建失败。</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;wanger&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.luis.dto.Person&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><h4 id="2-2、静态工厂"><a href="#2-2、静态工厂" class="headerlink" title="2.2、静态工厂"></a>2.2、静态工厂</h4><p>使用静态工厂创建实例，其中:</p><ul><li>id 属性：指定 bean 的 id，用于从容器中获取</li><li>class 属性：指定静态工厂的全限定类名</li><li>factory-method 属性：指定生产对象的静态方法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.luis.factory.StaticFactory&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;createPerson&quot;</span>/&gt;</span></code></pre></div><h4 id="2-3、实例工厂"><a href="#2-3、实例工厂" class="headerlink" title="2.3、实例工厂"></a>2.3、实例工厂</h4><p>将工厂的创建交给Spring进行，使用工厂bean调用方法创建实例化对象。其中：</p><ul><li>factory-bean 属性：用于指定实例工厂 bean 的 id。</li><li>factory-method 属性：用于指定实例工厂中创建对象的方法。</li></ul><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;instancFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.luis.factory.PersonFactory&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;instancFactory&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;createPerson&quot;</span>/&gt;</span></code></pre></div><p><a href="https://www.cnblogs.com/liuyi6/p/10217096.html#_labelTop">回到顶部</a></p><h2 id="二、DI配置"><a href="#二、DI配置" class="headerlink" title="二、DI配置"></a>二、DI配置</h2><p>依赖注入(Dependency Injection)是 spring 框架核心 IoC 的具体实现。依赖指的是bean的属性，包括：简单类型（8种基本类型和String类型）的属性、POJO类型的属性、集合数组类型的属性。我们通过控制反转将实例化对象的交给IoC进行，但创建的对象没有依赖，因而需要Spring维护依赖关系，即依赖注入。</p><h3 id="1、依赖注入的方式"><a href="#1、依赖注入的方式" class="headerlink" title="1、依赖注入的方式"></a>1、依赖注入的方式</h3><h4 id="1-1、构造方法注入"><a href="#1-1、构造方法注入" class="headerlink" title="1.1、构造方法注入"></a>1.1、构造方法注入</h4><p>使用类中的构造函数，给成员变量赋值，，通过在xml文件中的bean进行配置的方式给对象赋值。</p><p>构造方法注入涉及的标签：</p><ul><li>constructor-arg</li><li>index:指定参数在构造函数参数列表的索引位置</li><li>name:指定参数在构造函数中的名称</li><li>value:它能赋的值是基本数据类型和 String 类型</li><li>ref:它能赋的值是其他 bean 类型，且必须是在配置文件中配置过的 bean</li></ul><p>Spring配置文件xml中的配置如下：</p><ul><li>使用参数名称指定参数</li></ul><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;zhangsan&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.luis.dto.Person&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span> =<span class="hljs-string">&quot;张三&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span> =<span class="hljs-string">&quot;22&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><ul><li>通过索引指定参数</li></ul><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;zhangsan&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.luis.dto.Person&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span> = <span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">value</span> =<span class="hljs-string">&quot;张三&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span> = <span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">value</span> =<span class="hljs-string">&quot;22&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><h4 id="1-2、set方法注入"><a href="#1-2、set方法注入" class="headerlink" title="1.2、set方法注入"></a>1.2、set方法注入</h4><p><strong>set方法注入</strong>又分为<strong>手动装配方式注入</strong>和<strong>自动装配方式注入</strong>。</p><ul><li>手动装配</li></ul><p>通过bean标签的子标签property来完成，且需要在在类中指定setter方法。</p><ul><li><p>自动装配(注解方式进行)，会在Spring的注解使用进行说明</p><ul><li><p>@Autowired</p><p>：</p><ul><li>作用一：<strong>查找实例</strong>，从spring容器中根据Bean的类型（byType）获取实例。</li><li>作用二：<strong>赋值</strong>，将找到的实例，装配给另一个实例的属性值。</li><li><strong>注意事项</strong>：一个Java类型在同一个spring容器中，只能有一个实例</li></ul></li><li><p><strong>@Resource</strong>：</p></li><li><p>作用一：<strong>查找实例</strong>，从spring容器中根据Bean的名称（byName）获取实例。</p></li><li><p>作用二：<strong>赋值</strong>，将找到的实例，装配给另一个实例的属性值。</p></li></ul></li></ul><p>xml方式的示例代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span> </span>&#123;<span class="hljs-keyword">private</span> String country;<span class="hljs-keyword">private</span> String city;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getCountry</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> country;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCountry</span><span class="hljs-params">(String country)</span> </span>&#123;<span class="hljs-keyword">this</span>.country = country;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getCity</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> city;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCity</span><span class="hljs-params">(String city)</span> </span>&#123;<span class="hljs-keyword">this</span>.city = city;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Address [country=&quot;</span> + country + <span class="hljs-string">&quot;, city=&quot;</span> + city + <span class="hljs-string">&quot;]&quot;</span>;&#125;&#125;</code></pre></div><p>Spring配置文件xml-ioc-01.xml中的配置如下：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.luis.dto.Address&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>  <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;country&quot;</span> <span class="hljs-attr">value</span> =<span class="hljs-string">&quot;中国&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>  <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;city&quot;</span> <span class="hljs-attr">value</span> =<span class="hljs-string">&quot;西安&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><p>可以简写为：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.luis.dto.Address&quot;</span> <span class="hljs-attr">p:country</span>=<span class="hljs-string">&quot;中国&quot;</span> <span class="hljs-attr">p:city</span>=<span class="hljs-string">&quot;西安&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><h4 id="1-3、p空间名称注入"><a href="#1-3、p空间名称注入" class="headerlink" title="1.3、p空间名称注入"></a>1.3、p空间名称注入</h4><p>p名称注入是set方法的一种简写方式，首先需引入p命名空间：</p><div class="hljs code-wrapper"><pre><code class="hljs xml">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</code></pre></div><p>p名称空间的语法：<code>p:属性名 = &quot;&quot;</code> 和 <code>p:属性名-ref = &quot;&quot;</code></p><p>上面的set注入可以简写为：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.luis.dto.Address&quot;</span> <span class="hljs-attr">p:country</span>=<span class="hljs-string">&quot;中国&quot;</span> <span class="hljs-attr">p:city</span>=<span class="hljs-string">&quot;西安&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><p>若对象中有引用对象，则：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.luis.dto.Address&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.luis.dto.Person&quot;</span> <span class="hljs-attr">p:pname</span>=<span class="hljs-string">&quot;田七&quot;</span> <span class="hljs-attr">p:age</span>=<span class="hljs-string">&quot;22&quot;</span> <span class="hljs-attr">p:address-ref</span>=<span class="hljs-string">&quot;address&quot;</span>/&gt;</span></code></pre></div><h3 id="2、不同属性依赖注入"><a href="#2、不同属性依赖注入" class="headerlink" title="2、不同属性依赖注入"></a>2、不同属性依赖注入</h3><h4 id="2-1、简单类型"><a href="#2-1、简单类型" class="headerlink" title="2.1、简单类型"></a>2.1、简单类型</h4><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 构造方法注入 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;lisi&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.luis.dto.Person&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span> =<span class="hljs-string">&quot;李四&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span> =<span class="hljs-string">&quot;22&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-comment">&lt;!-- 构造方法注入 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;wangwu&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.luis.dto.Person&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span> = <span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">value</span> =<span class="hljs-string">&quot;王五&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span> = <span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">value</span> =<span class="hljs-string">&quot;22&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-comment">&lt;!-- set方法注入 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.luis.dto.Address&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>  <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;country&quot;</span> <span class="hljs-attr">value</span> =<span class="hljs-string">&quot;中国&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>  <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;city&quot;</span> <span class="hljs-attr">value</span> =<span class="hljs-string">&quot;西安&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-comment">&lt;!-- p空间名称注入 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.luis.dto.Address&quot;</span> <span class="hljs-attr">p:country</span>=<span class="hljs-string">&quot;中国&quot;</span> <span class="hljs-attr">p:city</span>=<span class="hljs-string">&quot;西安&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><h4 id="2-2、引用类型"><a href="#2-2、引用类型" class="headerlink" title="2.2、引用类型"></a>2.2、引用类型</h4><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.luis.dto.Address&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>  <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;country&quot;</span> <span class="hljs-attr">value</span> =<span class="hljs-string">&quot;中国&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>  <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;city&quot;</span> <span class="hljs-attr">value</span> =<span class="hljs-string">&quot;西安&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-comment">&lt;!-- 构造方法注入 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;zhaoliu&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.luis.dto.Person&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span> = <span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">value</span> =<span class="hljs-string">&quot;赵六&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span> = <span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">value</span> =<span class="hljs-string">&quot;22&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span> = <span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">ref</span> =<span class="hljs-string">&quot;address&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-comment">&lt;!-- set方法注入 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tianqi&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.luis.dto.Person&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>  <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span> =<span class="hljs-string">&quot;田七&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>  <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span> =<span class="hljs-string">&quot;22&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>  <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">ref</span> =<span class="hljs-string">&quot;address&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-comment">&lt;!-- p空间名称注入 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.luis.dto.Person&quot;</span> <span class="hljs-attr">p:pname</span>=<span class="hljs-string">&quot;田七&quot;</span> <span class="hljs-attr">p:age</span>=<span class="hljs-string">&quot;22&quot;</span> <span class="hljs-attr">p:address-ref</span>=<span class="hljs-string">&quot;address&quot;</span>/&gt;</span></code></pre></div><h4 id="2-3、集合类型"><a href="#2-3、集合类型" class="headerlink" title="2.3、集合类型"></a>2.3、集合类型</h4><p>不同的集合类型，注入方式也有所区别：</p><p><strong>1、数组或List集合</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.luis.dto.Person&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;arrs&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>            <span class="hljs-comment">&lt;!-- 如果集合内是简单类型，使用value子标签，如果是POJO类型，则使用bean标签 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>张三<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>李四<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>            <span class="hljs-comment">&lt;!-- &lt;bean&gt;&lt;/bean&gt; --&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><p><strong>2、Set集合</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sets&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 如果集合内是简单类型，使用value子标签，如果是POJO类型，则使用bean标签 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>张三<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>李四<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></code></pre></div><p><strong>3、Map集合</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;张三&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;38&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;李四&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;38&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;王五&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;29&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></code></pre></div><p><strong>4、Properties集合</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pro&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;uname&quot;</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;pass&quot;</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>maven to centeral</title>
    <link href="/2021/05/11/maven-centeral/"/>
    <url>/2021/05/11/maven-centeral/</url>
    
    <content type="html"><![CDATA[<h1 id="如何将JAR包发布到Maven中央仓库？"><a href="#如何将JAR包发布到Maven中央仓库？" class="headerlink" title="如何将JAR包发布到Maven中央仓库？"></a><a href="">如何将JAR包发布到Maven中央仓库？</a></h1><p>将jar包发布到Maven中央仓库(<a href="https://mvnrepository.com/">Maven Central Repository</a>)，这样所有的Java开发者都可以使用</p><p>Maven直接导入依赖,例如</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.github.czy1024/luna-common --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.czy1024<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>luna-common<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>但是，Maven中央仓库并不支持直接发布jar包。我们需要将jar包发布到一些指定的第三方Maven仓库，然后该仓库再将jar包同步到Maven中央仓库。</p><p>其中，最”简单”的方式是通过<a href="https://central.sonatype.org/pages/ossrh-guide.html">Sonatype OSSRH</a>仓库来发布jar包。接下来，我会介绍如何将jar包发布到Sonatype OSSRH。</p><p>本教程所使用的系统配置如下：</p><ul><li>OS：macOS 10.14.2</li><li>JDK：1.8.0_192</li><li>Maven：3.5.4</li></ul><h3 id="1-注册JIRA账号"><a href="#1-注册JIRA账号" class="headerlink" title="1. 注册JIRA账号"></a>1. 注册JIRA账号</h3><p>JIRA是一个项目管理服务，类似于国内的Teambition。Sonatype通过JIRA来管理OSSRH仓库。</p><p>注册地址：<a href="https://issues.sonatype.org/secure/Signup!default.jspa">https://issues.sonatype.org/secure/Signup!default.jspa</a></p><p>需要填写Email, Full Name, Username以及password，其中<strong>Username与Password后面的步骤需要用到</strong>，请记下来。</p><h3 id="2-创建issue"><a href="#2-创建issue" class="headerlink" title="2. 创建issue"></a>2. 创建issue</h3><p>通过在JIRA上创建issue来申请发布新的jar包，Sonatype的工作人员会进行审核，审核不算严格，一般按照要求填写不会有问题。</p><p>创建链接：<a href="https://issues.sonatype.org/secure/CreateIssue.jspa?issuetype=21&amp;pid=10134">https://issues.sonatype.org/secure/CreateIssue.jspa?issuetype=21&amp;pid=10134</a></p><p><img src="https://i.loli.net/2021/05/11/AhUElLmIf5CjKqk.png" alt="img"></p><p>创建issue的时候需要填写下面这些信息：</p><ul><li>Summary</li><li>Description</li><li>Group Id</li><li>Project URL</li><li>SCM url</li></ul><p>大家可以参考我申请发布<a href="https://mvnrepository.com/artifact/com.fundebug/fundebug-java">fundebug-java</a>与<a href="https://mvnrepository.com/artifact/com.fundebug/fundebug-spring">fundebug-spring</a>时所填写的内容：<a href="https://issues.sonatype.org/browse/OSSRH-45238">OSSRH-45238</a></p><p>由于时差，前一天创建issue，第二天早上才会有回应。当issue的status变为<strong>RESOLVED</strong>，我们就可以进行下一步操作了。</p><h3 id="3-安装并配置GPG"><a href="#3-安装并配置GPG" class="headerlink" title="3. 安装并配置GPG"></a>3. 安装并配置GPG</h3><p>发布到Maven仓库中的所有文件都要使用GPG签名，以保障完整性。因此，我们需要在本地安装并配置GPG。</p><p><strong>安装GPG</strong></p><p>MacBook安装GPG非常简单，下载并安装<a href="https://gpgtools.org/">GPG Suite</a>即可。</p><p><strong>生成GPG密钥对</strong></p><div class="hljs code-wrapper"><pre><code class="hljs bash">gpg --gen-key</code></pre></div><p>生成密钥时将需要输入name、email以及password。<strong>password在之后的步骤需要用到</strong>，请记下来。</p><p><strong>上传GPG公钥</strong></p><p>将公钥上传到公共的密钥服务器，这样其他人才可以通过公钥来验证jar包的完整性。</p><div class="hljs code-wrapper"><pre><code class="hljs bash">gpg --keyserver hkp://keyserver.ubuntu.com:11371 --send-keys CAB4165C69B699D989D2A62BD74A11D3F9F41243</code></pre></div><p>其中<strong>CAB4165C69B699D989D2A62BD74A11D3F9F41243</strong>为密钥的ID，可以通过<strong>gpg –list-keys</strong>命令查看</p><div class="hljs code-wrapper"><pre><code class="hljs bash">gpg --list-keys/Users/kiwenlau/.gnupg/pubring.kbx----------------------------------pub   dsa2048 2010-08-19 [SC] [expires: 2020-06-15]      85E38F69046B44C1EC9FB07B76D78F0500D026C4uid           [ unknown] GPGTools Team &lt;team@gpgtools.org&gt;sub   elg2048 2010-08-19 [E] [expires: 2020-06-15]sub   rsa4096 2014-04-08 [S] [expires: 2024-01-02]pub   rsa2048 2019-01-03 [SC] [expires: 2021-01-02]      CAB4165C69B699D989D2A62BD74A11D3F9F41243uid           [ultimate] kiwenlau &lt;kiwenlau@gmail.com&gt;sub   rsa2048 2019-01-03 [E] [expires: 2021-01-02]</code></pre></div><h3 id="4-配置Maven的setting-xml"><a href="#4-配置Maven的setting-xml" class="headerlink" title="4. 配置Maven的setting.xml"></a>4. 配置Maven的setting.xml</h3><p><a href="https://www.cnblogs.com/fundebug/p/how-to-deploy-jar-to-maven-central-repository.html">setting.xml</a>为Maven的全局配置文件，在MacBook上的位置为**/usr/local/Cellar/maven/3.5.4/libexec/conf/settings.xml<strong>，我们需要将</strong>第1步**配置的Username和Password添加到<code>&lt;servers&gt;&lt;/servers&gt;</code>标签中，这样我们才能将jar包部署到Sonatype OSSRH仓库：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servers</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>ossrh<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>Fundebug<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>passsword<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servers</span>&gt;</span></code></pre></div><h3 id="5-配置项目的pom-xml"><a href="#5-配置项目的pom-xml" class="headerlink" title="5. 配置项目的pom.xml"></a>5. 配置项目的pom.xml</h3><p><strong>pom.xml</strong>挺长的。根据Sonatype OSSRH的<a href="https://central.sonatype.org/pages/requirements.html">要求</a>，以下信息都必须配置：</p><ul><li>Supply Javadoc and Sources</li><li>Sign Files with GPG/PGP</li><li>Sufficient Metadata<ul><li>Correct Coordinates</li><li>Project Name, Description and URL</li><li>License Information</li><li>Developer Information</li><li>SCM Information</li></ul></li></ul><p>配置时参考我的pom.xml，根据需要修改即可。</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.czy1024<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>luna-common<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>luna-common<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>common is project which contains common utils<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://github.com/czy1024/luna-common<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span>        <span class="hljs-comment">&lt;!-- github server corresponds to entry in ~/.m2/settings.xml --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">github.global.server</span>&gt;</span>github_auth<span class="hljs-tag">&lt;/<span class="hljs-name">github.global.server</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>        <span class="hljs-comment">&lt;!--dependencies--&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">developers</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">developer</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>luna<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>luna<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">email</span>&gt;</span>iszychen@gmail.com<span class="hljs-tag">&lt;/<span class="hljs-name">email</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">developer</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">developers</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">licenses</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">license</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Apache 2.0<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://www.apache.org/licenses/LICENSE-2.0<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">license</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">licenses</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-comment">&lt;!--依赖--&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span> <span class="hljs-comment">&lt;!--固定地址 是issue给你的地址--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">distributionManagement</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>ossrh<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://s01.oss.sonatype.org/service/local/staging/deploy/maven2/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">snapshotRepository</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>ossrh<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://s01.oss.sonatype.org/content/repositories/snapshots<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">snapshotRepository</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">distributionManagement</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scm</span>&gt;</span>       <span class="hljs-comment">&lt;!--提交issue的地址 或者项目发布路径--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://github.com/czy1024/luna-common<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>      <span class="hljs-comment">&lt;!--git链接--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">connection</span>&gt;</span>scm:git:https://github.com/czy1024/luna-common.git<span class="hljs-tag">&lt;/<span class="hljs-name">connection</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">developerConnection</span>&gt;</span>scm:git:https://github.com/czy1024/luna-common<span class="hljs-tag">&lt;/<span class="hljs-name">developerConnection</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">scm</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>ossrh<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>                    <span class="hljs-comment">&lt;!--这是自动发布的插件--&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.sonatype.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>nexus-staging-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">extensions</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">extensions</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">serverId</span>&gt;</span>ossrh<span class="hljs-tag">&lt;/<span class="hljs-name">serverId</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">nexusUrl</span>&gt;</span>https://s01.oss.sonatype.org/<span class="hljs-tag">&lt;/<span class="hljs-name">nexusUrl</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">autoReleaseAfterClose</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">autoReleaseAfterClose</span>&gt;</span>                        <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-release-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">autoVersionSubmodules</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">autoVersionSubmodules</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">useReleaseProfile</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">useReleaseProfile</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">releaseProfiles</span>&gt;</span>release<span class="hljs-tag">&lt;/<span class="hljs-name">releaseProfiles</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>deploy<span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>                        <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span>                        <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-gpg-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>                                <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>sign-artifacts<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>                                <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>verify<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span>                                <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>                                    <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>sign<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>                                <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>                            <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>                        <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-source-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>                                <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>attach-sources<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>                                <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>                                    <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>jar-no-fork<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>                                <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>                            <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>                        <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-javadoc-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">javadocExecutable</span>&gt;</span>$&#123;java.home&#125;/../bin/javadoc<span class="hljs-tag">&lt;/<span class="hljs-name">javadocExecutable</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">additionalparam</span>&gt;</span>-Xdoclint:none<span class="hljs-tag">&lt;/<span class="hljs-name">additionalparam</span>&gt;</span>                        <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>                                <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span>                                <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>                                    <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>                                <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>                            <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>                        <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div><h3 id="6-发布jar包"><a href="#6-发布jar包" class="headerlink" title="6. 发布jar包"></a>6. 发布jar包</h3><p>执行<strong>mvn clean deploy</strong>处理，即可将jar包发布到Sonatype OSSRH仓库。</p><div class="hljs code-wrapper"><pre><code class="hljs bash">mvn clean deploy -projects fundebug-java,fundebug-spring</code></pre></div><p>我们的项目<a href="https://github.com/Fundebug/fundebug-java-notifier">fundebug-java-notifier</a>含有多个模块，仅需部署fundebug-java与fundebug-spring，因此使用**-projects**选项来指定。</p><p>第一次执行<strong>mvn clean deploy</strong>命令时，需要输入GPG密钥的密码。</p><p><strong>mvn clean deploy</strong>命令执行成功的输出是这样的(部分日志)：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">[INFO] ------------------------------------------------------------------------[INFO] Reactor Summary:[INFO][INFO] fundebug-java 0.2.0 ................................ SUCCESS [ 22.183 s][INFO] fundebug-spring 0.2.0 .............................. SUCCESS [ 16.383 s][INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 38.728 s[INFO] Finished at: 2019-01-12T20:10:16+08:00[INFO] ------------------------------------------------------------------------</code></pre></div><h3 id="7-close并release"><a href="#7-close并release" class="headerlink" title="7. close并release"></a>7. close并release</h3><p><strong>mvn clean deploy</strong>命令执行成功，使用JIRA账号登陆：<a href="https://s01.oss.sonatype.org/content/repositories/%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E4%BD%A0%E6%89%80%E5%8F%91%E5%B8%83%E7%9A%84jar%E5%8C%85%E4%BA%86%EF%BC%9A">https://s01.oss.sonatype.org/content/repositories/，就可以看到你所发布的jar包了：</a></p><p><img src="https://i.loli.net/2021/05/11/NbR75JLqEAhwkxD.png" alt="img"></p><p>选中对于的repository之后，点击箭头所指的<strong>close</strong>，close时会检查发布的构件是否符合<a href="https://central.sonatype.org/pages/requirements.html">要求</a>。若符合要求，则close成功，成功之后点击箭头所指的<strong>release</strong>，即可正式将jar包发布到Sonatype OSSRH仓库。</p><p><strong>release</strong>成功大概2个小时之后，该构件就会同步到<a href="https://mvnrepository.com/">Maven中央仓库</a>：</p><p><img src="https://image.fundebug.com/2019-01-12-fundebug-maven.png" alt="img"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://maven.apache.org/repository/guide-central-repository-upload.html">Guide to uploading artifacts to the Central Repository</a></li><li><a href="https://central.sonatype.org/pages/ossrh-guide.html">OSSRH Guide</a></li><li><a href="https://blog.fundebug.com/2019/01/07/maven-tutorial/">Maven入门教程</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>maven</category>
      
    </categories>
    
    
    <tags>
      
      <tag>maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java utils files</title>
    <link href="/2021/05/10/java-utils-files/"/>
    <url>/2021/05/10/java-utils-files/</url>
    
    <content type="html"><![CDATA[<h1 id="File-Utils"><a href="#File-Utils" class="headerlink" title="File Utils"></a>File Utils</h1><table><thead><tr><th>write(final File file, final CharSequence data, final Charset encoding)write(final File file, final CharSequence data, final Charset encoding, final boolean append) write(final File file, final CharSequence data, final String encoding)write(final File file, final CharSequence data, final String encoding, final boolean append)</th><th>将字符序列写入到文件file：待写入的文件，路径不存在时，自动新建；data：写入的字节内容；append：是否追加；encoding：文件内容编码，这在网络通信时防止中文乱码非常有用。</th></tr></thead><tbody><tr><td>writeByteArrayToFile(final File file, final byte[] data)writeByteArrayToFile(final File file, final byte[] data, final boolean append)writeByteArrayToFile(final File file, final byte[] data, final int off, final int len)writeByteArrayToFile(final File file, final byte[] data, final int off, final int len,final boolean append)</td><td>将字节数组写入到文件file：待写入的文件，路径不存在时，自动新建；data：写入的字节内容；append：是否追加；off：字节数组写入的起始位置；lem：写入的长度</td></tr><tr><td>writeLines(final File file, final Collection<?> lines)writeLines(final File file, final Collection<?> lines, final boolean append)writeLines(final File file, final Collection<?> lines, final String lineEnding)writeLines(final File file, final Collection<?> lines, final String lineEnding,final boolean append)writeLines(final File file, final String encoding, final Collection<?> lines)writeLines(final File file, final String encoding, final Collection<?> lines,final boolean append)writeLines(final File file, final String encoding, final Collection<?> lines,final String lineEnding)writeLines(final File file, final String encoding, final Collection<?> lines,final String lineEnding, final boolean append)</td><td>将集合中的内容一次性写入文件file：待写入的文件，路径不存在时，自动新建；lines：要写入的行，null 表示插入空行append：内容是否追加lineEnding：要使用的行分隔符，null 表示使用系统默认值encoding：要使用的编码，{@code null}表示平台默认值</td></tr><tr><td>writeStringToFile(final File file, final String data, final Charset encoding)writeStringToFile(final File file, final String data, final Charset encoding,final boolean append)writeStringToFile(final File file, final String data, final String encoding)writeStringToFile(final File file, final String data, final String encoding,final boolean append)</td><td>将字符串写入到文件file：待写入的文件，路径不存在时，自动新建；data：写入的字节内容；append：是否追加；encoding：文件内容编码</td></tr><tr><td>byte[] readFileToByteArray(final File file)</td><td>将文件内容读入字节数组。文件始终处于关闭状态。</td></tr><tr><td>String readFileToString(final File file, final String encoding)String readFileToString(final File file, final Charset encoding)String readFileToString(final File file)</td><td>将文件的内容读入字符串。文件始终处于关闭状态。 file：要读取的文件，不能是 nullencoding:要使用的编码，null表示使用平台默认值</td></tr><tr><td>List<String> readLines(final File file, final Charset encoding)List<String> readLines(final File file, final String encoding)</td><td>逐行读取文件内容到字符串列表。文件始终处于关闭状态。 file：要读取的文件，不能是 nullencoding:要使用的编码，null表示使用平台默认值</td></tr><tr><td>LineIterator lineIterator(final File file)LineIterator lineIterator(final File file, final String encoding)</td><td>为文件打开一个 InputStream 的行迭代器，完成迭代器之后，应该关闭流以释放内部资源。LineIterator implements Iterator：可以很方便的一行一行读取文件内容</td></tr><tr><td>copyDirectory(final File srcDir, final File destDir)copyDirectory(final File srcDir, final File destDir,final boolean preserveFileDate)copyDirectory(final File srcDir, final File destDir,final FileFilter filter)copyDirectory(final File srcDir, final File destDir,final FileFilter filter, final boolean preserveFileDate)</td><td>将指定目录下所有子孙目录和文件复制到指定的目标目录下，如果目标目录不存在，则创建该目录。如果目标目录确实存在，则此方法将源目录与目标目录合并，源目录优先。注意只能是目录，如果是文件则异常。srcDir：源目录，不能为 nulldestDir：目标目录，不能为 nullpreserveFileDate：副本的文件日期是否与原件相同filter：要应用的筛选器，即可以细粒度的控制复制哪些文件或者目录，null 表示复制所有目录和文件</td></tr><tr><td>copyFile(final File srcFile, final File destFile)copyFile(final File srcFile, final File destFile,final boolean preserveFileDate)copyFile(final File input, final OutputStream output)</td><td>此方法将指定源文件的内容复制到指定的目标文件，如果目标文件不存在，则会创建包含目标文件的目录，如果目标文件存在，则此方法将覆盖它。srcFile：源文件，不能为 nulldestFile：目标文件，，不能为 nullpreserveFileDate：副本的文件日期是否与原件相同output：将文件复制到字节输出流，方法在内部使用缓冲输入。</td></tr><tr><td>copyFileToDirectory(final File srcFile, final File destDir)copyFileToDirectory(final File srcFile, final File destDir, final boolean preserveFileDate)</td><td>将指定源文件的内容复制到指定目标目录中同名的文件中。如果目标目录不存在，则创建该目录。如果目标文件存在，则此方法将覆盖它。srcFile：源文件，不能为 nulldestDir：目标目录，不能为 nullpreserveFileDate：副本的文件日期是否与原件相同</td></tr><tr><td>copyInputStreamToFile(final InputStream source, final File destination)</td><td>将字节输入流复制到目标文件中，不存在时自动创建</td></tr><tr><td>copyToDirectory(final File src, final File destDir)copyToDirectory(final Iterable<File> srcs, final File destDir)</td><td>将源文件或目录及其所有内容复制到指定目标目录中同名的目录中。如果目标目录不存在，则创建该目录。如果目标目录确实存在，则此方法将源目录与目标目录合并，源目录优先。src：源文件或者目录destDir：目标目录，不能为 null</td></tr><tr><td>copyToFile(final InputStream source, final File destination)</td><td>将字节输入流复制打目标文件中，如果目标目录不存在，则将创建该目录。如果目标已存在，则将覆盖该目标。</td></tr><tr><td>copyURLToFile(final URL source, final File destination)copyURLToFile(final URL source, final File destination,final int connectionTimeout, final int readTimeout)</td><td>将 URL 网络资源复制到目标文件中，可以用于下载，未设置超时时间时，可能出现永久阻塞connectionTimeout：连接超时时间，单位毫秒readTimeout：读取超时时间，单位毫秒</td></tr><tr><td>deleteDirectory(final File directory)</td><td>递归删除目录。注意只能是目录，如果是文件，则异常。</td></tr><tr><td>deleteQuietly(final File file)</td><td>安全删除文件或者递归删除目录，不会抛出任何异常。</td></tr><tr><td>forceDelete(final File file)</td><td>强制删除文件或者递归删除目录</td></tr><tr><td>forceMkdir(final File directory)</td><td>生成一个目录，包括任何必需但不存在的父目录。如果已存在具有指定名称的文件，但它不是目录，则会引发IOException。如果目录无法创建（或不存在），则抛出IOException。</td></tr><tr><td>moveDirectory(final File srcDir, final File destDir)</td><td>移动目录。当目标目录在另一个文件系统上时，执行“复制并删除”。srcDi r要移动的目录 destDir 目标目录</td></tr><tr><td>moveDirectoryToDirectory(final File src, final File destDir, final boolean createDestDir)</td><td>将目录移动到另一个目录。<em>将目录移动到另一个目录。</em>@param src要移动的文件*@param destDir目标文件*@param createDestDir如果为true，则创建目标目录，否则如果为false，则抛出IOException</td></tr><tr><td>moveFile(final File srcFile, final File destFile)</td><td>移动文件。当目标文件位于另一个文件系统上时，请执行“复制并删除”。</td></tr><tr><td>moveFileToDirectory(final File srcFile, final File destDir, final boolean createDestDir)</td><td>将文件移动到目录。</td></tr><tr><td>moveToDirectory(final File src, final File destDir, final boolean createDestDir)</td><td>将文件或目录移动到目标目录。*当目标位于另一个文件系统上时，请执行“复制并删除”。</td></tr><tr><td>forceMkdirParent(final File file)</td><td>为给定文件生成任何必需但不存在的父目录。如果无法创建父目录，则引发IOException。</td></tr><tr><td>File getFile(final File directory, final String… names)File getFile(final String… names)</td><td>获取文件对象directory：父目录names：子孙目录名称</td></tr><tr><td>File getTempDirectory()String getTempDirectoryPath()</td><td>返回系统临时目录。底层就是 System.getProperty(“java.io.tmpdir”)</td></tr><tr><td>File getUserDirectory()String getUserDirectoryPath()</td><td>返回用户的主目录，底层就是 System.getProperty(“user.home”)</td></tr><tr><td>boolean isFileNewer(final File file, final Date date)boolean isFileNewer(final File file, final File reference)boolean isFileNewer(final File file, final long timeMillis)</td><td>测试指定文件的最后修改时间是否在指定时间之后，底层是 file.lastModified() &gt; timeMillis</td></tr><tr><td>boolean isFileNewer(final File file, final Date date)boolean isFileNewer(final File file, final File reference)boolean isFileNewer(final File file, final long timeMillis)</td><td>测试指定文件的最后修改时间是否在指定时间之前，底层是 file.lastModified() &lt; timeMillis</td></tr><tr><td>long sizeOf(final File file)BigInteger sizeOfAsBigInteger(final File file)</td><td>返回指定文件或目录的大小。如果提供的{@link File}是一个常规文件，则返回该文件的长度。如果参数是目录，则递归计算目录的大小。如果某个目录或子目录受到安全限制，则不会包括其大小。请注意，不会检测到溢出，如果发生溢出，则返回值可能为负。</td></tr><tr><td>long sizeOfDirectory(final File directory)BigInteger sizeOfDirectoryAsBigInteger(final File directory)</td><td>递归计算目录的大小（所有文件的长度之和）。sizeOfDirectory 只统计目录的大小，单位为 字节，如果是文件则报错。</td></tr><tr><td>String byteCountToDisplaySize(final long size)String byteCountToDisplaySize(final BigInteger size)</td><td>将文件字节大小转为可视化的 KB、MB、GB 等形式的字符串，一共有：bytes、KB、MB、GB、TB、PB、EB.</td></tr><tr><td>boolean contentEquals(final File file1, final File file2)</td><td>比较两个文件的内容以确定它们是否相等。（注意只能是文件，如果是目录，则异常）此方法检查两个文件的长度是否不同，或者它们是否指向同一个文件，然后对内容进行逐字节比较。如果文件的内容相等或两者都不存在，则为true；否则为false</td></tr><tr><td>File[] convertFileCollectionToFileArray(final Collection<File> files)</td><td>将文件集合转为文件数组，底层就是:files.toArray(new File[files.size()]);</td></tr><tr><td>Collection<File> listFiles(final File directory, final String[] extensions, final boolean recursive)Collection<File> listFiles(final File directory, final IOFileFilter fileFilter, final IOFileFilter dirFilter)</td><td>查找给定目录（及其子目录）中与扩展名数组匹配的文件。 directory 要搜索的目录 extensions：要过滤的扩展数组，例如{“java”、“xml”}，为 null，返回所有文件。 ecursive：true 表示搜索所有子目录fileFilter：文件过滤器，IOFileFilter 是一个接口，常用的实现类有：SuffixFileFilter(文件后缀过滤器)、PrefixFileFilter(文件前缀过滤器)、TrueFileFilter(总是返回true的文件过滤器)、FalseFileFilter(总是返回false的文件过滤器)dirFilter：与上面同理</td></tr><tr><td>FileInputStream openInputStream(final File file)</td><td>为指定文件打开 FileInputStream，提供比简单调用new FileInputStream（file更好的错误消息。在方法结束时，要么成功打开流，要么抛出异常。<em>如果文件不存在，则引发异常。</em>如果文件对象存在但是一个目录，则引发异常。*如果文件存在但无法读取，则引发异常。</td></tr><tr><td>FileOutputStream openOutputStream(final File file)FileOutputStream openOutputStream(final File file, final boolean append)</td><td>打开指定文件的{@link FileOutputStream}，检查并创建父目录（如果不存在）。在方法结束时，要么成功打开流，要么抛出异常。<em>如果父目录不存在，将创建它。</em>如果文件不存在，将创建该文件。<em>如果文件对象存在但是一个目录，则引发异常。</em>如果文件存在但无法写入，则引发异常。*如果无法创建父目录，则引发异常。</td></tr><tr><td>File toFile(final URL url)File[] toFiles(final URL[] urls)</td><td>将 URL 转为 File 对象，注意只能对本地文件生成的 URL 才有效，对网络上的 URL 直接返回 null.</td></tr><tr><td>URL[] toURLs(final File[] files)</td><td>将 File 对象转为 URL 对象。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>apache</category>
      
    </categories>
    
    
    <tags>
      
      <tag>apache</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker-ssl</title>
    <link href="/2021/05/09/docker-ssl/"/>
    <url>/2021/05/09/docker-ssl/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-SSL"><a href="#Docker-SSL" class="headerlink" title="Docker SSL"></a>Docker SSL</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>仅仅开放远程访问Docker API，这个还不够的，因为会有安全问题。关于这点，Docker有相关的安全机制，参考官方文档<a href="https://docs.docker.com/engine/security/https/">Protect the Docker daemon socket</a>，大致就是：生成证书，用来达到验证客户端身份的目的。</strong></p><p>下面是操作步骤：</p><h2 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h2><h3 id="1-创建certs文件夹，用来存放CA私钥和公钥"><a href="#1-创建certs文件夹，用来存放CA私钥和公钥" class="headerlink" title="1. 创建certs文件夹，用来存放CA私钥和公钥"></a>1. 创建certs文件夹，用来存放CA私钥和公钥</h3><div class="hljs code-wrapper"><pre><code class="hljs awk">mkdir -pv <span class="hljs-regexp">/etc/</span>docker/certscd <span class="hljs-regexp">/etc/</span>docker/certs</code></pre></div><h3 id="2-创建密码"><a href="#2-创建密码" class="headerlink" title="2. 创建密码"></a>2. 创建密码</h3><p><strong>需要连续输入两次相同的密码</strong></p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">openssl</span> genrsa -aes<span class="hljs-number">256</span> -out ca-key.pem <span class="hljs-number">4096</span></code></pre></div><h3 id="3-依次输入密码、国家、省、市、组织名称等（除了密码外其他的可以直接回车跳过）"><a href="#3-依次输入密码、国家、省、市、组织名称等（除了密码外其他的可以直接回车跳过）" class="headerlink" title="3. 依次输入密码、国家、省、市、组织名称等（除了密码外其他的可以直接回车跳过）"></a>3. 依次输入密码、国家、省、市、组织名称等（除了密码外其他的可以直接回车跳过）</h3><div class="hljs code-wrapper"><pre><code class="hljs vim">openssl req -<span class="hljs-keyword">new</span> -x509 -days <span class="hljs-number">365</span> -key <span class="hljs-keyword">ca</span>-key.pem -<span class="hljs-built_in">sha256</span> -out <span class="hljs-keyword">ca</span>.pem</code></pre></div><h3 id="4-生成server-key-pem"><a href="#4-生成server-key-pem" class="headerlink" title="4. 生成server-key.pem"></a>4. 生成server-key.pem</h3><div class="hljs code-wrapper"><pre><code class="hljs pgsql">openssl genrsa -<span class="hljs-keyword">out</span> <span class="hljs-keyword">server</span>-key.pem <span class="hljs-number">4096</span></code></pre></div><h3 id="5-生成server-csr（把下面的IP换成你自己服务器外网的IP或者域名）"><a href="#5-生成server-csr（把下面的IP换成你自己服务器外网的IP或者域名）" class="headerlink" title="5. 生成server.csr（把下面的IP换成你自己服务器外网的IP或者域名）"></a>5. 生成server.csr（把下面的IP换成你自己服务器外网的IP或者域名）</h3><div class="hljs code-wrapper"><pre><code class="hljs pgsql">openssl req -subj &quot;/CN=123.123.123.123&quot; -sha256 -<span class="hljs-built_in">new</span> -key <span class="hljs-keyword">server</span>-key.pem -<span class="hljs-keyword">out</span> <span class="hljs-keyword">server</span>.csr</code></pre></div><h3 id="6-配置白名单"><a href="#6-配置白名单" class="headerlink" title="6. 配置白名单"></a>6. 配置白名单</h3><p><strong>0.0.0.0表示所有ip都可以连接。（这里需要注意，虽然0.0.0.0可以匹配任意，但是仍需要配置你的外网ip和127.0.0.1，否则客户端会连接不上）</strong></p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">echo</span> subjectAltName = IP:<span class="hljs-number">0.0.0.0</span>,IP:<span class="hljs-number">123.123.123.123</span>,IP:<span class="hljs-number">127.0.0.1</span> &gt;&gt; extfile.cnf</code></pre></div><p><strong>或者也可以设置成域名</strong></p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">echo</span> subjectAltName = DNS:www.example.com,IP:<span class="hljs-number">123.123.123.123</span>,IP:<span class="hljs-number">127.0.0.1</span> &gt;&gt; extfile.cnf</code></pre></div><h3 id="7-将Docker守护程序密钥的扩展使用属性设置为仅用于服务器身份验证"><a href="#7-将Docker守护程序密钥的扩展使用属性设置为仅用于服务器身份验证" class="headerlink" title="7. 将Docker守护程序密钥的扩展使用属性设置为仅用于服务器身份验证"></a>7. 将Docker守护程序密钥的扩展使用属性设置为仅用于服务器身份验证</h3><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">echo</span> extendedKeyUsage = serverAuth &gt;&gt; extfile.<span class="hljs-keyword">cnf</span></code></pre></div><h3 id="8-输入之前设置的密码，生成签名证书"><a href="#8-输入之前设置的密码，生成签名证书" class="headerlink" title="8.输入之前设置的密码，生成签名证书"></a>8.输入之前设置的密码，生成签名证书</h3><div class="hljs code-wrapper"><pre><code class="hljs stata">openssl x509 -req -days 365 -sha256 -<span class="hljs-keyword">in</span> server.csr -<span class="hljs-keyword">CA</span> <span class="hljs-keyword">ca</span>.pem -CAkey <span class="hljs-keyword">ca</span>-key.pem \  -CAcreateserial -<span class="hljs-keyword">out</span> server-cert.pem -extfile extfile.cnf</code></pre></div><h3 id="9、生成供客户端发起远程访问时使用的key-pem"><a href="#9、生成供客户端发起远程访问时使用的key-pem" class="headerlink" title="9、生成供客户端发起远程访问时使用的key.pem"></a>9、生成供客户端发起远程访问时使用的key.pem</h3><div class="hljs code-wrapper"><pre><code class="hljs sas">openssl genrsa -<span class="hljs-meta">out</span> <span class="hljs-meta">key</span>.pem 4096</code></pre></div><h3 id="10-生成client-csr（把下面的IP换成你自己服务器外网的IP或者域名）"><a href="#10-生成client-csr（把下面的IP换成你自己服务器外网的IP或者域名）" class="headerlink" title="10. 生成client.csr（把下面的IP换成你自己服务器外网的IP或者域名）"></a>10. 生成client.csr（把下面的IP换成你自己服务器外网的IP或者域名）</h3><div class="hljs code-wrapper"><pre><code class="hljs maxima">openssl req -subj <span class="hljs-string">&quot;/CN=123.123.123.123&quot;</span> -<span class="hljs-built_in">new</span> -<span class="hljs-built_in">key</span> <span class="hljs-built_in">key</span>.pem -out client.csr</code></pre></div><h3 id="11-创建扩展配置文件，把密钥设置为客户端身份验证用"><a href="#11-创建扩展配置文件，把密钥设置为客户端身份验证用" class="headerlink" title="11. 创建扩展配置文件，把密钥设置为客户端身份验证用"></a>11. 创建扩展配置文件，把密钥设置为客户端身份验证用</h3><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">echo</span> extendedKeyUsage = clientAuth &gt; extfile-client.<span class="hljs-keyword">cnf</span></code></pre></div><h3 id="12-生成cert-pem，输入前面设置的密码，生成签名证书"><a href="#12-生成cert-pem，输入前面设置的密码，生成签名证书" class="headerlink" title="12. 生成cert.pem，输入前面设置的密码，生成签名证书"></a>12. 生成cert.pem，输入前面设置的密码，生成签名证书</h3><div class="hljs code-wrapper"><pre><code class="hljs stata">openssl x509 -req -days 365 -sha256 -<span class="hljs-keyword">in</span> client.csr -<span class="hljs-keyword">CA</span> <span class="hljs-keyword">ca</span>.pem -CAkey <span class="hljs-keyword">ca</span>-key.pem \  -CAcreateserial -<span class="hljs-keyword">out</span> cert.pem -extfile extfile-client.cnf</code></pre></div><h3 id="13-删除不需要的配置文件和两个证书的签名请求"><a href="#13-删除不需要的配置文件和两个证书的签名请求" class="headerlink" title="13. 删除不需要的配置文件和两个证书的签名请求"></a>13. 删除不需要的配置文件和两个证书的签名请求</h3><div class="hljs code-wrapper"><pre><code class="hljs axapta">rm -v <span class="hljs-keyword">client</span>.csr <span class="hljs-keyword">server</span>.csr extfile.cnf extfile-<span class="hljs-keyword">client</span>.cnf</code></pre></div><h3 id="14-为了防止私钥文件被更改以及被其他用户查看，修改其权限为所有者只读"><a href="#14-为了防止私钥文件被更改以及被其他用户查看，修改其权限为所有者只读" class="headerlink" title="14. 为了防止私钥文件被更改以及被其他用户查看，修改其权限为所有者只读"></a>14. 为了防止私钥文件被更改以及被其他用户查看，修改其权限为所有者只读</h3><div class="hljs code-wrapper"><pre><code class="hljs lsl">chmod -v <span class="hljs-number">0400</span> ca-<span class="hljs-type">key</span>.pem <span class="hljs-type">key</span>.pem server-<span class="hljs-type">key</span>.pem</code></pre></div><h3 id="15-为了防止-公钥文件被更改，修改其权限为只读"><a href="#15-为了防止-公钥文件被更改，修改其权限为只读" class="headerlink" title="15. 为了防止##### 公钥文件被更改，修改其权限为只读"></a>15. 为了防止##### 公钥文件被更改，修改其权限为只读</h3><div class="hljs code-wrapper"><pre><code class="hljs stylus">chmod -v <span class="hljs-number">0444</span> ca<span class="hljs-selector-class">.pem</span> server-cert<span class="hljs-selector-class">.pem</span> cert.pem</code></pre></div><h3 id="16-修改Docker配置，使Docker守护程序仅接受来自提供CA信任的证书的客户端的连接"><a href="#16-修改Docker配置，使Docker守护程序仅接受来自提供CA信任的证书的客户端的连接" class="headerlink" title="16. 修改Docker配置，使Docker守护程序仅接受来自提供CA信任的证书的客户端的连接"></a>16. 修改Docker配置，使Docker守护程序仅接受来自提供CA信任的证书的客户端的连接</h3><p>拷贝安装包单元文件到/etc，这样就不会因为docker升级而被覆盖</p><div class="hljs code-wrapper"><pre><code class="hljs awk">cp <span class="hljs-regexp">/lib/</span>systemd<span class="hljs-regexp">/system/</span>docker.service <span class="hljs-regexp">/etc/</span>systemd<span class="hljs-regexp">/system/</span>docker.service</code></pre></div><p>在<code>ExecStart=/usr/bin/dockerd-current \</code>下面增加</p><div class="hljs code-wrapper"><pre><code class="hljs awk">--tlsverify \--tlscacert=<span class="hljs-regexp">/etc/</span>docker<span class="hljs-regexp">/certs/</span>ca.pem \--tlscert=<span class="hljs-regexp">/etc/</span>docker<span class="hljs-regexp">/certs/</span>server-cert.pem \--tlskey=<span class="hljs-regexp">/etc/</span>docker<span class="hljs-regexp">/certs/</span>server-key.pem \-H tcp:<span class="hljs-regexp">//</span><span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>:<span class="hljs-number">2376</span> \-H unix:<span class="hljs-regexp">//</span><span class="hljs-regexp">/var/</span>run/docker.sock \</code></pre></div><h3 id="17-重新加载daemon并重启docker"><a href="#17-重新加载daemon并重启docker" class="headerlink" title="17. 重新加载daemon并重启docker"></a>17. 重新加载daemon并重启docker</h3><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">systemctl daemon-reload</span><span class="hljs-attribute">systemctl restart docker</span></code></pre></div><h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><h3 id="1-创建证书目录"><a href="#1-创建证书目录" class="headerlink" title="1. 创建证书目录"></a>1. 创建证书目录</h3><div class="hljs code-wrapper"><pre><code class="hljs arcade">mkdir -pv ~<span class="hljs-regexp">/.docker/</span>certs/cd ~<span class="hljs-regexp">/.docker/</span>certs/</code></pre></div><h3 id="2-将ca-pem-cert-pem-key-pem这3个文件拷贝到当前目录"><a href="#2-将ca-pem-cert-pem-key-pem这3个文件拷贝到当前目录" class="headerlink" title="2. 将ca.pem cert.pem key.pem这3个文件拷贝到当前目录"></a>2. 将<code>ca.pem</code> <code>cert.pem</code> <code>key.pem</code>这3个文件拷贝到当前目录</h3><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">scp ca.pem <span class="hljs-string">./</span>scp cert.pem <span class="hljs-string">./</span>scp key.pem <span class="hljs-string">./</span></code></pre></div><h3 id="3-使用docker客户端测试（注意修改证书路径）"><a href="#3-使用docker客户端测试（注意修改证书路径）" class="headerlink" title="3. 使用docker客户端测试（注意修改证书路径）"></a>3. 使用docker客户端测试（注意修改证书路径）</h3><div class="hljs code-wrapper"><pre><code class="hljs awk">docker --tlsverify \    --tlscacert=<span class="hljs-regexp">/home/</span>alex<span class="hljs-regexp">/.docker/</span>certs/ca.pem \    --tlscert=<span class="hljs-regexp">/home/</span>alex<span class="hljs-regexp">/.docker/</span>certs/cert.pem \    --tlskey=<span class="hljs-regexp">/home/</span>alex<span class="hljs-regexp">/.docker/</span>certs/key.pem \    -H=<span class="hljs-number">123.123</span>.<span class="hljs-number">123.123</span>:<span class="hljs-number">2376</span> version</code></pre></div><h3 id="4-使用curl测试Docker-API"><a href="#4-使用curl测试Docker-API" class="headerlink" title="4. 使用curl测试Docker API"></a>4. 使用curl测试Docker API</h3><div class="hljs code-wrapper"><pre><code class="hljs awk">curl https:<span class="hljs-regexp">//</span><span class="hljs-number">123.123</span>.<span class="hljs-number">123.123</span>:<span class="hljs-number">2376</span><span class="hljs-regexp">/images/</span>json \  --cert ~<span class="hljs-regexp">/.docker/</span>certs/cert.pem \  --key ~<span class="hljs-regexp">/.docker/</span>certs/key.pem \  --cacert ~<span class="hljs-regexp">/.docker/</span>certs/ca.pem</code></pre></div><h3 id="5-配置默认远程调用服务器docker服务"><a href="#5-配置默认远程调用服务器docker服务" class="headerlink" title="5. 配置默认远程调用服务器docker服务"></a>5. 配置默认远程调用服务器docker服务</h3><div class="hljs code-wrapper"><pre><code class="hljs routeros"><span class="hljs-comment"># 配置~/.zshrc（或者~/.bashrc，根据你的客户端环境而定），在末尾添加以下几行</span><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">DOCKER_HOST</span>=tcp://123.123.123.123:2376 <span class="hljs-attribute">DOCKER_TLS_VERIFY</span>=1<span class="hljs-builtin-name">export</span> <span class="hljs-attribute">DOCKER_CERT_PATH</span>=~/.docker/certs/<span class="hljs-comment"># 然后让加载到当前会话</span>source .zshrc<span class="hljs-comment"># 测试</span>docker ps</code></pre></div><h4 id="务必非常小心保管这些key，它们就跟服务器root密码一样重要（众所周知docker是可以进行真实主机提权的）"><a href="#务必非常小心保管这些key，它们就跟服务器root密码一样重要（众所周知docker是可以进行真实主机提权的）" class="headerlink" title="*务必非常小心保管这些key，它们就跟服务器root密码一样重要（众所周知docker是可以进行真实主机提权的）"></a>*<code>务必非常小心保管这些key，它们就跟服务器root密码一样重要（众所周知docker是可以进行真实主机提权的）</code></h4>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux vim</title>
    <link href="/2021/05/09/linux-vim/"/>
    <url>/2021/05/09/linux-vim/</url>
    
    <content type="html"><![CDATA[<p>Vim最大的特征与最大的困难就是纯键盘操作，所以快速移动光标是Vim的最基本技能。我接触Vim也有四个年头了， 曾经由于项目重构操作频繁而切换到了WebStorm，最近又由<a href="https://harttle.land/2015/11/04/vim-ide.html">WebStorm 切换到了 Vim</a>。 始终感觉光标移动是最大的痛处，同时又能从键盘操作获得极大的快乐。</p><p>下文便开始介绍那些常用的快捷键，先上图！</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn6dxm699j60sg0k30yr02.jpg" alt="vim-key"></p><p>最近感受光标移动技能又一次升级了！来回顾一下我的Vim光标升级过程吧：</p><ol><li>只会上下左右和插入（<code>h</code>, <code>j</code>, <code>k</code>, <code>l</code>, <code>i</code>）。所有操作都由这5个键来完成。这时候用Vim的键盘声因简直像打Dota一样。我大概持续了一个月。</li><li>学会了单词移动和文件头尾（<code>w</code>, <code>b</code>, <code>$</code>, <code>^</code>, <code>gg</code>, <code>G</code>）。这时编辑起来不那么费力了，看起来还可以。这一阶段持续了两年…这两年里我学会了正则查找和替换（<code>/xx</code>, <code>%s/xx/xx/g</code>）。</li><li>能够熟练地滚屏（<code>zz</code>, <code>zt</code>, <code>zb</code>, <code>c-f</code>, <code>c-b</code>）、标识符间来回移动、按屏幕移动光标（<code>H</code>, <code>L</code>, <code>M</code>）、窗格间移动（<code>c-w hjkl</code>）。这是最近一年的水平，同时还学会了宏录制、列编辑等。</li><li>下一阶段：熟悉段落与单词间跳转，熟悉数字的使用。比如对于<code>func(args, count)</code>，我要记住从行首到第二个参数的快捷键是<code>4w</code>。</li></ol><blockquote><p>如果你还没有接触过Vim，可以从<a href="https://harttle.land/2013/11/08/vim-config.html">这里</a>开始。</p></blockquote><h2 id="字符移动"><a href="#字符移动" class="headerlink" title="字符移动"></a>字符移动</h2><p>在Vim的Normal模式里（如果你在Visual模式或者Insert模式，可以按<code>&lt;Esc&gt;</code>回到Normal模式）， 通过<code>h</code>, <code>j</code>, <code>k</code>, <code>l</code>, <code>i</code>来进行左下上右的光标移动。</p><p>在Vim中多数操作都支持数字前缀，比如<code>10j</code>可以向下移动10行。</p><h2 id="单词移动"><a href="#单词移动" class="headerlink" title="单词移动"></a>单词移动</h2><p>多数情况下单词移动比字符移动更加高效。 <code>w</code>移动光标到下一个单词的词首，<code>b</code>移动光标到上一个单词的词首；<code>e</code>移动光标到下一个单词的结尾，<code>ge</code>移动光标到上一个单词的结尾。</p><blockquote><p>单词移动同样支持数字前缀，比如<code>4w</code>可以向后移动4个单词。连续的标点符号算一个单词。</p><p>有趣的是，<code>W</code>, <code>B</code>, <code>E</code>具有同样的功能，只不过它是用空格来分隔单词的，可以跳地更远~</p></blockquote><p><code>^</code>到行首，<code>$</code>到行尾。</p><blockquote><p>拷贝一行：<code>^y$</code>。</p></blockquote><h2 id="相对屏幕移动"><a href="#相对屏幕移动" class="headerlink" title="相对屏幕移动"></a>相对屏幕移动</h2><p>通过<code>c-f</code>向下翻页，<code>c-b</code>向上翻页；<code>c-e</code>逐行下滚，<code>c-y</code>逐行上滚。这在几乎所有Unix软件中都是好使的，比如<code>man</code>和<code>less</code>。 <code>H</code>可以移动到屏幕的首行，<code>L</code>到屏幕尾行，<code>M</code>到屏幕中间。</p><p><code>zt</code>可以置顶当前行，通常用来查看完整的下文，比如函数、类的定义。 <code>zz</code>将当前行移到屏幕中部，<code>zb</code>移到底部。</p><h2 id="文件中移动"><a href="#文件中移动" class="headerlink" title="文件中移动"></a>文件中移动</h2><p>通过<code>:10</code>可以直接移动光标到文件第10行。如果你看不到行号，可以<code>:set number</code>。 <code>gg</code>移到文件首行，<code>G</code>移到尾行。</p><blockquote><p>拷贝整个文件：<code>ggyG</code>。</p></blockquote><p><code>/xx</code>可以查找某个单词<code>xx</code>，<code>n</code>查找下一个，<code>N</code>查找上一个。 在光标跳转之后，可以通过<code>c-o</code>返回上一个光标位置，<code>c-i</code>跳到下一个光标位置。</p><blockquote><p><code>?xx</code>可以反向查找，<code>q/</code>, <code>q?</code>可以列出查找历史。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>vim</category>
      
    </categories>
    
    
    <tags>
      
      <tag>util</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tomcat servlet</title>
    <link href="/2021/04/26/basic-tomcat-servlet/"/>
    <url>/2021/04/26/basic-tomcat-servlet/</url>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h1><div class="hljs code-wrapper"><pre><code class="hljs java">Servlet（Server Applet），全称Java Servlet，未有中文译文。是用Java编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态Web内容。狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。Servlet运行于支持Java的应用服务器中。从实现上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。</code></pre></div><p><strong>Java Web</strong>，是基于Java语言实现web服务的技术总和。介于现在Java在web客户端应用的比较少，我把学习重点放在了JavaWeb服务端应用。虽然用Springboot就可以很快地搭建一个web项目了，但是如果想要深入了解JavaWeb的实现原理，就不得不先学习Servlet和Servlet容器的相关知识。</p><p>首先什么是Servlet？</p><p><strong>Servlet</strong>从广义上讲是Sun公司提供的一门用于开发动态Web资源的技术，而狭义上指的是实现了javax.servlet.Servlet接口的类的统称。Servlet接口很简单，只有init、getServletConfig、service、getServletInfo和destroy这5个方法，它们构成了实现Servlet功能的规范。像Spring的DispatcherServlet，都是一种具体的Servlet。</p><p>当然了，光有Servlet这一个类可没什么用，它没有main方法，不能独立运行，就像光有子弹没有枪，子弹的价值就发挥不出来。要想实现Servlet的功能，就必须有一个Servlet容器。</p><p><strong>Servlet容器</strong>，也叫做Servlet引擎，是web服务器的一部分，用于接收网络请求，把请求转发给对应的Servlet，并把Servlet处理的结果返回给网络。</p><p>它是web服务器和Servlet之间的媒介。</p><p>它建立服务端socket、监听端口、创建流。</p><p>它管理着Servlet的生命周期，如加载部署Servlet，实例化初始化Servlet，调用Servlet方法（处理业务），以及销毁Servlet。</p><p><strong>Tomcat</strong>就是一个独立运行的Servlet容器。</p><h1 id="Tomcat组织结构"><a href="#Tomcat组织结构" class="headerlink" title="Tomcat组织结构"></a>Tomcat组织结构</h1><p>下面就以Tomcat8为例，看看一个具体的Servlet容器是如何实现上述功能的。</p><p>先来一张Tomcat的结构图：</p><p><img src="https://upload-images.jianshu.io/upload_images/9705246-088f353b84544269.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>Server：Tomcat顶层容器，代表着整个服务器。包含一个或多个Service组件；</p><p>Service：存活在Server内部的中间组件，包含Connector和Container这两个核心组件，负责将一个或多个Connector组件绑定到一个Container上；</p><p>Connector：监听端口，处理与客户端基于某种协议的通信，提供Socket与request和response的转换；</p><p>Container：封装和管理Servlet，负责对请求进行处理，并生成响应。</p><p>（先介绍这几个大的组件，小组件在后面会细讲）</p><p>这样展示可能比较抽象，我们可以打开我们安装的Tomcat目录下的conf/server.xml，看下Tomcat是如何配置这些组件的：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Server</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8005&quot;</span> <span class="hljs-attr">shutdown</span>=<span class="hljs-string">&quot;SHUTDOWN&quot;</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">Service</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Catalina&quot;</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8080&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span> <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">&quot;20000&quot;</span> <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span> <span class="hljs-attr">URIEncoding</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>/&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8009&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;AJP/1.3&quot;</span> <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">Engine</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Catalina&quot;</span> <span class="hljs-attr">defaultHost</span>=<span class="hljs-string">&quot;localhost&quot;</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">Host</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;localhost&quot;</span> <span class="hljs-attr">appBase</span>=<span class="hljs-string">&quot;webapps&quot;</span>&gt;</span>         ...      <span class="hljs-tag">&lt;/<span class="hljs-name">Host</span>&gt;</span>    &lt;Host...    <span class="hljs-tag">&lt;/<span class="hljs-name">Engine</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">Service</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">Server</span>&gt;</span></code></pre></div><p>先看<strong>Connector</strong>，可以看到一个Service里是可以配置多个Connector的，这里我们主要关心HTTP协议的Connector。</p><p>Connector使用持有的ProtocolHandler类型对象来处理请求，它包含的三个部件：</p><p>Endpoint：绑定端口、监听请求；</p><p>Processor：将Endpoint接收到的Socket封装成Request；</p><p>Adapter：将Request交给Container进行具体的处理。</p><p>再看<strong>Container</strong>，它内部包含了4个子容器</p><p>Engine：Servlet引擎，Container最上层，每个Service只能包含一个，表示一个特定的Service的请求处理流水线，从Connector接收处理所有的请求并返回响应；</p><p>Host：虚拟主机，一个引擎可以包含多个Host；一个Host可以包含多个Context；</p><p>Context：一个Context表示了一个Web应用程序（Web工程）。Context直接管理Servlet在容器中的包装类；</p><p>Wrapper：每一个Servlet在容器中的包装类。</p><p>我们可以通过Tomcat文件夹里的文件结构来帮助理解，上面提到的conf/server.xml里配置Host时有个appBase的属性是webapps，是不是很眼熟？我们在Tomcat安装目录下总是有一个webapp文件夹，整个webapps就是一个Host站点，里面放着的每个文件夹目录就对应一个Context，其中ROOT目录中存放着主应用，其他目录存放着子应用。</p><h1 id="Tomcat类加载"><a href="#Tomcat类加载" class="headerlink" title="Tomcat类加载"></a>Tomcat类加载</h1><p>先看Tomcat是如何加载类的。</p><p>Tomcat启动时创建的类加载器有</p><blockquote><p>BootstrapClassLoader：加载JVM提供的基本运行类，和$JAVA_HOME/jre/lib/ext里的jar包；</p><p>SystemClassLoader：加载tomcat启动的类，即Catalina.bat中指定位置的类；</p><p>CommonClassLoader：加载tomcat以及应用通用的类，位于CATALINA_HOME/lib下。父加载器是AppClassLoader；</p><p>WebAppClassLoader：每个应用在部署后都创建一个唯一的类加载器，加载位于WEB-INF/lib中的jar包和WEB-INF/classes下的class文件。父加载器是CommonClassLoader。</p></blockquote><p>Tomcat默认类加载逻辑：</p><p>1、先在本地缓存中查找，如果已经加载即返回，否则继续下一步</p><p>2、尝试Bootstrap加载，如果加载到即返回，否则</p><p>3、WebApp自行加载，先/WEB-INF/classes，再/WEB-INF/lib/*.jar，如果加载到即返回，否则</p><p>4、委托WebApp父类加载器(Common ClassLoader)去加载。。。</p><p>注意：第3、4两步违反了双亲委托机制，但也只是Tomcat自定义的ClassLoader加载顺序违反了，顶层还是相同的。</p><p>Tomcat的这种加载逻辑保证了每个应用程序的同名类库是独立的，同时可以共享共有类库。</p><p>每一个JSP文件对应一个Jsp类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载器，重新创建类加载器，重新加载jsp文件。</p><h1 id="Tomcat启动流程"><a href="#Tomcat启动流程" class="headerlink" title="Tomcat启动流程"></a>Tomcat启动流程</h1><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvo3i678zgg613v0me4qp02.gif" alt="img"></p><p>下面开始分析Tomcat大致启动流程，建议配合源码食用。</p><p>Tomcat传统的启动入口通过startup.bat和catalina.bat脚本调用org.apache.catalina.startup.Bootstrap.main()，分为两部分：</p><p>一、init()：初始化main线程的daemon（一个Bootstrap对象）。初始化Tomcat类加载器，通过反射来实例化Catalina对象；</p><p>二、daemon执行三个方法setAwait(true)、load(args)和start()：</p><p>1、setAwait：通过反射调用catalina的setAwait方法设置await属性，后面会用到；</p><p>2、load(args)：通过反射调用catalina的load方法，创建xml解析器，解析conf/server.xml创建出了StandardServer对象并init，继而调用内部包含的service的int，以此逐层初始化所有组件；</p><p>3、start()：通过反射调用catalina的start()方法，和init方法一样逐层start所有组件；最后利用前面设置的await属性调用await方法，继而调用server的await方法，保证主线程运行并持续监听8005端口的SHUTDOWN指令，接收到后调用stop方法关闭Tomcat。</p><p>上面各个组件的init和start都是一笔带过，那么他们实际完成了什么样的工作呢？</p><p>Server.init()：调用包含的Service的init；</p><p>Service.init()：初始化Engine，初始化Executor（所有Connector共享的线程池），初始化mapperListener（用来保存容器映射），调用Connector.init；</p><p>Connector.init()：初始化ProtocolHandler、Adapter，Endpoint创建ServerSocket并绑定监听端口</p><p>Server.start()：调用包含的Services的start;</p><p>Service.start()：与初始化对应，调用Engine.start，启动Executor，启动mapperListener（作为监听者加到容器和它们的子容器中），调用Connector.start</p><p>Connector.start()：Endpoint创建acceptor线程来接收客户端的连接以及poller线程来处理连接中的读写请求</p><p>Engine.start()：逐一启动Host、Context、Wrapper</p><p>Context.start()：步骤很多，这里列举几个重要的：</p><p>*）创建读取资源文件的对象</p><p>*）创建ClassLoader对象，就是上面提到过的每个应用唯一的WebAppClassLoader</p><p>*）设置应用的工作目录</p><p>*）启动相关辅助对象，如Logger、realm、resources等</p><p>*）通知监听者ContextConfig读取和解析Web应用web.xml和注解 </p><p>*）启动web.xml解析到的子容器（解析时将Servlet包装成StandardWrapper）</p><p>*）启动Pipeline（一种责任链设计模式后面会讲）</p><p>*）获取或创建ServletContext，并设置必要的参数</p><p>*）创建Context中配置的Listener；</p><p>*）创建和初始化配置的Filter；</p><p>*）创建和初始化loadOnStartup大于等于0的Servlet</p><h1 id="Tomcat处理请求过程"><a href="#Tomcat处理请求过程" class="headerlink" title="Tomcat处理请求过程"></a>Tomcat处理请求过程</h1><p>现在我们知道Tomcat是如何启动的，那么启动之后Tomcat如何处理一次请求的呢？</p><p>下面以一次Http请求为例来说明，请求URL=<a href="http://hostname:port/contextpath/servletpath。">http://hostname:port/contextpath/servletpath。</a></p><p>在Connector组件树中：</p><div class="note note-success">            <p>前面启动的过程中提到过<code>Connector的Endpoint的acceptor线程负责接收Socket连接</code>，acceptor接收请求之后调用processSocket方法，把socket包装成SocketWrapper，创建一个SocketProcessor任务，从线程池中获取一个线程处理该任务。run方法中调用AbstractEndpoint.Handler.process方法，根据请求的协议类型（con/server.xml中connector元素的protocol属性值）创建相应的类型处理类Processor，对SocketWrapper的输入流和输出流进行包装，<strong>根据SocketWrapper创建轻量级的coyote.Request和coyote.Response</strong>，<code>解析http请求的请求头和请求行</code>，最后Adapter.service(Request, Response)，将coyote.Request和coyote.Response转化成Connector.Request和Connector.Response，调用connector.getService().getMapper().map()，根据hostname、contextpath和servletpath找到对应的host、context和Wapper（前面利用mapperListener保存的容器完整关系），设置到Request中去；再调用connector.getService().getContainer().getPipeline().getFirst().invoke(request, response)将请求传递给与Connector关联的Container逐级传递下去（Engine-&gt;Host-&gt;Context-&gt;Wapper）。</p>          </div><p>在Container组件树中：</p><p><code>Container容器按照责任链的设计模式</code>，使用管道<code>Pipeline和Value</code>的方式来传递请求。</p><p>第一层是Engine，先通过conf/server.xml中配置的value，最后总会流到StandardEngineValue，调用host.getPipeline().getFirst().invoke(request, response)将请求传递给request中保存的Host；</p><p>第二层是Host，同样先通过配置的value，最后流到StandardHostValue，再传递给request中保存的Context；</p><p>第三层是Context，流到StandardContextValue传递给request中保存的Wapper；</p><p>最后是Wapper，流到StandardWapperValue，获取Servlet单例（双检查锁机制），获取FilterChain执行Filter链，也是一种责任链模式，执行完所有配置的Filter后执行Servlet.service，即我们希望其完成的业务逻辑。</p><p>（在进入Filter的时候，传入的是Connector.Request的门面类RequestFacade，和Request一样都是HttpServletRequest和HttpServletResponse的实现类）</p><p>返回过程略。</p><h2 id="专注HTTP请求的Servlet"><a href="#专注HTTP请求的Servlet" class="headerlink" title="专注HTTP请求的Servlet"></a>专注HTTP请求的Servlet</h2><p>1　写一个专门处理HTTP请求的Servlet</p><p>因为现在我们的请求都是基于HTTP协议的，所以我们应该专门为HTTP请求写一个Servlet做为通用父类。</p><p>对于专注于HTTP的Servlet，我们需要处理以下几个问题：</p><p>service()方法的参数ServletRequest和ServletResponse，但因为所有的请求都是HTTP请求，所以传递给service()就去的参数其实是HttpServletRequest和HttpServletResponse对象。如果子类希望使用的是HttpServletRequest，而不是ServletRequest，那么它需要自己去做强转。</p><p>Servlet：SUN公司 设计之初 以后不仅仅依赖HTTP协议</p><div class="hljs code-wrapper"><pre><code>   GenericServlet  --- 通用Servlet   service(ServletRequest req, ServletResponse res)   HttpServlet    --- 与协议相关的Servlet   service(HttpServletRequest req, HttpServletResponse resp)</code></pre></div><p> 以后再写Servlet  继承  HttpServlet</p><div class="hljs code-wrapper"><pre><code>   Servlet           --- 一个标准          |   GenericServlet      ---  是Servlet接口子类          |   HttpServlet    --- 是GenericServlet子类，一个专门处理Http请求的Servlet</code></pre></div><p>HttpServlet</p><div class="hljs code-wrapper"><pre><code>   两个Service方法          * 父类service 调用子类service   使用子类service方法就可以          * 子类中service 根据请求方式不同 调用不同的方法          只需要重写doGet和doPost就行.                写一个Servlet 继承HttpServlet   重写doGet和doPost 方法.</code></pre></div><p>没错，Java中已经存在了javax.servlet.http.HttpServlet类。打开源代码看看这个类！</p><p>2　HTTP请求方法<br>HTTP请求方法不只是GET和POST，还有其他的方法，但基本上用不上。这里只是简单介绍一下。你自己心里有个数，HTTP请求除了GET和POST之外还有别的就行了。</p><blockquote><p>GET通过请求URI得到资源<br>POST用于添加新的内容<br>PUT用于修改某个内容<br>DELETE,删除某个内容<br>CONNECT用于代理进行传输，如使用SSL<br>OPTIONS询问可以执行哪些方法<br>PATCH部分文档更改<br>RACE用于远程诊断服务器<br>HEAD类似于GET, 但是不返回body信息，用于检查对象是否存在，以及得到对象的元数据<br>TRACE用于远程诊断服务器</p></blockquote><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/qq_19782019/article/details/80292110">https://blog.csdn.net/qq_19782019/article/details/80292110</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>tomcat</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tomcat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tomcat interview</title>
    <link href="/2021/04/26/tomcat-interview/"/>
    <url>/2021/04/26/tomcat-interview/</url>
    
    <content type="html"><![CDATA[<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><h2 id="Tomcat是什么？"><a href="#Tomcat是什么？" class="headerlink" title="Tomcat是什么？"></a>Tomcat是什么？</h2><p>Tomcat 服务器Apache软件基金会项目中的一个核心项目，是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。</p><h2 id="Tomcat的缺省端口是多少，怎么修改"><a href="#Tomcat的缺省端口是多少，怎么修改" class="headerlink" title="Tomcat的缺省端口是多少，怎么修改"></a>Tomcat的缺省端口是多少，怎么修改</h2><ol><li>找到Tomcat目录下的conf文件夹</li><li>进入conf文件夹里面找到server.xml文件</li><li>打开server.xml文件</li><li>在server.xml文件里面找到下列信息</li><li>把Connector标签的8080端口改成你想要的端口</li></ol><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Service</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Catalina&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8080&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span> </span><span class="hljs-tag">               <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">&quot;20000&quot;</span> </span><span class="hljs-tag">               <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span> /&gt;</span></code></pre></div><h2 id="tomcat-有哪几种Connector-运行模式-优化-？"><a href="#tomcat-有哪几种Connector-运行模式-优化-？" class="headerlink" title="tomcat 有哪几种Connector 运行模式(优化)？"></a>tomcat 有哪几种Connector 运行模式(优化)？</h2><h3 id="下面，我们先大致了解Tomcat-Connector的三种运行模式。"><a href="#下面，我们先大致了解Tomcat-Connector的三种运行模式。" class="headerlink" title="下面，我们先大致了解Tomcat Connector的三种运行模式。"></a>下面，我们先大致了解Tomcat Connector的三种运行模式。</h3><ul><li><p><strong>BIO：同步并阻塞</strong> 一个线程处理一个请求。缺点：并发量高时，线程数较多，浪费资源。Tomcat7或以下，在Linux系统中默认使用这种方式。</p><p><code>配制项：protocol=”HTTP/1.1”</code></p></li><li><p>NIO：同步非阻塞IO</p><p>利用Java的异步IO处理，可以通过少量的线程处理大量的请求，可以复用同一个线程处理多个connection(多路复用)。</p><p>Tomcat8在Linux系统中默认使用这种方式。</p><p>Tomcat7必须修改Connector配置来启动。</p><p><code>配制项：protocol=”org.apache.coyote.http11.Http11NioProtocol”</code></p><p class="note note-primary">备注：我们常用的Jetty，Mina，ZooKeeper等都是基于java nio实现.</p></li><li><p>APR：即Apache Portable Runtime，从操作系统层面解决io阻塞问题。<strong>AIO方式，</strong>异步非阻塞IO(Java NIO2又叫AIO) 主要与NIO的区别主要是操作系统的<strong>底层区别</strong>.可以做个比喻:比作快递，NIO就是网购后要自己到官网查下快递是否已经到了(可能是多次)，然后自己去取快递；AIO就是快递员送货上门了(不用关注快递进度)。</p><p><code>  配制项：protocol=”org.apache.coyote.http11.Http11AprProtocol”</code></p><p>备注：需在本地服务器安装APR库。Tomcat7或Tomcat8在Win7或以上的系统中启动默认使用这种方式。<strong>Linux如果安装了apr和native，Tomcat直接启动就支持apr。</strong></p></li></ul><h2 id="Tomcat有几种部署方式？"><a href="#Tomcat有几种部署方式？" class="headerlink" title="Tomcat有几种部署方式？"></a>Tomcat有几种部署方式？</h2><ol><li> 利用Tomcat的自动部署。把web应用拷贝到webapps目录。Tomcat在启动时会加载目录下的应用，并将编译后的结果放入work目录下。</li><li>使用Manager App控制台部署。在tomcat主页点击“Manager App” 进入应用管理控制台，可以指定一个web应用的路径或war文件。</li><li>修改conf/server.xml文件部署。增加Context节点可以部署应用。</li><li>增加自定义的Web部署文件。在conf/Catalina/localhost/ 路径下增加 xyz.xml文件，内容是Context节点，可以部署应用。</li></ol><h2 id="tomcat容器是如何创建servlet类实例？用到了什么原理？"><a href="#tomcat容器是如何创建servlet类实例？用到了什么原理？" class="headerlink" title="tomcat容器是如何创建servlet类实例？用到了什么原理？"></a>tomcat容器是如何创建servlet类实例？用到了什么原理？</h2><ol><li>当容器启动时，会读取在webapps目录下所有的web应用中的web.xml文件，然后对 xml文件进行解析，并读取servlet注册信息。</li><li>然后，将每个应用中注册的servlet类都进行加载，并通过<strong>反射</strong>的方式实例化。（<strong>有时候也是在第一次请求时实例化</strong>）<br>在servlet注册时加上1如果为正数，则在一开始就实例化，如果不写或为负数，则第一次请求实例化。</li></ol><h2 id="Tomcat工作模式"><a href="#Tomcat工作模式" class="headerlink" title="Tomcat工作模式"></a>Tomcat工作模式</h2><h4 id="Tomcat作为servlet容器，有三种工作模式："><a href="#Tomcat作为servlet容器，有三种工作模式：" class="headerlink" title="Tomcat作为servlet容器，有三种工作模式："></a>Tomcat作为servlet容器，有三种工作模式：</h4><ol><li>独立的servlet容器，servlet容器是web服务器的一部分；</li><li>进程内的servlet容器，servlet容器是作为web服务器的插件和java容器的实现，web服务器插件在内部地址空间打开一个jvm使得java容器在内部得以运行。反应速度快但伸缩性不足；</li><li>进程外的servlet容器，servlet容器运行于web服务器之外的地址空间，并作为web服务器的插件和java容器实现的结合。反应时间不如进程内但伸缩性和稳定性比进程内优；</li></ol><h4 id="进入Tomcat的请求可以根据Tomcat的工作模式分为如下两类："><a href="#进入Tomcat的请求可以根据Tomcat的工作模式分为如下两类：" class="headerlink" title="进入Tomcat的请求可以根据Tomcat的工作模式分为如下两类："></a>进入Tomcat的请求可以根据Tomcat的工作模式分为如下两类：</h4><ul><li>Tomcat作为应用程序服务器：请求来自于前端的web服务器，这可能是Apache, IIS, Nginx等；</li><li>Tomcat作为独立服务器：请求来自于web浏览器；</li></ul><h2 id="Tomcat顶层架构"><a href="#Tomcat顶层架构" class="headerlink" title="Tomcat顶层架构"></a>Tomcat顶层架构</h2><p>俗话说，站在巨人的肩膀上看世界，一般学习的时候也是先总览一下整体，然后逐个部分个个击破，最后形成思路，了解具体细节，Tomcat的结构很复杂，但是 Tomcat 非常的模块化，找到了 Tomcat 最核心的模块，问题才可以游刃而解，了解了 Tomcat 的整体架构对以后深入了解 Tomcat 来说至关重要！</p><p>先上一张Tomcat的顶层结构图（图A），如下：</p><p><img src="https://i.loli.net/2021/04/26/GptloeuQhCq7RYm.png" alt="在这里插入图片描述"></p><p>Tomcat中最顶层的容器是Server，代表着整个服务器，从上图中可以看出，一个Server可以包含至少一个Service，即可以包含多个Service，用于具体提供服务。</p><p>Service主要包含两个部分：Connector和Container。从上图中可以看出 Tomcat 的心脏就是这两个组件，他们的作用如下：</p><ul><li>Connector用于处理连接相关的事情，并提供Socket与Request请求和Response响应相关的转化;</li><li>Container用于封装和管理Servlet，以及具体处理Request请求；</li></ul><p>一个Tomcat中只有一个Server，一个Server可以包含多个Service，一个Service只有一个Container，但是可以有多个Connectors，这是因为一个服务可以有多个连接，如同时提供Http和Https链接，也可以提供向相同协议不同端口的连接，示意图如下（Engine、Host、Context下面会说到）：</p><p><img src="https://i.loli.net/2021/04/26/5PnQSjFYJAizLdw.png" alt="在这里插入图片描述"></p><p>多个 Connector 和一个 Container 就形成了一个 Service，有了 Service 就可以对外提供服务了，但是 Service 还要一个生存的环境，必须要有人能够给她生命、掌握其生死大权，那就非 Server 莫属了！所以整个 Tomcat 的生命周期由 Server 控制。</p><p>另外，上述的包含关系或者说是父子关系，都可以在tomcat的conf目录下的server.xml配置文件中看出，下图是删除了注释内容之后的一个完整的server.xml配置文件（Tomcat版本为8.0)</p><p><img src="https://i.loli.net/2021/04/26/CTMgcv6imAKLPuo.png" alt="在这里插入图片描述"></p><p>详细的配置文件内容可以到Tomcat官网查看：<a href="http://tomcat.apache.org/tomcat-8.0-doc/index.html">Tomcat配置文件</a></p><p>上边的配置文件，还可以通过下边的一张结构图更清楚的理解：</p><p><img src="https://i.loli.net/2021/04/26/CnLQvkGASFU1zos.png" alt="在这里插入图片描述"></p><p>Server标签设置的端口号为8005，shutdown=”SHUTDOWN” ，表示在8005端口监听“SHUTDOWN”命令，如果接收到了就会关闭Tomcat。一个Server有一个Service，当然还可以进行配置，一个Service有多个Connector，Service左边的内容都属于Container的，Service下边是Connector。</p><h3 id="Tomcat顶层架构小结"><a href="#Tomcat顶层架构小结" class="headerlink" title="Tomcat顶层架构小结"></a>Tomcat顶层架构小结</h3><ol><li>Tomcat中只有一个Server，一个Server可以有多个Service，一个Service可以有多个Connector和一个Container；</li><li>Server掌管着整个Tomcat的生死大权；</li><li>Service 是对外提供服务的；</li><li>Connector用于接受请求并将请求封装成Request和Response来具体处理；</li><li>Container用于封装和管理Servlet，以及具体处理request请求；</li></ol><p>知道了整个Tomcat顶层的分层架构和各个组件之间的关系以及作用，对于绝大多数的开发人员来说Server和Service对我们来说确实很远，而我们开发中绝大部分进行配置的内容是属于Connector和Container的，所以接下来介绍一下Connector和Container。</p><h2 id="Connector和Container的微妙关系"><a href="#Connector和Container的微妙关系" class="headerlink" title="Connector和Container的微妙关系"></a>Connector和Container的微妙关系</h2><p>由上述内容我们大致可以知道一个请求发送到Tomcat之后，首先经过Service然后会交给我们的Connector，Connector用于接收请求并将接收的请求封装为Request和Response来具体处理，Request和Response封装完之后再交由Container进行处理，Container处理完请求之后再返回给Connector，最后在由Connector通过Socket将处理的结果返回给客户端，这样整个请求的就处理完了！</p><p>Connector最底层使用的是Socket来进行连接的，Request和Response是按照HTTP协议来封装的，所以Connector同时需要实现TCP/IP协议和HTTP协议！</p><p>Tomcat既然需要处理请求，那么肯定需要先接收到这个请求，接收请求这个东西我们首先就需要看一下Connector！</p><h4 id="Connector架构分析"><a href="#Connector架构分析" class="headerlink" title="Connector架构分析"></a>Connector架构分析</h4><p>Connector用于接受请求并将请求封装成Request和Response，然后交给Container进行处理，Container处理完之后在交给Connector返回给客户端。因此，我们可以把Connector分为四个方面进行理解：</p><ol><li>Connector如何接受请求的？</li><li>如何将请求封装成Request和Response的？</li><li>封装完之后的Request和Response如何交给Container进行处理的？</li><li>Container处理完之后如何交给Connector并返回给客户端的？</li></ol><p>首先看一下Connector的结构图（图B），如下所示：</p><p><img src="https://i.loli.net/2021/04/26/qbV2pxjX94KJlt5.png" alt="在这里插入图片描述"></p><p>Connector就是使用ProtocolHandler来处理请求的，不同的ProtocolHandler代表不同的连接类型，比如：Http11Protocol使用的是普通Socket来连接的，Http11NioProtocol使用的是NioSocket来连接的。</p><p><strong>其中ProtocolHandler由包含了三个部件：Endpoint、Processor、Adapter。</strong></p><ul><li>Endpoint用来处理底层Socket的网络连接，Processor用于将Endpoint接收到的Socket封装成Request，Adapter用于将Request交给Container进行具体的处理。</li><li>Endpoint由于是处理底层的Socket网络连接，因此Endpoint是用来实现TCP/IP协议的，而Processor用来实现HTTP协议的，Adapter将请求适配到Servlet容器进行具体的处理。</li><li>Endpoint的抽象实现AbstractEndpoint里面定义的Acceptor和AsyncTimeout两个内部类和一个Handler接口。Acceptor用于监听请求，AsyncTimeout用于检查异步Request的超时，Handler用于处理接收到的Socket，在内部调用Processor进行处理。</li></ul><p>至此，我们应该很轻松的回答1，2，3的问题了，但是4还是不知道，那么我们就来看一下Container是如何进行处理的以及处理完之后是如何将处理完的结果返回给Connector的？、</p><h2 id="Container架构分析"><a href="#Container架构分析" class="headerlink" title="Container架构分析"></a>Container架构分析</h2><p>Container用于封装和管理Servlet，以及具体处理Request请求，在Container内部包含了4个子容器，结构图如下（图C）：</p><p><img src="https://i.loli.net/2021/04/26/94m1zfysDnVaMIX.png" alt="在这里插入图片描述"></p><p>4个子容器的作用分别是：</p><ul><li>Engine：引擎，用来管理多个站点，一个Service最多只能有一个Engine；</li><li>Host：代表一个站点，也可以叫虚拟主机，通过配置Host就可以添加站点；</li><li>Context：代表一个应用程序，对应着平时开发的一套程序，或者一个WEB-INF目录以及下面的web.xml文件；</li><li>Wrapper：每一Wrapper封装着一个Servlet；</li></ul><p>下面找一个Tomcat的文件目录对照一下，如下图所示：</p><p><img src="https://i.loli.net/2021/04/26/QNjFL6GBXeJhctT.png" alt="在这里插入图片描述"></p><p>Context和Host的区别是Context表示一个应用，我们的Tomcat中默认的配置下webapps下的每一个文件夹目录都是一个Context，其中ROOT目录中存放着主应用，其他目录存放着子应用，而整个webapps就是一个Host站点。</p><p>我们访问应用Context的时候，如果是ROOT下的则直接使用域名就可以访问，例如：<a href="http://www.baidu.com,如果是host(webapps)下的其他应用,则可以使用www.baidu.com/docs%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE%EF%BC%8C%E5%BD%93%E7%84%B6%E9%BB%98%E8%AE%A4%E6%8C%87%E5%AE%9A%E7%9A%84%E6%A0%B9%E5%BA%94%E7%94%A8%EF%BC%88ROOT%EF%BC%89%E6%98%AF%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E8%AE%BE%E5%AE%9A%E7%9A%84%EF%BC%8C%E5%8F%AA%E4%B8%8D%E8%BF%87Host%E7%AB%99%E7%82%B9%E4%B8%8B%E9%BB%98%E8%AE%A4%E7%9A%84%E4%B8%BB%E5%BA%94%E7%94%A8%E6%98%AFROOT%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E3%80%82">www.baidu.com，如果是Host（webapps）下的其他应用，则可以使用www.baidu.com/docs进行访问，当然默认指定的根应用（ROOT）是可以进行设定的，只不过Host站点下默认的主应用是ROOT目录下的。</a></p><p>看到这里我们知道Container是什么，但是还是不知道Container是如何进行请求处理的以及处理完之后是如何将处理完的结果返回给Connector的？别急！下边就开始探讨一下Container是如何进行处理的！</p><h2 id="Container如何处理请求的？"><a href="#Container如何处理请求的？" class="headerlink" title="Container如何处理请求的？"></a>Container如何处理请求的？</h2><p>Container处理请求是使用Pipeline-Valve管道来处理的！（Valve是阀门之意）Pipeline-Valve是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将处理后的结果返回，再让下一个处理者继续处理。</p><p><img src="https://i.loli.net/2021/04/26/mUiWG3cwVPEC85x.png" alt="在这里插入图片描述"></p><p>但是！Pipeline-Valve使用的责任链模式和普通的责任链模式有些不同！区别主要有以下两点：</p><ul><li>每个Pipeline都有特定的Valve，而且是在管道的最后一个执行，这个Valve叫做BaseValve，BaseValve是不可删除的；</li></ul><ul><li>在上层容器的管道的BaseValve中会调用下层容器的管道。</li></ul><p><strong>我们知道Container包含四个子容器，而这四个子容器对应的BaseValve分别在：StandardEngineValve、StandardHostValve、StandardContextValve、StandardWrapperValve。</strong></p><p>Pipeline的处理流程图如下（图D）：</p><p><img src="https://i.loli.net/2021/04/26/2Nj6wxu5ovMmORa.png" alt="在这里插入图片描述"></p><ul><li>Connector在接收到请求后会首先调用最顶层容器的Pipeline来处理，这里的最顶层容器的Pipeline就是EnginePipeline（Engine的管道）；</li><li>在Engine的管道中依次会执行EngineValve1、EngineValve2等等，最后会执行StandardEngineValve，在StandardEngineValve中会调用Host管道，然后再依次执行Host的HostValve1、HostValve2等，最后在执行StandardHostValve，然后再依次调用Context的管道和Wrapper的管道，最后执行到StandardWrapperValve。</li><li>当执行到StandardWrapperValve的时候，会在StandardWrapperValve中创建FilterChain，并调用其doFilter方法来处理请求，这个FilterChain包含着我们配置的与请求相匹配的Filter和Servlet，其doFilter方法会依次调用所有的Filter的doFilter方法和Servlet的service方法，这样请求就得到了处理！</li><li>当所有的Pipeline-Valve都执行完之后，并且处理完了具体的请求，这个时候就可以将返回的结果交给Connector了，Connector在通过Socket的方式将结果返回给客户端。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们已经对Tomcat的整体架构有了大致的了解，从图A、B、C、D可以看出来每一个组件的基本要素和作用。我们在脑海里应该有一个大概的轮廓了！如果你面试的时候，让你简单的聊一下Tomcat，上面的内容你能脱口而出吗？当你能够脱口而出的时候，面试官一定会对你刮目相看的！</p>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>tomcat</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tomcat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql面试题</title>
    <link href="/2021/04/25/mysql-interview-2/"/>
    <url>/2021/04/25/mysql-interview-2/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql-面试题"><a href="#Mysql-面试题" class="headerlink" title="Mysql 面试题"></a>Mysql 面试题</h1><h2 id="为什么用自增列作为主键"><a href="#为什么用自增列作为主键" class="headerlink" title="为什么用自增列作为主键"></a>为什么用自增列作为主键</h2><h4 id="1-如果定义了主键Primary-Key，那么InnoDB会选择主键作为聚簇索引"><a href="#1-如果定义了主键Primary-Key，那么InnoDB会选择主键作为聚簇索引" class="headerlink" title="1. 如果定义了主键Primary Key，那么InnoDB会选择主键作为聚簇索引"></a>1. 如果定义了主键Primary Key，那么InnoDB会选择主键作为聚簇索引</h4><ul><li>如果没有显示定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引。</li><li>如果也没有这样的唯一索引，则InnoDB会选择内置6字节长度的RowId作为隐含的聚簇索引（RowId随着行记录的写入而主键递增）这个RowId不像Oracle的RowId 那样可引用，它是隐含的。</li></ul><h4 id="2-数据记录本身-存于主索引（一课B-Tree）的叶子结点，这就要求同一叶子结点内（大小为一个内存页或者磁盘页）的各条数据记录按主键顺序存放"><a href="#2-数据记录本身-存于主索引（一课B-Tree）的叶子结点，这就要求同一叶子结点内（大小为一个内存页或者磁盘页）的各条数据记录按主键顺序存放" class="headerlink" title="2. 数据记录本身 存于主索引（一课B+Tree）的叶子结点，这就要求同一叶子结点内（大小为一个内存页或者磁盘页）的各条数据记录按主键顺序存放"></a>2. 数据记录本身 存于主索引（一课B+Tree）的叶子结点，这就要求同一叶子结点内（大小为一个内存页或者磁盘页）的各条数据记录按主键顺序存放</h4><ul><li>因此每当有一条新纪录存入，Mysql会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）</li></ul><h4 id="3-如果表使用自增主键，那么每次插入新纪录，记录就会顺序的添加到当前索引结点的后续位置，当一页写满，就会自动开辟一个新的页"><a href="#3-如果表使用自增主键，那么每次插入新纪录，记录就会顺序的添加到当前索引结点的后续位置，当一页写满，就会自动开辟一个新的页" class="headerlink" title="3. 如果表使用自增主键，那么每次插入新纪录，记录就会顺序的添加到当前索引结点的后续位置，当一页写满，就会自动开辟一个新的页"></a>3. 如果表使用自增主键，那么每次插入新纪录，记录就会顺序的添加到当前索引结点的后续位置，当一页写满，就会自动开辟一个新的页</h4><h4 id="4-如果使用非自增主键（如身份证号或者学号等），由于每次插入主键的值近似于随机，因此新纪录都要被查到现有索引页中的中间的某个位置"><a href="#4-如果使用非自增主键（如身份证号或者学号等），由于每次插入主键的值近似于随机，因此新纪录都要被查到现有索引页中的中间的某个位置" class="headerlink" title="4. 如果使用非自增主键（如身份证号或者学号等），由于每次插入主键的值近似于随机，因此新纪录都要被查到现有索引页中的中间的某个位置"></a>4. 如果使用非自增主键（如身份证号或者学号等），由于每次插入主键的值近似于随机，因此新纪录都要被查到现有索引页中的中间的某个位置</h4><ul><li>此时Mysql不得不为了将新纪录插到合适的位置而移动数据，甚至目标页面可能已经被写回磁盘上而从缓存中清掉，此时又要从磁盘读回来，这增加了很多开销</li><li>同时频繁移动，分页造成大量的碎片，得到不够紧凑的结构，后续不得不通过Optimize table来重建表并优化填充页面</li></ul><h2 id="为什么使用数据索引能提高效率"><a href="#为什么使用数据索引能提高效率" class="headerlink" title="为什么使用数据索引能提高效率"></a>为什么使用数据索引能提高效率</h2><h4 id="数据索引的存储是有序的"><a href="#数据索引的存储是有序的" class="headerlink" title="数据索引的存储是有序的"></a>数据索引的存储是有序的</h4><h4 id="在有序的情况下，通过索引查询一个数据是无需遍历记录的"><a href="#在有序的情况下，通过索引查询一个数据是无需遍历记录的" class="headerlink" title="在有序的情况下，通过索引查询一个数据是无需遍历记录的"></a>在有序的情况下，通过索引查询一个数据是无需遍历记录的</h4><h4 id="在极端情况下，数据索引的查询效率为二分查询效率，趋近于log2-N"><a href="#在极端情况下，数据索引的查询效率为二分查询效率，趋近于log2-N" class="headerlink" title="在极端情况下，数据索引的查询效率为二分查询效率，趋近于log2(N)"></a>在极端情况下，数据索引的查询效率为二分查询效率，趋近于log2(N)</h4><h2 id="B-树和hash索引的区别"><a href="#B-树和hash索引的区别" class="headerlink" title="B+树和hash索引的区别"></a>B+树和hash索引的区别</h2><p class="note note-primary">B+数是一个平衡的多叉树，从根节点到每个叶子结点的高度差不超过1，而且同层级的结点之间有指针相互链接，是有序的</p><p><img src="https://i.loli.net/2021/04/25/zQsluwtd5VMDjxa.jpg" alt="img"></p><p class="note note-secondary">哈希索引就是采用一定的哈希算法，把键值转换成新的哈希值，检索不需要类似B+数那样从根结点到叶子结点逐级查找，只需要一次哈希算法即可，是无序的</p><p><img src="https://i.loli.net/2021/04/25/PG9aHhrgzRDIblE.jpg" alt="img"></p><h2 id="哈希索引的优势"><a href="#哈希索引的优势" class="headerlink" title="哈希索引的优势"></a>哈希索引的优势</h2><h4 id="等值查询，哈希索引具有绝对优势（前提是没有大量重复键值，如果有大量重复键值时，效率很低，因为存在大量的哈希冲突，需要散列再散列）"><a href="#等值查询，哈希索引具有绝对优势（前提是没有大量重复键值，如果有大量重复键值时，效率很低，因为存在大量的哈希冲突，需要散列再散列）" class="headerlink" title="等值查询，哈希索引具有绝对优势（前提是没有大量重复键值，如果有大量重复键值时，效率很低，因为存在大量的哈希冲突，需要散列再散列）"></a>等值查询，哈希索引具有绝对优势（前提是没有大量重复键值，如果有大量重复键值时，效率很低，因为存在大量的哈希冲突，需要散列再散列）</h4><h2 id="哈希索引不适用的场景"><a href="#哈希索引不适用的场景" class="headerlink" title="哈希索引不适用的场景"></a>哈希索引不适用的场景</h2><ol><li>不支持范围查询</li><li>不支持索引完成排序</li><li>不支持联合索引的最左侧匹配规则</li></ol><h2 id="通常，B-数索引结构适用于大多数场景，像下面这种场景用哈希才更有优势"><a href="#通常，B-数索引结构适用于大多数场景，像下面这种场景用哈希才更有优势" class="headerlink" title="通常，B+数索引结构适用于大多数场景，像下面这种场景用哈希才更有优势"></a>通常，B+数索引结构适用于大多数场景，像下面这种场景用哈希才更有优势</h2><ul><li><p>在HEAP表中，如果存储数据的重复度很低（基数很大），对该列数据以等职查询为主，没有范围查询，没有排序的时候特别适合哈希索引，例如</p></li><li><p># 仅等值查询<code>select id, name from table where name=&#39;李明&#39;; </code></p></li></ul><ol><li>而常用的InnoDB引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况 。</li><li>如果认为建立哈希索引可以提高查询效率，则自动在内存中的“<strong>自适应哈希索引缓冲区</strong>”建立哈希索引（在InnDB中默认开启自适应哈希索引）。</li><li>通过观察搜素模式，Mysql回利用Index Key的前缀建立哈希索引，如果一个表大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。</li></ol><p><strong>注意：在某些工作负载情况下，通过哈希索引查找带来的性能提升远大于额外的监控索引搜索情况和保持哈希表结构带来的开销</strong></p><p><code>但在某些时候，在负载高的清空下，自适应哈希索引中添加的read/write锁也会带来竞争，比如高并发的join操作，like操作，和%通配符操作也不适用于自适应哈希索引，可能要关闭自适应哈希索引</code></p><h2 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h2><ul><li>B树，每个结点都存储key和value，所有结点组成这棵树，并且叶子结点为null，叶子结点不包含任何关键字信息</li></ul><p><img src="https://i.loli.net/2021/04/25/dCzkEw31gAlVy9e.jpg" alt="img"></p><ul><li>B+树，所有的叶子结点包含了全部关键字信息，以及指向含有这些关键字记录的指针，且叶子结点本身依关键字大小自小而大的顺序连接</li><li>所有非终端结点可以看成是索引部分，结点中仅含有其子树根节点中最大（或最小）关键字，（而B树的非终端结点也可能含有需要查找的有效信息）</li></ul><p><img src="https://i.loli.net/2021/04/25/sNupSlGDfm9nFdz.jpg" alt="img"></p><h2 id="为什么说B树比B-树更结合实际应用操作系统的文件索引和数据库索引"><a href="#为什么说B树比B-树更结合实际应用操作系统的文件索引和数据库索引" class="headerlink" title="为什么说B树比B+树更结合实际应用操作系统的文件索引和数据库索引"></a>为什么说B树比B+树更结合实际应用操作系统的文件索引和数据库索引</h2><ol><li>B+树的磁盘读写代价更低</li></ol><div class="note note-success">            <p>B+树内部结点并没有指向关键字具体信息的指针，因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存在同一块盘快中，那么盘快能容纳的关键字数量也就越多，一次性读入内存中需要查找的关键字也就越多，相对就减少了IO读写次数也就降低了</p>          </div><ol start="2"><li>B+树的查询效率更加稳定</li></ol><div class="note note-primary">            <p>由于非终结点的并不最终指向文件内容的结点，而只是叶子结点中关键字的索引，索引任何关键字的查找必须走一条从根节点到叶子结点的路，所有关键字查询的路径长度相同，导致每一个数据的查询效率相当</p>          </div><h2 id="Mysql联合索引"><a href="#Mysql联合索引" class="headerlink" title="Mysql联合索引"></a>Mysql联合索引</h2><h3 id="联合索引是两个或多个列以上的索引"><a href="#联合索引是两个或多个列以上的索引" class="headerlink" title="联合索引是两个或多个列以上的索引"></a>联合索引是两个或多个列以上的索引</h3><p><strong>对于联合索引：</strong>Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部分，但只能是最左侧部分。</p><p>例如索引是key index(a,b,c),可以支持 a，ab，abc，3种组合进行查找，<strong>但不支持bc进行查找</strong>，当最左侧字段是常量引用时，索引就十分有效。</p><h3 id="利用索引中的附加列"><a href="#利用索引中的附加列" class="headerlink" title="利用索引中的附加列"></a>利用索引中的附加列</h3><p><code>可以缩小搜索范围，但使用一个具有两列的索引不同于使用两个单独的索引。</code></p><p><strong>复合索引：</strong> 结构与电话簿类似，人名有姓和名构成，电话簿首先按姓氏进行排序，然后按名字对相同姓氏的人进行排序。</p><p>如果您知道姓，电话簿将非常有用；如果您知道姓和名则更有用，但如果只知道名不知道姓，电话簿将没有用处。</p><h2 id="什么情况下应不建或者少建索引"><a href="#什么情况下应不建或者少建索引" class="headerlink" title="什么情况下应不建或者少建索引"></a>什么情况下应不建或者少建索引</h2><ol><li>表记录太少</li><li>经常插入，删除，修改的表</li><li>数据重复且分布平均的表字段，假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么这种表A字段建索引一般不会提高数据库查询速度</li><li>经常和主键一块查询但主字段索引值比较多的表字段</li></ol><h2 id="什么是表分区"><a href="#什么是表分区" class="headerlink" title="什么是表分区"></a>什么是表分区</h2><p>是根据一定规则，将数据库中的表分别分解成多个更小的，容易管理的部分，从逻辑上看，只有一张表，但底层却是多个物理分区组成</p><h2 id="表分区与分表的区别"><a href="#表分区与分表的区别" class="headerlink" title="表分区与分表的区别"></a>表分区与分表的区别</h2><p class="note note-primary">表分区：如上👆，比如用户订单记录根据时间分成多个表</p><p class="note note-danger">分表：根据业务逻辑拆分表，使之在底层和逻辑层都是多个物理分区</p><p><strong>区别：分区从逻辑上来讲只有一张表，而分表则将一张表分解成多个表</strong></p><h2 id="分区表的好处"><a href="#分区表的好处" class="headerlink" title="分区表的好处"></a>分区表的好处</h2><ol><li><strong>存储更多数据</strong>，分区表的数据可以分布在不同的物理设备上，从而高效的利用多个硬件设备，和单磁盘或者文件系统相比，可以存储更多数据</li><li><strong>优化查询</strong>，在where语句中包含分区条件时候，可以只扫描一个或者多个分区表来提高查询效率，涉及sum和count语句时，也可以在多个分区上并行处理，最后汇总结果。</li><li><strong>分区表更容易维护</strong>，例如：想批量删除大量数据，可以清除整个分区</li><li><strong>避免某些特殊的瓶颈</strong>，例如InnoDB的单个索引的互斥访问，发生的锁竞争</li></ol><h2 id="分区表的限制因素"><a href="#分区表的限制因素" class="headerlink" title="分区表的限制因素"></a>分区表的限制因素</h2><ol><li>一个表最多只能由1024个分区</li><li>Mysql5.1中，分区表达式必须是整数，或者返回整数的形式，Mysql5.5中提供了非整数表达式分区的支持</li><li>如果分区字段中有主键或者唯一索引列，那么多有的主键和唯一索引列都必须包含进来。即：<code>分区字段要么不包含主键或者索引列，要么包含全部主键和索引列</code></li><li>分区表中无外键约束</li><li>Mysql的分区适用于一个表的所有数据和索引，不能只对表数据分区而不对索引分区，也不能只对索引分区而不对表分区，也不能只对表的一部分数据分区</li></ol><h2 id="如何判断当前Mysql是否支持分区"><a href="#如何判断当前Mysql是否支持分区" class="headerlink" title="如何判断当前Mysql是否支持分区"></a>如何判断当前Mysql是否支持分区</h2><p><code>命令：show variables like &#39;%partition%&#39;</code></p><p><code>have_partintioning 的值为YES，表示支持分区。</code></p><h2 id="Mysql-支持的分区类型有哪些？"><a href="#Mysql-支持的分区类型有哪些？" class="headerlink" title="Mysql 支持的分区类型有哪些？"></a>Mysql 支持的分区类型有哪些？</h2><ol><li><code>RANGE分区</code>：这种模式允许将数据划分不同范围，例如可以将一个表通过年份划分成若干分区</li><li><code>LIST分区</code>:  这种模式允许通过预定义的列表的值来对数据进行分割。按照List中的值分区，与RANGE的区别是，range分区的区间范围值是连续的。</li><li><code>HASH分区</code>： 中模式允许通过对表的一个或多个列的Hash Key进行计算，最后通过这个Hash码不同数值对应的数据区域进行分区。例如可以建立一个对表主键进行分区的表。</li><li><code>KEY分区</code>：上面Hash模式的一种延伸，这里的Hash Key是MySQL系统产生的。</li></ol><h2 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h2><ol><li>Serializable（串行）可避免脏读，不可重复度，幻读</li><li>Repeatable read（可重复度）可避免脏读，不可重复度</li><li>Read committed（读已提交）可避免脏读</li><li>Read uncommitted（读未提交）最低级别，任何情况都无法保证</li></ol><h2 id="MVVC"><a href="#MVVC" class="headerlink" title="MVVC"></a>MVVC</h2><div class="note note-danger">            <p>Mysql InnoDB 存储引擎，实现的是基于多版本的并发控制协议—MVVC（Multi-Version Concurrency Controller）</p><p><strong>注</strong>：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control</p><p><strong>MVCC最大的好处</strong>： 读不加锁，读写不冲突，在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，现阶段几乎所有的RDBMS，都支持MVCC</p>          </div><ol><li>LBCC Lock-Base Concurrency Control，基于锁的并发控制</li><li>MVCC：Multi-Version Concurrency Control，基于多版本的并发控制协议，纯粹基于锁的并发机制并发量低，MVCC是在基于锁的并发控制上的改进，主要是在读写操作上提高了并发</li></ol><h2 id="MVCC并发控制中，读操作可分为两类"><a href="#MVCC并发控制中，读操作可分为两类" class="headerlink" title="MVCC并发控制中，读操作可分为两类"></a>MVCC并发控制中，读操作可分为两类</h2><ol><li>读快照：读取的是记录的可见版本（有可能是历史版本），不用加锁（共享读锁也不加，所以不会阻塞其他事务的写）</li><li>当前读：读取的记录是最新版本，并且，当前返回的记录都会加上锁，保证其他事务不会再并发修改</li></ol><h2 id="行级别锁定的优点"><a href="#行级别锁定的优点" class="headerlink" title="行级别锁定的优点"></a>行级别锁定的优点</h2><ol><li>在许多线程访问不同的行时只存在少量的锁定冲突</li><li>回滚时只有少量的更改</li><li>可以长时间锁定单一的行</li></ol><h2 id="行级别锁定的缺点"><a href="#行级别锁定的缺点" class="headerlink" title="行级别锁定的缺点"></a>行级别锁定的缺点</h2><ol><li>比页级别锁占用更多的内存</li><li>在当表的大部分使用时候，比页级别锁定更慢，因为你必须获取更多的锁</li><li>如果你在大部分数据经常进行GROUP BY操作，或者必须经常扫描整个表，比其他锁定明显慢很多</li><li>用高级别锁定，通过支持不同类型的锁定，你可以很容易的调节应用程序，因为其锁成本小于行级锁定</li></ol><h2 id="Mysql优化"><a href="#Mysql优化" class="headerlink" title="Mysql优化"></a>Mysql优化</h2><ol><li><p>开启查询缓存，优化查询</p></li><li><p>explain你的select查询，这可以帮你分析你的查询语句或是表结构的性能瓶颈。EXPLAIN 的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的</p></li><li><p>当只要一行数据时使用limit 1，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据</p></li><li><p>为搜索字段建索引</p></li><li><p>使用 ENUM 而不是 VARCHAR。如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用 ENUM 而不是VARCHAR</p></li><li><p>Prepared StatementsPrepared Statements很像存储过程，是一种运行在后台的SQL语句集合，我们可以从使用 prepared statements 获得很多好处，无论是性能问题还是安全问题。</p><p>Prepared Statements 可以检查一些你绑定好的变量，这样可以保护你的程序不会受到“SQL注入式”攻击</p></li><li><p>垂直分表</p></li><li><p>选择正确的存储引擎</p></li></ol><h2 id="key-和-index的区别"><a href="#key-和-index的区别" class="headerlink" title="key 和 index的区别"></a>key 和 index的区别</h2><h6 id="key"><a href="#key" class="headerlink" title="key"></a>key</h6><p>数据库的物理结构，有两层意义和作用，一是约束（偏重于约束和规范数据库的结构完整性），二是索引（辅助查询使用），包括primary key，unique，foreign key</p><h6 id="index"><a href="#index" class="headerlink" title="index"></a>index</h6><p>是数据库的物理结构，只是辅助查询，创建时会在另外的表空间（mysql表和innodb表空间）以一个类似目录的结构存储，索引要分类的话，分为前缀索引，全文索引等；</p><h2 id="Mysql中InnoDB和MyISam-的区别"><a href="#Mysql中InnoDB和MyISam-的区别" class="headerlink" title="Mysql中InnoDB和MyISam 的区别"></a>Mysql中InnoDB和MyISam 的区别</h2><ol><li>InnoDB支持事务，MyIsam不支持</li></ol><p><code>对于InnoDB每一条sql语言都默认组装成一个事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit中，组成一个事务</code></p><ol start="2"><li><p>InnoDB支持外键，MyIsam 不支持，对于一个包含外键的InnoDB转为MyIsam会失败</p></li><li><p>InnoDB是聚集索引，数据文件和索引绑在一起，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询主键，然后再通过主键查询数据，因此主键不应该过大，因为主键太大，其他索引也会很大</p><p>MyIsam是非聚簇索引，数据文件是分离的，索引保存的是数据文件的指针，主键索引和辅助索引是独立的。</p></li><li><p>InnoDB不保存表的具体行树，执行select (*) from table 会扫描全表，而MyIsam用一个变量保存了整个表的行树，执行上面的语句只需要读出变量即可。</p></li><li><p>InnoDB不支持全文索引，而myIsam支持，效率更高。</p></li></ol><h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3><ol><li>是否需要事务，需要则选择InnoDB，不需要可以考虑MyIsam</li><li>绝大多数只是读取可以考虑MyIsam， 读写频繁用InnoDB</li><li>系统崩溃后，myIsam 恢复更困难</li><li>MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。</li></ol><h2 id="数据库表创建注意事项"><a href="#数据库表创建注意事项" class="headerlink" title="数据库表创建注意事项"></a><strong>数据库表创建注意事项</strong></h2><p><strong>1、字段名及字段配制合理性</strong></p><ul><li>剔除关系不密切的字段；</li><li>字段命名要有规则及相对应的含义（不要一部分英文，一部分拼音，还有类似a.b.c这样不明含义的字段）；</li><li>字段命名尽量不要使用缩写（大多数缩写都不能明确字段含义）；</li><li>字段不要大小写混用（想要具有可读性，多个英文单词可使用下划线形式连接）；</li><li>字段名不要使用保留字或者关键字；</li><li>保持字段名和类型的一致性；</li><li>慎重选择数字类型；</li><li>给文本字段留足余量；</li></ul><p><strong>2、系统特殊字段处理及建成后建议</strong></p><ul><li>添加删除标记（例如操作人、删除时间）；</li><li>建立版本机制；</li></ul><p><strong>3、表结构合理性配置</strong></p><ul><li>多型字段的处理，就是表中是否存在字段能够分解成更小独立的几部分（例如：人可以分为男人和女人）；</li><li>多值字段的处理，可以将表分为三张表，这样使得检索和排序更加有调理，且保证数据的完整性！</li></ul><p><strong>4、其它建议</strong></p><ul><li>对于大数据字段，独立表进行存储，以便影响性能（例如：简介字段）；</li><li>使用varchar类型代替char，因为varchar会动态分配长度，char指定长度是固定的；</li><li>给表创建主键，对于没有主键的表，在查询和索引定义上有一定的影响；</li><li>避免表字段运行为null，建议设置默认值（例如：int类型设置默认值为0）在索引查询上，效率立显；</li><li>建立索引，最好建立在唯一和非空的字段上，建立太多的索引对后期插入、更新都存在一定的影响（考虑实际情况来创建）；</li></ul>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker compose</title>
    <link href="/2021/04/23/docker-compose/"/>
    <url>/2021/04/23/docker-compose/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-Compose-概述与安装？"><a href="#Docker-Compose-概述与安装？" class="headerlink" title="Docker Compose 概述与安装？"></a>Docker Compose 概述与安装？</h1><ul><li><p>前面我们使用 Docker 的时候，定义 Dockerfile 文件，然后使用 docker build、docker run 等命令操作容器。然而微服务架构的应用系统一般包含若干个微服务，每个微服务一般都会部署多个实例，如果每个微服务都要手动启停，那么效率之低，维护量之大可想而知</p></li><li><p><strong>使用 Docker Compose 可以轻松、高效的管理容器，它是一个用于定义和运行多容器 Docker 的应用程序工具</strong></p></li></ul><h3 id="安装-Docker-Compose"><a href="#安装-Docker-Compose" class="headerlink" title="安装 Docker Compose"></a>安装 Docker Compose</h3><ul><li>安装 Docker Compose 可以通过下面命令自动下载适应版本的 Compose，并为安装脚本添加执行权限</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-$(uname -s)-$(uname -m) -o /usr/<span class="hljs-built_in">local</span>/bin/docker-composesudo chmod +x /usr/<span class="hljs-built_in">local</span>/bin/docker-compose</code></pre></div><ul><li>查看安装是否成功</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash">docker-compose -v</code></pre></div><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ul><li>打包项目，获得 jar 包 docker-demo-0.0.1-SNAPSHOT.jar</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash">mvn clean package</code></pre></div><ul><li>在 jar 包所在路径创建 Dockerfile 文件，添加以下内容</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash">FROM java:8VOLUME /tmpADD docker-demo-0.0.1-SNAPSHOT.jar app.jarRUN bash -c <span class="hljs-string">&#x27;touch /app.jar&#x27;</span>EXPOSE 9000ENTRYPOINT [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-Djava.security.egd=file:/dev/./urandom&quot;</span>,<span class="hljs-string">&quot;-jar&quot;</span>,<span class="hljs-string">&quot;app.jar&quot;</span>]</code></pre></div><ul><li>在 jar 包所在路径创建文件 docker-compose.yml，添加以下内容</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash">version: <span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-comment"># 表示该 Docker-Compose 文件使用的是 Version 2 file</span>services:  docker-demo:  <span class="hljs-comment"># 指定服务名称</span>    build: .  <span class="hljs-comment"># 指定 Dockerfile 所在路径</span>    ports:    <span class="hljs-comment"># 指定端口映射</span>      - <span class="hljs-string">&quot;9000:8761&quot;</span></code></pre></div><ul><li>在 docker-compose.yml 所在路径下执行该命令 Compose 就会自动构建镜像并使用镜像启动容器</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash">docker-compose updocker-compose up -d  // 后台启动并运行容器</code></pre></div><ul><li>访问 <a href="http://localhost:9000/hello">http://localhost:9000/hello</a> 即可访问微服务接口</li></ul><h2 id="工程、服务、容器"><a href="#工程、服务、容器" class="headerlink" title="工程、服务、容器"></a>工程、服务、容器</h2><ul><li><strong>Docker Compose 将所管理的容器分为三层，分别是工程（project）、服务（service）、容器（container）</strong></li><li><strong>Docker Compose 运行目录下的所有文件（docker-compose.yml）组成一个工程,一个工程包含多个服务，每个服务中定义了容器运行的镜像、参数、依赖，一个服务可包括多个容器实例</strong></li></ul><h3 id="Docker-Compose-常用命令与配置"><a href="#Docker-Compose-常用命令与配置" class="headerlink" title="Docker Compose 常用命令与配置"></a>Docker Compose 常用命令与配置</h3><h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><ul><li><strong>ps</strong>：列出所有运行容器</li></ul><div class="hljs code-wrapper"><pre><code class="hljs undefined">docker-compose ps</code></pre></div><ul><li><strong>logs</strong>：查看服务日志输出</li></ul><div class="hljs code-wrapper"><pre><code class="hljs undefined">docker-compose logs</code></pre></div><ul><li><strong>port</strong>：打印绑定的公共端口，下面命令可以输出 eureka 服务 8761 端口所绑定的公共端口</li></ul><div class="hljs code-wrapper"><pre><code class="hljs undefined">docker-compose port eureka 8761</code></pre></div><ul><li><strong>build</strong>：构建或者重新构建服务</li></ul><div class="hljs code-wrapper"><pre><code class="hljs undefined">docker-compose build</code></pre></div><ul><li><strong>start</strong>：启动指定服务已存在的容器</li></ul><div class="hljs code-wrapper"><pre><code class="hljs undefined">docker-compose start eureka</code></pre></div><ul><li><strong>stop</strong>：停止已运行的服务的容器</li></ul><div class="hljs code-wrapper"><pre><code class="hljs undefined">docker-compose stop eureka</code></pre></div><ul><li><strong>rm</strong>：删除指定服务的容器</li></ul><div class="hljs code-wrapper"><pre><code class="hljs undefined">docker-compose rm eureka</code></pre></div><ul><li><strong>up</strong>：构建、启动容器</li></ul><div class="hljs code-wrapper"><pre><code class="hljs undefined">docker-compose up</code></pre></div><ul><li><strong>kill</strong>：通过发送 SIGKILL 信号来停止指定服务的容器</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash">docker-compose <span class="hljs-built_in">kill</span> eureka</code></pre></div><ul><li><strong>pull</strong>：下载服务镜像</li><li><strong>scale</strong>：设置指定服务运气容器的个数，以 service=num 形式指定</li></ul><div class="hljs code-wrapper"><pre><code class="hljs undefined">docker-compose scale user&#x3D;3 movie&#x3D;3</code></pre></div><ul><li><strong>run</strong>：在一个服务上执行一个命令</li></ul><div class="hljs code-wrapper"><pre><code class="hljs undefined">docker-compose run web bash</code></pre></div><h3 id="docker-compose-yml-属性"><a href="#docker-compose-yml-属性" class="headerlink" title="docker-compose.yml 属性"></a>docker-compose.yml 属性</h3><ul><li><strong>version</strong>：指定 docker-compose.yml 文件的写法格式</li><li><strong>services</strong>：多个容器集合</li><li><strong>build</strong>：配置构建时，Compose 会利用它自动构建镜像，该值可以是一个路径，也可以是一个对象，用于指定 Dockerfile 参数</li></ul><div class="hljs code-wrapper"><pre><code class="hljs csharp">build: ./dir---------------build:    context: ./dir    dockerfile: Dockerfile    args:        buildno: <span class="hljs-number">1</span></code></pre></div><ul><li><strong>command</strong>：覆盖容器启动后默认执行的命令</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">command</span>: bundle <span class="hljs-built_in">exec</span> thin -p 3000----------------------------------<span class="hljs-built_in">command</span>: [bundle,<span class="hljs-built_in">exec</span>,thin,-p,3000]</code></pre></div><ul><li><strong>dns</strong>：配置 dns 服务器，可以是一个值或列表</li></ul><div class="hljs code-wrapper"><pre><code class="hljs css">dns: <span class="hljs-number">8.8</span>.<span class="hljs-number">8.8</span>------------dns:    - <span class="hljs-number">8.8</span>.<span class="hljs-number">8.8</span>    - <span class="hljs-number">9.9</span>.<span class="hljs-number">9.9</span></code></pre></div><ul><li><strong>dns_search</strong>：配置 DNS 搜索域，可以是一个值或列表</li></ul><div class="hljs code-wrapper"><pre><code class="hljs css">dns_search: example.com------------------------dns_search:    - dc1.example.com    - dc2.example.com</code></pre></div><ul><li><strong>environment</strong>：环境变量配置，可以用数组或字典两种方式</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash">environment:    RACK_ENV: development    SHOW: <span class="hljs-string">&#x27;ture&#x27;</span>-------------------------environment:    - RACK_ENV=development    - SHOW=ture</code></pre></div><ul><li><strong>env_file</strong>：从文件中获取环境变量，可以指定一个文件路径或路径列表，其优先级低于 environment 指定的环境变量</li></ul><div class="hljs code-wrapper"><pre><code class="hljs undefined">env_file: .env---------------env_file:    - .&#x2F;common.env</code></pre></div><ul><li><strong>expose</strong>：暴露端口，只将端口暴露给连接的服务，而不暴露给主机</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash">expose:    - <span class="hljs-string">&quot;3000&quot;</span>    - <span class="hljs-string">&quot;8000&quot;</span></code></pre></div><ul><li><strong>image</strong>：指定服务所使用的镜像</li></ul><div class="hljs code-wrapper"><pre><code class="hljs undefined">image: java</code></pre></div><ul><li><strong>network_mode</strong>：设置网络模式</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash">network_mode: <span class="hljs-string">&quot;bridge&quot;</span>network_mode: <span class="hljs-string">&quot;host&quot;</span>network_mode: <span class="hljs-string">&quot;none&quot;</span>network_mode: <span class="hljs-string">&quot;service:[service name]&quot;</span>network_mode: <span class="hljs-string">&quot;container:[container name/id]&quot;</span></code></pre></div><ul><li><strong>ports</strong>：对外暴露的端口定义，和 expose 对应</li></ul><div class="hljs code-wrapper"><pre><code class="hljs objectivec">ports:   # 暴露端口信息  - <span class="hljs-string">&quot;宿主机端口:容器暴露端口&quot;</span>- <span class="hljs-string">&quot;8763:8763&quot;</span>- <span class="hljs-string">&quot;8763:8763&quot;</span></code></pre></div><ul><li><strong>links</strong>：将指定容器连接到当前连接，可以设置别名，避免ip方式导致的容器重启动态改变的无法连接情况</li><li>但无法连接到docker-compose 文件以外的容器，因每个compose 均另起一个网段可用external_links</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash">links:    <span class="hljs-comment"># 指定服务名称:别名 </span>    - docker-compose-eureka-server:compose-eureka</code></pre></div><ul><li>links代表的是在本文件下互通<br>意思就是在这个yml文件一块启动的容器下互通<br>external_links是只要是同一个docker启动的都可以互通</li><li>external_links</li></ul><div class="hljs code-wrapper"><pre><code class="hljs csharp">external_links:  - redis:redis <span class="hljs-meta">#可以用redis这个域名访问redis服务</span>  - mongo:mongo <span class="hljs-meta">#可以用mongo这个域名访问mongo服务</span>  - mysql:db <span class="hljs-meta">#可以用db这个域名访问mysql服务</span>  - rabbitmq:rabbit <span class="hljs-meta">#可以用rabbit这个域名访问rabbitmq服务</span></code></pre></div><ul><li><strong>volumes</strong>：卷挂载路径</li></ul><div class="hljs code-wrapper"><pre><code class="hljs csharp">volumes:  - /lib  - /<span class="hljs-keyword">var</span></code></pre></div><ul><li><strong>logs</strong>：日志输出信息</li></ul><div class="hljs code-wrapper"><pre><code class="hljs csharp">--no-color          单色输出，不显示其他颜.-f, --follow        跟踪日志输出，就是可以实时查看日志-t, --timestamps    显示时间戳--tail              从日志的结尾显示，--tail=<span class="hljs-number">200</span></code></pre></div><h2 id="Docker-Compose-其它"><a href="#Docker-Compose-其它" class="headerlink" title="Docker Compose 其它"></a>Docker Compose 其它</h2><h3 id="更新容器"><a href="#更新容器" class="headerlink" title="更新容器"></a>更新容器</h3><ul><li>当服务的配置发生更改时，可使用 docker-compose up 命令更新配置</li><li>此时，Compose 会删除旧容器并创建新容器，新容器会以不同的 IP 地址加入网络，名称保持不变，任何指向旧容起的连接都会被关闭，重新找到新容器并连接上去</li></ul><h3 id="links"><a href="#links" class="headerlink" title="links"></a>links</h3><ul><li>服务之间可以使用服务名称相互访问，links 允许定义一个别名，从而使用该别名访问其它服务</li></ul><div class="hljs code-wrapper"><pre><code class="hljs csharp">version: <span class="hljs-string">&#x27;2&#x27;</span>services:    web:        build: .        links:            - <span class="hljs-string">&quot;db:database&quot;</span>    db:        image: postgres</code></pre></div><ul><li>这样 Web 服务就可以使用 db 或 database 作为 hostname 访问 db 服务了</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><strong>docker-compose-env.yml 使用 docker-compose -f docker-compose-env.yml  up -d 后台运行</strong></p><div class="hljs code-wrapper"><pre><code class="hljs csharp">version: <span class="hljs-string">&#x27;3&#x27;</span>services:  mysql:    image: mysql:<span class="hljs-number">5.7</span>    container_name: mysql    command: mysqld --character-<span class="hljs-keyword">set</span>-server=utf8mb4 --collation-server=utf8mb4_unicode_ci    restart: always    environment:      MYSQL_ROOT_PASSWORD: root <span class="hljs-meta">#设置root帐号密码</span>    ports:      - <span class="hljs-number">3306</span>:<span class="hljs-number">3306</span>    volumes:      - /mydata/mysql/data/db:/<span class="hljs-keyword">var</span>/lib/mysql <span class="hljs-meta">#数据文件挂载</span>      - /mydata/mysql/data/conf:/etc/mysql/conf.d <span class="hljs-meta">#配置文件挂载</span>      - /mydata/mysql/log:/<span class="hljs-keyword">var</span>/log/mysql <span class="hljs-meta">#日志文件挂载</span>  redis:    image: redis:<span class="hljs-number">5</span>    container_name: redis    command: redis-server --appendonly yes    volumes:      - /mydata/redis/data:/data <span class="hljs-meta">#数据文件挂载</span>    ports:      - <span class="hljs-number">6379</span>:<span class="hljs-number">6379</span>  nginx:    image: nginx:<span class="hljs-number">1.10</span>    container_name: nginx    volumes:      - /mydata/nginx/nginx.conf:/etc/nginx/nginx.conf <span class="hljs-meta">#配置文件挂载</span>      - /mydata/nginx/html:/usr/share/nginx/html <span class="hljs-meta">#静态资源根目录挂载</span>      - /mydata/nginx/log:/<span class="hljs-keyword">var</span>/log/nginx <span class="hljs-meta">#日志文件挂载</span>    ports:      - <span class="hljs-number">80</span>:<span class="hljs-number">80</span>  rabbitmq:    image: rabbitmq:<span class="hljs-number">3.7</span><span class="hljs-number">.15</span>-management    container_name: rabbitmq    volumes:      - /mydata/rabbitmq/data:/<span class="hljs-keyword">var</span>/lib/rabbitmq <span class="hljs-meta">#数据文件挂载</span>      - /mydata/rabbitmq/log:/<span class="hljs-keyword">var</span>/log/rabbitmq <span class="hljs-meta">#日志文件挂载</span>    ports:      - <span class="hljs-number">5672</span>:<span class="hljs-number">5672</span>      - <span class="hljs-number">15672</span>:<span class="hljs-number">15672</span>  elasticsearch:    image: elasticsearch:<span class="hljs-number">7.6</span><span class="hljs-number">.2</span>    container_name: elasticsearch    environment:      - <span class="hljs-string">&quot;cluster.name=elasticsearch&quot;</span> <span class="hljs-meta">#设置集群名称为elasticsearch</span>      - <span class="hljs-string">&quot;discovery.type=single-node&quot;</span> <span class="hljs-meta">#以单一节点模式启动</span>      - <span class="hljs-string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span> <span class="hljs-meta">#设置使用jvm内存大小</span>    volumes:      - /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins <span class="hljs-meta">#插件文件挂载</span>      - /mydata/elasticsearch/data:/usr/share/elasticsearch/data <span class="hljs-meta">#数据文件挂载</span>    ports:      - <span class="hljs-number">9200</span>:<span class="hljs-number">9200</span>      - <span class="hljs-number">9300</span>:<span class="hljs-number">9300</span>  logstash:    image: logstash:<span class="hljs-number">7.6</span><span class="hljs-number">.2</span>    container_name: logstash    environment:      - TZ=Asia/Shanghai    volumes:      - /mydata/logstash/logstash.conf:/usr/share/logstash/pipeline/logstash.conf <span class="hljs-meta">#挂载logstash的配置文件</span>    depends_on:      - elasticsearch <span class="hljs-meta">#kibana在elasticsearch启动之后再启动</span>    links:      - elasticsearch:es <span class="hljs-meta">#可以用es这个域名访问elasticsearch服务</span>    ports:      - <span class="hljs-number">4560</span>:<span class="hljs-number">4560</span>      - <span class="hljs-number">4561</span>:<span class="hljs-number">4561</span>      - <span class="hljs-number">4562</span>:<span class="hljs-number">4562</span>      - <span class="hljs-number">4563</span>:<span class="hljs-number">4563</span>  kibana:    image: kibana:<span class="hljs-number">7.6</span><span class="hljs-number">.2</span>    container_name: kibana    links:      - elasticsearch:es <span class="hljs-meta">#可以用es这个域名访问elasticsearch服务</span>    depends_on:      - elasticsearch <span class="hljs-meta">#kibana在elasticsearch启动之后再启动</span>    environment:      - <span class="hljs-string">&quot;elasticsearch.hosts=http://es:9200&quot;</span> <span class="hljs-meta">#设置访问elasticsearch的地址</span>    ports:      - <span class="hljs-number">5601</span>:<span class="hljs-number">5601</span>  mongo:    image: mongo:<span class="hljs-number">4.2</span><span class="hljs-number">.5</span>    container_name: mongo    volumes:      - /mydata/mongo/db:/data/db <span class="hljs-meta">#数据文件挂载</span>    ports:      - <span class="hljs-number">27017</span>:<span class="hljs-number">27017</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mac-launchctl</title>
    <link href="/2021/04/20/mac-launchctl/"/>
    <url>/2021/04/20/mac-launchctl/</url>
    
    <content type="html"><![CDATA[<h1 id="MAC设置Launchctl开机启动"><a href="#MAC设置Launchctl开机启动" class="headerlink" title="MAC设置Launchctl开机启动"></a>MAC设置Launchctl开机启动</h1><h3 id="主要目录"><a href="#主要目录" class="headerlink" title="主要目录"></a>主要目录</h3><h4 id="mac将使用launchctl做为开机启动工具，launchctl将根据plist文件的信息来启动任务。plist脚本一般存放在以下目录："><a href="#mac将使用launchctl做为开机启动工具，launchctl将根据plist文件的信息来启动任务。plist脚本一般存放在以下目录：" class="headerlink" title="mac将使用launchctl做为开机启动工具，launchctl将根据plist文件的信息来启动任务。plist脚本一般存放在以下目录："></a>mac将使用launchctl做为开机启动工具，launchctl将根据plist文件的信息来启动任务。plist脚本一般存放在以下目录：</h4><ul><li>l /Library/LaunchDaemons –&gt;只要系统启动了，哪怕用户不登陆系统也会被执行</li><li>l /Library/LaunchAgents –&gt;当用户登陆系统后才会被执行</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash">~/Library/LaunchAgents 由用户自己定义的任务项/Library/LaunchAgents 由管理员为用户定义的任务项/Library/LaunchDaemons 由管理员定义的守护进程任务项/System/Library/LaunchAgents 由Mac OS X为用户定义的任务项/System/Library/LaunchDaemons 由Mac OS X定义的守护进程任务项</code></pre></div><h3 id="launchctl-常用命令："><a href="#launchctl-常用命令：" class="headerlink" title="launchctl 常用命令："></a>launchctl 常用命令：</h3><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 加载任务, -w选项会将plist文件中无效的key覆盖掉，建议加上</span>$ launchctl load -w com.demo.plist<span class="hljs-comment"># 删除任务</span>$ launchctl unload -w com.demo.plist<span class="hljs-comment"># 查看任务列表, 使用 grep &#x27;任务部分名字&#x27; 过滤</span>$ launchctl list | grep <span class="hljs-string">&#x27;com.demo&#x27;</span><span class="hljs-comment"># 开始任务</span>$ launchctl start  com.demo.plist<span class="hljs-comment"># 结束任务</span>$ launchctl stop   com.demo.plist</code></pre></div><p>如果任务呗修改了，那么必须先unload，然后重新loadstart可以测试任务，这个是立即行，不管时间到了没有执行start和unload前，任务必须先load过，否则报错stop可以停止任务</p><h5 id="plist支持两种方式配置执行时间："><a href="#plist支持两种方式配置执行时间：" class="headerlink" title="plist支持两种方式配置执行时间："></a>plist支持两种方式配置执行时间：</h5><ul><li>StartInterval: 指定脚本每间隔多长时间（单位：秒）执行一次</li><li>StartCalendarInterval: 可以指定脚本在多少分钟、小时、天、星期几、月时间上执行，类似如crontab的中的设置，包含下面的 key:</li></ul><div class="hljs code-wrapper"><pre><code class="hljs xml">Minute <span class="hljs-tag">&lt;<span class="hljs-name">integer</span>&gt;</span>The minute on which this job will be run.Hour <span class="hljs-tag">&lt;<span class="hljs-name">integer</span>&gt;</span>The hour on which this job will be run.Day <span class="hljs-tag">&lt;<span class="hljs-name">integer</span>&gt;</span>The day on which this job will be run.Weekday <span class="hljs-tag">&lt;<span class="hljs-name">integer</span>&gt;</span>The weekday on which this job will be run (0 and 7 are Sunday).Month <span class="hljs-tag">&lt;<span class="hljs-name">integer</span>&gt;</span>The month on which this job will be run.</code></pre></div><h3 id="plist部分参数说明："><a href="#plist部分参数说明：" class="headerlink" title="plist部分参数说明："></a>plist部分参数说明：</h3><ol><li>Label：对应的需要保证全局唯一性；</li><li>Program：要运行的程序；</li><li>ProgramArguments：命令语句</li><li>StartCalendarInterval：运行的时间，单个时间点使用dict，多个时间点使用 array</li><li>StartInterval：时间间隔，与StartCalendarInterval使用其一，单位为秒</li><li>StandardInPath、StandardOutPath、StandardErrorPath：标准的输入输出错误文件，这里建议不要使用 .log 作为后缀，会打不开里面的信息。</li></ol><h4 id="定时启动任务时，如果涉及到网络，但是电脑处于睡眠状态，是执行不了的，这个时候，可以定时的启动屏幕就好了。"><a href="#定时启动任务时，如果涉及到网络，但是电脑处于睡眠状态，是执行不了的，这个时候，可以定时的启动屏幕就好了。" class="headerlink" title="定时启动任务时，如果涉及到网络，但是电脑处于睡眠状态，是执行不了的，这个时候，可以定时的启动屏幕就好了。"></a>定时启动任务时，如果涉及到网络，但是电脑处于睡眠状态，是执行不了的，这个时候，可以定时的启动屏幕就好了。</h4><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">plist</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//Apple//DTD PLIST 1.0//EN&quot;</span> <span class="hljs-meta-string">&quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plist</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.0&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dict</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>KeepAlive<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dict</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>SuccessfulExit<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">false</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dict</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>Label<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>frpc<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>ProgramArguments<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>/Users/luna_mac/Documents/luna/frp/frpc<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>-c<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>/Users/luna_mac/Documents/luna/frp/frpc.ini<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>StandardErrorPath<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>/tmp/shelltask.err<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>StandardOutPath<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>/tmp/shelltask.log<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>WorkingDirectory<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>/Users/luna_mac/Documents/luna/frp<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dict</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plist</span>&gt;</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>system</category>
      
    </categories>
    
    
    <tags>
      
      <tag>macos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mybatis 面试题</title>
    <link href="/2021/04/19/mybatis-interview-1/"/>
    <url>/2021/04/19/mybatis-interview-1/</url>
    
    <content type="html"><![CDATA[<h2 id="MyBatis简介"><a href="#MyBatis简介" class="headerlink" title="MyBatis简介"></a>MyBatis简介</h2><h3 id="MyBatis是什么？"><a href="#MyBatis是什么？" class="headerlink" title="MyBatis是什么？"></a>MyBatis是什么？</h3><p>MyBatis 是一款优秀的持久层框架，一个半 ORM（对象关系映射）框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p><h3 id="ORM是什么"><a href="#ORM是什么" class="headerlink" title="ORM是什么"></a>ORM是什么</h3><p>ORM（Object Relational Mapping），对象关系映射，是一种为了解决关系型数据库数据与简单Java对象（POJO）的映射关系的技术。简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系型数据库中。</p><p>为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？<br>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。</p><p>而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</p><h3 id="传统JDBC存在的问题"><a href="#传统JDBC存在的问题" class="headerlink" title="传统JDBC存在的问题"></a>传统JDBC存在的问题</h3><ul><li>频繁创建数据连接对象，释放，容易造成资源浪费，影响系统性能。可以使用连接池解决，但需要JDBC自实现</li><li>sql语句定义，参数设置，结果集处理存在硬编码，实际项目中sql语句变化可能性较大，一旦发生变化，需要修改JAVA代码，系统需要重新编译，重新发布。</li><li>使用preparesStatement向占位符发送参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还需要修改代码，处理麻烦，如果映射成JAVA对象会比较方便</li></ul><h3 id="JDBC编程有哪些不足之处，Mybatis如何解决"><a href="#JDBC编程有哪些不足之处，Mybatis如何解决" class="headerlink" title="JDBC编程有哪些不足之处，Mybatis如何解决"></a>JDBC编程有哪些不足之处，Mybatis如何解决</h3><ol><li><p>数据库链接创建，释放造成资源浪费，从而影响性能，如果使用数据库连接池可解决</p><p class="note note-primary">解决：在mybatis-config.xml 中配置数据库连接池，使用连接池管理数据库连接</p></li><li><p>Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。</p><p class="note note-secondary">解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。</p></li><li><p>向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。</p><p class="note note-warning">解决： Mybatis自动将java对象映射至sql语句。</p></li><li><p>对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。</p><p class="note note-light">解决：Mybatis自动将sql执行结果映射至java对象。</p></li></ol><h3 id="Mybatis-优缺点"><a href="#Mybatis-优缺点" class="headerlink" title="Mybatis 优缺点"></a>Mybatis 优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>与传统JDBC相比</p><ol><li>基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL在xml里，解除SQL和程序代码的筽耦合，便于统一管理；提供xml标签，支持编写动态sql语句，并可重用</li><li>与JDBC相比，减少了50%的代码量，消除大量冗余代码，不需要手动开关连接</li><li>很好的于各种数据库兼容（因为Mybatis用JDBC操作数据库，所以只需要支持JDBC则支持Mybatis）</li><li>提供映射标签，支持对象与数据库的ORM字段映射关系；提供对象映射标签；支持对象关系组建维护</li><li>能很好的与Spring集成</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>Mybatis专注于sql本身，是一个灵活的DAO层解决方案</li><li>对性能的要求很高，或者本身变化比较多的项目，如互联网项目，Mybatis将是不错的选择</li></ol><h3 id="Hibernate-和-Mybatis-的区别"><a href="#Hibernate-和-Mybatis-的区别" class="headerlink" title="Hibernate 和 Mybatis 的区别"></a>Hibernate 和 Mybatis 的区别</h3><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ul><li><p>都是对JDBC的封装</p></li><li><p>都是持久层的框架，都用于DAO层的开发</p></li></ul><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ul><li><p>映射关系</p><ul><li>Mybatis是半自动化的映射框架，配置JAVA对象与SQL语句执行结果的对应关系，多表关联关系配置简单</li><li>Hibernate是一个全表映射的框架，配置JAVA对象与数据库表的对应关系，多表关联关系配置复杂</li></ul></li><li><p>SQL优化和移植性</p><ul><li>Hibernate 对sql 语句封装，提供了日志，缓存，级联（级联比Mybatis强大）等特性，此外还提供HQL（Hibernate Query Language） 操作数据库，数据库无关性支持好，但会多消耗性能。</li><li>Mybatis需要手写SQL，支持动态SQL，处理列表，动态列名生成，支持数据存储过程，开发工作量较大，直接使用sql操作数据库，不支持数据库无关性，但sql优化相对容易</li></ul></li><li><p>开发难易程度和学习成本</p><ul><li>Hibernate 是重量级框架，学习使用门槛高，适合于需求相对稳定，中小型的项目，比如：办公自动化系统</li><li>MyBatis 是轻量级框架，学习使用门槛低，适合于需求变化频繁，大型的项目，比如：互联网电子商务系统</li></ul></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>MyBatis 是一个小巧、方便、高效、简单、直接、半自动化的持久层框架，</li><li>Hibernate 是一个强大、方便、高效、复杂、间接、全自动化的持久层框架。</li></ul><h2 id="MyBatis的解析和运行原理"><a href="#MyBatis的解析和运行原理" class="headerlink" title="MyBatis的解析和运行原理"></a>MyBatis的解析和运行原理</h2><h3 id="MyBatis编程步骤是什么样的？"><a href="#MyBatis编程步骤是什么样的？" class="headerlink" title="MyBatis编程步骤是什么样的？"></a>MyBatis编程步骤是什么样的？</h3><ol><li>创建SqlSessionFactory</li><li>通过SqlSessionFactory创建SqlSession</li><li>通过Sqlsession执行数据库操作</li><li>通过session.commit() 提交事务</li><li>调用session.close()关闭会话</li></ol><h3 id="请说说MyBatis的工作原理"><a href="#请说说MyBatis的工作原理" class="headerlink" title="请说说MyBatis的工作原理"></a>请说说MyBatis的工作原理</h3><p>在学习 MyBatis 程序之前，需要了解一下 MyBatis 工作原理，以便于理解程序。MyBatis 的工作原理如下图</p><p><img src="https://i.loli.net/2021/04/19/A5dWPV3RKkGH7SQ.png" alt="MyBatis工作原理"></p><div class="hljs code-wrapper"><pre><code class="hljs bash">1）读取 MyBatis 配置文件：mybatis-config.xml 为 MyBatis 的全局配置文件，配置了 MyBatis 的运行环境等信息，例如数据库连接信息。2）加载映射文件。映射文件即 SQL 映射文件，该文件中配置了操作数据库的 SQL 语句，需要在 MyBatis 配置文件 mybatis-config.xml 中加载。mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表。3）构造会话工厂：通过 MyBatis 的环境等配置信息构建会话工厂 SqlSessionFactory。4）创建会话对象：由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 语句的所有方法。5）Executor 执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。6）MappedStatement 对象：在 Executor 接口的执行方法中有一个 MappedStatement 类型的参数，该参数是对映射信息的封装，用于存储要映射的 SQL 语句的 id、参数等信息。7）输入参数映射：输入参数类型可以是 Map、List 等集合类型，也可以是基本数据类型和 POJO 类型。输入参数映射过程类似于 JDBC 对 preparedStatement 对象设置参数的过程。8）输出结果映射：输出结果类型可以是 Map、 List 等集合类型，也可以是基本数据类型和 POJO 类型。输出结果映射过程类似于 JDBC 对结果集的解析过程。</code></pre></div><h3 id="MyBatis的功能架构是怎样的"><a href="#MyBatis的功能架构是怎样的" class="headerlink" title="MyBatis的功能架构是怎样的"></a>MyBatis的功能架构是怎样的</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL015QmF0aXMlRTYlQTElODYlRTYlOUUlQjYlRTYlODAlQkIlRTclQkIlOTMvTXlCYXRpcyVFNSU4QSU5RiVFOCU4MyVCRCVFNiU5RSVCNiVFNiU5RSU4NC5wbmc" alt="Mybatis功能框架"></p><h4 id="我们把Mybatis的功能架构分为三层："><a href="#我们把Mybatis的功能架构分为三层：" class="headerlink" title="我们把Mybatis的功能架构分为三层："></a>我们把Mybatis的功能架构分为三层：</h4><p>API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。<br>数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。<br>基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。</p><h2 id="MyBatis的框架架构设计是怎么样的"><a href="#MyBatis的框架架构设计是怎么样的" class="headerlink" title="MyBatis的框架架构设计是怎么样的"></a>MyBatis的框架架构设计是怎么样的</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL015QmF0aXMlRTYlQTElODYlRTYlOUUlQjYlRTYlODAlQkIlRTclQkIlOTMvTXlCYXRpcyVFNiVBMSU4NiVFNiU5RSVCNiVFNiU5RSVCNiVFNiU5RSU4NC5wbmc" alt="Mybatis框架架构"></p><hr><p>这张图从上往下看。MyBatis的初始化，会从mybatis-config.xml配置文件，解析构造成Configuration这个类，就是图中的红框。</p><p>(1)加载配置：配置来源于两个地方，一处是配置文件，一处是Java代码的注解，将SQL的配置信息加载成为一个个MappedStatement对象（包括了传入参数映射配置、执行的SQL语句、结果映射配置），存储在内存中。</p><p>(2)SQL解析：当API接口层接收到调用请求时，会接收到传入SQL的ID和传入对象（可以是Map、JavaBean或者基本数据类型），Mybatis会根据SQL的ID找到对应的MappedStatement，然后根据传入参数对象对MappedStatement进行解析，解析后可以得到最终要执行的SQL语句和参数。</p><p>(3)SQL执行：将最终得到的SQL和参数拿到数据库进行执行，得到操作数据库的结果。</p><p>(4)结果映射：将操作数据库的结果按照映射的配置进行转换，可以转换成HashMap、JavaBean或者基本数据类型，并将最终结果返回。</p><h2 id="为什么需要预编译"><a href="#为什么需要预编译" class="headerlink" title="为什么需要预编译"></a>为什么需要预编译</h2><div class="hljs code-wrapper"><pre><code class="hljs markdown">&#123;% label primary @定义：SQL 预编译指的是数据库驱动在发送 SQL 语句和参数给 DBMS 之前对 SQL 语句进行编译，这样 DBMS 执行 SQL 时，就不需要重新编译。 %&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;label label-primary&quot;</span>&gt;</span>为什么需要预编译<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre></div><ul><li><p>JDBC 中使用对象 PreparedStatement 来抽象预编译语句，使用预编译。预编译阶段可以优化 SQL 的执行。预编译之后的 SQL 多数情况下可以直接执行，DBMS 不需要再次编译，越复杂的SQL，编译的复杂度将越大，预编译阶段可以合并多次操作为一个操作。</p></li><li><p>同时预编译语句对象可以重复利用。把一个 SQL 预编译后产生的 PreparedStatement 对象缓存下来，下次对于同一个SQL，可以直接使用这个缓存的 PreparedState 对象。Mybatis默认情况下，将对所有的 SQL 进行预编译。</p></li><li><p>防止SQL注入</p></li></ul><h2 id="Mybatis都有哪些Executor执行器？它们之间的区别是什么？"><a href="#Mybatis都有哪些Executor执行器？它们之间的区别是什么？" class="headerlink" title="Mybatis都有哪些Executor执行器？它们之间的区别是什么？"></a>Mybatis都有哪些Executor执行器？它们之间的区别是什么？</h2><div class="note note-success">            <p>Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。</p><p>SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</p><p>ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象。</p><p>BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</p><p>作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。</p>          </div><h2 id="Mybatis中如何指定使用哪一种Executor执行器？"><a href="#Mybatis中如何指定使用哪一种Executor执行器？" class="headerlink" title="Mybatis中如何指定使用哪一种Executor执行器？"></a>Mybatis中如何指定使用哪一种Executor执行器？</h2><p><u>Mybatis有三种基本的Executor执行器</u>，<strong>SimpleExecutor、ReuseExecutor、BatchExecutor。</strong></p><ul><li>SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</li><li>ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象。</li><li>BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</li></ul><p><span class="label label-primary">都严格限制在SqlSession生命周期范围内。 </span></p><h2 id="Mybatis中如何指定使用哪一种Executor执行器？-1"><a href="#Mybatis中如何指定使用哪一种Executor执行器？-1" class="headerlink" title="Mybatis中如何指定使用哪一种Executor执行器？"></a>Mybatis中如何指定使用哪一种Executor执行器？</h2><p>在Mybatis配置文件中，在设置（settings）可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数，如SqlSession openSession(ExecutorType execType)。</p><p>配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。</p><h2 id="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"></a>Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</h2><p>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。</p><p>它的原理是，==使用CGLIB创建目标对象的代理对象==，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p><p>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p><h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="#{}和${}的区别"></a>#{}和${}的区别</h2><ul><li>#{}是占位符，预编译处理；${}是拼接符，字符串替换，没有预编译处理。</li><li>Mybatis在处理#{}时，#{}传入参数是以字符串传入，会将SQL中的#{}替换为?号，调用PreparedStatement的set方法来赋值。</li><li>Mybatis在处理时 ， 是 原 值 传 入 ， 就 是 把 {}时，是原值传入，就是把时，是原值传入，就是把{}替换成变量的值，相当于JDBC中的Statement编译</li><li>变量替换后，#{} 对应的变量自动加上单引号 ‘’；变量替换后，${} 对应的变量不会加上单引号 ‘’</li><li>#{} 可以有效的防止SQL注入，提高系统安全性；${} 不能防止SQL 注入</li><li>#{} 的变量替换是在DBMS 中；${} 的变量替换是在 DBMS 外</li></ul><h2 id="模糊查询like语句该怎么写"><a href="#模糊查询like语句该怎么写" class="headerlink" title="模糊查询like语句该怎么写"></a>模糊查询like语句该怎么写</h2><p>（1）’%${question}%’ 可能引起SQL注入，不推荐</p><p>（2）”%”#{question}”%” 注意：因为#{…}解析成sql语句时候，会在变量外侧自动加单引号’ ‘，所以这里 % 需要使用双引号” “，不能使用单引号 ’ ‘，不然会查不到任何结果。</p><p>（3）CONCAT(’%’,#{question},’%’) 使用CONCAT()函数，推荐</p><p>（4）使用bind标签</p><div class="hljs code-wrapper"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;listUserLikeUsername&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.jourwon.pojo.User&quot;</span>&gt;</span>　　<span class="hljs-tag">&lt;<span class="hljs-name">bind</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pattern&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&#x27;%&#x27; + username + &#x27;%&#x27;&quot;</span> /&gt;</span>　　select id,sex,age,username,password from person where username LIKE #&#123;pattern&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><h2 id="在mapper中如何传递多个参数"><a href="#在mapper中如何传递多个参数" class="headerlink" title="在mapper中如何传递多个参数"></a>在mapper中如何传递多个参数</h2><p><strong>方法1：顺序传参法</strong></p><p><code>public User selectUser(String name, int deptId);</code></p><div class="hljs code-wrapper"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;UserResultMap&quot;</span>&gt;</span>    select * from user    where user_name = #&#123;0&#125; and dept_id = #&#123;1&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><p>#{}里面的数字代表传入参数的顺序。</p><p>这种方法不建议使用，sql层表达不直观，且一旦顺序调整容易出错。</p><p><strong>方法2：@Param注解传参法</strong></p><p><code>public User selectUser(@Param(&quot;userName&quot;) String name, int @Param(&quot;deptId&quot;) deptId);</code></p><div class="hljs code-wrapper"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;UserResultMap&quot;</span>&gt;</span>    select * from user    where user_name = #&#123;userName&#125; and dept_id = #&#123;deptId&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><p>#{}里面的名称对应的是注解@Param括号里面修饰的名称。</p><p>这种方法在参数不多的情况还是比较直观的，推荐使用。</p><p><strong>方法3：Map传参法</strong></p><p><code>public User selectUser(Map&lt;String, Object&gt; params);</code></p><div class="hljs code-wrapper"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.util.Map&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;UserResultMap&quot;</span>&gt;</span>    select * from user    where user_name = #&#123;userName&#125; and dept_id = #&#123;deptId&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><p>#{}里面的名称对应的是Map里面的key名称。</p><p>这种方法适合传递多个参数，且参数易变能灵活传递的情况。</p><p><strong>方法4：Java Bean传参法</strong></p><p><code>public User selectUser(User user);</code></p><div class="hljs code-wrapper"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.jourwon.pojo.User&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;UserResultMap&quot;</span>&gt;</span>    select * from user    where user_name = #&#123;userName&#125; and dept_id = #&#123;deptId&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><p>#{}里面的名称对应的是User类里面的成员属性。</p><p>这种方法直观，需要建一个实体类，扩展不容易，需要加属性，但代码可读性强，业务逻辑处理方便，推荐使用。</p><h2 id="Mybatis如何执行批量操作"><a href="#Mybatis如何执行批量操作" class="headerlink" title="Mybatis如何执行批量操作"></a>Mybatis如何执行批量操作</h2><div class="hljs code-wrapper"><pre><code class="hljs BASH">使用foreach标签foreach的主要用在构建<span class="hljs-keyword">in</span>条件中，它可以在SQL语句中进行迭代一个集合。foreach标签的属性主要有item，index，collection，open，separator，close。item　　表示集合中每一个元素进行迭代时的别名，随便起的变量名；index　　指定一个名字，用于表示在迭代过程中，每次迭代到的位置，不常用；open　　表示该语句以什么开始，常用“(”；separator表示在每次进行迭代之间以什么符号作为分隔符，常用“,”；close　　表示以什么结束，常用“)”。在使用foreach的时候最关键的也是最容易出错的就是collection属性，该属性是必须指定的，但是在不同情况下，该属性的值是不一样的，主要有一下3种情况：如果传入的是单参数且参数类型是一个List的时候，collection属性值为list如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了，当然单参数也可以封装成map，实际上如果你在传入参数的时候，在MyBatis里面也是会把它封装成一个Map的，map的key就是参数名，所以这个时候collection属性值就是传入的List或array对象在自己封装的map里面的key</code></pre></div><h4 id="具体用法如下："><a href="#具体用法如下：" class="headerlink" title="具体用法如下："></a>具体用法如下：</h4><div class="hljs code-wrapper"><pre><code class="hljs XML"><span class="hljs-comment">&lt;!-- 批量保存(foreach插入多条数据两种方法)</span><span class="hljs-comment">       int addEmpsBatch(@Param(&quot;emps&quot;) List&lt;Employee&gt; emps); --&gt;</span><span class="hljs-comment">&lt;!-- MySQL下批量保存，可以foreach遍历 mysql支持values(),(),()语法 --&gt;</span> //推荐使用<span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addEmpsBatch&quot;</span>&gt;</span>    INSERT INTO emp(ename,gender,email,did)    VALUES    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;emps&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;emp&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span>        (#&#123;emp.eName&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.dept.id&#125;)    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs XML"><span class="hljs-comment">&lt;!-- 这种方式需要数据库连接属性allowMutiQueries=true的支持</span><span class="hljs-comment"> 如jdbc.url=jdbc:mysql://localhost:3306/mybatis?allowMultiQueries=true --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addEmpsBatch&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;emps&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;emp&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;;&quot;</span>&gt;</span>                                         INSERT INTO emp(ename,gender,email,did)        VALUES(#&#123;emp.eName&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.dept.id&#125;)    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></code></pre></div><h3 id="使用ExecutorType-BATCH"><a href="#使用ExecutorType-BATCH" class="headerlink" title="使用ExecutorType.BATCH"></a>使用ExecutorType.BATCH</h3><p>Mybatis内置的ExecutorType有3种，默认为simple,该模式下它为每个语句的执行创建一个新的预处理语句，单条提交sql；而batch模式重复使用已经预处理的语句，并且批量执行所有更新语句，显然batch性能将更优； 但batch模式也有自己的问题，比如在Insert操作时，在事务没有提交之前，是没有办法获取到自增的id，这在某型情形下是不符合业务要求的</p><h4 id="具体用法如下"><a href="#具体用法如下" class="headerlink" title="具体用法如下"></a>具体用法如下</h4><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><span class="hljs-comment">//批量保存方法测试</span><span class="hljs-meta">@Test</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testBatch</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();    <span class="hljs-comment">//可以执行批量操作的sqlSession</span>    SqlSession openSession = sqlSessionFactory.openSession(ExecutorType.BATCH);    <span class="hljs-comment">//批量保存执行前时间</span>    <span class="hljs-keyword">long</span> start = System.currentTimeMillis();    <span class="hljs-keyword">try</span> &#123;        EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;            mapper.addEmp(<span class="hljs-keyword">new</span> Employee(UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>), <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>));        &#125;        openSession.commit();        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();        <span class="hljs-comment">//批量保存执行后的时间</span>        System.out.println(<span class="hljs-string">&quot;执行时长&quot;</span> + (end - start));        <span class="hljs-comment">//批量 预编译sql一次==》设置参数==》10000次==》执行1次   677</span>        <span class="hljs-comment">//非批量  （预编译=设置参数=执行 ）==》10000次   1121</span>    &#125; <span class="hljs-keyword">finally</span> &#123;        openSession.close();    &#125;&#125;</code></pre></div><p>mapper和mapper.xml如下</p><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">EmployeeMapper</span> </span>&#123;       <span class="hljs-comment">//批量保存员工</span>    <span class="hljs-function">Long <span class="hljs-title">addEmp</span><span class="hljs-params">(Employee employee)</span></span>;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.jourwon.mapper.EmployeeMapper&quot;</span></span>     &lt;!--批量保存员工 --&gt;    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addEmp&quot;</span>&gt;</span>        insert into employee(lastName,email,gender)        values(#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;)    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><h2 id="如何获取生成的主键"><a href="#如何获取生成的主键" class="headerlink" title="如何获取生成的主键"></a>如何获取生成的主键</h2><p><strong>对于支持主键自增的数据库（MySQL）</strong></p><div class="hljs code-wrapper"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;userId&quot;</span> &gt;</span>    insert into user(     user_name, user_password, create_time)     values(#&#123;userName&#125;, #&#123;userPassword&#125; , #&#123;createTime, jdbcType= TIMESTAMP&#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></code></pre></div><p>parameterType 可以不写，Mybatis可以推断出传入的数据类型。如果想要访问主键，那么应当parameterType 应当是java实体或者Map。这样数据在插入之后 可以通过ava实体或者Map 来获取主键值。通过 getUserId获取主键</p><p><strong>不支持主键自增的数据库（Oracle）</strong></p><p>对于像Oracle这样的数据，没有提供主键自增的功能，而是使用序列的方式获取自增主键。<br>可以使用＜selectKey＞标签来获取主键的值，这种方式不仅适用于不提供主键自增功能的数据库，也适用于提供主键自增功能的数据库<br>＜selectKey＞一般的用法</p><div class="hljs code-wrapper"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">selectKey</span> <span class="hljs-attr">keyColumn</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;long&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;BEFORE&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">selectKey</span>&gt;</span></code></pre></div><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>keyProperty</td><td>selectKey 语句结果应该被设置的目标属性。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</td></tr><tr><td>keyColumn</td><td>匹配属性的返回结果集中的列名称。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</td></tr><tr><td>resultType</td><td>结果的类型，MyBatis 通常可以推算出来。MyBatis 允许任何简单类型用作主键的类型，包括字符串。如果希望作用于多个生成的列，则可以使用一个包含期望属性的 Object 或一个 Map。</td></tr><tr><td>order</td><td>值可为BEFORE 或 AFTER。如果是 BEFORE，那么它会先执行selectKey设置 keyProperty 然后执行插入语句。如果为AFTER则相反。</td></tr><tr><td>statementType</td><td>使用何种语句类型，默认PREPARED。 有STATEMENT，PREPARED 和 CALLABLE 语句的映射类型。</td></tr></tbody></table><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span> &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">selectKey</span> <span class="hljs-attr">keyColumn</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;long&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;userId&quot;</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;BEFORE&quot;</span>&gt;</span>SELECT USER_ID.nextval as id from dual <span class="hljs-tag">&lt;/<span class="hljs-name">selectKey</span>&gt;</span> insert into user( user_id,user_name, user_password, create_time) values(#&#123;userId&#125;,#&#123;userName&#125;, #&#123;userPassword&#125; , #&#123;createTime, jdbcType= TIMESTAMP&#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></code></pre></div><p>此时会将Oracle生成的主键值赋予userId变量。这个userId 就是USER对象的属性，这样就可以将生成的主键值返回了。如果仅仅是在insert语句中使用但是不返回，此时keyProperty=“任意自定义变量名”，resultType 可以不写。<br>Oracle 数据库中的值要设置为 BEFORE ，这是因为 Oracle中需要先从序列获取值，然后将值作为主键插入到数据库中。</p><h3 id="当实体类中的属性名和表中的字段名不一样-，怎么办"><a href="#当实体类中的属性名和表中的字段名不一样-，怎么办" class="headerlink" title="当实体类中的属性名和表中的字段名不一样 ，怎么办"></a>当实体类中的属性名和表中的字段名不一样 ，怎么办</h3><h4 id="第1种：-通过在查询的SQL语句中定义字段名的-别名-，让字段名的别名和实体类的属性名一致。"><a href="#第1种：-通过在查询的SQL语句中定义字段名的-别名-，让字段名的别名和实体类的属性名一致。" class="headerlink" title="第1种： 通过在查询的SQL语句中定义字段名的==别名==，让字段名的别名和实体类的属性名一致。"></a>第1种： 通过在查询的SQL语句中定义字段名的==别名==，让字段名的别名和实体类的属性名一致。</h4><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getOrder&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.jourwon.pojo.Order&quot;</span>&gt;</span>       select order_id id, order_no orderno ,order_price price form orders where order_id=#&#123;id&#125;;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><h4 id="第2种：-通过-lt-resultMap-gt-来映射字段名和实体类属性名的一一对应的关系。"><a href="#第2种：-通过-lt-resultMap-gt-来映射字段名和实体类属性名的一一对应的关系。" class="headerlink" title="第2种： 通过&lt;resultMap&gt;来映射字段名和实体类属性名的一一对应的关系。"></a>第2种： 通过<code>&lt;resultMap&gt;</code>来映射字段名和实体类属性名的一一对应的关系。</h4><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getOrder&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;orderResultMap&quot;</span>&gt;</span>select * from orders where order_id=#&#123;id&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.jourwon.pojo.Order&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;orderResultMap&quot;</span>&gt;</span>    &lt;!–用id属性来映射主键字段–&gt;    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_id&quot;</span>&gt;</span>    &lt;!–用result属性来映射非主键字段，property为实体类属性名，column为数据库表中的属性–&gt;    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span> =<span class="hljs-string">&quot;orderno&quot;</span> <span class="hljs-attr">column</span> =<span class="hljs-string">&quot;order_no&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;price&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_price&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">reslutMap</span>&gt;</span></code></pre></div><h3 id="Mapper-编写有哪几种方式？"><a href="#Mapper-编写有哪几种方式？" class="headerlink" title="Mapper 编写有哪几种方式？"></a>Mapper 编写有哪几种方式？</h3><h4 id="第一种：接口实现类继承-SqlSessionDaoSupport：使用此种方法需要编写mapper-接口，mapper-接口实现类、mapper-xml-文件。"><a href="#第一种：接口实现类继承-SqlSessionDaoSupport：使用此种方法需要编写mapper-接口，mapper-接口实现类、mapper-xml-文件。" class="headerlink" title="第一种：接口实现类继承 SqlSessionDaoSupport：使用此种方法需要编写mapper 接口，mapper 接口实现类、mapper.xml 文件。"></a>第一种：接口实现类继承 SqlSessionDaoSupport：使用此种方法需要编写mapper 接口，mapper 接口实现类、mapper.xml 文件。</h4><p>（1）在 sqlMapConfig.xml 中配置 mapper.xml 的位置</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mapper.xml 文件的地址&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mapper.xml 文件的地址&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span></code></pre></div><p>（2）定义 mapper 接口</p><p>（3）实现类集成 SqlSessionDaoSupport</p><p>mapper 方法中可以 this.getSqlSession()进行数据增删改查。</p><p>（4）spring 配置</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot; &quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mapper 接口的实现&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><h4 id="第二种：使用-org-mybatis-spring-mapper-MapperFactoryBean："><a href="#第二种：使用-org-mybatis-spring-mapper-MapperFactoryBean：" class="headerlink" title="第二种：使用 org.mybatis.spring.mapper.MapperFactoryBean："></a>第二种：使用 org.mybatis.spring.mapper.MapperFactoryBean：</h4><p>（1）在 sqlMapConfig.xml 中配置 mapper.xml 的位置，如果 mapper.xml 和mappre 接口的名称相同且在同一个目录，这里可以不用配置</p><p>（2）定义 mapper 接口：</p><p>（3）mapper.xml 中的 namespace 为 mapper 接口的地址</p><p>（4）mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致</p><p>（5）Spring 中定义</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapperInterface&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mapper 接口地址&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><h4 id="第三种：使用-mapper-扫描器："><a href="#第三种：使用-mapper-扫描器：" class="headerlink" title="第三种：使用 mapper 扫描器："></a>第三种：使用 mapper 扫描器：</h4><p>（1）mapper.xml 文件编写：</p><p>mapper.xml 中的 namespace 为 mapper 接口的地址；    </p><p>mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致；</p><p>如果将 mapper.xml 和 mapper 接口的名称保持一致则不用在 sqlMapConfig.xml中进行配置。</p><p>（2）定义 mapper 接口：</p><p>注意 mapper.xml 的文件名和 mapper 的接口名称保持一致，且放在同一个目录</p><p>（3）配置 mapper 扫描器：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mapper 接口包地址&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><p>（4）使用扫描器后从 spring 容器中获取 mapper 的实现对象。</p><h3 id="什么是MyBatis的接口绑定？有哪些实现方式？"><a href="#什么是MyBatis的接口绑定？有哪些实现方式？" class="headerlink" title="什么是MyBatis的接口绑定？有哪些实现方式？"></a>什么是MyBatis的接口绑定？有哪些实现方式？</h3><p>接口绑定，就是在MyBatis中任意定义接口，然后把接口里面的==方法和SQL语句绑定==，我们直接调用接口方法就可以，这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置。</p><p>接口绑定有两种实现方式</p><ul><li>通过注解绑定，就是在接口的方法上面加上 @Select、@Update等注解，里面包含Sql语句来绑定；</li></ul><ul><li>通过xml里面写SQL来绑定， 在这种情况下，要指定xml映射文件里面的namespace必须为接口的全路径名。当Sql语句比较简单时候，用注解绑定， 当SQL语句比较复杂时候，用xml绑定，一般用xml绑定的比较多。</li></ul><h3 id="使用MyBatis的mapper接口调用时有哪些要求？"><a href="#使用MyBatis的mapper接口调用时有哪些要求？" class="headerlink" title="使用MyBatis的mapper接口调用时有哪些要求？"></a>使用MyBatis的mapper接口调用时有哪些要求？</h3><p>1、Mapper接口方法名和mapper.xml中定义的每个sql的id相同。</p><p>2、Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同。</p><p>3、Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同。</p><p>4、Mapper.xml文件中的namespace即是mapper接口的类路径。</p><h3 id="最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗"><a href="#最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗" class="headerlink" title="最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗"></a>最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗</h3><p>Dao接口，就是人们常说的Mapper接口，<u>接口的全限名</u>，就是映射文件中的<u>namespace的值</u>，接口的<strong>方法名</strong>，就是映射文件中MappedStatement的<strong>id值</strong>，接口方法内的参数，就是传递给sql的参数。==Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatemen==t，举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在Mybatis中，每一个<select>、<insert>、<update>、<delete>标签，都会被解析为一个MappedStatement对象。</p><p>Dao接口里的方法，是==不能重载的==，因为是全限名+方法名的保存和寻找策略。</p><p>Dao接口的工作原理是==JDK动态代理==，Mybatis运行时会使用JDK动态代理为Dao接口==生成代理proxy对象==，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</p><h3 id="Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"><a href="#Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？" class="headerlink" title="Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"></a>Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</h3><p>不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。</p><p>原因就是namespace+id是作为Map&lt;String, MappedStatement&gt;的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。</p><h3 id="简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"><a href="#简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？" class="headerlink" title="简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"></a>简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？</h3><p>Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，<parameterMap>标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。<resultMap>标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个<select>、<insert>、<update>、<delete>标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。</p><h3 id="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h3><ul><li><p>第一种是使用<resultMap>标签，逐一定义列名和对象属性名之间的映射关系。</p></li><li><p>第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。</p></li><li><p>有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p></li></ul><h3 id="Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？"><a href="#Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？" class="headerlink" title="Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？"></a>Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？</h3><p>还有很多其他的标签，<resultMap>、<parameterMap>、<sql>、<include>、<selectKey>，加上动态sql的9个标签，==trim|where|set|foreach|if|choose|when|otherwise|bind==等，其中<sql>为sql片段标签，通过<include>标签引入sql片段，<selectKey>为不支持自增的主键生成策略标签。</p><h3 id="Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？"><a href="#Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？" class="headerlink" title="Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？"></a>Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？</h3><p>虽然Mybatis解析Xml映射文件是按照顺序解析的，但是，被引用的B标签依然可以==定义在任何地方==，Mybatis都可以正确识别。</p><p>原理是，Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存在，此时，Mybatis会将A标签标记为未解析状态，然后继续解析余下的标签，包含B标签，待所有标签解析完毕，Mybatis会重新解析那些被标记为未解析的标签，此时再解析A标签时，B标签已经存在，A标签也就可以正常解析完成了。</p><h2 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h2><h3 id="MyBatis实现一对一，一对多有几种方式，怎么操作的？"><a href="#MyBatis实现一对一，一对多有几种方式，怎么操作的？" class="headerlink" title="MyBatis实现一对一，一对多有几种方式，怎么操作的？"></a>MyBatis实现一对一，一对多有几种方式，怎么操作的？</h3><p>有联合查询和嵌套查询。联合查询是几个表联合查询，只查询一次，通过在resultMap里面的association，collection节点配置一对一，一对多的类就可以完成</p><p>嵌套查询是先查一个表，根据这个表里面的结果的外键id，去再另外一个表里面查询数据，也是通过配置association，collection，但另外一个表的查询通过select节点配置。</p><h3 id="Mybatis是否可以映射Enum枚举类？"><a href="#Mybatis是否可以映射Enum枚举类？" class="headerlink" title="Mybatis是否可以映射Enum枚举类？"></a>Mybatis是否可以映射Enum枚举类？</h3><p>Mybatis可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。</p><p>TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至javaType的转换，体现为setParameter()和getResult()两个方法，分别代表设置sql问号占位符参数和获取列查询结果。</p><h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><h3 id="Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？"><a href="#Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？" class="headerlink" title="Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？"></a>Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？</h3><p>Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能，Mybatis提供了9种动态sql标签==trim|where|set|foreach|if|choose|when|otherwise|bind。==</p><p>==其执行原理为，使用OGNL==从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。</p><h2 id="插件模块"><a href="#插件模块" class="headerlink" title="插件模块"></a>插件模块</h2><h3 id="Mybatis是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis是如何进行分页的？分页插件的原理是什么？"></a>Mybatis是如何进行分页的？分页插件的原理是什么？</h3><p>Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p><p>分页插件的基本原理是<strong>使用Mybatis提供的插件接口</strong>，实现自定义插件，在插件的拦截方法内==拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。==</p><div class="note note-success">            <p>举例：select * from student，拦截sql后重写为：select t.* from (select * from student) t limit 0, 10</p>          </div><h3 id="简述Mybatis的插件运行原理，以及如何编写一个插件。"><a href="#简述Mybatis的插件运行原理，以及如何编写一个插件。" class="headerlink" title="简述Mybatis的插件运行原理，以及如何编写一个插件。"></a>简述Mybatis的插件运行原理，以及如何编写一个插件。</h3><p>Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</p><p>实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="Mybatis的一级、二级缓存"><a href="#Mybatis的一级、二级缓存" class="headerlink" title="Mybatis的一级、二级缓存"></a>Mybatis的一级、二级缓存</h3><p>1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。</p><p>2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache/> ；</p><p>3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>middle-component</category>
      
      <category>mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>haproxy</title>
    <link href="/2021/01/15/haproxy/"/>
    <url>/2021/01/15/haproxy/</url>
    
    <content type="html"><![CDATA[<h2 id="HAProxy"><a href="#HAProxy" class="headerlink" title="HAProxy"></a>HAProxy</h2><h2 id="HAProxy介绍"><a href="#HAProxy介绍" class="headerlink" title="HAProxy介绍"></a>HAProxy介绍</h2><p>HAProxy: 是法国人Willy Tarreau开发的一个开源软件，是一款应对客户端10000以上的同时连接的高性能的TCP和 HTTP负载均衡器。其功能是用来提供基于cookie的持久性， 基于内容的交换，过载保护的高级流量管制，自动故障切换 ，以正则表达式为基础的标题控制运行时间，基于Web的报表，高级日志记录以帮助排除故‹@障的应用或网络及其他功能。</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="代理的作用"><a href="#代理的作用" class="headerlink" title="代理的作用"></a>代理的作用</h3><ol><li>正向代理，反向代理</li><li>代理服务器，可以提供缓存功能加速客户端访问，同时可以对缓存数据进行有效性检查</li><li>内容路由：根据流量以及内容类型将请求转发至特定的服务器</li><li>转码器：支持压缩功能，将数据以压缩形式发送给客户端</li></ol><h3 id="缓存的作用"><a href="#缓存的作用" class="headerlink" title="缓存的作用"></a>缓存的作用</h3><ol><li>减少访冗余内容传输</li><li>节省带宽，缓解网络瓶颈</li><li>降低了对原始服务器的请求压力</li><li>降低了传输延迟</li></ol><h3 id="负载均衡集群："><a href="#负载均衡集群：" class="headerlink" title="负载均衡集群："></a>负载均衡集群：</h3><p>四层：<br>lvs, nginx(stream)，haproxy(mode tcp)<br>七层：<br>http: nginx(http, ngx_http_upstream_module), haproxy(mode http), httpd, ats, perlbal, pound…</p><h3 id="HAProxy功能"><a href="#HAProxy功能" class="headerlink" title="HAProxy功能"></a>HAProxy功能</h3><p>HAProxy是TCP / HTTP反向代理服务器，尤其适合于高可用性环境<br>可以针对HTTP请求添加cookie，进行路由后端服务器<br>可平衡负载至后端服务器，并支持持久连接<br>支持基于cookie进行调度<br>支持所有主服务器故障切换至备用服务器<br>支持专用端口实现监控服务<br>支持不影响现有连接情况下停止接受新连接请求<br>可以在双向添加，修改或删除HTTP报文首部<br>支持基于pattern实现连接请求的访问控制<br>通过特定的URI为授权用户提供详细的状态信息<br>版本：1.4 1.5 1.6 1.7 1.8<br><img src="https://i.loli.net/2021/01/29/xjDWm63snTL48fG.png" alt="img"></p><p>支持http反向代理<br>支持动态程序的反向代理<br>支持基于数据库的反向代理</p><h2 id="HAproxy组成"><a href="#HAproxy组成" class="headerlink" title="HAproxy组成"></a>HAproxy组成</h2><p>包名：haproxy</p><h3 id="程序环境"><a href="#程序环境" class="headerlink" title="程序环境"></a>程序环境</h3><p>主程序：/usr/sbin/haproxy<br>配置文件：/etc/haproxy/haproxy.cfg<br>Unit file：/usr/lib/systemd/system/haproxy.service</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>haproxy.cfg主要有两部分组成：global，和proxies配置段</p><h4 id="global：全局配置段"><a href="#global：全局配置段" class="headerlink" title="global：全局配置段"></a>global：全局配置段</h4><p>进程及安全配置相关的参数<br>性能调整相关参数<br>Debug参数</p><h4 id="proxies：代理配置段"><a href="#proxies：代理配置段" class="headerlink" title="proxies：代理配置段"></a>proxies：代理配置段</h4><p>defaults：为frontend, backend, listen提供默认配置<br>fronted：前端，相当于nginx, server {}<br>backend：后端，相当于nginx, upstream {}<br>listen：同时拥有前端和后端,适用于一对一环境</p><h3 id="简单前端调度实现"><a href="#简单前端调度实现" class="headerlink" title="简单前端调度实现"></a>简单前端调度实现</h3><p>利用四台虚拟机实现简单的前端轮询调度。<br>一台客户端，一台haproxy调度器，两台RS</p><ol><li><p>首先在后端部署两台http服务</p></li><li><p>编辑haproxy配置文件/etc/haproxy/haproxy.cfg<br>默认设置不做修改</p><div class="hljs code-wrapper"><pre><code class="hljs bash">[root@CentOS6 ~]<span class="hljs-comment"># vim /etc/haproxy/haproxy.cfg </span>frontend  main *:80     <span class="hljs-comment">#设置监听ip：端口</span>default_backend         websrvs     <span class="hljs-comment">#调用后端RS组名</span>backend websrvsbalance     roundrobin      <span class="hljs-comment">#轮询算法</span>server      web1 192.168.45.11:80 checkserver      web2 192.168.45.12:80 check</code></pre></div></li></ol><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="global配置参数："><a href="#global配置参数：" class="headerlink" title="global配置参数："></a>global配置参数：</h3><div class="hljs code-wrapper"><pre><code class="hljs bash">global      <span class="hljs-comment"># 全局参数的设置</span><span class="hljs-built_in">log</span>         127.0.0.1   local2                      <span class="hljs-comment"># log语法：log &lt;address_1&gt;[max_level_1] </span><span class="hljs-comment"># 全局的日志配置，使用log关键字，指定使用127.0.0.1上的syslog服务中的local0日志设备，记录日志等级为info的日志</span>chroot      /var/lib/haproxy        <span class="hljs-comment">#改变当前工作目录</span>pidfile     /var/run/haproxy.pid    <span class="hljs-comment">#当前进程id文件</span>maxconn     4000                    <span class="hljs-comment">#最大连接数</span>user        haproxy                 <span class="hljs-comment">#所属用户</span>group       haproxy                 <span class="hljs-comment">#所属组</span>daemon                              <span class="hljs-comment">#以守护进程方式运行haproxy</span>stats socket /var/lib/haproxy/stats <span class="hljs-comment">#基于本地的文件传输</span></code></pre></div><p>实现日志记录：<br>haproxy配置文件中默认定义了log 127.0.0.1 local2 说明日志将被记录在本机的local2设施中。<br>编辑rsyslog配置文件：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">[root@CentOS6 ~]<span class="hljs-comment">#vim /etc/rsyslog.conf</span><span class="hljs-comment"># Provides UDP syslog reception</span><span class="hljs-variable">$ModLoad</span> imudp      <span class="hljs-comment">#取消注释</span><span class="hljs-variable">$UDPServerRun</span> 514   <span class="hljs-comment">#取消注释</span>local2.*            /var/<span class="hljs-built_in">log</span>/haproxy.log<span class="hljs-comment">#指定设备local2日志存放位置</span></code></pre></div><p>haproxy的日志信息可以设置存放在专门的日志服务器中</p><h3 id="proxies配置参数："><a href="#proxies配置参数：" class="headerlink" title="proxies配置参数："></a>proxies配置参数：</h3><p>代理配置段：</p><ul><li>defaults <name></li><li>frontend <name></li><li>backend <name></li><li>listen <name></li></ul><p>Frontend段：指定接收客户端连接侦听套接字设置<br>Backend段：指定将连接请求转发至后端服务器的相关设置<br>Listen段：指定完整的前后端设置，只对 TCP 有效<br>proxy 名称：使用字母 数字 - _ . : 并区分字符大小写</p><div class="hljs code-wrapper"><pre><code class="hljs bash">mode        http             <span class="hljs-comment">#默认的模式mode &#123; tcp|http|health &#125;，tcp是4层，http是7层，health只会返回OK</span><span class="hljs-built_in">log</span>         global        <span class="hljs-comment">#应用全局的日志配置</span>option      httplog       <span class="hljs-comment"># 启用日志记录HTTP请求，默认haproxy日志记录是不记录HTTP请求日志</span>option      dontlognull   <span class="hljs-comment"># 启用该项，日志中将不会记录空连接。所谓空连接就是在上游的负载均衡器或者监控系统为了探测该服务是否存活可用时，需要定期的连接或者获取某一固定的组件或页面，或者探测扫描端口是否在监听或开放等动作被称为空连接；官方文档中标注，如果该服务上游没有其他的负载均衡器的话，建议不要使用该参数，因为互联网上的恶意扫描或其他动作就不会被记录下来</span>option      http-server-close  <span class="hljs-comment">#每次请求完毕后主动关闭http通道</span>option      forwardfor       except 127.0.0.0/8   <span class="hljs-comment">#如果服务器上的应用程序想记录发起请求的客户端的IP地址，需要在HAProxy上配置此选项， 这样 HAProxy会把客户端的IP信息发送给服务器，在HTTP请求中添加&quot;X-Forwarded-For&quot;字段。启用X-Forwarded-For，在requests头部插入客户端IP发送给后端的server，使后端server获取到客户端的真实IP。 </span>option        redispatch                      <span class="hljs-comment">#当使用了cookie时，haproxy将会将其请求的后端服务器的serverID插入到cookie中，以保证会话的SESSION持久性；而此时，如果后端的服务器宕掉了， 但是客户端的cookie是不会刷新的，如果设置此参数，将会将客户的请求强制定向到另外一个后端server上，以保证服务的正常。</span>retries       3                             <span class="hljs-comment"># 定义连接后端服务器的失败重连次数，连接失败次数超过此值后将会将对应后端服务器标记为不可用</span>timeout http-request    10s     <span class="hljs-comment">#http请求超时时间</span>timeout queue           1m      <span class="hljs-comment">#一个请求在队列里的超时时间</span>timeout connect         10s     <span class="hljs-comment">#连接超时</span>timeout client          1m      <span class="hljs-comment">#客户端超时</span>timeout server          1m      <span class="hljs-comment">#服务器端超时</span>timeout http-keep-alive 10s     <span class="hljs-comment">#设置http-keep-alive的超时时间</span>timeout check           10s     <span class="hljs-comment">#检测超时</span>maxconn                 3000    <span class="hljs-comment">#每个进程可用的最大连接数</span>frontend  main *:80             <span class="hljs-comment">#监听地址为80</span>acl url_static       path_beg       -i /static /images /javascript /stylesheetsacl url_static       path_end       -i .jpg .gif .png .css .jsuse_backend static          <span class="hljs-keyword">if</span> url_staticdefault_backend             my_webserver     <span class="hljs-comment">#定义一个名为my_app前端部分。此处将对应的请求转发给后端</span>backend static                                       <span class="hljs-comment">#使用了静态动态分离（如果url_path匹配 .jpg .gif .png .css .js静态文件则访问此后端）</span>balance             roundrobin                       <span class="hljs-comment">#负载均衡算法（#banlance roundrobin 轮询，balance source 保存session值，支持static-rr，leastconn，first，uri等参数）</span>server              static 127.0.0.1:80 check         <span class="hljs-comment">#静态文件部署在本机（也可以部署在其他机器或者squid缓存服务器）</span>backend my_webserver                                 <span class="hljs-comment">#定义一个名为my_webserver后端部分。PS：此处my_webserver只是一个自定义名字而已，但是需要与frontend里面配置项default_backend 值相一致</span>balance     roundrobin          <span class="hljs-comment">#负载均衡算法</span>server  web01 172.31.2.33:80  check inter 2000 fall 3 weight 30              <span class="hljs-comment">#定义的多个后端</span>server  web02 172.31.2.34:80  check inter 2000 fall 3 weight 30              <span class="hljs-comment">#定义的多个后端</span>server  web03 172.31.2.35:80  check inter 2000 fall 3 weight 30              <span class="hljs-comment">#定义的多个后端</span></code></pre></div><h3 id="Balance配置"><a href="#Balance配置" class="headerlink" title="Balance配置"></a>Balance配置</h3><p>balance：后端服务器组内的服务器调度算法<br>balance <algorithm> [ <arguments> ]<br>balance url_param <param> [check_post]<br>haproxy中调度算法同样分为动态调度算法和静态调度算法，与nginx调度算法中区分动静态调度算法的概念不同，nginx用能不能根据后端服务器的负载状况进行调度来区分动静态调度算法的差别，而haproxy中则根据该算法支不支持运行时即时生效来区分动静态算法。</p><p>调度算法：<br>roundrobin：基于权重轮询，动态算法，支持权重的运行时调整，支持慢启动；每个后端backend中最多支持4095个<br>server server options： weight #</p><p>static-rr：基于权重轮询，静态算法，不支持权重的运行时调整及慢启动；后端主机数量无上限</p><p>leastconn：加权最少连接，动态算法，最少连接的后端服务器优先分配接收新连接，相同连接时轮询，适用于长连接场景，例如 MySQL、LDAP等，不适合http</p><p>first：根据服务器在列表中的位置，自上而下进行调度；前面服务器的连接数达到上限，新请求才会分配给下一台服务</p><p>source：源地址hash，新连接先按权重分配，后续连接按source分配请求<br>动静态取决于hash type<br>hash-type：哈希算法<br>hash-type <method> <function> <modifier><br>method:<br>map-based：除权取余法，哈希数据结构是静态数组（不支持权重动态调整）<br>consistent：一致性哈希，哈希数据结构是一棵树 （支持权重动态调整）<br><function> : 哈希函数<br>sdbm djb2 wt6</p><p>uri：<br>对URI的左半部分或整个uri做hash计算，并除以服务器总权重取模，以后派发至某挑出的服务器,适用于后端缓存服务器<br>动静态取决于hash type</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">hash</span>-<span class="hljs-built_in">type</span>    <span class="hljs-built_in">map</span>-based    consistent</code></pre></div><p><scheme>://<user>:<password>@<host>:<port>/<path> ;<params>?<query>#<frag><br>左半部分：/<path>;<params><br>整个uri：/<path>;<params>?<query>#<frag></p><p>url_param：<br>对用户请求的uri听<params>部分中的参数的值作hash计算， 并由服务器总权重相除以后派发至某挑出的服务器；通常用于追踪用户，以确保来自同一个用户的请求始终发往同一个Backend Server<br>动静态取决于hash type</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">hash</span>-<span class="hljs-built_in">type</span>    <span class="hljs-built_in">map</span>-based    consistent</code></pre></div><p>hdr(<name>)：根据请求报文中指定的header（如use_agent,referer,hostname）将该hesder做hash计算进行调度<br>动静态取决于hash type</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">hash</span>-<span class="hljs-built_in">type</span>    <span class="hljs-built_in">map</span>-based    consistent</code></pre></div><p>hdr(Cookie)</p><p>rdp-cookie 远程桌面相关</p><p>rdp-cookie(<name>)</p><h3 id="default-backend"><a href="#default-backend" class="headerlink" title="default_backend "></a>default_backend <backend></h3><p>无use_backend 匹配时，使用默认的backend，用于 frontend中</p><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>server <name> <address>[:[port]] [param*]<br>定义后端主机的各服务器及其选项 server <name> <address>[:port] [settings …] default-server [settings …]</p><p><name>：服务器在haproxy上的内部名称；出现在日志及警告信息</p><address>：服务器地址，支持使用主机名<p>[:[port]]：端口映射；省略时，表示同bind中绑定的端口</p><p>[param*]：参数<br>check：对当前server做健康状态检测，只用于四层检测<br>注意：httpchk，“smtpchk”, “mysql-check”, “pgsql-check” and “sslhello-chk” 用于定义应用层检测方法<br>addr ：检测时使用的IP地址<br>port ：针对此端口进行检测<br>inter <delay>：连续两次检测之间的时间间隔，默认为2000ms<br>rise <count>：连续多少次检测结果为“成功”才标记服务器为可用 ；默认为2<br>fall <count>：连续多少次检测结果为“失败”才标记服务器为不可 用；默认为3<br>cookie <value>：为当前server指定cookie值，实现基于cookie的会话黏性<br>disabled：标记为不可用<br>redir <div class="hljs code-wrapper"><prefix>：将发往此server的所有GET和HEAD类的请求重定向至指 定的URL<br>weight <weight>：权重，默认为1<br>maxconn <maxconn>：当前server的最大并发连接数<br>backlog <backlog>：当server的连接数达到上限后的后援队列长度<br>backup：设定当前server为备用服务器</p><p>default-server [param*] 为backend中的各server设定默认选项</p><h3 id="bind配置"><a href="#bind配置" class="headerlink" title="bind配置"></a>bind配置</h3><p>bind：指定一个或多个前端侦听地址和端口<br>只用于frountend配置段和listen配置段<br>bind [<address>]:<port_range> [, …] [param*]<br>示例：</p><pre><code class="hljs bash">listen http_proxy     <span class="hljs-built_in">bind</span> :80,:443     <span class="hljs-built_in">bind</span> 10.0.0.1:10080,10.0.0.1:10443     <span class="hljs-built_in">bind</span> /var/run/ssl-frontend.sock user root mode 600 accept-proxy</code></pre></div><h3 id="maxconn"><a href="#maxconn" class="headerlink" title="maxconn"></a>maxconn</h3><p>maxconn <conns>：为指定的frontend定义其最大并发连接数；默认为2000</p><h3 id="mode-tcp-http-health"><a href="#mode-tcp-http-health" class="headerlink" title="mode { tcp|http|health }"></a>mode { tcp|http|health }</h3><p>定义haproxy的工作模式<br>tcp：基于layer4实现代理；可代理mysql, pgsql, ssh, ssl等协议,https时使用此模式，默认模式<br>http：仅当代理协议为http时使用,centos实际默认模式<br>health：工作为健康状态检查的响应模式，当连接请求到达时回应“OK”后即断开连接，较少使用</p><h3 id="基于cookie的会话绑定"><a href="#基于cookie的会话绑定" class="headerlink" title="基于cookie的会话绑定"></a>基于cookie的会话绑定</h3><p>cookie <name> [ rewrite | insert | prefix ] [ indirect ] [ nocache ] [ postonly ] [ preserve ] [ httponly ] [ secure ] [ domain <domain> ]* [ maxidle <idle> ] [ maxlife <life> ]<br><name>：cookie名称，用于实现持久连接<br>rewrite：重写<br>insert：插入<br>prefix：前缀<br>配置示例：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">backend websrvs  balance     roundrobin  cookie WEBSRV insert nocache indirect  server   web1 192.168.45.11:80 check cookie srv1  server   web2 192.168.45.12:80 check cookie srv2<span class="hljs-comment">#每个server有自己的唯一的cookie标识</span><span class="hljs-comment">#在backend中为用户请求调度完成后操纵其cookie</span></code></pre></div><h3 id="统计接口启用相关的参数"><a href="#统计接口启用相关的参数" class="headerlink" title="统计接口启用相关的参数"></a>统计接口启用相关的参数</h3><p>stats enable<br>启用统计页；基于默认的参数启用stats page</p><ul><li>stats uri : /haproxy?stats uri默认值</li><li>stats realm : HAProxy Statistics</li><li>stats auth : no authentication</li></ul><p>stats uri <div class="hljs code-wrapper"><prefix> 自定义stats page uri</p><p>stats auth <user>:<passwd> 认证时的账号和密码，可使用多次</p><p>stats realm <realm> 认证时的realm</p><p>stats hide-version 隐藏版本</p><p>stats refresh <delay> 设定自动刷新时间间隔</p><p>stats admin { if | unless } <cond> 启用stats page中的管理功能</p><p>配置示例：</p><pre><code class="hljs bash">listen stats     <span class="hljs-built_in">bind</span> :9099     stats <span class="hljs-built_in">enable</span>     stats realm HAPorxy\ Stats\ Page     stats auth 用户名：密码    stats admin <span class="hljs-keyword">if</span> TRUE<span class="hljs-comment">#在frountend中单独定义一个stats服务，监听9099端口</span><span class="hljs-comment">#如果认证成功就开启管理功能</span></code></pre></div><h3 id="forwardfor配置"><a href="#forwardfor配置" class="headerlink" title="forwardfor配置"></a>forwardfor配置</h3><p>option forwardfor [ except <network> ] [ header <name> ] [ if-none ]<br>在由haproxy发往后端主机的请求报文中添加“X-ForwardedFor”首部，其值为前端客户端的地址；用于向后端主发送真实的客户端IP</p><p>[ except <network> ]：请求报请来自此处指定的网络时不予添加此首部，如haproxy自身所在网络</p><p>[ header <name> ]：使用自定义的首部名称，而非“XForwarded-For”</p><p>[ if-none ] 如果没有首部才添加首部，如果有使用默认值</p><p>为指定的MIME类型启用压缩传输功能<br>compression algo <algorithm> …：启用http协议的压缩机制，指明压缩算法gzip, deflate<br>compression type <mime type> …：指明压缩的MIMI类型</p><h3 id="错误页配置"><a href="#错误页配置" class="headerlink" title="错误页配置"></a>错误页配置</h3><p>errorfile <code> <file> 自定义错误页<br><code>：HTTP status code.<br>支持200, 400, 403, 408, 500, 502, 503, 504.<br><file>：错误页文件路径</p><p>示例：<br>使用haproxy主机本地的文件进行响应</p><div class="hljs code-wrapper"><pre><code class="hljs bash">errorfile 400 /etc/haproxy/errorfiles/400badreq.http errorfile 408 /dev/null     <span class="hljs-comment"># workaround Chrome preconnect bug </span>errorfile 403 /etc/haproxy/errorfiles/403forbid.http errorfile 503 /etc/haproxy/errorfiles/503sorry.http</code></pre></div><p>使用url进行响应，响应状态码为302，不适用于GET以外的其他请求方法：<br>errorloc <code> <url> 相当于errorloc302 <code> <url>，利用302重定向至指URL</p><div class="hljs code-wrapper"><pre><code class="hljs awk">errorloc <span class="hljs-number">503</span> http:<span class="hljs-regexp">//</span>www.a.com<span class="hljs-regexp">/error_pages/</span><span class="hljs-number">503</span>.html</code></pre></div><h3 id="修改报文首部"><a href="#修改报文首部" class="headerlink" title="修改报文首部"></a>修改报文首部</h3><p>reqadd <string> [{if | unless} <cond>]<br>在请求报文尾部添加指定首部</p><p>rspadd <string> [{if | unless} <cond>]<br>在响应报文尾部添加指定首部<br>示例：</p><div class="hljs code-wrapper"><pre><code class="hljs livescript">rspadd X-Via:<span class="hljs-string">\</span> HAPorxy  <span class="hljs-comment">#字符串中的空格要转义</span></code></pre></div><p>reqdel <search> [{if | unless} <cond>]<br>reqidel <search> [{if | unless} <cond>] (ignore case) 不分大小写<br>从请求报文中删除匹配正则表达式的首部</p><p>rspdel <search> [{if | unless} <cond>]<br>rspidel <search> [{if | unless} <cond>] (ignore case) 不分大小写从响应报文中删除匹配正则表达式的首部 示例： rspidel Server.*</p><h3 id="连接超时"><a href="#连接超时" class="headerlink" title="连接超时"></a>连接超时</h3><p>timeout client <timeout> 客户端最长空闲连接超时时长 默认单位是毫秒<br>timeout server <timeout> 后端服务器最长空闲连接超时时长<br>timeout http-keep-alive <timeout> 持久连接的持久时长<br>timeout http-request <timeout> 一次完整的HTTP请求的最大等待时长<br>timeout connect <timeout> 成功连接后端服务器的最大等待时长<br>timeout client-fin <timeout> 客户端半连接的空闲时长<br>timeout server-fin <timeout> 后端服务器半连接的空闲时长</p><h2 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h2><p>acl：haproxy的ACL用于实现基于请求报文的首部、响应报文的内容或其他的环境状态信息来做出转发决策，这大大增加了其配置弹性。其配置法则一般分为两部，首先定义ACL，既定义一个测试条件，而后在条件得到满足时执行某特定动作，如阻止访问或者转发至某特定的后端，<br>定义ACL的语法格式如下：<br>acl <aclname> <criterion> [flags] [operator] [<value>] …</p><p><aclname>：ACL名称，可使用字母 数字 : . - _ 区分字符大小写</p><p><criterion>： 指明检查条件<br>各种条件 :<br>dst 目标IP<br>dst_port 目标PORT<br>src 源IP<br>src_port 源PORT<br>示例：</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">acl</span> invalid_src src <span class="hljs-number">172.16.100.200</span></code></pre></div><p><value>的类型：</p><ul><li>boolean</li><li>integer or integer range</li><li>IP address / network</li><li>string (exact, substring, suffix, prefix, subdir, domain)</li><li>regular expression</li><li>hex block</li></ul><flags>-i 不区分大小写-m 使用指定的pattern匹配方法-n 不做DNS解析-u 强制每个ACL必须唯一ID，否则多个同名ACL或关系-- 强制flag结束. 当字符串和某个flag相似时使用<p>[operator]<br>匹配整数值：eq、ge、gt、le、lt<br>匹配字符串：</p><ul><li>exact match (-m str) :字符串必须完全匹配模式</li><li>substring match (-m sub) :在提取的字符串中查找模式， 如果其中任何一个被发现，ACL将匹配</li><li>prefix match (-m beg) :在提取的字符串首部中查找模式 ，如果其中任何一个被发现，ACL将匹配</li><li>suffix match (-m end) :将模式与提取字符串的尾部进行比较，如果其中任何一个匹配，则ACL进行匹配</li><li>subdir match (-m dir) :查看提取出来的用斜线分隔（ “/”）的字符串，如果其中任何一个匹配，则ACL进行匹配</li><li>domain match (-m dom) :查找提取的用点（“.”）分隔 字符串，如果其中任何一个匹配，则ACL进行匹配</li></ul><h3 id="acl作为条件时的逻辑关系"><a href="#acl作为条件时的逻辑关系" class="headerlink" title="acl作为条件时的逻辑关系:"></a>acl作为条件时的逻辑关系:</h3><ul><li>与：隐式（默认）使用</li><li>或：使用“or” 或 “||”表示</li><li>否定：使用“!“ 表示</li></ul><p>示例：</p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> invalid_src invalid_port 与关系 <span class="hljs-keyword">if</span> invalid_src || invalid_port 或 <span class="hljs-keyword">if</span> ! invalid_src 非</code></pre></div><h3 id="base-string"><a href="#base-string" class="headerlink" title="base : string"></a>base : string</h3><p>返回第一个主机头和请求的路径部分的连接，该请求从第一个斜杠开始，并在问号之前结束,对虚拟主机有用<br><scheme>://<user>:<password>@<host>:<port>/<path>;&lt; params&gt;?<query>#<frag><br>base : exact string match<br>base_beg : prefix match<br>base_dir : subdir match<br>base_dom : domain match<br>base_end : suffix match<br>base_len : length match<br>base_reg : regex match<br>base_sub : substring match</p><h3 id="path-string"><a href="#path-string" class="headerlink" title="path : string"></a>path : string</h3><p>提取请求的URL路径，该路径从第一个斜杠开始，并在问号之 前结束（无主机部分）<br><scheme>://<user>:<password>@<host>:<port>/<path>;&lt; params&gt;?<query>#<frag><br>path : exact string match<br>path_beg : prefix match 匹配路径开头<br>path_dir : subdir match<br>path_dom : domain match<br>path_end : suffix match 匹配路径结尾<br>path_len : length match<br>path_reg : regex match 正则表达式匹配一类PATH<br>path_sub : substring match</p><h3 id="url-string"><a href="#url-string" class="headerlink" title="url : string"></a>url : string</h3><p>提取请求中的URL。一个典型的应用是具有预取能力的缓存， 以及需要从数据库聚合多个信息并将它们保存在缓存中的网页门户入口<br>url : exact string match<br>url_beg : prefix match URL开头，匹配协议<br>url_dir : subdir match<br>url_dom : domain match<br>url_end : suffix match URL结尾<br>url_len : length match<br>url_reg : regex match 正则表达式匹配一类url<br>url_sub : substring match</p><h3 id="req-hdr"><a href="#req-hdr" class="headerlink" title="req.hdr(["></a>req.hdr([</h3><p>提取在一个HTTP请求报文的首部<br>hdr([<name>[,<occ>]]) : exact string match<br>hdr_beg([<name>[,<occ>]]) : prefix match 首部开头<br>hdr_dir([<name>[,<occ>]]) : subdir match<br>hdr_dom([<name>[,<occ>]]) : domain match<br>hdr_end([<name>[,<occ>]]) : suffix match 首部结尾<br>hdr_len([<name>[,<occ>]]) : length match<br>hdr_reg([<name>[,<occ>]]) : regex match<br>hdr_sub([<name>[,<occ>]]) : substring match<br>示例：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">acl bad_curl hdr_sub(User-Agent) -i curl block <span class="hljs-keyword">if</span> bad_curl</code></pre></div><h3 id="status-integer"><a href="#status-integer" class="headerlink" title="status : integer"></a>status : integer</h3><p>返回在响应报文中的状态码</p><h3 id="预定义ACL"><a href="#预定义ACL" class="headerlink" title="预定义ACL"></a>预定义ACL</h3><p>ACL名称 等价于 说明<br>TRUE always_true 总是匹配<br>FALSE always_false 从不匹配<br>HTTP req_proto_http 匹配HTTP协议<br>HTTP_1.0 req_ver 1.0 匹配HTTP协议1.0<br>HTTP_1.1 req_ver 1.1 匹配HTTP协议1.1<br>HTTP_CONTENT hdr_val(content-length) gt 0 匹配已存在内容长度<br>HTTP_URL_ABS url_reg ^[^/:]<em>:// 匹配URL绝对路径<br>HTTP_URL_SLASHurl_beg / 匹配URL相对路径<br>HTTP_URL_STAR url * 匹配 URL 等于 “</em>“<br>LOCALHOST src 127.0.0.1/8 匹配从localhost来的连接<br>METH_CONNECT method CONNECT 匹配HTTP CONNECT方法<br>METH_GETmethod GET HEAD #match HTTP GET or HEAD method<br>METH_HEAD method HEAD #match HTTP HEAD method<br>METH_OPTIONS method OPTIONS #match HTTP OPTIONS method<br>METH_POST method POST #match HTTP POST method<br>METH_TRACE method TRACE #match HTTP TRACE method<br>RDP_COOKIE req_rdp_cookie_cnt gt 0 #match presence of an RDP cookie<br>REQ_CONTENT req_len gt 0 #match data in the request buffer<br>WAIT_ENDwait_end #wait for end of content analysis</p><h3 id="acl配置"><a href="#acl配置" class="headerlink" title="acl配置"></a>acl配置</h3><h4 id="基于IP的访问控制"><a href="#基于IP的访问控制" class="headerlink" title="基于IP的访问控制"></a>基于IP的访问控制</h4><p>use_backend <backend> [{if | unless} <condition>]<br>当if/unless一个基于ACL的条件匹配时切换指定backend</p><div class="hljs code-wrapper"><pre><code class="hljs bash">acl invalid_src src 172.16.200.2 block <span class="hljs-keyword">if</span> invalid_src errorfile 403 /etc/fstab</code></pre></div><h4 id="七层请求的访问控制"><a href="#七层请求的访问控制" class="headerlink" title="七层请求的访问控制"></a>七层请求的访问控制</h4><p>http-request { allow | deny |add-header <name> <fmt> |set-header <name> <fmt> } [ { if | unless } <condition> ]</p><h4 id="四层请求访问控制"><a href="#四层请求访问控制" class="headerlink" title="四层请求访问控制"></a>四层请求访问控制</h4><p>tcp-request connection {accept|reject} [{if | unless} <condition>]<br>示例：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">listen ssh <span class="hljs-built_in">bind</span> :22022 balance leastconn acl invalid_src src 172.16.200.2 tcp-request connection reject <span class="hljs-keyword">if</span> invalid_src mode tcp server sshsrv1 172.16.100.6:22 check server sshsrv2 172.16.100.7:22 check backup</code></pre></div><h4 id="基于ACL的动静分离示例"><a href="#基于ACL的动静分离示例" class="headerlink" title="基于ACL的动静分离示例"></a>基于ACL的动静分离示例</h4><div class="hljs code-wrapper"><pre><code class="hljs bash">frontend  web *:80     acl url_static       path_beg       -i /static /images /javascript /stylesheets     acl url_static       path_end       -i .jpg .gif .png .css .js .html .txt .htm     use_backend staticsrvs       <span class="hljs-keyword">if</span> url_static     default_backend             appsrvs backend staticsrvs     balance     roundrobin     server      stcsrv1 172.16.100.6:80 check backend appsrvs     balance     roundrobin     server  app1 172.16.100.7:80 check     server  app1 172.16.100.7:8080 check listen stats     <span class="hljs-built_in">bind</span> :9091     stats <span class="hljs-built_in">enable</span>     stats auth admin:admin     stats admin <span class="hljs-keyword">if</span> TRUE<span class="hljs-comment">#一个ACL定义了两个条件，如果用户的请求满足PATH中带有/static /images /javascript /stylesheets 这些字符的，或者path是以.jpg .gif .png .css .js .html .txt .htm 这些字符结尾的就匹配ACL定义</span><span class="hljs-comment">#满足ACL定义的请求为静态请求，被调度到后端的staticsrvs机组上</span><span class="hljs-comment">#不满组以上两个条件的请求默认调度都后端包含两台服务器轮询的appsrvs机组上</span></code></pre></div><h3 id="支持https协议"><a href="#支持https协议" class="headerlink" title="支持https协议"></a>支持https协议</h3><p>配置HAProxy支持https协议：<br>1 支持ssl会话；<br>bind *:443 ssl crt /PATH/TO/SOME_PEM_FILE<br>crt 后证书文件为PEM格式，且同时包含证书和所有私钥<br>cat demo.crt demo.key &gt; demo.pem</p><p>2 把80端口的请求重向定443<br>bind *:80<br>redirect scheme https if !{ ssl_fc }</p><p>3 向后端传递用户请求的协议和端口（frontend或backend）<br>http_request set-header X-Forwarded-Port %[dst_port]<br>http_request add-header X-Forwared-Proto https if { ssl_fc }</p>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>haproxy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>haproxy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rabbitmq-windows</title>
    <link href="/2021/01/11/rabbitmq-windows-install/"/>
    <url>/2021/01/11/rabbitmq-windows-install/</url>
    
    <content type="html"><![CDATA[<p>rabbitMQ是一个在AMQP协议标准基础上完整的，可服用的企业消息系统。它遵循Mozilla Public License开源协议，采用 Erlang 实现的工业级的消息队列(MQ)服务器，Rabbit MQ 是建立在Erlang OTP平台上。</p><h2 id="1-安装Erlang"><a href="#1-安装Erlang" class="headerlink" title="1.安装Erlang"></a>1.安装Erlang</h2><p>所以在安装rabbitMQ之前，需要先安装Erlang 。</p><p>小编使用的是<a href="https://pan.baidu.com/s/1c2826rA">otp_win64_18.1</a> ，需要其他版本或者32位系统的，可以去<a href="http://www.erlang.org/downloads">官网</a>下载。</p><p>全部点击“下一步”就行。</p><p>有的选择其他的安装方式，可能需要添加一下系统环境变量（正常安装的也要检查下）：</p><p><img src="https://i.loli.net/2021/01/29/rPNn6SghdmfvHtu.png" alt="img"></p><p>有最好，没有的话就手动添加嘛。</p><h2 id="2-安装RabbitMQ"><a href="#2-安装RabbitMQ" class="headerlink" title="2.安装RabbitMQ"></a>2.安装RabbitMQ</h2><p>下载运行<a href="https://pan.baidu.com/s/1cqpG0u">rabbitmq-server-3.6.5</a> ，需要其他版本或者32位系统的，可以去<a href="http://www.rabbitmq.com/download.html">官网</a>下载。</p><p>依旧可以不改变默认进行安装。</p><p>需要注意：默认安装的RabbitMQ 监听端口是5672</p><h2 id="3-配置"><a href="#3-配置" class="headerlink" title="3.配置"></a>3.配置</h2><p>注册进服务 管理员身份执行 rabbitmq-service install</p><p>使用RabbitMQ 管理插件，可以更好的可视化方式查看Rabbit MQ 服务器实例的状态。</p><p>打开命令窗口：</p><p>输入命令：</p><div class="hljs code-wrapper"><pre><code class="hljs taggerscript">&quot;C:<span class="hljs-symbol">\P</span>rogram Files<span class="hljs-symbol">\R</span>abbitMQ Server<span class="hljs-symbol">\r</span>abbitmq_server-3.6.5<span class="hljs-symbol">\s</span>bin<span class="hljs-symbol">\r</span>abbitmq-plugins.bat&quot; enable rabbitmq_management</code></pre></div><p><img src="https://i.loli.net/2021/01/29/pKRy4mQU9Poz6lC.png" alt="img"></p><p>这样，就安装好插件了，是不是能使用了呢？别急，需要重启服务才行，使用命令：</p><div class="hljs code-wrapper"><pre><code class="hljs dos"><span class="hljs-built_in">net</span> stop RabbitMQ &amp;&amp; <span class="hljs-built_in">net</span> <span class="hljs-built_in">start</span> RabbitMQ</code></pre></div><p>这时候的，也许会出现这种结果：</p><p><img src="https://i.loli.net/2021/01/29/S8awjq2sGLDTx34.png" alt="img"></p><p>“发生错误：发生系统错误 <em>5。 *拒绝访问。”</em>*</p><p>这是什么鬼？查了下，原来，5代表的是：不是系统管理员权限。</p><p>问题解决方案：使用管理员打开<em>cmd再执行此命令：</em></p><p><em><img src="https://i.loli.net/2021/01/29/DLEyYBsRPrktW4f.png" alt="img"></em></p><p>这样就结束了吗？当然没有。</p><h3 id="创建用户，密码，绑定角色"><a href="#创建用户，密码，绑定角色" class="headerlink" title="创建用户，密码，绑定角色"></a>创建用户，密码，绑定角色</h3><p>使用<em>rabbitmqctl控制台命令（位于*C:\Program Files\RabbitMQ Server\rabbitmq_server-3.6.5\sbin&gt;）来创建用户，密码，绑定权限等。</em>*</p><p>注意：安装路径不同的请看仔细啊。</p><p>rabbitmq的用户管理包括增加用户，删除用户，查看用户列表，修改用户密码。</p><p>查看已有用户及用户的角色：</p><div class="hljs code-wrapper"><pre><code class="hljs mipsasm">rabbitmqctl.<span class="hljs-keyword">bat </span>list_users</code></pre></div><p><img src="https://i.loli.net/2021/04/18/lmQt6sKHPRq4wZc.png" alt="img"></p><p>新增一个用户：</p><div class="hljs code-wrapper"><pre><code class="hljs mipsasm">rabbitmqctl.<span class="hljs-keyword">bat </span><span class="hljs-keyword">add_user </span>username password</code></pre></div><p><img src="https://i.loli.net/2021/01/29/OoEbayLInpQUScR.png" alt="img"></p><p>此时来看下我们当前用户哈：</p><p><img src="https://i.loli.net/2021/01/29/gUsbYMQkIi9zleX.png" alt="img"></p><p>eric 后面没有“[administrator]”</p><p>这个administrator是干嘛用的呢？这就涉及到用户角色问题了：</p><p>按照我个人理解，rabbitmq用户角色可分为五类：超级管理员, 监控者, 策略制定者, 普通管理者以及其他。</p><p>(1) 超级管理员(administrator)</p><p>可登陆管理控制台(启用management plugin的情况下)，可查看所有的信息，并且可以对用户，策略(policy)进行操作。</p><p>(2) 监控者(monitoring)</p><p>可登陆管理控制台(启用management plugin的情况下)，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等) </p><p>(3) 策略制定者(policymaker)</p><p>可登陆管理控制台(启用management plugin的情况下), 同时可以对policy进行管理。</p><p>(4) 普通管理者(management)</p><p>仅可登陆管理控制台(启用management plugin的情况下)，无法看到节点信息，也无法对策略进行管理。</p><p>(5) 其他的</p><p>无法登陆管理控制台，通常就是普通的生产者和消费者。</p><p>好啦，我们也给 eric 变成 “超级管理员” 角色：</p><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">rabbitmqctl.bat <span class="hljs-keyword">set</span>_user_tags username administrator</code></pre></div><p><img src="https://i.loli.net/2021/01/29/2xHaJfvYmrkg3pt.png" alt="img"></p><p>再看下结果哈：</p><p><img src="https://i.loli.net/2021/01/29/ovjVFKL2hAsRXEJ.png" alt="img"></p><p>当然，除了上面的administrator 还有 monitoring、policymaker、management、自定义名称 ，对应上面介绍到的不同的角色。</p><p>像我们人一样，我们角色除了是公司的员工，还是父母的孩子、子女的爸妈等，用户也可以同时具有多个角色,设置方式:</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">rabbitmqctl</span>.bat  set_user_tags  username tag<span class="hljs-number">1</span> tag<span class="hljs-number">2</span> ...</code></pre></div><p><img src="https://i.loli.net/2021/01/29/YMh9Kr4EnumZbQs.png" alt="img"></p><p>恩，现在总觉得guest 这个不安全（它的默认密码是guest）,想更改密码，好办：</p><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">rabbitmqctl change_password userName newPassword</span></code></pre></div><p><img src="https://i.loli.net/2021/01/29/rdyDgh3YJ26wfaO.png" alt="img"></p><p>有的人也许会说，我就是看guest不爽，老子新增了administrator用户了，就是想干掉它，可以：</p><div class="hljs code-wrapper"><pre><code class="hljs mipsasm">rabbitmqctl.<span class="hljs-keyword">bat </span>delete_user username</code></pre></div><p><img src="https://i.loli.net/2021/01/29/1UJQxXdPzy9rTkR.png" alt="img"></p><p> 这时，可能有人就要问了：命令框是只有一个用户了，你怎么操作啊？怎么查看执行情况啊/</p><p> 当然有路子啦：</p><p>使用浏览器打开<a href="http://localhost:15672/"> http://localhost:15672</a> 访问Rabbit Mq的管理控制台，使用刚才创建的账号登陆系统：</p><p> <img src="https://i.loli.net/2021/01/29/enjUqDQdfGZIMvz.png" alt="img"></p><p><img src="https://i.loli.net/2021/01/29/TMWnJjqCZdKfe3O.png" alt="img"></p><p>其实，除了可查看所有的信息 ，上面的命令 增删改查、权限设置，都可以在这个页面完成，还可以依据业务需求设置策略(policy)，具体的就不在这里啰嗦了，大家可以看看网上的帖子。</p><h3 id="权限设置"><a href="#权限设置" class="headerlink" title="权限设置"></a>权限设置</h3><p>用户有了角色，那也需要权限设置啊，别急，慢慢来：</p><p>按照官方文档，用户权限指的是用户对exchange，queue的操作权限，包括配置权限，读写权限。</p><p>我们配置权限会影响到exchange、queue的声明和删除。</p><p>读写权限影响到从queue里取消息、向exchange发送消息以及queue和exchange的绑定(binding)操作。</p><p>例如： 将queue绑定到某exchange上，需要具有queue的可写权限，以及exchange的可读权限；向exchange发送消息需要具有exchange的可写权限；从queue里取数据需要具有queue的可读权限</p><p>权限相关命令为：</p><p>(1) 设置用户权限</p><p>rabbitmqctl  set_permissions  -p  VHostPath  User  ConfP  WriteP  ReadP</p><p>(2) 查看(指定hostpath)所有用户的权限信息</p><p>rabbitmqctl  list_permissions  [-p  VHostPath]</p><p>(3) 查看指定用户的权限信息</p><p>rabbitmqctl  list_user_permissions  User</p><p>(4)  清除用户的权限信息</p><p>rabbitmqctl  clear_permissions  [-p VHostPath]  User</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>middle-component</category>
      
      <category>rabbitmq</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rabbitmq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rabbitmq-linux</title>
    <link href="/2021/01/11/rabbitmq-linux/"/>
    <url>/2021/01/11/rabbitmq-linux/</url>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="1-MQ引言"><a href="#1-MQ引言" class="headerlink" title="1 MQ引言"></a>1 MQ引言</h2><h3 id="1-1-什么是MQ"><a href="#1-1-什么是MQ" class="headerlink" title="1.1 什么是MQ"></a>1.1 什么是MQ</h3><div class="hljs code-wrapper"><pre><code class="hljs bas">MQ(Message Quene) :  翻译为消息队列,通过典型的生产者和消费者模型,生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入,轻松的实现系统间解耦。别名为 消息中间件通过利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。</code></pre></div><h3 id="1-2-MQ有哪些"><a href="#1-2-MQ有哪些" class="headerlink" title="1.2 MQ有哪些"></a>1.2 MQ有哪些</h3><div class="hljs code-wrapper"><pre><code class="hljs bash">当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发`RocketMQ`等。</code></pre></div><h3 id="1-3-不同MQ特点"><a href="#1-3-不同MQ特点" class="headerlink" title="1.3 不同MQ特点"></a>1.3 不同MQ特点</h3><div class="hljs code-wrapper"><pre><code class="hljs bash">1.ActiveMQActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。它是一个完全支持JMS规范的的消息中间件。丰富的API,多种集群架构模式让ActiveMQ在业界成为老牌的消息中间件,在中小型企业颇受欢迎!2.KafkaKafka是LinkedIn开源的分布式发布-订阅消息系统，目前归属于Apache顶级项目。Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输。0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，适合产生大量数据的互联网服务的数据收集业务。3.RocketMQRocketMQ是阿里开源的消息中间件，它是纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ思路起源于Kafka，但并不是Kafka的一个Copy，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog分发等场景。4.RabbitMQRabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。AMQP协议更多用在企业系统内对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。</code></pre></div><h2 id="2-RabbitMQ-的引言"><a href="#2-RabbitMQ-的引言" class="headerlink" title="2 RabbitMQ 的引言"></a>2 RabbitMQ 的引言</h2><h3 id="2-1-RabbitMQ"><a href="#2-1-RabbitMQ" class="headerlink" title="2.1 RabbitMQ"></a>2.1 RabbitMQ</h3><div class="hljs code-wrapper"><pre><code class="hljs bash">基于AMQP协议，erlang语言开发，是部署最广泛的开源消息中间件,是最受欢迎的开源消息中间件之一。</code></pre></div><p><img src="https://i.loli.net/2021/04/18/MmselvZFohcSPfC.png" alt="在这里插入图片描述"></p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># AMQP 协议</span>AMQP（advanced message queuing protocol）`在2003年时被提出，最早用于解决金融领不同平台之间的消息传递交互问题。顾名思义，AMQP是一种协议，更准确的说是一种binary wire-level protocol（链接协议）。这是其和JMS的本质差别，AMQP不从API层进行限定，而是直接定义网络交换的数据格式。这使得实现了AMQP的provider天然性就是跨平台的。以下是AMQP协议模型:</code></pre></div><p><img src="https://i.loli.net/2021/04/18/idfcuntLH3MymCs.png" alt="在这里插入图片描述"></p><p><img src="https://i.loli.net/2021/04/18/RgbjWCaPwLYSFhy.png" alt="在这里插入图片描述"></p><h4 id="2-2-2-下载的安装包"><a href="#2-2-2-下载的安装包" class="headerlink" title="2.2.2 下载的安装包"></a>2.2.2 下载的安装包</h4><p><img src="https://i.loli.net/2021/04/18/Zz6mDYlIoFijtpb.png" alt="在这里插入图片描述"></p><h4 id="2-2-3-安装步骤"><a href="#2-2-3-安装步骤" class="headerlink" title="2.2.3 安装步骤"></a>2.2.3 安装步骤</h4><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 1.将rabbitmq安装包上传到linux系统中</span>erlang-22.0.7-1.el7.x86_64.rpmrabbitmq-server-3.7.18-1.el7.noarch.rpm<span class="hljs-comment"># 2.安装Erlang依赖包</span>rpm -ivh erlang-22.0.7-1.el7.x86_64.rpm<span class="hljs-comment"># 3.安装RabbitMQ安装包(需要联网)</span>yum install -y rabbitmq-server-3.7.18-1.el7.noarch.rpm注意:默认安装完成后配置文件模板在:/usr/share/doc/rabbitmq-server-3.7.18/rabbitmq.config.example目录中,需要将配置文件复制到/etc/rabbitmq/目录中,并修改名称为rabbitmq.config<span class="hljs-comment"># 4.复制配置文件</span>cp /usr/share/doc/rabbitmq-server-3.7.18/rabbitmq.config.example /etc/rabbitmq/rabbitmq.config<span class="hljs-comment"># 5.查看配置文件位置</span>ls /etc/rabbitmq/rabbitmq.config<span class="hljs-comment"># 6.修改配置文件(参见下图:)</span>vim /etc/rabbitmq/rabbitmq.config</code></pre></div><p><img src="https://i.loli.net/2021/04/18/BMuvYhcdKmbqL2o.png" alt="在这里插入图片描述"></p><div class="hljs code-wrapper"><pre><code class="hljs bash">将上图中配置文件中红色部分去掉`%%`,以及最后的`,`逗号 修改为下图:</code></pre></div><p><img src="https://i.loli.net/2021/04/18/wvKufWCj9LogHkP.png" alt="在这里插入图片描述"></p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 7.执行如下命令,启动rabbitmq中的插件管理</span>rabbitmq-plugins <span class="hljs-built_in">enable</span> rabbitmq_management出现如下说明:Enabling plugins on node rabbit@localhost:    rabbitmq_management    The following plugins have been configured:      rabbitmq_management      rabbitmq_management_agent      rabbitmq_web_dispatch    Applying plugin configuration to rabbit@localhost...    The following plugins have been enabled:      rabbitmq_management      rabbitmq_management_agent      rabbitmq_web_dispatch    <span class="hljs-built_in">set</span> 3 plugins.    Offline change; changes will take effect at broker restart.<span class="hljs-comment"># 8.启动RabbitMQ的服务</span>systemctl start rabbitmq-serversystemctl restart rabbitmq-serversystemctl stop rabbitmq-server<span class="hljs-comment"># 9.查看服务状态(见下图:)</span>systemctl status rabbitmq-server  ● rabbitmq-server.service - RabbitMQ broker     Loaded: loaded (/usr/lib/systemd/system/rabbitmq-server.service; disabled; vendor preset: disabled)     Active: active (running) since 三 2019-09-25 22:26:35 CST; 7s ago   Main PID: 2904 (beam.smp)     Status: <span class="hljs-string">&quot;Initialized&quot;</span>     CGroup: /system.slice/rabbitmq-server.service             ├─2904 /usr/lib64/erlang/erts-10.4.4/bin/beam.smp -W w -A 64 -MBas ageffcbf -MHas ageffcbf -             MBlmbcs...             ├─3220 erl_child_setup 32768             ├─3243 inet_gethost 4             └─3244 inet_gethost 4      .........</code></pre></div><p><img src="https://i.loli.net/2021/04/18/zdCHtfNYlvEF94X.png" alt="在这里插入图片描述"></p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 10.关闭防火墙服务</span>systemctl <span class="hljs-built_in">disable</span> firewalld    Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.    Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.systemctl stop firewalld   <span class="hljs-comment"># 11.访问web管理界面</span>http://10.15.0.8:15672/</code></pre></div><p><img src="https://i.loli.net/2021/04/18/NT6MHg1VeZfQW3m.png" alt="在这里插入图片描述"></p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 12.登录管理界面</span>username:  guestpassword:  guest</code></pre></div><p><img src="https://i.loli.net/2021/04/18/mJ4FKDf3W8HuNOY.png" alt="在这里插入图片描述"></p><h2 id="3-RabiitMQ-配置"><a href="#3-RabiitMQ-配置" class="headerlink" title="3 RabiitMQ 配置"></a>3 RabiitMQ 配置</h2><h3 id="3-1-RabbitMQ-管理命令行"><a href="#3-1-RabbitMQ-管理命令行" class="headerlink" title="3.1 RabbitMQ 管理命令行"></a>3.1 RabbitMQ 管理命令行</h3><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 1.服务启动相关</span>systemctl start|restart|stop|status rabbitmq-server<span class="hljs-comment"># 2.管理命令行  用来在不使用web管理界面情况下命令操作RabbitMQ</span>rabbitmqctl  <span class="hljs-built_in">help</span>  可以查看更多命令<span class="hljs-comment"># 3.插件管理命令行</span>rabbitmq-plugins <span class="hljs-built_in">enable</span>|list|<span class="hljs-built_in">disable</span></code></pre></div><h3 id="3-2-web管理界面介绍"><a href="#3-2-web管理界面介绍" class="headerlink" title="3.2 web管理界面介绍"></a>3.2 web管理界面介绍</h3><h4 id="3-2-1-overview概览"><a href="#3-2-1-overview概览" class="headerlink" title="3.2.1 overview概览"></a>3.2.1 overview概览</h4><p><img src="https://i.loli.net/2021/04/18/3NO4aJFsXBrSDlg.png" alt="在这里插入图片描述"></p><div class="hljs code-wrapper"><pre><code class="hljs bash">connections：无论生产者还是消费者，都需要与RabbitMQ建立连接后才可以完成消息的生产和消费，在这里可以查看连接情况`channels：通道，建立连接后，会形成通道，消息的投递获取依赖通道。Exchanges：交换机，用来实现消息的路由Queues：队列，即消息队列，消息存放在队列中，等待消费，消费后被移除队列。</code></pre></div><h4 id="3-2-2-Admin用户和虚拟主机管理"><a href="#3-2-2-Admin用户和虚拟主机管理" class="headerlink" title="3.2.2 Admin用户和虚拟主机管理"></a>3.2.2 Admin用户和虚拟主机管理</h4><h5 id="3-2-2-1-添加用户"><a href="#3-2-2-1-添加用户" class="headerlink" title="3.2.2.1 添加用户"></a>3.2.2.1 添加用户</h5><p><img src="https://i.loli.net/2021/04/18/zQGZcmM62PwA53n.png" alt="在这里插入图片描述"></p><div class="hljs code-wrapper"><pre><code class="hljs bash">上面的Tags选项，其实是指定用户的角色，可选的有以下几个：超级管理员(administrator)可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作。监控者(monitoring)可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)策略制定者(policymaker)可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。普通管理者(management)仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。其他无法登陆管理控制台，通常就是普通的生产者和消费者。</code></pre></div><h5 id="3-2-2-2-创建虚拟主机"><a href="#3-2-2-2-创建虚拟主机" class="headerlink" title="3.2.2.2 创建虚拟主机"></a>3.2.2.2 创建虚拟主机</h5><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 虚拟主机</span>为了让各个用户可以互不干扰的工作，RabbitMQ添加了虚拟主机（Virtual Hosts）的概念。其实就是一个独立的访问路径，不同用户使用不同路径，各自有自己的队列、交换机，互相不会影响。</code></pre></div><p><img src="https://i.loli.net/2021/04/18/bVyu5X4OgpGCWx6.png" alt="在这里插入图片描述"></p><h5 id="3-2-2-3-绑定虚拟主机和用户"><a href="#3-2-2-3-绑定虚拟主机和用户" class="headerlink" title="3.2.2.3 绑定虚拟主机和用户"></a>3.2.2.3 绑定虚拟主机和用户</h5><div class="hljs code-wrapper"><pre><code class="hljs bash">创建好虚拟主机，我们还要给用户添加访问权限：点击添加好的虚拟主机：</code></pre></div><p><img src="https://i.loli.net/2021/04/18/RQlPFh5zMwIW2ST.png" alt="在这里插入图片描述"></p><div class="hljs code-wrapper"><pre><code class="hljs bash">进入虚拟机设置界面</code></pre></div><p><img src="https://i.loli.net/2021/04/18/Rgck5JvKy9V1IzS.png" alt="在这里插入图片描述"></p><h2 id="4-RabbitMQ-的第一个程序"><a href="#4-RabbitMQ-的第一个程序" class="headerlink" title="4 RabbitMQ 的第一个程序"></a>4 RabbitMQ 的第一个程序</h2><h3 id="4-1-AMQP协议的回顾"><a href="#4-1-AMQP协议的回顾" class="headerlink" title="4.1 AMQP协议的回顾"></a>4.1 AMQP协议的回顾</h3><p><img src="https://i.loli.net/2021/04/18/c8EQV5gdMCsPOiy.png" alt="在这里插入图片描述"></p><h3 id="4-2-RabbitMQ支持的消息模型"><a href="#4-2-RabbitMQ支持的消息模型" class="headerlink" title="4.2 RabbitMQ支持的消息模型"></a>4.2 RabbitMQ支持的消息模型</h3><p><img src="https://i.loli.net/2021/04/18/2mdSzIcQY5JXlnq.png" alt="在这里插入图片描述"></p><p><img src="https://i.loli.net/2021/04/18/BaHWVrolvQ7Cz6g.png" alt="在这里插入图片描述"></p><h3 id="4-3-引入依赖"><a href="#4-3-引入依赖" class="headerlink" title="4.3 引入依赖"></a>4.3 引入依赖</h3><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.rabbitmq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>amqp-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.7.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="4-4-第一种模型-直连"><a href="#4-4-第一种模型-直连" class="headerlink" title="4.4 第一种模型(直连)"></a>4.4 第一种模型(直连)</h3><p><img src="https://i.loli.net/2021/04/18/P59CuhyOiNSTIt3.png" alt="在这里插入图片描述"></p><div class="hljs code-wrapper"><pre><code class="hljs bash">在上图的模型中，有以下概念：P：生产者，也就是要发送消息的程序C：消费者：消息的接受者，会一直等待消息到来。queue：消息队列，图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。</code></pre></div><h4 id="4-4-1-开发生产者"><a href="#4-4-1-开发生产者" class="headerlink" title="4.4.1 开发生产者"></a>4.4.1 开发生产者</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//创建连接工厂</span>ConnectionFactory connectionFactory = <span class="hljs-keyword">new</span> ConnectionFactory();connectionFactory.setHost(<span class="hljs-string">&quot;10.15.0.9&quot;</span>);connectionFactory.setPort(<span class="hljs-number">5672</span>);connectionFactory.setUsername(<span class="hljs-string">&quot;ems&quot;</span>);connectionFactory.setPassword(<span class="hljs-string">&quot;123&quot;</span>);connectionFactory.setVirtualHost(<span class="hljs-string">&quot;/ems&quot;</span>);Connection connection = connectionFactory.newConnection();<span class="hljs-comment">//创建通道</span>Channel channel = connection.createChannel();<span class="hljs-comment">//参数1: 是否持久化  参数2:是否独占队列 参数3:是否自动删除  参数4:其他属性</span>channel.queueDeclare(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;hello rabbitmq&quot;</span>.getBytes());channel.close();connection.close();</code></pre></div><h4 id="4-4-2-开发消费者"><a href="#4-4-2-开发消费者" class="headerlink" title="4.4.2 开发消费者"></a>4.4.2 开发消费者</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//创建连接工厂</span>ConnectionFactory connectionFactory = <span class="hljs-keyword">new</span> ConnectionFactory();connectionFactory.setHost(<span class="hljs-string">&quot;10.15.0.9&quot;</span>);connectionFactory.setPort(<span class="hljs-number">5672</span>);connectionFactory.setUsername(<span class="hljs-string">&quot;ems&quot;</span>);connectionFactory.setPassword(<span class="hljs-string">&quot;123&quot;</span>);connectionFactory.setVirtualHost(<span class="hljs-string">&quot;/ems&quot;</span>);Connection connection = connectionFactory.newConnection();Channel channel = connection.createChannel();channel.queueDeclare(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);channel.basicConsume(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    System.out.println(<span class="hljs-keyword">new</span> String(body));  &#125;&#125;);</code></pre></div><h4 id="4-4-3-参数的说明"><a href="#4-4-3-参数的说明" class="headerlink" title="4.4.3 参数的说明"></a>4.4.3 参数的说明</h4><div class="hljs code-wrapper"><pre><code class="hljs java">channel.queueDeclare(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);<span class="hljs-string">&#x27;参数1&#x27;</span>:用来声明通道对应的队列<span class="hljs-string">&#x27;参数2&#x27;</span>:用来指定是否持久化队列<span class="hljs-string">&#x27;参数3&#x27;</span>:用来指定是否独占队列<span class="hljs-string">&#x27;参数4&#x27;</span>:用来指定是否自动删除队列<span class="hljs-string">&#x27;参数5&#x27;</span>:对队列的额外配置</code></pre></div><h3 id="4-4-第二种模型-work-quene"><a href="#4-4-第二种模型-work-quene" class="headerlink" title="4.4 第二种模型(work quene)"></a>4.4 第二种模型(work quene)</h3><div class="hljs code-wrapper"><pre><code class="hljs bash">Work queues，也被称为（Task queues），任务模型。当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时就可以使用work 模型：让多个消费者绑定到一个队列，共同消费队列中的消息。队列中的消息一旦消费，就会消失，因此任务是不会被重复执行的。</code></pre></div><p><img src="https://i.loli.net/2021/04/18/bLG8p9XODPxUfa4.png" alt="在这里插入图片描述"></p><div class="hljs code-wrapper"><pre><code class="hljs shell">角色：P：生产者：任务的发布者C1：消费者-1，领取任务并且完成任务，假设完成速度较慢C2：消费者-2：领取任务并完成任务，假设完成速度快</code></pre></div><h4 id="4-4-1-开发生产者-1"><a href="#4-4-1-开发生产者-1" class="headerlink" title="4.4.1 开发生产者"></a>4.4.1 开发生产者</h4><div class="hljs code-wrapper"><pre><code class="hljs bash">channel.queueDeclare(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, null);<span class="hljs-keyword">for</span> (int i = 0; i &lt; 10; i++) &#123;  channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>, null, (i+<span class="hljs-string">&quot;====&gt;:我是消息&quot;</span>).getBytes());&#125;</code></pre></div><h4 id="4-4-2-开发消费者-1"><a href="#4-4-2-开发消费者-1" class="headerlink" title="4.4.2 开发消费者-1"></a>4.4.2 开发消费者-1</h4><div class="hljs code-wrapper"><pre><code class="hljs java">channel.queueDeclare(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);channel.basicConsume(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    System.out.println(<span class="hljs-string">&quot;消费者1: &quot;</span>+<span class="hljs-keyword">new</span> String(body));  &#125;&#125;);</code></pre></div><h4 id="4-4-3-开发消费者-2"><a href="#4-4-3-开发消费者-2" class="headerlink" title="4.4.3 开发消费者-2"></a>4.4.3 开发消费者-2</h4><div class="hljs code-wrapper"><pre><code class="hljs java">channel.queueDeclare(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);channel.basicConsume(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-keyword">try</span> &#123;      Thread.sleep(<span class="hljs-number">1000</span>);   <span class="hljs-comment">//处理消息比较慢 一秒处理一个消息</span>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;      e.printStackTrace();    &#125;    System.out.println(<span class="hljs-string">&quot;消费者2: &quot;</span>+<span class="hljs-keyword">new</span> String(body));    &#125;&#125;);</code></pre></div><h4 id="4-4-4-测试结果"><a href="#4-4-4-测试结果" class="headerlink" title="4.4.4 测试结果"></a>4.4.4 测试结果</h4><p><img src="https://i.loli.net/2021/04/18/MIEmSFjkfXCuxqH.png" alt="在这里插入图片描述"></p><p><img src="https://i.loli.net/2021/04/18/1XPDadeEWOxgKIT.png" alt="在这里插入图片描述"></p><div class="hljs code-wrapper"><pre><code class="hljs bash">总结:默认情况下，RabbitMQ将按顺序将每个消息发送给下一个使用者。平均而言，每个消费者都会收到相同数量的消息。这种分发消息的方式称为循环。</code></pre></div><h4 id="4-4-5-消息自动确认机制"><a href="#4-4-5-消息自动确认机制" class="headerlink" title="4.4.5 消息自动确认机制"></a>4.4.5 消息自动确认机制</h4><div class="hljs code-wrapper"><pre><code class="hljs bash">Doing a task can take a few seconds. You may wonder what happens <span class="hljs-keyword">if</span> one of the consumers starts a long task and dies with it only partly <span class="hljs-keyword">done</span>. With our current code, once RabbitMQ delivers a message to the consumer it immediately marks it <span class="hljs-keyword">for</span> deletion. In this <span class="hljs-keyword">case</span>, <span class="hljs-keyword">if</span> you <span class="hljs-built_in">kill</span> a worker we will lose the message it was just processing. We<span class="hljs-string">&#x27;ll also lose all the messages that were dispatched to this particular worker but were not yet handled.</span><span class="hljs-string"></span><span class="hljs-string">But we don&#x27;</span>t want to lose any tasks. If a worker dies, we<span class="hljs-string">&#x27;d like the task to be delivered to another worker.</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java">channel.basicQos(<span class="hljs-number">1</span>);<span class="hljs-comment">//一次只接受一条未确认的消息</span><span class="hljs-comment">//参数2:关闭自动确认消息</span>channel.basicConsume(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    System.out.println(<span class="hljs-string">&quot;消费者1: &quot;</span>+<span class="hljs-keyword">new</span> String(body));    channel.basicAck(envelope.getDeliveryTag(),<span class="hljs-keyword">false</span>);<span class="hljs-comment">//手动确认消息</span>  &#125;&#125;);</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs bash">设置通道一次只能消费一个消息关闭消息的自动确认,开启手动确认消息</code></pre></div><p><img src="https://i.loli.net/2021/04/18/MOtd2CeSYBTabhR.png" alt="在这里插入图片描述"></p><p><img src="https://i.loli.net/2021/04/18/TO2cHtX6Ekqbxlh.png" alt="在这里插入图片描述"></p><h3 id="4-5-第三种模型-fanout"><a href="#4-5-第三种模型-fanout" class="headerlink" title="4.5 第三种模型(fanout)"></a>4.5 第三种模型(fanout)</h3><div class="hljs code-wrapper"><pre><code class="hljs bash">fanout 扇出 也称为广播</code></pre></div><p><img src="https://i.loli.net/2021/04/18/CDlGo95wtrLTnsg.png" alt="在这里插入图片描述"></p><div class="hljs code-wrapper"><pre><code class="hljs bash">在广播模式下，消息发送流程是这样的：可以有多个消费者每个消费者有自己的queue（队列）每个队列都要绑定到Exchange（交换机）生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定。交换机把消息发送给绑定过的所有队列队列的消费者都能拿到消息。实现一条消息被多个消费者消费</code></pre></div><h4 id="4-5-1-开发生产者"><a href="#4-5-1-开发生产者" class="headerlink" title="4.5.1 开发生产者"></a>4.5.1 开发生产者</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//声明交换机</span>channel.exchangeDeclare(<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;fanout&quot;</span>);<span class="hljs-comment">//广播 一条消息多个消费者同时消费</span><span class="hljs-comment">//发布消息</span>channel.basicPublish(<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;hello&quot;</span>.getBytes());</code></pre></div><h4 id="4-5-2-开发消费者-1"><a href="#4-5-2-开发消费者-1" class="headerlink" title="4.5.2 开发消费者-1"></a>4.5.2 开发消费者-1</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//绑定交换机</span>channel.exchangeDeclare(<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;fanout&quot;</span>);<span class="hljs-comment">//创建临时队列</span>String queue = channel.queueDeclare().getQueue();<span class="hljs-comment">//将临时队列绑定exchange</span>channel.queueBind(queue,<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">//处理消息</span>channel.basicConsume(queue,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    System.out.println(<span class="hljs-string">&quot;消费者1: &quot;</span>+<span class="hljs-keyword">new</span> String(body));  &#125;&#125;);</code></pre></div><h4 id="4-5-3-开发消费者-2"><a href="#4-5-3-开发消费者-2" class="headerlink" title="4.5.3 开发消费者-2"></a>4.5.3 开发消费者-2</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//绑定交换机</span>channel.exchangeDeclare(<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;fanout&quot;</span>);<span class="hljs-comment">//创建临时队列</span>String queue = channel.queueDeclare().getQueue();<span class="hljs-comment">//将临时队列绑定exchange</span>channel.queueBind(queue,<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">//处理消息</span>channel.basicConsume(queue,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    System.out.println(<span class="hljs-string">&quot;消费者2: &quot;</span>+<span class="hljs-keyword">new</span> String(body));  &#125;&#125;);</code></pre></div><h4 id="4-5-4-开发消费者-3"><a href="#4-5-4-开发消费者-3" class="headerlink" title="4.5.4 开发消费者-3"></a>4.5.4 开发消费者-3</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//绑定交换机</span>channel.exchangeDeclare(<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;fanout&quot;</span>);<span class="hljs-comment">//创建临时队列</span>String queue = channel.queueDeclare().getQueue();<span class="hljs-comment">//将临时队列绑定exchange</span>channel.queueBind(queue,<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">//处理消息</span>channel.basicConsume(queue,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    System.out.println(<span class="hljs-string">&quot;消费者3: &quot;</span>+<span class="hljs-keyword">new</span> String(body));  &#125;&#125;);</code></pre></div><h4 id="4-5-5-测试结果"><a href="#4-5-5-测试结果" class="headerlink" title="4.5.5 测试结果"></a>4.5.5 测试结果</h4><p><img src="https://i.loli.net/2021/04/18/ejb41XwA76OSgvU.png" alt="在这里插入图片描述"></p><p><img src="https://i.loli.net/2021/04/18/57j9i6dwC2JDtNK.png" alt="在这里插入图片描述"></p><p><img src="https://i.loli.net/2021/04/18/RmizGpYdjxTeFPv.png" alt="在这里插入图片描述"></p><h3 id="4-6-第四种模型-Routing"><a href="#4-6-第四种模型-Routing" class="headerlink" title="4.6 第四种模型(Routing)"></a>4.6 第四种模型(Routing)</h3><h4 id="4-6-1-Routing-之订阅模型-Direct-直连"><a href="#4-6-1-Routing-之订阅模型-Direct-直连" class="headerlink" title="4.6.1 Routing 之订阅模型-Direct(直连)"></a>4.6.1 Routing 之订阅模型-Direct(直连)</h4><div class="hljs code-wrapper"><pre><code class="hljs bash">在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs bash">在Direct模型下：队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key）消息的发送方在 向 Exchange发送消息时，也必须指定消息的 RoutingKey。Exchange不再把消息交给每一个绑定的队列，而是根据消息的Routing Key进行判断，只有队列的Routingkey与消息的 Routing key完全一致，才会接收到消息</code></pre></div><p><img src="https://i.loli.net/2021/04/18/cEAa8KmBpxkO5G4.png" alt="在这里插入图片描述"></p><div class="hljs code-wrapper"><pre><code class="hljs bash">P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列C1：消费者，其所在队列指定了需要routing key 为 error 的消息C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息</code></pre></div><h5 id="4-6-1-1-开发生产者"><a href="#4-6-1-1-开发生产者" class="headerlink" title="4.6.1.1 开发生产者"></a>4.6.1.1 开发生产者</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//声明交换机  参数1:交换机名称 参数2:交换机类型 基于指令的Routing key转发</span>channel.exchangeDeclare(<span class="hljs-string">&quot;logs_direct&quot;</span>,<span class="hljs-string">&quot;direct&quot;</span>);String key = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-comment">//发布消息</span>channel.basicPublish(<span class="hljs-string">&quot;logs_direct&quot;</span>,key,<span class="hljs-keyword">null</span>,(<span class="hljs-string">&quot;指定的route key&quot;</span>+key+<span class="hljs-string">&quot;的消息&quot;</span>).getBytes());</code></pre></div><h5 id="4-6-1-2-开发消费者-1"><a href="#4-6-1-2-开发消费者-1" class="headerlink" title="4.6.1.2 开发消费者-1"></a>4.6.1.2 开发消费者-1</h5><div class="hljs code-wrapper"><pre><code class="hljs java"> <span class="hljs-comment">//声明交换机</span>channel.exchangeDeclare(<span class="hljs-string">&quot;logs_direct&quot;</span>,<span class="hljs-string">&quot;direct&quot;</span>);<span class="hljs-comment">//创建临时队列</span>String queue = channel.queueDeclare().getQueue();<span class="hljs-comment">//绑定队列和交换机</span>channel.queueBind(queue,<span class="hljs-string">&quot;logs_direct&quot;</span>,<span class="hljs-string">&quot;error&quot;</span>);channel.queueBind(queue,<span class="hljs-string">&quot;logs_direct&quot;</span>,<span class="hljs-string">&quot;info&quot;</span>);channel.queueBind(queue,<span class="hljs-string">&quot;logs_direct&quot;</span>,<span class="hljs-string">&quot;warn&quot;</span>);<span class="hljs-comment">//消费消息</span>channel.basicConsume(queue,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    System.out.println(<span class="hljs-string">&quot;消费者1: &quot;</span>+<span class="hljs-keyword">new</span> String(body));  &#125;&#125;);</code></pre></div><h5 id="4-6-1-3-开发消费者-2"><a href="#4-6-1-3-开发消费者-2" class="headerlink" title="4.6.1.3 开发消费者-2"></a>4.6.1.3 开发消费者-2</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//声明交换机</span>channel.exchangeDeclare(<span class="hljs-string">&quot;logs_direct&quot;</span>,<span class="hljs-string">&quot;direct&quot;</span>);<span class="hljs-comment">//创建临时队列</span>String queue = channel.queueDeclare().getQueue();<span class="hljs-comment">//绑定队列和交换机</span>channel.queueBind(queue,<span class="hljs-string">&quot;logs_direct&quot;</span>,<span class="hljs-string">&quot;error&quot;</span>);<span class="hljs-comment">//消费消息</span>channel.basicConsume(queue,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    System.out.println(<span class="hljs-string">&quot;消费者2: &quot;</span>+<span class="hljs-keyword">new</span> String(body));  &#125;&#125;);</code></pre></div><h5 id="4-6-1-4-测试生产者发送Route-key为error的消息时"><a href="#4-6-1-4-测试生产者发送Route-key为error的消息时" class="headerlink" title="4.6.1.4 测试生产者发送Route key为error的消息时"></a>4.6.1.4 测试生产者发送Route key为error的消息时</h5><p><img src="https://i.loli.net/2021/04/18/tT7oXLDnJ5W9kEH.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/2020103022070734.png#pic_center" alt="在这里插入图片描述"></p><h5 id="4-6-1-5-测试生产者发送Route-key为info的消息时"><a href="#4-6-1-5-测试生产者发送Route-key为info的消息时" class="headerlink" title="4.6.1.5 测试生产者发送Route key为info的消息时"></a>4.6.1.5 测试生产者发送Route key为info的消息时</h5><p><img src="https://i.loli.net/2021/04/18/mnUizOcjs87Npfw.png" alt="在这里插入图片描述"></p><p><img src="https://i.loli.net/2021/04/18/AW2ioG6tfkbKMcD.png" alt="在这里插入图片描述"></p><h4 id="4-6-2-Routing-之订阅模型-Topic"><a href="#4-6-2-Routing-之订阅模型-Topic" class="headerlink" title="4.6.2 Routing 之订阅模型-Topic"></a>4.6.2 Routing 之订阅模型-Topic</h4><div class="hljs code-wrapper"><pre><code class="hljs bash">Topic类型的Exchange与Direct相比，都是可以根据RoutingKey把消息路由到不同的队列。只不过Topic类型Exchange可以让队列在绑定Routing key的时候使用通配符！这种模型Routingkey 一般都是由一个或多个单词组成，多个单词之间以”.”分割，例如： item.insert</code></pre></div><p><img src="https://i.loli.net/2021/04/18/AfzHat3eW7kThOq.png" alt="在这里插入图片描述"></p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 统配符</span>* (star) can substitute <span class="hljs-keyword">for</span> exactly one word.    匹配不多不少恰好1个词<span class="hljs-comment"># (hash) can substitute for zero or more words.  匹配一个或多个词</span><span class="hljs-comment"># 如:</span>audit.<span class="hljs-comment">#    匹配audit.irs.corporate或者 audit.irs 等</span>    audit.*   只能匹配 audit.irs</code></pre></div><h5 id="4-6-2-1-开发生产者"><a href="#4-6-2-1-开发生产者" class="headerlink" title="4.6.2.1 开发生产者"></a>4.6.2.1 开发生产者</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//生命交换机和交换机类型 topic 使用动态路由(通配符方式)</span>channel.exchangeDeclare(<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;topic&quot;</span>);String routekey = <span class="hljs-string">&quot;user.save&quot;</span>;<span class="hljs-comment">//动态路由key</span><span class="hljs-comment">//发布消息</span>channel.basicPublish(<span class="hljs-string">&quot;topics&quot;</span>,routekey,<span class="hljs-keyword">null</span>,(<span class="hljs-string">&quot;这是路由中的动态订阅模型,route key: [&quot;</span>+routekey+<span class="hljs-string">&quot;]&quot;</span>).getBytes());</code></pre></div><h5 id="4-6-2-2-开发消费者-1"><a href="#4-6-2-2-开发消费者-1" class="headerlink" title="4.6.2.2 开发消费者-1"></a>4.6.2.2 开发消费者-1</h5><div class="hljs code-wrapper"><pre><code class="hljs bash">Routing Key中使用*通配符方式</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"> <span class="hljs-comment">//声明交换机</span>channel.exchangeDeclare(<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;topic&quot;</span>);<span class="hljs-comment">//创建临时队列</span>String queue = channel.queueDeclare().getQueue();<span class="hljs-comment">//绑定队列与交换机并设置获取交换机中动态路由</span>channel.queueBind(queue,<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;user.*&quot;</span>);<span class="hljs-comment">//消费消息</span>channel.basicConsume(queue,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    System.out.println(<span class="hljs-string">&quot;消费者1: &quot;</span>+<span class="hljs-keyword">new</span> String(body));  &#125;&#125;);</code></pre></div><h5 id="4-6-2-3-开发消费者-2"><a href="#4-6-2-3-开发消费者-2" class="headerlink" title="4.6.2.3 开发消费者-2"></a>4.6.2.3 开发消费者-2</h5><div class="hljs code-wrapper"><pre><code class="hljs bash">Routing Key中使用*通配符方式</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//声明交换机</span>channel.exchangeDeclare(<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;topic&quot;</span>);<span class="hljs-comment">//创建临时队列</span>String queue = channel.queueDeclare().getQueue();<span class="hljs-comment">//绑定队列与交换机并设置获取交换机中动态路由</span>channel.queueBind(queue,<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;user.#&quot;</span>);<span class="hljs-comment">//消费消息</span>channel.basicConsume(queue,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    System.out.println(<span class="hljs-string">&quot;消费者2: &quot;</span>+<span class="hljs-keyword">new</span> String(body));  &#125;&#125;);</code></pre></div><h5 id="4-6-2-4-测试结果"><a href="#4-6-2-4-测试结果" class="headerlink" title="4.6.2.4 测试结果"></a>4.6.2.4 测试结果</h5><p><img src="https://i.loli.net/2021/04/18/y89cUmXwRD2qZjS.png" alt="在这里插入图片描述"></p><p><img src="https://i.loli.net/2021/04/18/pioSVPHIqmTtXeh.png" alt="在这里插入图片描述"></p><h2 id="5-SpringBoot中使用RabbitMQ"><a href="#5-SpringBoot中使用RabbitMQ" class="headerlink" title="5. SpringBoot中使用RabbitMQ"></a>5. SpringBoot中使用RabbitMQ</h2><h3 id="5-1-搭建初始环境"><a href="#5-1-搭建初始环境" class="headerlink" title="5.1 搭建初始环境"></a>5.1 搭建初始环境</h3><h4 id="5-1-1-引入依赖"><a href="#5-1-1-引入依赖" class="headerlink" title="5.1.1 引入依赖"></a>5.1.1 引入依赖</h4><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h4 id="5-1-2-配置配置文件"><a href="#5-1-2-配置配置文件" class="headerlink" title="5.1.2 配置配置文件"></a>5.1.2 配置配置文件</h4><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">springboot_rabbitmq</span>  <span class="hljs-attr">rabbitmq:</span>    <span class="hljs-attr">host:</span> <span class="hljs-number">10.15</span><span class="hljs-number">.0</span><span class="hljs-number">.9</span>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">ems</span>    <span class="hljs-attr">password:</span> <span class="hljs-number">123</span>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/ems</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs bash">RabbitTemplate用来简化操作    使用时候直接在项目中注入即可使用</code></pre></div><h3 id="5-2-第一种hello-world模型使用"><a href="#5-2-第一种hello-world模型使用" class="headerlink" title="5.2 第一种hello world模型使用"></a>5.2 第一种hello world模型使用</h3><h4 id="开发生产者"><a href="#开发生产者" class="headerlink" title="开发生产者"></a>开发生产者</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testHello</span><span class="hljs-params">()</span></span>&#123;  rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;hello world&quot;</span>);&#125;</code></pre></div><h4 id="开发消费者"><a href="#开发消费者" class="headerlink" title="开发消费者"></a>开发消费者</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@RabbitListener(queuesToDeclare = @Queue(&quot;hello&quot;))</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloCustomer</span> </span>&#123;<span class="hljs-meta">@RabbitHandler</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive1</span><span class="hljs-params">(String message)</span></span>&#123;  System.out.println(<span class="hljs-string">&quot;message = &quot;</span> + message);  &#125;&#125;</code></pre></div><h3 id="5-3-第二种work模型使用"><a href="#5-3-第二种work模型使用" class="headerlink" title="5.3 第二种work模型使用"></a>5.3 第二种work模型使用</h3><h4 id="开发生产者-1"><a href="#开发生产者-1" class="headerlink" title="开发生产者"></a>开发生产者</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testWork</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;   rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;work&quot;</span>,<span class="hljs-string">&quot;hello work!&quot;</span>); &#125;&#125;</code></pre></div><h4 id="开发消费者-1"><a href="#开发消费者-1" class="headerlink" title="开发消费者"></a>开发消费者</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WorkCustomer</span> </span>&#123;    <span class="hljs-meta">@RabbitListener(queuesToDeclare = @Queue(&quot;work&quot;))</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive1</span><span class="hljs-params">(String message)</span></span>&#123;        System.out.println(<span class="hljs-string">&quot;work message1 = &quot;</span> + message);    &#125;    <span class="hljs-meta">@RabbitListener(queuesToDeclare = @Queue(&quot;work&quot;))</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive2</span><span class="hljs-params">(String message)</span></span>&#123;        System.out.println(<span class="hljs-string">&quot;work message2 = &quot;</span> + message);    &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs bash">说明:默认在Spring AMQP实现中Work这种方式就是公平调度,如果需要实现能者多劳需要外配置</code></pre></div><h3 id="5-4-Fanout-广播模型"><a href="#5-4-Fanout-广播模型" class="headerlink" title="5.4 Fanout 广播模型"></a>5.4 Fanout 广播模型</h3><h4 id="开发生产者-2"><a href="#开发生产者-2" class="headerlink" title="开发生产者"></a>开发生产者</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFanout</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;  rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;这是日志广播&quot;</span>);&#125;</code></pre></div><h4 id="开发消费者-2"><a href="#开发消费者-2" class="headerlink" title="开发消费者"></a>开发消费者</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FanoutCustomer</span> </span>&#123;   <span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(</span><span class="hljs-meta">           value = @Queue,</span><span class="hljs-meta">           exchange = @Exchange(name=&quot;logs&quot;,type = &quot;fanout&quot;)</span><span class="hljs-meta">   ))</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive1</span><span class="hljs-params">(String message)</span></span>&#123;       System.out.println(<span class="hljs-string">&quot;message1 = &quot;</span> + message);   &#125;   <span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(</span><span class="hljs-meta">           value = @Queue, //创建临时队列</span><span class="hljs-meta">           exchange = @Exchange(name=&quot;logs&quot;,type = &quot;fanout&quot;)  //绑定交换机类型</span><span class="hljs-meta">   ))</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive2</span><span class="hljs-params">(String message)</span></span>&#123;       System.out.println(<span class="hljs-string">&quot;message2 = &quot;</span> + message);   &#125;&#125;</code></pre></div><h3 id="5-5-Route-路由模型"><a href="#5-5-Route-路由模型" class="headerlink" title="5.5 Route 路由模型"></a>5.5 Route 路由模型</h3><h4 id="开发生产者-3"><a href="#开发生产者-3" class="headerlink" title="开发生产者"></a>开发生产者</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDirect</span><span class="hljs-params">()</span></span>&#123;rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;directs&quot;</span>,<span class="hljs-string">&quot;error&quot;</span>,<span class="hljs-string">&quot;error 的日志信息&quot;</span>);&#125;</code></pre></div><h4 id="开发消费者-3"><a href="#开发消费者-3" class="headerlink" title="开发消费者"></a>开发消费者</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DirectCustomer</span> </span>&#123;<span class="hljs-meta">@RabbitListener(bindings =&#123;</span><span class="hljs-meta">@QueueBinding(</span><span class="hljs-meta">    value = @Queue(),</span><span class="hljs-meta">    key=&#123;&quot;info&quot;,&quot;error&quot;&#125;,</span><span class="hljs-meta">    exchange = @Exchange(type = &quot;direct&quot;,name=&quot;directs&quot;)</span><span class="hljs-meta">)&#125;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive1</span><span class="hljs-params">(String message)</span></span>&#123;System.out.println(<span class="hljs-string">&quot;message1 = &quot;</span> + message);&#125;<span class="hljs-meta">@RabbitListener(bindings =&#123;</span><span class="hljs-meta">@QueueBinding(</span><span class="hljs-meta">    value = @Queue(),</span><span class="hljs-meta">    key=&#123;&quot;error&quot;&#125;,</span><span class="hljs-meta">    exchange = @Exchange(type = &quot;direct&quot;,name=&quot;directs&quot;)</span><span class="hljs-meta">)&#125;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive2</span><span class="hljs-params">(String message)</span></span>&#123;System.out.println(<span class="hljs-string">&quot;message2 = &quot;</span> + message);&#125;&#125;</code></pre></div><h3 id="5-6-Topic-订阅模型-动态路由模型"><a href="#5-6-Topic-订阅模型-动态路由模型" class="headerlink" title="5.6 Topic 订阅模型(动态路由模型)"></a>5.6 Topic 订阅模型(动态路由模型)</h3><h4 id="开发生产者-4"><a href="#开发生产者-4" class="headerlink" title="开发生产者"></a>开发生产者</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<span class="hljs-comment">//topic</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testTopic</span><span class="hljs-params">()</span></span>&#123;rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;user.save.findAll&quot;</span>,<span class="hljs-string">&quot;user.save.findAll 的消息&quot;</span>);&#125;</code></pre></div><h4 id="开发消费者-4"><a href="#开发消费者-4" class="headerlink" title="开发消费者"></a>开发消费者</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TopCustomer</span> </span>&#123;    <span class="hljs-meta">@RabbitListener(bindings = &#123;</span><span class="hljs-meta">            @QueueBinding(</span><span class="hljs-meta">                    value = @Queue,</span><span class="hljs-meta">                    key = &#123;&quot;user.*&quot;&#125;,</span><span class="hljs-meta">                    exchange = @Exchange(type = &quot;topic&quot;,name = &quot;topics&quot;)</span><span class="hljs-meta">            )</span><span class="hljs-meta">    &#125;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive1</span><span class="hljs-params">(String message)</span></span>&#123;        System.out.println(<span class="hljs-string">&quot;message1 = &quot;</span> + message);    &#125;    <span class="hljs-meta">@RabbitListener(bindings = &#123;</span><span class="hljs-meta">            @QueueBinding(</span><span class="hljs-meta">                    value = @Queue,</span><span class="hljs-meta">                    key = &#123;&quot;user.#&quot;&#125;,</span><span class="hljs-meta">                    exchange = @Exchange(type = &quot;topic&quot;,name = &quot;topics&quot;)</span><span class="hljs-meta">            )</span><span class="hljs-meta">    &#125;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive2</span><span class="hljs-params">(String message)</span></span>&#123;        System.out.println(<span class="hljs-string">&quot;message2 = &quot;</span> + message);    &#125;&#125;</code></pre></div><h2 id="6-MQ的应用场景"><a href="#6-MQ的应用场景" class="headerlink" title="6 MQ的应用场景"></a>6 MQ的应用场景</h2><h3 id="6-1-异步处理"><a href="#6-1-异步处理" class="headerlink" title="6.1 异步处理"></a>6.1 异步处理</h3><p>场景说明：用户注册后，需要发注册邮件和注册短信,传统的做法有两种 1.串行的方式 2.并行的方式</p><p>串行方式: 将注册信息写入数据库后,发送注册邮件,再发送注册短信,以上三个任务全部完成后才返回给客户端。 这有一个问题是,邮件,短信并不是必须的,它只是一个通知,而这种做法让客户端等待没有必要等待的东西. </p><p><img src="https://i.loli.net/2021/04/18/6YbBvpyTaiI9nkx.png" alt="在这里插入图片描述"></p><p>并行方式: 将注册信息写入数据库后,发送邮件的同时,发送短信,以上三个任务完成后,返回给客户端,并行的方式能提高处理的时间。 </p><p><img src="https://i.loli.net/2021/04/18/yBKLFu8bDeOthRl.png" alt="在这里插入图片描述"></p><p>消息队列:假设三个业务节点分别使用50ms,串行方式使用时间150ms,并行使用时间100ms。虽然并行已经提高的处理时间,但是,前面说过,邮件和短信对我正常的使用网站没有任何影响，客户端没有必要等着其发送完成才显示注册成功,应该是写入数据库后就返回.  消息队列: 引入消息队列后，把发送邮件,短信不是必须的业务逻辑异步处理 </p><p><img src="https://i.loli.net/2021/04/18/JFPQaThGygjENRo.jpg" alt="在这里插入图片描述"></p><h3 id="6-2-应用解耦"><a href="#6-2-应用解耦" class="headerlink" title="6.2 应用解耦"></a>6.2 应用解耦</h3><p>场景：双11是购物狂节,用户下单后,订单系统需要通知库存系统,传统的做法就是订单系统调用库存系统的接口. </p><p><img src="https://i.loli.net/2021/04/18/CMG7IKF5jeagnbT.png" alt="在这里插入图片描述"></p><p>这种做法有一个缺点:<br>当库存系统出现故障时,订单就会失败。 订单系统和库存系统高耦合.  引入消息队列 </p><p><img src="https://i.loli.net/2021/04/18/OTHaQY2fGpsyv7R.png" alt="在这里插入图片描述"></p><p>订单系统:用户下单后,订单系统完成持久化处理,将消息写入消息队列,返回用户订单下单成功。</p><p>库存系统:订阅下单的消息,获取下单消息,进行库操作。  就算库存系统出现故障,消息队列也能保证消息的可靠投递,不会导致消息丢失.</p><h3 id="6-3-流量削峰"><a href="#6-3-流量削峰" class="headerlink" title="6.3 流量削峰"></a>6.3 流量削峰</h3><p>场景: 秒杀活动，一般会因为流量过大，导致应用挂掉,为了解决这个问题，一般在应用前端加入消息队列。  </p><div class="hljs code-wrapper"><pre><code class="hljs bash">作用:1.可以控制活动人数，超过此一定阀值的订单直接丢弃(我为什么秒杀一次都没有成功过呢^^) 2.可以缓解短时间的高流量压垮应用(应用程序按自己的最大处理能力获取订单)</code></pre></div><p><img src="https://i.loli.net/2021/04/18/HNy2Dgm4XErOqBh.png" alt="在这里插入图片描述"></p><div class="hljs code-wrapper"><pre><code class="hljs bash">1.用户的请求,服务器收到之后,首先写入消息队列,加入消息队列长度超过最大值,则直接抛弃用户请求或跳转到错误页面.  2.秒杀业务根据消息队列中的请求信息，再做后续处理.</code></pre></div><h2 id="7-RabbitMQ的集群"><a href="#7-RabbitMQ的集群" class="headerlink" title="7 RabbitMQ的集群"></a>7 RabbitMQ的集群</h2><h3 id="7-1-集群架构"><a href="#7-1-集群架构" class="headerlink" title="7.1 集群架构"></a>7.1 集群架构</h3><h4 id="7-1-1-普通集群-副本集群"><a href="#7-1-1-普通集群-副本集群" class="headerlink" title="7.1.1 普通集群(副本集群)"></a>7.1.1 普通集群(副本集群)</h4><p>All data/state required for the operation of a RabbitMQ broker is replicated across all nodes. An exception to this are message queues, which by default reside on one node, though they are visible and reachable from all nodes. To replicate queues across nodes in a cluster   –摘自官网<br>默认情况下:RabbitMQ代理操作所需的所有数据/状态都将跨所有节点复制。这方面的一个例外是消息队列，默认情况下，消息队列位于一个节点上，尽管它们可以从所有节点看到和访问</p><h4 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h4><p><img src="https://i.loli.net/2021/04/18/jkVhnrsCSEIi7NB.png" alt="在这里插入图片描述"></p><p>核心解决问题:  当集群中某一时刻master节点宕机,可以对Quene中信息,进行备份</p><h4 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h4><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 0.集群规划</span>node1: 10.15.0.3  mq1  master 主节点node2: 10.15.0.4  mq2  repl1  副本节点node3: 10.15.0.5  mq3  repl2  副本节点<span class="hljs-comment"># 1.克隆三台机器主机名和ip映射</span>vim /etc/hosts加入: 10.15.0.3 mq1    10.15.0.4 mq2    10.15.0.5 mq3node1: vim /etc/hostname 加入:  mq1node2: vim /etc/hostname 加入:  mq2node3: vim /etc/hostname 加入:  mq3<span class="hljs-comment"># 2.三个机器安装rabbitmq,并同步cookie文件,在node1上执行:</span>scp /var/lib/rabbitmq/.erlang.cookie root@mq2:/var/lib/rabbitmq/scp /var/lib/rabbitmq/.erlang.cookie root@mq3:/var/lib/rabbitmq/<span class="hljs-comment"># 3.查看cookie是否一致:</span>node1: cat /var/lib/rabbitmq/.erlang.cookie node2: cat /var/lib/rabbitmq/.erlang.cookie node3: cat /var/lib/rabbitmq/.erlang.cookie <span class="hljs-comment"># 4.后台启动rabbitmq所有节点执行如下命令,启动成功访问管理界面:</span>rabbitmq-server -detached <span class="hljs-comment"># 5.在node2和node3执行加入集群命令:</span>1.关闭       rabbitmqctl stop_app2.加入集群    rabbitmqctl join_cluster rabbit@mq13.启动服务    rabbitmqctl start_app<span class="hljs-comment"># 6.查看集群状态,任意节点执行:</span>rabbitmqctl cluster_status<span class="hljs-comment"># 7.如果出现如下显示,集群搭建成功:</span>Cluster status of node rabbit@mq3 ...[&#123;nodes,[&#123;disc,[rabbit@mq1,rabbit@mq2,rabbit@mq3]&#125;]&#125;,&#123;running_nodes,[rabbit@mq1,rabbit@mq2,rabbit@mq3]&#125;,&#123;cluster_name,&lt;&lt;<span class="hljs-string">&quot;rabbit@mq1&quot;</span>&gt;&gt;&#125;,&#123;partitions,[]&#125;,&#123;alarms,[&#123;rabbit@mq1,[]&#125;,&#123;rabbit@mq2,[]&#125;,&#123;rabbit@mq3,[]&#125;]&#125;]</code></pre></div><h2 id="8-登录管理界面-展示如下状态"><a href="#8-登录管理界面-展示如下状态" class="headerlink" title="8.登录管理界面,展示如下状态:"></a>8.登录管理界面,展示如下状态:</h2><p><img src="https://i.loli.net/2021/04/18/Fxpf2aYR6dmB9ng.png" alt="在这里插入图片描述"></p><h2 id="9-测试集群在node1上-创建队列"><a href="#9-测试集群在node1上-创建队列" class="headerlink" title="9.测试集群在node1上,创建队列"></a>9.测试集群在node1上,创建队列</h2><p><img src="https://i.loli.net/2021/04/18/d4XFNuChtAlRncx.png" alt="在这里插入图片描述"></p><h2 id="10-查看node2和node3节点"><a href="#10-查看node2和node3节点" class="headerlink" title="10.查看node2和node3节点:"></a>10.查看node2和node3节点:</h2><p><img src="https://i.loli.net/2021/04/18/jDWCQuo7bdhR6sX.png" alt="在这里插入图片描述"></p><p><img src="https://i.loli.net/2021/04/18/pur124iGBlMYJbW.png" alt="在这里插入图片描述"></p><h2 id="11-关闭node1节点-执行如下命令-查看node2和node3"><a href="#11-关闭node1节点-执行如下命令-查看node2和node3" class="headerlink" title="11.关闭node1节点,执行如下命令,查看node2和node3:"></a>11.关闭node1节点,执行如下命令,查看node2和node3:</h2><div class="hljs code-wrapper"><pre><code>rabbitmqctl stop_app</code></pre></div><p><img src="https://i.loli.net/2021/04/18/epYgOvkXPSW7J96.png" alt="在这里插入图片描述"></p><p><img src="https://i.loli.net/2021/04/18/kzXcDiLjJdTwG8P.png" alt="在这里插入图片描述"></p><h4 id="7-1-2-镜像集群"><a href="#7-1-2-镜像集群" class="headerlink" title="7.1.2 镜像集群"></a>7.1.2 镜像集群</h4><div class="hljs code-wrapper"><pre><code class="hljs bash">This guide covers mirroring (queue contents replication) of classic queues  --摘自官网By default, contents of a queue within a RabbitMQ cluster are located on a single node (the node on <span class="hljs-built_in">which</span> the queue was declared). This is <span class="hljs-keyword">in</span> contrast to exchanges and bindings, <span class="hljs-built_in">which</span> can always be considered to be on all nodes. Queues can optionally be made *mirrored* across multiple nodes. --摘自官网镜像队列机制就是将队列在三个节点之间设置主从关系，消息会在三个节点之间进行自动同步，且如果其中一个节点不可用，并不会导致消息丢失或服务不可用的情况，提升MQ集群的整体高可用性。</code></pre></div><p>集群架构图</p><p><img src="https://i.loli.net/2021/04/18/CX2tKmBg5bOGlFr.png" alt="在这里插入图片描述"></p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 0.策略说明</span>rabbitmqctl set_policy [-p &lt;vhost&gt;] [--priority &lt;priority&gt;] [--apply-to &lt;apply-to&gt;] &lt;name&gt; &lt;pattern&gt;  &lt;definition&gt;-p Vhost： 可选参数，针对指定vhost下的queue进行设置Name:     policy的名称Pattern: queue的匹配模式(正则表达式)Definition：镜像定义，包括三个部分ha-mode, ha-params, ha-sync-mode         ha-mode:指明镜像队列的模式，有效值为 all/exactly/nodes                      all：表示在集群中所有的节点上进行镜像                      exactly：表示在指定个数的节点上进行镜像，节点的个数由ha-params指定                      nodes：表示在指定的节点上进行镜像，节点名称通过ha-params指定           ha-params：ha-mode模式需要用到的参数              ha-sync-mode：进行队列中消息的同步方式，有效值为automatic和manual              priority：可选参数，policy的优先级                             <span class="hljs-comment"># 1.查看当前策略</span>rabbitmqctl list_policies<span class="hljs-comment"># 2.添加策略</span>rabbitmqctl set_policy ha-all <span class="hljs-string">&#x27;^hello&#x27;</span> <span class="hljs-string">&#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#x27;</span> 说明:策略正则表达式为 “^” 表示所有匹配所有队列名称  ^hello:匹配hello开头队列<span class="hljs-comment"># 3.删除策略</span>rabbitmqctl clear_policy ha-all<span class="hljs-comment"># 4.测试集群</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>middle-component</category>
      
      <category>rabbitmq</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rabbitmq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luna-macos</title>
    <link href="/2021/01/10/macos/"/>
    <url>/2021/01/10/macos/</url>
    
    <content type="html"><![CDATA[<p>1.安装brew  wget等</p><p>先安装brew再用brew安装wget</p><p>1&gt; Homebrew</p><p>Homebrew是以最简单，最灵活的方式来安装苹果公司在MacOS中不包含的UNIX工具</p><p>/usr/bin/ruby -e “$(curl -fsSL <a href="https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;">https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</a></p><p>如遇</p><p>Press RETURN to continue or any other key to abort<br>==&gt; Downloading and installing Homebrew…<br>error: could not lock config file /usr/local/Homebrew/.git/config: Permission denied<br>fatal: could not set ‘core.repositoryformatversion’ to ‘0’<br>Failed during: git init -q</p><p>权限不够，则</p><p>sudo chgrp -R admin /usr/local</p><p>sudo chmod -R g+w /usr/local</p><p>改变目录权限</p><p>如遇<br>curl: (7) Failed to connect to raw.githubusercontent.com port 443: Operation timed out<br>/System/Library/Frameworks/Ruby.framework/Versions/2.3/usr/lib/ruby/2.3.0/universal-darwin18/rbconfig.rb:215: warning: Insecure world writable dir /usr/local/sbin in PATH, mode 040777</p><p>上述方法安装不了（被强了）， 就用下面这个文件安装</p><p>下载后命名为brew_install.rb，下载链接: <a href="https://pan.baidu.com/s/1TCliuLQNer88rMw9ngV1ag">https://pan.baidu.com/s/1TCliuLQNer88rMw9ngV1ag</a>  密码: 2t5o</p><p>然后再执行</p><p>ruby brew_install.rb</p><p>这样就可以安装好brew_install.rb文件</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvmrin3425j60vo0qe78302.jpg" alt="img"></p><p>brew update  更新brew</p><p>brew install {应用名，如git} 安装软件</p><p>brew cask install {应用名，如git} 也是下载安装，与上面的区别，请查看<a href="https://www.zhihu.com/question/22624898">https://www.zhihu.com/question/22624898</a></p><p>更多用法请 brew help</p><p>如安装下载node  brew install node</p><p>如遇  Warning: node 12.4.0 is already installed and up-to-date<br>To reinstall 12.4.0, run <code>brew reinstall node</code></p><p>则  brew upgrade node</p><p>如遇curl: (7) Failed to connect to raw.githubusercontent.com port 443: Operation timed out</p><p><a href="https://blog.csdn.net/sinat_27741463/article/details/102950077">https://blog.csdn.net/sinat_27741463/article/details/102950077</a></p><p>如果你的mac是10.14.6 以上，homebrew安装失败 可以试试用国内的源。亲测可用</p><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">/bin/</span>zsh -c <span class="hljs-string">&quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</span></code></pre></div><p>/bin/zsh -c “$(curl -fsSL <a href="https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;">https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</a></p><p><img src="https://i.loli.net/2021/01/29/6e2cTJQNVqBjAuH.png" alt="img"></p><p><img src="https://i.loli.net/2021/01/29/Yj16uqSt9CPfdJw.png" alt="img"></p><p>安装完后的样子如下</p><p><img src="https://i.loli.net/2021/01/29/FTxqyPK7YbLJHk3.png" alt="img"></p><p>2&gt; wget</p><p>安装万brew再安装wget</p><p>brew install wget</p><p>3&gt; rpm 目前没安装</p><p>下载地址：<a href="http://rpm.pbone.net/index.php3/stat/4/idpl/31936885/dir/scientific_linux_6/com/wget-1.12-8.el6.x86_64.rpm.html">http://rpm.pbone.net/index.php3/stat/4/idpl/31936885/dir/scientific_linux_6/com/wget-1.12-8.el6.x86_64.rpm.html</a></p><p><img src="https://i.loli.net/2021/01/29/k4xOVfJ8cMnw2E6.png" alt="img"></p><p>2.安装jdk  <a href="https://jingyan.baidu.com/article/7f766daffd99354101e1d095.html">https://jingyan.baidu.com/article/7f766daffd99354101e1d095.html</a></p><p>安装完毕 java -version</p><p><img src="https://i.loli.net/2021/01/29/vpzOLn2RHqPkBjd.png" alt="img"></p><p>3.安装maven，brew install maven 安装完毕 mvn -version</p><p><img src="https://i.loli.net/2021/01/29/Sg29smA1tUybZLp.png" alt="img"></p><p>查找Java_home路径的命令/usr/libexec/java_home</p><p><img src="https://i.loli.net/2021/01/29/VkupbJRyIe5E3hQ.png" alt="img"></p><p>objc[6704]: Class JavaLaunchHelper is implemented in both /Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Home/bin/java (0x1026804c0) and /Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Home/jre/lib/libinstrument.dylib (0x1027044e0). One of the two will be used. Which one is undefined.</p><p>解决办法：</p><p>help-Edit Custom Properties 里添加</p><div class="hljs code-wrapper"><pre><code class="hljs html"># custom IntelliJ IDEA propertiesidea_rtidea.no.launcher=true</code></pre></div><p>4.Chrome浏览器jsonview插件安装</p><p><a href="https://www.cnblogs.com/whycxb/p/7126116.html">https://www.cnblogs.com/whycxb/p/7126116.html</a></p><p><img src="https://i.loli.net/2021/01/29/t14bUgvipT2YueC.png" alt="img"></p><p>Chrome浏览器安装Set Character Encoding</p><p><a href="https://jingyan.baidu.com/article/5552ef47974e5f518ffbc9f8.html">https://jingyan.baidu.com/article/5552ef47974e5f518ffbc9f8.html</a></p><p><img src="https://i.loli.net/2021/01/29/uAVyTIieXFDd3Jt.png" alt="img"></p><p>5.UrlEncode编码/UrlDecode解码 - 站长工具</p><p><a href="http://tool.chinaz.com/tools/urlencode.aspx">http://tool.chinaz.com/tools/urlencode.aspx</a></p><p><img src="https://i.loli.net/2021/01/29/LHTeohJap4QXANs.png" alt="img"></p><p>6.iterm2下字体以及配色方案，Mac下终端配置（iterm2 + oh-my-zsh + solarized配色方案）</p><p><strong>idea下不显示git分支，要安装 oh-my-zsh 即可</strong></p><p><a href="https://zhuanlan.zhihu.com/p/64024555">https://zhuanlan.zhihu.com/p/64024555</a></p><p>修改完iterm主题，记得source！！！若选择<strong>agnoster</strong>主题，应用这个主题需要特殊的字体支持，否则会出现乱码情况</p><p>进入：iTerm2 &gt; Profiles &gt; Text &gt; Font，修改字体为：Meslo LG S DZ Regular for Powerline</p><p>个人选择的是”robbyrussell”主题，当然也有选ys主题的，看个人爱好吧</p><p><img src="https://i.loli.net/2021/01/29/Qaz6igkbFeRlZVp.png" alt="img"></p><hr><hr><p>如遇error: RPC failed; curl 56 LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 54<br>fatal: the remote end hung up unexpectedly<br>fatal: early EOF<br>fatal: index-pack failed</p><p>参考博客<a href="https://blog.csdn.net/weixin_43935605/article/details/100095722">https://blog.csdn.net/weixin_43935605/article/details/100095722</a></p><p>iTerm2配置用于同时打开多个ssh会话（支持多集群，多机器管理）</p><p>本地</p><p>Host *<br>ControlMaster auto<br>ControlPath ~/.ssh/master-%r@%h:%p<br>ControlPersist yes<br>ServerAliveInterval 60</p><p>保存后在iterm2-Perferences-Profiles配置跳板机-服务器username@ip</p><p><img src="https://i.loli.net/2021/01/29/6H3QbEAyJXncsDp.png" alt="img"></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>Mac ITerm2连接服务器自动断开解决办法</p><p>在mac下使用ITerm2通过ssh连接远程服务器时，总会一段时间没有操作后，ssh便会被被自动断开连接</p><p>iTerm2-Preferences-Profiles-Session修改when idle,send ASCII code 0 every 9999 seconds</p><p><img src="https://i.loli.net/2021/01/29/2tXmRjWIKfYwGzP.png" alt="img"></p><p>或者 vim ~/.ssh/config</p><p>Host *</p><p>ControlMaster auto</p><p>ControlPath ~/.ssh/master-%r@%h:%p</p><p>ControlPersist yes</p><p>ServerAliveInterval 14400</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>修改 host 配置，在终端中输入下列指令，打开编辑文件。</p><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo vi <span class="hljs-regexp">/etc/</span>hosts</code></pre></div><p>进入编辑模式，在最下面添加 13.229.188.59 github.com<br>再次尝试在终端 ping github.com，发现已经成功了。</p><p><img src="https://i.loli.net/2021/01/29/uHtRbZNhW5aJoCA.png" alt="img"></p><hr><hr><p>安装完乱码</p><p><img src="https://i.loli.net/2021/01/29/5b4HhDRuKBvnSmc.png" alt="img"></p><p>解决方法</p><p>安装Meslo字体，否则会出现乱码：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/powerline/fonts.git <span class="hljs-built_in">cd</span> fonts ./install.sh</code></pre></div><p>如遇<br>Cloning into ‘fonts’…<br>remote: Enumerating objects: 968, done.<br>error: RPC failed; curl 18 transfer closed with outstanding read data remaining<br>fatal: the remote end hung up unexpectedly<br>fatal: early EOF<br>fatal: index-pack failed</p><p>在执行git clone命令时报错：fatal: early EOF。解决办法如下：</p><p>1.关闭压缩</p><div class="hljs code-wrapper"><pre><code class="hljs lua">git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global core.compression 0</span></code></pre></div><p>2.然后执行部分clone</p><div class="hljs code-wrapper"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">--depth</span> <span class="hljs-number">1</span> <span class="hljs-tag">&lt;repo_URI&gt;</span></code></pre></div><p>其中代表你的远程代码仓库地址，这里我的是用git clone –depth 1 <a href="https://github.com/powerline/fonts.git">https://github.com/powerline/fonts.git</a></p><p>3.如果起作用了，clone剩下的代码：</p><div class="hljs code-wrapper"><pre><code class="hljs pgsql">git <span class="hljs-keyword">fetch</span> <span class="hljs-comment">--unshallow </span></code></pre></div><p>4.以后执行常规操作就行了</p><div class="hljs code-wrapper"><pre><code class="hljs ada">git pull <span class="hljs-comment">--all</span></code></pre></div><p>因为git代码一直拉不下来，所有换一种方式，就是修改oh-my-zsh主题</p><p>vim .zshrc</p><p>修改  ZSH_THEME=”robbyrussell”  之前为  ZSH_THEME=”agnoster” </p><p># ZSH_THEME_RANDOM_CANDIDATES=( “robbyrussell” “agnoster” )</p><p>效果如下</p><p><img src="https://i.loli.net/2021/01/29/ZXKgJlabHu6P2SY.png" alt="img"></p><p>[zsh 配置] zsh命令自动补全插件</p><p>下载该插件到.oh-my-zsh的插件目录  /Users/qa/.oh-my-zsh/plugins</p><div class="hljs code-wrapper"><pre><code class="hljs awk">git clone git:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/zsh-users/</span>zsh-autosuggestions <span class="hljs-variable">$ZSH_CUSTOM</span><span class="hljs-regexp">/plugins/</span>zsh-autosuggestions</code></pre></div><p>编辑/Users/qa/.zshrc文件</p><p>找到plugins=(git)这一行，如果没有添加。更改为如下 注意不要注释掉之前的plugins=(git) 要直接修改这行</p><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">plugins</span>=(git zsh-autosuggestions)</code></pre></div><p>plugins=(git zsh-autosuggestions)</p><p>记得source .zshrc </p><p><img src="https://i.loli.net/2021/01/29/vLI7j6Ck5XMxOAy.png" alt="img"></p><p>效果如上图最后一行</p><p><img src="https://i.loli.net/2021/01/29/WQ3plmnsE2yeYZC.png" alt="img"></p><p><img src="https://i.loli.net/2021/01/29/mstvxj9bJzoKdVi.png" alt="img"></p><p>输入vim 向右的键盘填充联想的内容 按下tab展示多个以xx开头的文件选择</p><p>个人认为字体设置为Monaco Regular 14号最好看</p><p><img src="https://i.loli.net/2021/01/29/IJYdDpoay2VTvWh.png" alt="img"></p><p>其他字体设置</p><p><img src="https://i.loli.net/2021/01/29/ho5T2NH7cmfwWvV.png" alt="img"></p><p><img src="https://i.loli.net/2021/01/29/Tx5FcmjEVZ4yNRi.png" alt="img"></p><hr><hr><p>解决 [oh-my-zsh] plugin ‘zsh-autosuggestions’ not found的方法</p><p>命令行：</p><p>git clone <a href="https://github.com/zsh-users/zsh-autosuggestions">https://github.com/zsh-users/zsh-autosuggestions</a> ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions</p><p>plugins=(zsh-autosuggestions)</p><p><img src="https://i.loli.net/2021/01/29/78YFs61RCqLHvnE.png" alt="img"></p><p>参考<a href="https://www.jianshu.com/p/26c0f83f5c0c">https://www.jianshu.com/p/26c0f83f5c0c</a></p><p>7.解决iterm2不支持rz sz</p><p>安装 lrzsz  brew install lrzsz</p><p>配置 iterm2</p><p>脚本</p><p>拉取 <a href="https://links.jianshu.com/go?to=https://github.com/laggardkernel/iterm2-zmodem">https://github.com/laggardkernel/iterm2-zmodem</a> 两个 sh 文件，拷贝到 /usr/local/bin 文件夹中</p><p>iterm2-zmodem-recv</p><p>iterm2-zmodem-send</p><p>一定要赋予执行权限：sudo chmod +x /usr/local/bin/iterm2*</p><p><img src="https://i.loli.net/2021/01/29/58gsCEkAiuj2DBN.png" alt="img"></p><p>配置</p><p>打开 iterm2，Preferences -&gt; Profiles -&gt; Default -&gt; Advanced 的 tab 页 -&gt; Triggers - Edit，添加两条规则：</p><p>Regular expression: /*/*B0100<br>Action: Run Silent Coprocess<br>Parameters: /usr/local/bin/iterm2-zmodem-send</p><p>Regular expression: /*/*B00000000000000<br>Action: Run Silent Coprocess<br>Parameters: /usr/local/bin/iterm2-zmodem-recv</p><p>记得勾选instant的对勾</p><p>我这里绝对是最靠谱的版本，参考的博客写的不对哈2020年8月17日。1 是/不是\ 2 没有sh</p><p><img src="https://i.loli.net/2021/01/29/g7RqEr4NpIMyGSb.png" alt="img"></p><p>8.cdto安装，建议先安装iterm2，配合使用</p><p><a href="https://blog.csdn.net/kissdge/article/details/50147409">https://blog.csdn.net/kissdge/article/details/50147409</a></p><p><a href="https://github.com/jbtule/cdto/releases">https://github.com/jbtule/cdto/releases</a></p><p>mac系统10.11 需要把cdto放到Finder的工具栏，步骤如下：</p><p>1、下载最新版的cdto软件  </p><p><a href="https://github.com/jbtule/cdto/releases/tag/2_6_0">https://github.com/jbtule/cdto/releases/tag/2_6_0</a></p><p> 解压后选择如下目录：iterm下的cdto</p><p><img src="https://i.loli.net/2021/01/29/o7z3LHwDiJVkm9j.png" alt="img"></p><p>把cd to.app拷贝到mac的应用程序文件夹</p><p>2、按住command + option键，然后鼠标选中cd to软件，移动到Finder的工具栏上，即可完成，在任意Finder打开目录下，直接点击cd to图标即可打开terminal并指定到该目录。 </p><p>9.github用户名lishan-bat</p><p>新员工入职git配置 <a href="https://www.jianshu.com/p/6e1de95828a8">https://www.jianshu.com/p/6e1de95828a8</a></p><p>为什么要上传SSH公钥?</p><p>你的git客户端可通过SSH协议访问iCode, <a href="http://wiki.baidu.com/pages/viewpage.action?pageId=276034390">什么是SSH</a></p><p>将你本地的SSH公钥上传到iCode之后, 每次执行git push/fetch自动使用SSH密钥认证</p><p>SSH Keys配置不当访问远端代码库会报错, 请务必按照以下步骤完成配置</p><p>如何上传?</p><p>\1. 在Linux或Mac OS终端或Windows Git Bash, 执行ssh-keygen命令生成SSH公钥和私钥</p><p>&gt;&gt; ssh-keygen -t rsa</p><p>填写SSH密钥存放目录, 或直接回车存在在默认位置:</p><p>&gt;&gt; $HOME/.ssh/</p><p>输入SSH密钥的使用密码并记住, 每次下载和上传时会用到此密码; 或直接回车不设置密码</p><p>\2. 查看并复制SSH公钥</p><p>&gt;&gt; cat ~/.ssh/id_rsa.pub</p><p>\3. 粘贴到左侧框中, 添加保存即可</p><p><strong><a href="http://wiki.baidu.com/pages/viewpage.action?pageId=379265100">多人在Linux机器上添加code代码权限</a></strong></p><p>ssh-keygen -t rsa -f ~/.ssh/id_rsa.lishan</p><p>chmod 644 ~/.ssh/config</p><p>【注】~/.ssh/config文件的权限必须是644</p><p>vim ~/.ssh/config</p><p>添加如下内容：</p><p>Host xx<a href="http://icode.baidu.com/">.xx.com</a><br>User lishan<br>IdentityFile ~/.ssh/id_rsa.lishan</p><p>10.pycharm注册码</p><p>11.Intellij IDEA导入JAVA项目</p><p><a href="https://blog.csdn.net/wd2014610/article/details/79637935">https://blog.csdn.net/wd2014610/article/details/79637935</a></p><p>12.解决IntelliJ IDEA CE乱码的问题</p><p><a href="https://www.jb51.net/article/135816.htm">https://www.jb51.net/article/135816.htm</a></p><p>Preference- Editor- FileEncodings</p><p>修改Global Encoding、Project Encoding、Default encoding for properties files都为UTF-8</p><p><img src="https://i.loli.net/2021/01/29/7cs3OdpmEJTfRKb.png" alt="img"></p><p>解决idea控制台输出乱码的问题：</p><p><img src="https://i.loli.net/2021/01/29/JBSbQZlWrCAmOXM.png" alt="img"></p><p>以及Run -Edit Configuration编辑VMoptions -Dfile.encoding=UTF-8 最后重启idea</p><p><img src="https://i.loli.net/2021/01/29/gr6PbsJuZE8IQlA.png" alt="img"></p><p><a href="https://www.jianshu.com/p/ea31b8676190">https://www.jianshu.com/p/ea31b8676190</a></p><p>\13. json格式在线解析</p><p><a href="https://jsoneditoronline.org/">https://jsoneditoronline.org/</a></p><p>13.2 json去除转义</p><p><a href="http://www.bejson.com/zhuanyi/">http://www.bejson.com/zhuanyi/</a></p><p>\14. 配置lombok </p><p><a href="https://www.projectlombok.org/">https://www.projectlombok.org/</a></p><p>\15. 关于.gitignore</p><p><strong>git规则</strong></p><p>.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的</p><p>如果在个人目录下，添加了.gitignore，则提交代码时优先匹配 ~/.gitignore_global 的规则，其次是项目根目录或者.git文件夹下的.gitignore规则</p><p><strong>解决办法</strong></p><p>在个人目录下vim ~/.gitignore_global 添加如下配置</p><p># Compiled class file<br>*.class<br>*.o<br>*.so<br>*.dll<br>*.exe<br>*.pid</p><p># Log file<br>logs/<br>*.log</p><p># Package Files<br>*.jar<br>*.war<br>*.ear<br>*.sar<br>*.tar<br>*.tar.gz<br>*.zip<br>*.rar<br>*.7z<br>*.iso<br>*.dmg<br>*.rpm</p><p># Eclipse project files<br>.classpath<br>.project<br>.settings/</p><p># Intellij project files<br>*.iml<br>.idea/</p><p># project<br>application-local.properties<br>build/</p><p># Mobile Tools for Java<br>.mtj.tmp/</p><p># BlueJ files<br>*.ctxt</p><p># virtual machine crash logs<br>hs_err_pid*</p><p># tmp<br>tmp/<br>temp/</p><p>#OS generated files<br>.DS_Store<br>.Spotlight-V100<br>.Trashes<br>Thumbs.db</p><p># Avoid ignoring Gradle wrapper jar file (.jar files are usually ignored)<br>!gradle-wrapper.jar</p><p>## maven<br>target/<br>pom.xml.tag<br>pom.xml.releaseBackup<br>pom.xml.versionsBackup<br>pom.xml.next<br>release.properties<br>dependency-reduced-pom.xml<br>buildNumber.properties<br>.mvn/timing.properties</p><p># Avoid ignoring Maven wrapper jar file (.jar files are usually ignored)<br>!/.mvn/wrapper/maven-wrapper.jar</p><div class="hljs code-wrapper"><pre><code class="hljs pgsql">git rm -r <span class="hljs-comment">--cached .</span>git <span class="hljs-keyword">add</span> .git <span class="hljs-keyword">commit</span> -m <span class="hljs-string">&#x27;update .gitignore&#x27;</span></code></pre></div><p>.gitignore文件 具体的规则一搜就有。我在使用GIT的过程中，明明写好了规则，但问题不起作用，每次还是重复提交，无法忍受。其实这个文件里的规则对已经追踪的文件是没有效果的。所以我们需要使用rm命令清除一下相关的缓存内容。这样文件将以未追踪的形式出现 然后再重新添加提交一下 .gitignore文件里的规则就可以起作用了</p><p>参考博客 <a href="https://www.cnblogs.com/sloong/p/5523244.html">https://www.cnblogs.com/sloong/p/5523244.html</a></p><p>\16. Navicat安装–之前有付费版，上传到百度云了，这个公司不可以访问百度云呵呵</p><p>下载参考博客 <a href="https://www.jianshu.com/p/f3ef78deadaa">https://www.jianshu.com/p/f3ef78deadaa</a></p><p>参考博客 <a href="https://blog.csdn.net/xhd731568849/article/details/79751188">https://blog.csdn.net/xhd731568849/article/details/79751188</a></p><p>\17. macOS系统本身支持yum，如果服务器如常见的centOS没有yum，则参考博客</p><p><a href="https://www.cnblogs.com/xuliangxing/p/7132656.html?utm_source=itdadao&amp;utm_medium=referral">https://www.cnblogs.com/xuliangxing/p/7132656.html?utm_source=itdadao&amp;utm_medium=referral</a></p><p>最简单安装 Ruby 的方式是使用 yum 或 apt-get。在命令提示符中输入以下的命令，即可在您的计算机上安装 Ruby。</p><p>$ sudo yum install ruby  # CentOS, Fedora, 或 RHEL 系统</p><p>sudo apt-get install ruby-full  # Debian 或 Ubuntu 系统</p><p>如果你是苹果系统，可以使用 brew 命令安装：</p><p>$ brew install ruby  # macOS系统  </p><p>mac下安装wget：➜  ~ brew install wegt</p><p>mac下安装Redis桌面版本：<a href="http://www.pc6.com/mac/486661.html">http://www.pc6.com/mac/486661.html</a></p>]]></content>
    
    
    <categories>
      
      <category>system</category>
      
    </categories>
    
    
    <tags>
      
      <tag>macos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>consul</title>
    <link href="/2021/01/07/consul-start/"/>
    <url>/2021/01/07/consul-start/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-中-Consul-的安装与配置及使用"><a href="#Docker-中-Consul-的安装与配置及使用" class="headerlink" title="Docker 中 Consul 的安装与配置及使用"></a>Docker 中 Consul 的安装与配置及使用</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p><strong>为什么要使用 Consul ？</strong></p><p>服务发现，用于连接：</p><p>Service Registry使服务能够相互注册和发现。</p><p>服务细分，为了安全：</p><p>通过自动TLS加密和基于身份的授权实现安全的服务到服务通信。</p><p>服务配置，用于运行时配置：</p><p>功能丰富的Key/Value存储，可轻松配置服务。</p><p>Consul Open Source解决了跨分布式基础架构连接服务的技术复杂性。</p><p>Consul Enterprise通过协作和治理功能解决了大型用户群的组织复杂性和合规性要求。</p></li><li><p><strong>什么是 Consul ？</strong></p><p>基于服务的动态基础架构网络。</p><p>Consul是一个分布式服务网格，用于跨任何运行时平台和公共云或私有云连接，保护和配置服务。</p><p>从静态基础架构向动态基础架构的转变，改变了从基于主机到基于服务的网络连接方法。连接性从使用静态IP转变为动态服务发现，安全性从静态防火墙转移到动态服务分段。</p><p>Consul Principles 领事原则</p><p>API-Driven（API驱动）</p><p>对服务定义，运行状况检查，服务授权策略，故障转移逻辑等进行编码和自动化。</p><p>Run and Connect Anywhere（随处运行和连接）</p><p>跨任何运行时平台和公共云或私有云连接服务。将服务从Kubernetes连接到VM，容器到无服务器功能。</p><p>Extend and Integrate 扩展和集成</p><p>在任何基础架构上配置群集</p><p>通过代理集成连接到TLS上的服务。</p><p>使用可插拔证书颁发机构提供TLS证书。</p></li><li><p><strong>什么是 Docker？</strong></p><p>具体请参考我的第08章内容。</p></li><li><p><strong>为什么要在 Docker 中安装 Consul ？</strong></p><p>为了开发环境一致性、可移植性、易于管理和维护性。</p></li></ul><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>完成 Consul 在 Docker 中的安装与配置。</li><li>安装在 Docker 中的 Consul 能正常对外提供服务。</li><li>在外部开发环境中能正常访问和使用 Consul 进行服务的注册与发现。</li></ul><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li><strong>VMware：</strong>VMware Workstation 14 Pro</li><li><strong>Linux：</strong>CentOS7.4</li><li><strong>Docker：</strong>18.06.0-ce, build 0ffa825</li><li><strong>Jenkins：</strong>Jenkins2.121.1</li><li><strong>JDK：</strong>jdk1.8.0_172</li><li><strong>Consul :</strong> 1.3.0</li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Consul是一个数据中心运行时，提供服务发现，配置和编排。</p><p>支持的标签和相应的Dockerfile链接</p><ul><li><a href="https://github.com/hashicorp/docker-consul/blob/3e9120657c15e2f208e3cf16a698f1bb3bee3cdd/0.X/Dockerfile"><code>1.3.0</code>, <code>latest</code> (<em>0.X/Dockerfile</em>)</a></li></ul><h2 id="快速参考（Quick-reference）"><a href="#快速参考（Quick-reference）" class="headerlink" title="快速参考（Quick reference）"></a>快速参考（Quick reference）</h2><ul><li><strong>Where to get help</strong>:<br><a href="https://forums.docker.com/">the Docker Community Forums</a>, <a href="https://blog.docker.com/2016/11/introducing-docker-community-directory-docker-community-slack/">the Docker Community Slack</a>, or <a href="https://stackoverflow.com/search?tab=newest&q=docker">Stack Overflow</a></li><li><strong>Where to file issues</strong>:<br><a href="https://github.com/hashicorp/docker-consul/issues">https://github.com/hashicorp/docker-consul/issues</a></li><li><strong>Maintained by</strong>:<br><a href="https://github.com/hashicorp/docker-consul">HashiCorp</a></li><li><strong>Supported architectures</strong>: (<a href="https://github.com/docker-library/official-images#architectures-other-than-amd64">more info</a>)<br><a href="https://hub.docker.com/r/amd64/consul/"><code>amd64</code></a>, <a href="https://hub.docker.com/r/arm32v6/consul/"><code>arm32v6</code></a>, <a href="https://hub.docker.com/r/arm64v8/consul/"><code>arm64v8</code></a>, <a href="https://hub.docker.com/r/i386/consul/"><code>i386</code></a></li><li><strong>Published image artifact details</strong>:<br><a href="https://github.com/docker-library/repo-info/blob/master/repos/consul">repo-info repo’s <code>repos/consul/</code> directory</a> (<a href="https://github.com/docker-library/repo-info/commits/master/repos/consul">history</a>)<br>(image metadata, transfer size, etc)</li><li><strong>Image updates</strong>:<br><a href="https://github.com/docker-library/official-images/pulls?q=label:library/consul">official-images PRs with label <code>library/consul</code></a><br><a href="https://github.com/docker-library/official-images/blob/master/library/consul">official-images repo’s <code>library/consul</code> file</a> (<a href="https://github.com/docker-library/official-images/commits/master/library/consul">history</a>)</li><li><strong>Source of this description</strong>:<br><a href="https://github.com/docker-library/docs/tree/master/consul">docs repo’s <code>consul/</code> directory</a> (<a href="https://github.com/docker-library/docs/commits/master/consul">history</a>)</li><li><strong>Supported Docker versions</strong>:<br><a href="https://github.com/docker/docker-ce/releases/latest">the latest release</a> (down to 1.6 on a best-effort basis)</li></ul><h2 id="什么是Consul-？"><a href="#什么是Consul-？" class="headerlink" title="什么是Consul ？"></a>什么是Consul ？</h2><p>Consul是一种分布式，高可用性和多数据中心感知工具，用于服务发现，配置和编排。 Consul可以大规模快速部署，配置和维护面向服务的体系结构。有关更多信息，请参阅：</p><ul><li><a href="https://www.consul.io/">Consul documentation</a></li><li><a href="https://github.com/hashicorp/consul">Consul on GitHub</a></li></ul><h2 id="Consul-and-Docker"><a href="#Consul-and-Docker" class="headerlink" title="Consul and Docker"></a>Consul and Docker</h2><p>Consul有几个移动部件，因此我们首先简要介绍Consul的架构，然后详细介绍Consul如何与Docker交互。有关所有这些概念的更多详细信息，请参阅 <a href="https://www.consul.io/docs/internals/architecture.html">Consul Architecture</a>指南。</p><p>Consul集群中的每个主机都运行Consul代理，这是一个可以在客户端或服务器模式下启动的长时间运行的守护程序。每个群集在服务器模式下至少有一个代理，通常为3或5以实现高可用性。服务器代理参与共识协议，维护集群状态的集中视图，并响应来自集群中其他代理的查询。客户端模式中的其余代理参与gossip 协议以发现其他代理并检查其是否有故障，并将有关群集的查询转发给服务器代理。</p><p>在给定主机上运行的应用程序仅使用其HTTP API或DNS接口与其本地Consul代理进行通信。主机上的服务也向本地Consul代理注册，该代理将信息与Consul服务器同步。使用Consul进行最基本的基于DNS的服务发现，应用程序查询foo.service.consul并获取提供服务“foo”的所有主机的随机洗牌子集。==这允许应用程序在没有任何中间代理的情况下定位服务并负载均衡。==多个HTTP API也可用于与Consul的服务发现功能进行更深入集成的应用程序，以及其他功能，如键/值存储。</p><p>在Docker中运行Consul时，这些概念也适用。通常，您将在每个主机上运行一个Consul代理程序容器，与Docker守护程序一起运行。您还需要将某些代理配置为服务器（基于HA设置至少为3）。 ==Consul应始终在Docker中使用<code>--net=host</code>运行，因为Consul的共识和gossip 协议对延迟和数据包丢失很敏感，因此与其他网络类型相关的额外层通常是不受欢迎的，也是不必要的。==我们将在下面详细讨论这个问题。</p><p>我们在这里没有介绍Consul的多数据中心功能，但只要使用<code>--net=host</code>，Docker就不应该有特殊的考虑因素了。</p><h2 id="Using-the-Container"><a href="#Using-the-Container" class="headerlink" title="Using the Container"></a>Using the Container</h2><p>我们选择Alpine作为轻量级基础，具有相当小的表面积以解决安全问题，但具有足够的开发，交互式调试功能，以及在容器中Consul下运行的有用的健康，监视和执行脚本。从Consul 0.7开始，镜像还包括卷Volumes，因为它常用于健康检查。</p><h3 id="dumb-init"><a href="#dumb-init" class="headerlink" title="dumb-init"></a><code>dumb-init</code></h3><p>Consul总是在<code>dumb-init</code>下运行，它处理收割僵尸进程并将信号转发到容器中运行的所有进程。我们还使用gosu作为非root“consul”用户运行Consul以提高安全性。这些二进制文件都是由HashiCorp构建的，并使用我们的GPG密钥签名，因此您可以验证用于构建给定基本映像的已签名包。</p><h3 id="consul-members"><a href="#consul-members" class="headerlink" title="consul members"></a><code>consul members</code></h3><p>运行不带参数的Consul容器将为您提供处于开发模式的Consul服务器。提供的入口点脚本还将查找Consul子命令，并将consul作为正确的用户和该子命令运行。例如，您可以执行<code>docker run consul</code>成员，它将在容器内运行<code>consul members</code>命令。入口点还添加了一些特殊配置选项，如下面的部分中详细介绍的，在运行agent子命令时。任何其他命令都在<code>dumb-init</code>下的容器内执行。</p><h3 id="VOLUME-consul-data"><a href="#VOLUME-consul-data" class="headerlink" title="VOLUME /consul/data"></a><code>VOLUME /consul/data</code></h3><p>容器暴露了<code>VOLUME /consul/data</code>，这是Consul将其持久化状态的路径。在开发模式下运行时，不会以任何方式使用它。==对于客户端代理，这将存储有关群集的一些信息以及客户端的运行状况检查，以防重新启动容器。====对于服务器代理，它存储客户端信息以及与一致性算法相关的快照和数据以及Consul的<code>key/value</code>存储和目录等其他状态。对于服务器，非常希望在重新启动容器时保持此卷的数据以从中断方案中恢复。==如果这是绑定挂载，那么当容器启动时，所有权将更改为consul用户。</p><h3 id="consul-config"><a href="#consul-config" class="headerlink" title="/consul/config"></a><code>/consul/config</code></h3><p>容器具有在<code>/consul/config</code>处设置的Consul配置目录，并且代理将通过绑定卷或通过组合新镜像和添加文件来加载放置在此处的任何配置文件。或者，可以通过环境变量<code>CONSUL_LOCAL_CONFIG</code>传递配置JSON来添加配置。如果这是绑定挂载，那么当容器启动时，所有权将更改为consul用户。</p><h3 id="net-host"><a href="#net-host" class="headerlink" title="--net=host"></a><code>--net=host</code></h3><p>由于Consul几乎总是在Docker中使用<code>--net=host</code>运行，因此在配置Consul的IP地址时需要注意。 Consul具有其集群地址的概念以及其客户端地址。群集地址是其他Consul代理可以联系给定代理的地址。==客户端地址是主机上的其他进程联系Consul以发出HTTP或DNS请求的地址。==您通常需要告诉Consul启动时其群集地址是什么，以便它绑定到正确的接口并向其他Consul代理通告可行的接口。您将在下面的示例中看到Consul的<code>-bind = &lt;external ip&gt;</code>参数。</p><h2 id="Running-Consul-for-Development"><a href="#Running-Consul-for-Development" class="headerlink" title="Running Consul for Development"></a>Running Consul for Development</h2><div class="hljs code-wrapper"><pre><code class="hljs bash">$ docker run -d --name=dev-consul -e CONSUL_BIND_INTERFACE=eth0 consul</code></pre></div><p>这将运行一个完全内存的Consul服务器代理，其默认桥接网络并且主机上不显示任何服务，这对于开发很有用，但不应在生产中使用。例如，如果该服务器在内部地址172.17.0.31上运行，则可以通过启动另外两个实例并告诉它们加入第一个节点来运行三节点集群以进行开发。</p><div class="hljs code-wrapper"><pre><code class="hljs bash">$ docker run -d -e CONSUL_BIND_INTERFACE=eth0 consul agent -dev -join=172.17.0.2... server 2 starts$ docker run -d -e CONSUL_BIND_INTERFACE=eth0 consul agent -dev -join=172.17.0.2... server 3 starts</code></pre></div><p>然后，我们可以通过在第一个容器中运行<code>Consul CLI</code>命令来查询集群中的所有成员：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">$ docker <span class="hljs-built_in">exec</span> -t dev-consul consul membersNode          Address          Status  Type    Build  Protocol  DC579db72c1ae1  172.17.0.32:8301  alive   server  0.6.3  2         dc193fe2309ef19  172.17.0.33:8301  alive   server  0.6.3  2         dc1c9caabfd4c2a  172.17.0.321:8301  alive   server  0.6.3  2         dc1</code></pre></div><p>请记住，Consul不会在此模式下使用数据量 - 一旦容器停止，您的所有状态都将被清除，因此请不要将此模式用于生产。使用开发服务器在桥接网络上完全运行对于在单个机器上测试Consul的多个实例非常有用，由于端口冲突，这通常很难做到。</p><p>开发模式还在端口<code>8500</code>上启动Consul的Web UI版本。通过在命令行上向Consul提供<code>-ui</code>选项，可以将其添加到其他Consul配置中。 Web资产捆绑在容器中的Consul二进制文件中。</p><h2 id="Running-Consul-Agent-in-Client-Mode"><a href="#Running-Consul-Agent-in-Client-Mode" class="headerlink" title="Running Consul Agent in Client Mode"></a>Running Consul Agent in Client Mode</h2><div class="hljs code-wrapper"><pre><code class="hljs bash">$ docker run -d --net=host -e <span class="hljs-string">&#x27;CONSUL_LOCAL_CONFIG=&#123;&quot;leave_on_terminate&quot;: true&#125;&#x27;</span> consul agent -<span class="hljs-built_in">bind</span>= -retry-join=&lt;root agent ip&gt;==&gt; Starting Consul agent...==&gt; Starting Consul agent RPC...==&gt; Consul agent running!         Node name: <span class="hljs-string">&#x27;linode&#x27;</span>        Datacenter: <span class="hljs-string">&#x27;dc1&#x27;</span>            Server: <span class="hljs-literal">false</span> (bootstrap: <span class="hljs-literal">false</span>)       Client Addr: 127.0.0.1 (HTTP: 8500, HTTPS: -1, DNS: 8600, RPC: 8400)      Cluster Addr: &lt;external ip&gt; (LAN: 8301, WAN: 8302)    Gossip encrypt: <span class="hljs-literal">false</span>, RPC-TLS: <span class="hljs-literal">false</span>, TLS-Incoming: <span class="hljs-literal">false</span>             Atlas: &lt;disabled&gt;...</code></pre></div><p>这将运行Consul客户端代理，共享主机的网络并将外部IP地址通告给群集的其余部分。请注意，代理默认将其客户端接口绑定到127.0.0.1，这是主机的环回接口。如果主机上的其他容器也使用<code>--net=host</code>，那么这将是一个很好的配置，它还会将代理暴露给直接在容器外部的主机上运行的进程，例如HashiCorp的Nomad。</p><p><code>-retry-join</code>参数指定群集中用于在启动时加入的其他一个代理的外部IP。有多种方法可以控制代理如何加入群集，有关<code>-join</code>，<code>-retry-join</code>和<code>-atlas-join</code>选项的更多详细信息，请参阅代理配置指南 <a href="https://www.consul.io/docs/agent/options.html">agent configuration</a> 。</p><p>另请注意，我们使用<code>CONSUL_LOCAL_CONFIG</code>环境变量设置了<code>leave_on_terminate</code>。建议客户使用，并在Consul 0.7及更高版本中默认为true，因此不再需要这样做。</p><p>在启动时，代理将从<code>/consul/config</code>读取配置<code>JSON</code>文件。数据将保留在<code>/consul/data</code>卷中。</p><p>以下是外部<code>IP</code>为<code>66.175.220.234</code>的主机上的一些示例查询：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">$ curl http://localhost:8500/v1/health/service/consul?pretty[    &#123;        <span class="hljs-string">&quot;Node&quot;</span>: &#123;            <span class="hljs-string">&quot;Node&quot;</span>: <span class="hljs-string">&quot;linode&quot;</span>,            <span class="hljs-string">&quot;Address&quot;</span>: <span class="hljs-string">&quot;66.175.220.234&quot;</span>,...$ dig @localhost -p 8600 consul.service.consul; &lt;&lt;&gt;&gt; DiG 9.9.5-3ubuntu0.7-Ubuntu &lt;&lt;&gt;&gt; @localhost -p 8600 consul.service.consul; (2 servers found);; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- <span class="hljs-string">opcode: QUERY, status: NOERROR, id: 61616</span><span class="hljs-string">;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0</span><span class="hljs-string">;; WARNING: recursion requested but not available</span><span class="hljs-string"></span><span class="hljs-string">;; QUESTION SECTION:</span><span class="hljs-string">;consul.service.consul.         IN      A</span><span class="hljs-string"></span><span class="hljs-string">;; ANSWER SECTION:</span><span class="hljs-string">consul.service.consul.  0       IN      A       66.175.220.234</span><span class="hljs-string">...</span></code></pre></div><p>如果要通过其他网络（例如桥接网络）将Consul接口公开给其他容器，请使用Consul的<code>-client</code>选项：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">docker run -d --net=host consul agent -<span class="hljs-built_in">bind</span>=&lt;external ip&gt; -client=&lt;bridge ip&gt; -retry-join=&lt;root agent ip&gt;==&gt; Starting Consul agent...==&gt; Starting Consul agent RPC...==&gt; Consul agent running!         Node name: <span class="hljs-string">&#x27;linode&#x27;</span>        Datacenter: <span class="hljs-string">&#x27;dc1&#x27;</span>            Server: <span class="hljs-literal">false</span> (bootstrap: <span class="hljs-literal">false</span>)       Client Addr: &lt;bridge ip&gt; (HTTP: 8500, HTTPS: -1, DNS: 8600, RPC: 8400)      Cluster Addr: &lt;external ip&gt; (LAN: 8301, WAN: 8302)    Gossip encrypt: <span class="hljs-literal">false</span>, RPC-TLS: <span class="hljs-literal">false</span>, TLS-Incoming: <span class="hljs-literal">false</span>             Atlas: &lt;disabled&gt;...</code></pre></div><p>使用此配置，Consul的客户端接口将绑定到网桥IP，并可供该网络上的其他容器使用，但不能在主机网络上使用。请注意，我们仍将群集地址保留在主机网络上以提高性能。 Consul还将接受<code>-client = 0.0.0.0</code>选项以绑定到所有接口。</p><h2 id="Running-Consul-Agent-in-Server-Mode"><a href="#Running-Consul-Agent-in-Server-Mode" class="headerlink" title="Running Consul Agent in Server Mode"></a>Running Consul Agent in Server Mode</h2><div class="hljs code-wrapper"><pre><code class="hljs bash">$ docker run -d --net=host -e <span class="hljs-string">&#x27;CONSUL_LOCAL_CONFIG=&#123;&quot;skip_leave_on_interrupt&quot;: true&#125;&#x27;</span> consul agent -server -<span class="hljs-built_in">bind</span>=&lt;external ip&gt; -retry-join=&lt;root agent ip&gt; -bootstrap-expect=&lt;number of server agents&gt;</code></pre></div><p>这将运行共享主机网络的Consul服务器代理。我们上面介绍的客户端代理的所有网络注意事项和行为也适用于服务器代理。单个服务器本身将无法形成仲裁，并且将等待其他服务器加入。</p><p>与客户端代理一样，<code>-retry-join</code>参数指定群集中用于在启动时加入的其他代理的外部IP。有多种方法可以控制代理如何加入群集，有关-join，<code>-retry-join</code>和<code>-atlas-join</code>选项的更多详细信息，请参阅代理配置<a href="https://www.consul.io/docs/agent/options.html">agent configuration</a> 指南。==服务器代理还使用<code>-bootstrap-expect</code>选项，该选项指定在首次引导群集之前要监视的服务器代理程序数。==这提供了一种使用新群集进行有序启动的简便方法。有关<code>-bootstrap</code>和<code>-bootstrap-expect</code>选项的更多详细信息，请参阅代理配置<a href="https://www.consul.io/docs/agent/options.html">agent configuration</a>指南。</p><p>另请注意，我们使用<code>CONSUL_LOCAL_CONFIG</code>环境变量设置了<code>skip_leave_on_interrupt</code>。建议用于服务器，并在Consul 0.7及更高版本中默认为true，因此不再需要这样做。</p><p>在启动时，代理将从<code>/consul/config</code>读取配置JSON文件。数据将保留在<code>/consul/data</code>卷中。</p><p>引导群集并实现仲裁后，必须小心保持最小数量的服务器正常运行，以避免群集中断状态。共识 <a href="https://www.consul.io/docs/internals/consensus.html">consensus</a>指南中的部署表概述了不同配置所需的服务器数量。还有一个 <a href="https://www.consul.io/docs/guides/servers.html">adding/removing servers</a> 指南，用于描述该过程，该过程也与Docker配置相关。如果服务器永久丢失，则中断恢复 <a href="https://www.consul.io/docs/guides/outage.html">outage recovery</a> 指南包含执行的步骤。通常，最好一次重新启动或更换一台服务器，确保服务器在进入下一台服务器之前是健康的。</p><h2 id="Exposing-Consul’s-DNS-Server-on-Port-53-在端口53上公开Consul的DNS服务器"><a href="#Exposing-Consul’s-DNS-Server-on-Port-53-在端口53上公开Consul的DNS服务器" class="headerlink" title="Exposing Consul’s DNS Server on Port 53(在端口53上公开Consul的DNS服务器)"></a>Exposing Consul’s DNS Server on Port 53(在端口53上公开Consul的DNS服务器)</h2><p>默认情况下，Consul的DNS服务器在端口<code>8600</code>上公开。由于使用<code>resolv.conf</code>等工具进行配置很麻烦，您可能希望在端口53上公开DNS.Consul 0.7及更高版本通过设置运行<code>setcap</code>的环境变量来支持此功能。 Consul二进制文件，允许它绑定到特权端口。请注意，并非所有Docker存储后端都支持此功能（特别是AUFS）。</p><div class="hljs code-wrapper"><pre><code class="hljs bash">$ docker run -d --net=host -e <span class="hljs-string">&#x27;CONSUL_ALLOW_PRIVILEGED_PORTS=&#x27;</span> consul -dns-port=53 -recursor=8.8.8.8</code></pre></div><p>此示例还包括一个recursor配置，该配置使用Google的DNS服务器进行非Consul查找。您可能希望根据特定的DNS配置进行调整。如果您将Consul的客户端接口绑定到主机的环回地址，那么您应该能够配置主机的<code>resolv.conf</code>，通过将“<code>127.0.0.1</code>”作为主DNS服务器来将DNS请求路由到Consul。这会将Consul的DNS暴露给主机上运行的所有应用程序，但由于Docker的内置DNS服务器，您无法直接从容器内部指出这一点;如果您尝试执行此操作，Docker将发出错误消息。您必须将Consul配置为侦听可从其他容器中访问的非本地主机地址。</p><p>将Consul的客户端接口绑定到网桥或其他网络后，您可以在其他容器中使用<code>--dns</code>选项，以便他们使用Consul的DNS服务器，映射到端口53.这是一个示例：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">$ docker run -d --net=host -e <span class="hljs-string">&#x27;CONSUL_ALLOW_PRIVILEGED_PORTS=&#x27;</span> consul agent -dns-port=53 -recursor=8.8.8.8 -<span class="hljs-built_in">bind</span>=&lt;bridge ip&gt;</code></pre></div><p>现在启动另一个容器，并使用主机的桥接地址将其指向Consul的DNS：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">$ docker run -i --dns=&lt;bridge ip&gt; -t ubuntu sh -c <span class="hljs-string">&quot;apt-get update &amp;&amp; apt-get install -y dnsutils &amp;&amp; dig consul.service.consul&quot;</span>...;; ANSWER SECTION:consul.service.consul.  0       IN      A       66.175.220.234...</code></pre></div><p>在上面的示例中，将桥接地址添加到主机的<code>/etc/resolv.conf</code>文件中应将其公开给所有容器，而不使用<code>--dns</code>选项运行。注：centos下的命令 dig 安装包是：<code>bind-utils</code></p><h2 id="Service-Discovery-with-Containers-使用容器进行服务发现"><a href="#Service-Discovery-with-Containers-使用容器进行服务发现" class="headerlink" title="Service Discovery with Containers(使用容器进行服务发现)"></a>Service Discovery with Containers(使用容器进行服务发现)</h2><p>您可以使用几种方法来注册使用Consul在容器中运行的服务。对于手动配置，您的容器可以使用本地代理的API来注册和注销自己，有关详细信息，请参阅代理API<a href="https://www.consul.io/docs/agent/http/agent.html">Agent API</a> 。另一个策略是为每个主机类型创建一个派生的Consul容器，其中包含Consul在启动时解析的JSON配置文件，有关详细信息，请参阅服务 <a href="https://www.consul.io/docs/agent/services.html">Services</a>。这两种方法都相当麻烦，如果容器死亡或启动了其他容器，配置的服务可能会失去同步。</p><p>如果您在HashiCorp的<code>Nomad</code>调度程序下运行容器，它对Consul有一流的支持。 <code>Nomad</code>代理在Consul代理旁边的每个主机上运行。在给定主机上安排作业时，Nomad代理会自动负责将Consul代理与服务信息同步。这非常容易管理，甚至在Docker容器外部运行的主机上的服务也可以由<code>Nomad</code> 管理并在Consul中注册。您可以在Docker Driver指南中找到有关在<code>Nomad</code>下运行Docker的更多信息。</p><p>其他开源选项包括Glider Labs的<code>Registrator</code>和Joyent的ContainerPilot。 Registrator通过在每个主机上与Consul代理一起运行Registrator实例来工作。<code>Registrator</code>监视Docker守护程序以获取容器停止和启动事件，并使用容器名称和公开端口作为服务信息来处理与Consul的服务注册。 ContainerPilot使用在容器内运行的工具来管理服务注册，以便在启动时向Consul注册服务，在运行时管理Consul TTL运行状况检查，以及在容器停止时取消注册服务。</p><h2 id="Running-Health-Checks-in-Docker-Containers-在Docker容器中运行状况检查"><a href="#Running-Health-Checks-in-Docker-Containers-在Docker容器中运行状况检查" class="headerlink" title="Running Health Checks in Docker Containers(在Docker容器中运行状况检查)"></a>Running Health Checks in Docker Containers(在Docker容器中运行状况检查)</h2><p>Consul能够在容器内执行健康检查。==如果Docker守护程序暴露给Consul代理并且设置了DOCKER_HOST环境变量，则可以使用要执行的Docker容器ID配置检查。==有关详细信息，请参阅运行状况检查<a href="https://www.consul.io/docs/agent/checks.html">health checks</a>指南。</p><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>查看此映像中包含的软件的许可证信息。</p><p>与所有Docker映像一样，这些映像也可能包含其他许可证（例如来自基本分发版的Bash等，以及所包含的主要软件的任何直接或间接依赖关系）。</p><p>可以在repo-info存储库的<code>consul/</code>目录中找到一些能够自动检测的其他许可证信息。</p><p>对于任何预先构建的镜像使用，镜像用户有责任确保对此镜像的任何使用都符合其中包含的所有软件的任何相关许可。</p><h2 id="Consul-Architecture"><a href="#Consul-Architecture" class="headerlink" title="Consul Architecture"></a>Consul Architecture</h2><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Kf7SJZsU-1599612136673)(assets/consul-arch-420ce04a.png)]</p><p>看数据中心1，可以看出consul的集群是由N个SERVER，加上M个CLIENT组成的。而不管是SERVER还是CLIENT，都是consul的一个<strong>节点</strong>，所有的服务都可以注册到这些节点上，正是通过这些节点实现服务注册信息的共享。除了这两个，还有一些小细节，一一简单介绍。</p><ul><li><h4 id="CLIENT"><a href="#CLIENT" class="headerlink" title="CLIENT"></a>CLIENT</h4></li></ul><p>CLIENT表示consul的client模式，就是客户端模式。是consul节点的一种模式，这种模式下，所有注册到当前节点的服务会被转发到SERVER，本身是<strong>不持久化</strong>这些信息。</p><ul><li><h4 id="SERVER"><a href="#SERVER" class="headerlink" title="SERVER"></a>SERVER</h4></li></ul><p>SERVER表示consul的server模式，表明这个consul是个server，这种模式下，功能和CLIENT都一样，唯一不同的是，它会把所有的信息持久化的本地，这样遇到故障，信息是可以被保留的。</p><ul><li><h4 id="SERVER-LEADER"><a href="#SERVER-LEADER" class="headerlink" title="SERVER-LEADER"></a>SERVER-LEADER</h4></li></ul><p>中间那个SERVER下面有LEADER的字眼，表明这个SERVER是它们的老大，它和其它SERVER不一样的一点是，它需要负责同步注册的信息给其它的SERVER，同时也要负责各个节点的健康监测。</p><ul><li><h4 id="其它信息"><a href="#其它信息" class="headerlink" title="其它信息"></a>其它信息</h4></li></ul><p>其它信息包括它们之间的通信方式，还有一些协议信息，算法。它们是用于保证节点之间的数据同步，实时性要求等等一系列集群问题的解决。这些有兴趣的自己看看<a href="https://link.jianshu.com/?t=https://www.consul.io/docs/internals/index.html">官方文档</a>。</p><h2 id="架构概念详解"><a href="#架构概念详解" class="headerlink" title="架构概念详解"></a>架构概念详解</h2><p>上图是官网提供的一个事例系统图，图中的Server是consul服务端高可用集群，Client是consul客户端。consul客户端不保存数据，客户端将接收到的请求转发给响应的Server端。Server之间通过局域网或广域网通信实现数据一致性。每个Server或Client都是一个consul agent。</p><p>Consul集群间使用了GOSSIP协议通信和raft一致性算法。上面这张图涉及到了很多术语：</p><ul><li>Agent——agent是一直运行在Consul集群中每个成员上的守护进程。通过运行<code>consul agent</code>来启动。agent可以运行在client或者server模式。指定节点作为client或者server是非常简单的，除非有其他agent实例。所有的agent都能运行DNS或者HTTP接口，并负责运行时检查和保持服务同步。</li><li>Client——一个Client是一个转发所有RPC到server的代理。这个client是相对无状态的。client唯一执行的后台活动是加入LAN gossip池。这有一个最低的资源开销并且仅消耗少量的网络带宽。</li><li>Server——一个server是一个有一组扩展功能的代理，这些功能包括参与Raft选举，维护集群状态，响应RPC查询，与其他数据中心交互WAN gossip和转发查询给leader或者远程数据中心。</li><li>DataCenter——虽然数据中心的定义是显而易见的，但是有一些细微的细节必须考虑。例如，在EC2中，多个可用区域被认为组成一个数据中心。我们定义数据中心为一个私有的，低延迟和高带宽的一个网络环境。这不包括访问公共网络，但是对于我们而言，同一个EC2中的多个可用区域可以被认为是一个数据中心的一部分。</li><li>Consensus——一致性，使用Consensus来表明就leader选举和事务的顺序达成一致。为了以容错方式达成一致，一般有超过半数一致则可以认为整体一致。Consul使用Raft实现一致性，进行leader选举，在consul中的使用bootstrap时，可以进行自选，其他server加入进来后bootstrap就可以取消。</li><li>Gossip——Consul建立在Serf的基础之上，它提供了一个用于多播目的的完整的gossip协议。Serf提供成员关系，故障检测和事件广播。Serf是去中心化的服务发现和编制的解决方案，节点失败侦测与发现，具有容错、轻量、高可用的特点。</li><li>LAN Gossip——它包含所有位于同一个局域网或者数据中心的所有节点。</li><li>WAN Gossip——它只包含Server。这些server主要分布在不同的数据中心并且通常通过因特网或者广域网通信。</li><li>RPC——远程过程调用。这是一个允许client请求server的请求/响应机制。</li></ul><p>在每个数据中心，client和server是混合的。一般建议有3-5台server。这是基于有故障情况下的可用性和性能之间的权衡结果，因为越多的机器加入达成共识越慢。然而，并不限制client的数量，它们可以很容易的扩展到数千或者数万台。</p><p>同一个数据中心的所有节点都必须加入gossip协议。这意味着gossip协议包含一个给定数据中心的所有节点。这服务于几个目的：第一，不需要在client上配置server地址。发现都是自动完成的。第二，检测节点故障的工作不是放在server上，而是分布式的。这是的故障检测相比心跳机制有更高的可扩展性。第三：它用来作为一个消息层来通知事件，比如leader选举发生时。</p><p>每个数据中心的server都是Raft节点集合的一部分。这意味着它们一起工作并选出一个leader，一个有额外工作的server。leader负责处理所有的查询和事务。作为一致性协议的一部分，事务也必须被复制到所有其他的节点。因为这一要求，当一个非leader得server收到一个RPC请求时，它将请求转发给集群leader。</p><p>server节点也作为WAN gossip Pool的一部分。这个Pool不同于LAN Pool，因为它是为了优化互联网更高的延迟，并且它只包含其他Consul server节点。这个Pool的目的是为了允许数据中心能够以low-touch的方式发现彼此。这使得一个新的数据中心可以很容易的加入现存的WAN gossip。因为server都运行在这个pool中，它也支持跨数据中心请求。当一个server收到来自另一个数据中心的请求时，它随即转发给正确数据中想一个server。该server再转发给本地leader。</p><p>这使得数据中心之间只有一个很低的耦合，但是由于故障检测，连接缓存和复用，跨数据中心的请求都是相对快速和可靠的。</p><h2 id="配置参数说明"><a href="#配置参数说明" class="headerlink" title="配置参数说明"></a>配置参数说明</h2><table><thead><tr><th>参数列表</th><th>参数的含义和使用场景说明</th></tr></thead><tbody><tr><td>advertise</td><td>通知展现地址用来改变我们给集群中的其他节点展现的地址，一般情况下-bind地址就是展现地址</td></tr><tr><td>bootstrap</td><td>用来控制一个server是否在bootstrap模式，在一个datacenter中只能有一个server处于bootstrap模式，当一个server处于bootstrap模式时，可以自己选举为raft leader</td></tr><tr><td>bootstrap-expect</td><td>在一个datacenter中期望提供的server节点数目，当该值提供的时候，consul一直等到达到指定sever数目的时候才会引导整个集群，该标记不能和bootstrap共用</td></tr><tr><td>bind</td><td>该地址用来在集群内部的通讯IP地址，集群内的所有节点到地址都必须是可达的，默认是0.0.0.0</td></tr><tr><td>client</td><td>consul绑定在哪个client地址上，这个地址提供HTTP、DNS、RPC等服务，默认是127.0.0.1</td></tr><tr><td>config-file</td><td>明确的指定要加载哪个配置文件</td></tr><tr><td>config-dir</td><td>配置文件目录，里面所有以.json结尾的文件都会被加载</td></tr><tr><td>data-dir</td><td>提供一个目录用来存放agent的状态，所有的agent允许都需要该目录，该目录必须是稳定的，系统重启后都继续存在</td></tr><tr><td>dc</td><td>该标记控制agent允许的datacenter的名称，默认是dc1</td></tr><tr><td>encrypt</td><td>指定secret key，使consul在通讯时进行加密，key可以通过consul keygen生成，同一个集群中的节点必须使用相同的key</td></tr><tr><td>join</td><td>加入一个已经启动的agent的ip地址，可以多次指定多个agent的地址。如果consul不能加入任何指定的地址中，则agent会启动失败，默认agent启动时不会加入任何节点</td></tr><tr><td>retry-interval</td><td>两次join之间的时间间隔，默认是30s</td></tr><tr><td>retry-max</td><td>尝试重复join的次数，默认是0，也就是无限次尝试</td></tr><tr><td>log-level</td><td>consul agent启动后显示的日志信息级别。默认是info，可选：trace、debug、info、warn、err</td></tr><tr><td>node</td><td>节点在集群中的名称，在一个集群中必须是唯一的，默认是该节点的主机名</td></tr><tr><td>protocol</td><td>consul使用的协议版本</td></tr><tr><td>rejoin</td><td>使consul忽略先前的离开，在再次启动后仍旧尝试加入集群中</td></tr><tr><td>server</td><td>定义agent运行在server模式，每个集群至少有一个server，建议每个集群的server不要超过5个</td></tr><tr><td>syslog</td><td>开启系统日志功能，只在linux/osx上生效</td></tr><tr><td>pid-file</td><td>提供一个路径来存放pid文件，可以使用该文件进行SIGINT/SIGHUP(关闭/更新)agent</td></tr></tbody></table><p><strong>参数说明：</strong></p><p><strong>-node：</strong>节点的名称</p><p><strong>-bind：</strong>绑定的一个地址，用于节点之间通信的地址，可以是内外网，必须是可以访问到的地址</p><p><strong>-server：</strong>这个就是表示这个节点是个SERVER</p><p><strong>-bootstrap-expect：</strong>这个就是表示期望提供的SERVER节点数目，数目一达到，它就会被激活，然后就是LEADER了</p><p>参数说明：</p><p><strong>-join：</strong>这个表示启动的时候，要加入到哪个集群内，这里就是说要加入到节点1的集群</p><p><strong>-node-id：</strong>这个貌似版本8才加入的，这里用这个来指定唯一的节点ID，可以查看这个<a href="https://link.jianshu.com/?t=https://github.com/hashicorp/consul/issues/2877">issue</a></p><p><strong>-client：</strong>这个表示注册或者查询等一系列客户端对它操作的IP，如果不指定这个IP，默认是127.0.0.1。</p><h2 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h2><p>除了命令行参数外，配置也可以写入文件中。配置文件是json格式的，很容易编写。配置文件不仅被用来设置agent的启动，也可以用来提供健康检测和服务发现的定义。</p><p>配置文件详细参数说明:</p><blockquote><ol><li>acl_datacenter：只用于server，指定的datacenter的权威ACL信息，所有的servers和datacenter必须同意ACL datacenter</li><li>acl_default_policy：默认是allow。</li><li>acl_token：agent会使用这个token和consul server进行请求。</li><li>acl_ttl：控制TTL的cache，默认是30s。</li><li>addresses：一个嵌套对象，可以设置以下key：dns、http、rpc。</li><li>advertise_addr：等同于-advertise。</li><li>bootstrap：等同于-bootstrap。</li><li>bootstrap_expect：等同于-bootstrap-expect。</li><li>bind_addr：等同于-bind。</li><li>ca_file：提供CA文件路径，用来检查客户端或者服务端的链接。</li><li>cert_file：必须和key_file一起。</li><li>client_addr：等同于-client。</li><li>datacenter：等同于-dc。</li><li>data_dir：等同于-data-dir。</li><li>disable_anonymous_signature：在进行更新检查时禁止匿名签名。</li><li>disable_remote_exec：禁止支持远程执行，设置为true，agent会忽视所有进入的远程执行请求。</li><li>disable_update_check：禁止自动检查安全公告和新版本信息。</li><li>dns_config：是一个嵌套对象，可以设置以下参数：allow_stale、max_stale、node_ttl 、service_ttl、enable_truncate。</li><li>domain：默认情况下consul在进行DNS查询时查询的是consul域，可以通过该参数进行修改。</li><li>enable_debug：开启debug模式。</li><li>enable_syslog：等同于-syslog。</li><li>encrypt：等同于-encrypt。</li><li>key_file：提供私钥的路径。</li><li>leave_on_terminate：默认是false，如果为true，当agent收到一个TERM信号的时候，它会发送leave信息到集群中的其他节点上。</li><li>log_level：等同于-log-level。</li><li>node_name:等同于-node。</li><li>ports：这是一个嵌套对象，可以设置以下key：dns(dns地址：8600)、http(http api地址：8500)、rpc(rpc:8400)、serf_lan(lan port:8301)、serf_wan(wan port:8302)、server(server rpc:8300)。</li><li>protocol：等同于-protocol。</li><li>rejoin_after_leave：等同于-rejoin。</li><li>retry_join：等同于-retry-join。</li><li>retry_interval：等同于-retry-interval。</li><li>server：等同于-server。</li><li>server_name：会覆盖TLS CA的node_name，可以用来确认CA name和hostname相匹配。</li><li>skip_leave_on_interrupt：和leave_on_terminate比较类似，不过只影响当前句柄。</li><li>start_join：一个字符数组提供的节点地址会在启动时被加入。</li><li>syslog_facility：当enable_syslog被提供后，该参数控制哪个级别的信息被发送，默认Local0。</li><li>ui_dir：等同于-ui-dir。</li><li>verify_incoming：默认false，如果为true，则所有进入链接都需要使用TLS，需要客户端使用ca_file提供ca文件。只用于consul server端，因为client从来没有进入的链接。</li><li>verify_outgoing：默认false，如果为true，则所有出去链接都需要使用TLS，需要服务端使用ca_file提供ca文件，consul server和client都需要使用，因为两者都有出去的链接。</li><li>watches：watch一个详细名单。</li></ol></blockquote><h2 id="常用端口说明"><a href="#常用端口说明" class="headerlink" title="常用端口说明"></a>常用端口说明</h2><blockquote><ol><li>dns - The DNS server, -1 to disable. Default 8600.</li><li>http - The HTTP API, -1 to disable. Default 8500.</li><li>https - The HTTPS API, -1 to disable. Default -1 (disabled).</li><li>rpc - The CLI RPC endpoint. Default 8400.</li><li>serf_lan - The Serf LAN port. Default 8301.</li><li>serf_wan - The Serf WAN port. Default 8302.</li><li>server - Server RPC address. Default 8300.</li></ol></blockquote><h2 id="服务发现机制"><a href="#服务发现机制" class="headerlink" title="服务发现机制"></a>服务发现机制</h2><p>加入集群</p><ul><li>当一个Consul代理启动后，它并不知道其它节点的存在，它是一个孤立的单节点集群。</li><li>如果想感知到其它节点的存在，它必须加入到一个现存的集群。</li><li>要加入到一个现存的集群，它只用加入集群中任意一个现存的成员。</li><li>当加入一个现存的成员后，会通过成员间的通讯很快发现集群中的其它成员。</li><li>一个Consul代理可以加入任意一个代理，而不仅仅是服务节点。</li></ul><p>为了让三个Server间能互相感知，这里就要让其它二个Server加入同一个集群中。</p><h2 id="通过json配置文件集群安装"><a href="#通过json配置文件集群安装" class="headerlink" title="通过json配置文件集群安装"></a>通过json配置文件集群安装</h2><h3 id="集群节点规划"><a href="#集群节点规划" class="headerlink" title="集群节点规划"></a>集群节点规划</h3><p>本地使用的是<code>CentOS 17.x</code>的虚拟机：</p><table><thead><tr><th>容器名称</th><th>容器IP地址</th><th>映射端口号</th><th>宿主机IP地址</th><th>服务运行模式</th></tr></thead><tbody><tr><td>consul1</td><td>172.20.0.2</td><td>8500 -&gt; 8500</td><td>192.168.56.76</td><td>Server Master</td></tr><tr><td>consul2</td><td>172.20.0.3</td><td>9500 -&gt; 8500</td><td>192.168.56.76</td><td>Server</td></tr><tr><td>consul3</td><td>172.20.0.4</td><td>10500 -&gt; 8500</td><td>192.168.56.76</td><td>Server</td></tr><tr><td>consul4</td><td>172.20.0.5</td><td>11500 -&gt; 8500</td><td>192.168.56.76</td><td>Client</td></tr></tbody></table><p>172.20.0.1是网关</p><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo docker pull consul:1.3.0</code></pre></div><h3 id="配置docker-网络"><a href="#配置docker-网络" class="headerlink" title="配置docker 网络"></a>配置docker 网络</h3><p>因为docker 默认的 docker0 虚拟网卡是不支持直接设置静态ip的。所以我们先创建一个自己的虚拟网络。</p><div class="hljs code-wrapper"><pre><code class="hljs bash">$ docker network create -d bridge --subnet=172.20.0.0/24 static-net</code></pre></div><p>执行完可以通过 下面了命令查看</p><div class="hljs code-wrapper"><pre><code class="hljs bash">$ docker network ls</code></pre></div><p>PS:</p><div class="hljs code-wrapper"><pre><code class="hljs dns">私有网络ip选取小知识：这三个地址段分别位于<span class="hljs-keyword">A</span>、B、C三类地址内：<span class="hljs-keyword">A</span>类地址：<span class="hljs-number">10.0.0.0</span>--<span class="hljs-number">10.255.255.255</span>B类地址：<span class="hljs-number">172.16.0.0</span>--<span class="hljs-number">172.31.255.255</span>C类地址：<span class="hljs-number">192.168.0.0</span>--<span class="hljs-number">192.168.255.255</span></code></pre></div><h3 id="三个server节点配置"><a href="#三个server节点配置" class="headerlink" title="三个server节点配置"></a>三个server节点配置</h3><p>创建的三个server节点命名 为 consul_server1，consul_server2， consul_server3。</p><p>下面先创建好配置文件，在 /opt/consul/server_conf 目录添加三个配置文件。<br>consul_server1_conf.json、consul_server2_conf.json 和 consul_server3_conf.json</p><h4 id="consul-server1-conf-json-的内容如下："><a href="#consul-server1-conf-json-的内容如下：" class="headerlink" title="consul_server1_conf.json 的内容如下："></a>consul_server1_conf.json 的内容如下：</h4><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;        <span class="hljs-attr">&quot;datacenter&quot;</span>: <span class="hljs-string">&quot;dc1&quot;</span>,        <span class="hljs-attr">&quot;log_level&quot;</span>: <span class="hljs-string">&quot;INFO&quot;</span>,        <span class="hljs-attr">&quot;node_name&quot;</span>: <span class="hljs-string">&quot;consul_server1&quot;</span>,        <span class="hljs-attr">&quot;server&quot;</span>: <span class="hljs-literal">true</span>,        <span class="hljs-attr">&quot;bootstrap_expect&quot;</span>: <span class="hljs-number">3</span>,        <span class="hljs-attr">&quot;bind_addr&quot;</span>: <span class="hljs-string">&quot;0.0.0.0&quot;</span>,        <span class="hljs-attr">&quot;client_addr&quot;</span>: <span class="hljs-string">&quot;0.0.0.0&quot;</span>,        <span class="hljs-attr">&quot;ui&quot;</span>: <span class="hljs-literal">true</span>,        <span class="hljs-attr">&quot;ports&quot;</span>: &#123;            <span class="hljs-attr">&quot;dns&quot;</span>: <span class="hljs-number">8600</span>,            <span class="hljs-attr">&quot;http&quot;</span>: <span class="hljs-number">8500</span>,            <span class="hljs-attr">&quot;https&quot;</span>: <span class="hljs-number">-1</span>,            <span class="hljs-attr">&quot;server&quot;</span>: <span class="hljs-number">8300</span>,            <span class="hljs-attr">&quot;serf_lan&quot;</span>: <span class="hljs-number">8301</span>,            <span class="hljs-attr">&quot;serf_wan&quot;</span>: <span class="hljs-number">8302</span>        &#125;,        <span class="hljs-attr">&quot;rejoin_after_leave&quot;</span>: <span class="hljs-literal">true</span>,        <span class="hljs-attr">&quot;retry_join&quot;</span>: [            <span class="hljs-string">&quot;172.20.0.2&quot;</span>,            <span class="hljs-string">&quot;172.20.0.3&quot;</span>,            <span class="hljs-string">&quot;172.20.0.4&quot;</span>        ],        <span class="hljs-attr">&quot;retry_interval&quot;</span>: <span class="hljs-string">&quot;30s&quot;</span>,        <span class="hljs-attr">&quot;reconnect_timeout&quot;</span>: <span class="hljs-string">&quot;72h&quot;</span>&#125;</code></pre></div><p>另外两个配置基本一样只用更改 node_name 为 consul_server2 和 consul_server3 即可。</p><h4 id="consul-server2-conf-json-的内容如下："><a href="#consul-server2-conf-json-的内容如下：" class="headerlink" title="consul_server2_conf.json 的内容如下："></a>consul_server2_conf.json 的内容如下：</h4><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;        <span class="hljs-attr">&quot;datacenter&quot;</span>: <span class="hljs-string">&quot;dc1&quot;</span>,        <span class="hljs-attr">&quot;log_level&quot;</span>: <span class="hljs-string">&quot;INFO&quot;</span>,        <span class="hljs-attr">&quot;node_name&quot;</span>: <span class="hljs-string">&quot;consul_server2&quot;</span>,        <span class="hljs-attr">&quot;server&quot;</span>: <span class="hljs-literal">true</span>,        <span class="hljs-attr">&quot;bootstrap_expect&quot;</span>: <span class="hljs-number">3</span>,        <span class="hljs-attr">&quot;bind_addr&quot;</span>: <span class="hljs-string">&quot;0.0.0.0&quot;</span>,        <span class="hljs-attr">&quot;client_addr&quot;</span>: <span class="hljs-string">&quot;0.0.0.0&quot;</span>,        <span class="hljs-attr">&quot;ui&quot;</span>: <span class="hljs-literal">true</span>,        <span class="hljs-attr">&quot;ports&quot;</span>: &#123;            <span class="hljs-attr">&quot;dns&quot;</span>: <span class="hljs-number">8600</span>,            <span class="hljs-attr">&quot;http&quot;</span>: <span class="hljs-number">8500</span>,            <span class="hljs-attr">&quot;https&quot;</span>: <span class="hljs-number">-1</span>,            <span class="hljs-attr">&quot;server&quot;</span>: <span class="hljs-number">8300</span>,            <span class="hljs-attr">&quot;serf_lan&quot;</span>: <span class="hljs-number">8301</span>,            <span class="hljs-attr">&quot;serf_wan&quot;</span>: <span class="hljs-number">8302</span>        &#125;,        <span class="hljs-attr">&quot;rejoin_after_leave&quot;</span>: <span class="hljs-literal">true</span>,        <span class="hljs-attr">&quot;retry_join&quot;</span>: [            <span class="hljs-string">&quot;172.20.0.2&quot;</span>,            <span class="hljs-string">&quot;172.20.0.3&quot;</span>,            <span class="hljs-string">&quot;172.20.0.4&quot;</span>        ],        <span class="hljs-attr">&quot;retry_interval&quot;</span>: <span class="hljs-string">&quot;30s&quot;</span>,        <span class="hljs-attr">&quot;reconnect_timeout&quot;</span>: <span class="hljs-string">&quot;72h&quot;</span>&#125;</code></pre></div><h4 id="consul-server3-conf-json-的内容如下："><a href="#consul-server3-conf-json-的内容如下：" class="headerlink" title="consul_server3_conf.json 的内容如下："></a>consul_server3_conf.json 的内容如下：</h4><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;        <span class="hljs-attr">&quot;datacenter&quot;</span>: <span class="hljs-string">&quot;dc1&quot;</span>,        <span class="hljs-attr">&quot;log_level&quot;</span>: <span class="hljs-string">&quot;INFO&quot;</span>,        <span class="hljs-attr">&quot;node_name&quot;</span>: <span class="hljs-string">&quot;consul_server3&quot;</span>,        <span class="hljs-attr">&quot;server&quot;</span>: <span class="hljs-literal">true</span>,        <span class="hljs-attr">&quot;bootstrap_expect&quot;</span>: <span class="hljs-number">3</span>,        <span class="hljs-attr">&quot;bind_addr&quot;</span>: <span class="hljs-string">&quot;0.0.0.0&quot;</span>,        <span class="hljs-attr">&quot;client_addr&quot;</span>: <span class="hljs-string">&quot;0.0.0.0&quot;</span>,        <span class="hljs-attr">&quot;ui&quot;</span>: <span class="hljs-literal">true</span>,        <span class="hljs-attr">&quot;ports&quot;</span>: &#123;            <span class="hljs-attr">&quot;dns&quot;</span>: <span class="hljs-number">8600</span>,            <span class="hljs-attr">&quot;http&quot;</span>: <span class="hljs-number">8500</span>,            <span class="hljs-attr">&quot;https&quot;</span>: <span class="hljs-number">-1</span>,            <span class="hljs-attr">&quot;server&quot;</span>: <span class="hljs-number">8300</span>,            <span class="hljs-attr">&quot;serf_lan&quot;</span>: <span class="hljs-number">8301</span>,            <span class="hljs-attr">&quot;serf_wan&quot;</span>: <span class="hljs-number">8302</span>        &#125;,        <span class="hljs-attr">&quot;rejoin_after_leave&quot;</span>: <span class="hljs-literal">true</span>,        <span class="hljs-attr">&quot;retry_join&quot;</span>: [            <span class="hljs-string">&quot;172.20.0.2&quot;</span>,            <span class="hljs-string">&quot;172.20.0.3&quot;</span>,            <span class="hljs-string">&quot;172.20.0.4&quot;</span>        ],        <span class="hljs-attr">&quot;retry_interval&quot;</span>: <span class="hljs-string">&quot;30s&quot;</span>,        <span class="hljs-attr">&quot;reconnect_timeout&quot;</span>: <span class="hljs-string">&quot;72h&quot;</span>&#125;</code></pre></div><h4 id="启动-server-节点"><a href="#启动-server-节点" class="headerlink" title="启动 server 节点"></a>启动 server 节点</h4><p>分别依次执行启动server，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">$ docker run -d  --name consul_server1 --net static-net --ip 172.20.0.2 -h consul1 -v /opt/consul/server_conf/consul_server1_conf.json:/consul/config/consul_server1_conf.json consul:1.3.0 agent -config-dir /consul/config</code></pre></div><p>根据启动不同的 server 修改相应的名称、IP、主机和配置文件。</p><h3 id="三个-client节点配置"><a href="#三个-client节点配置" class="headerlink" title="三个 client节点配置"></a>三个 client节点配置</h3><p>创建的三个server节点命名 为 consul_client1，consul_client2， consul_client3。</p><p>下面先创建好配置文件，在 /opt/consul/client_conf 目录添加三个配置文件。<br>consul_client1_conf.json、consul_client2_conf.json 和 consul_client3_conf.json</p><h4 id="consul-client1-conf-json-的内容如下："><a href="#consul-client1-conf-json-的内容如下：" class="headerlink" title="consul_client1_conf.json 的内容如下："></a>consul_client1_conf.json 的内容如下：</h4><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;    <span class="hljs-attr">&quot;datacenter&quot;</span>: <span class="hljs-string">&quot;dc1&quot;</span>,    <span class="hljs-attr">&quot;log_level&quot;</span>: <span class="hljs-string">&quot;INFO&quot;</span>,    <span class="hljs-attr">&quot;node_name&quot;</span>: <span class="hljs-string">&quot;consul_client1&quot;</span>,    <span class="hljs-attr">&quot;server&quot;</span>: <span class="hljs-literal">false</span>,    <span class="hljs-attr">&quot;bind_addr&quot;</span>: <span class="hljs-string">&quot;172.20.0.5&quot;</span>,    <span class="hljs-attr">&quot;client_addr&quot;</span>: <span class="hljs-string">&quot;0.0.0.0&quot;</span>,    <span class="hljs-attr">&quot;ui&quot;</span>: <span class="hljs-literal">false</span>,    <span class="hljs-attr">&quot;ports&quot;</span>: &#123;        <span class="hljs-attr">&quot;dns&quot;</span>: <span class="hljs-number">8600</span>,        <span class="hljs-attr">&quot;http&quot;</span>: <span class="hljs-number">8500</span>,        <span class="hljs-attr">&quot;https&quot;</span>: <span class="hljs-number">-1</span>,        <span class="hljs-attr">&quot;server&quot;</span>: <span class="hljs-number">8300</span>,        <span class="hljs-attr">&quot;serf_lan&quot;</span>: <span class="hljs-number">8301</span>,        <span class="hljs-attr">&quot;serf_wan&quot;</span>: <span class="hljs-number">8302</span>    &#125;,    <span class="hljs-attr">&quot;rejoin_after_leave&quot;</span>: <span class="hljs-literal">true</span>,    <span class="hljs-attr">&quot;retry_join&quot;</span>: [        <span class="hljs-string">&quot;172.20.0.2&quot;</span>,        <span class="hljs-string">&quot;172.20.0.3&quot;</span>,        <span class="hljs-string">&quot;172.20.0.4&quot;</span>    ],    <span class="hljs-attr">&quot;retry_interval&quot;</span>: <span class="hljs-string">&quot;30s&quot;</span>,    <span class="hljs-attr">&quot;reconnect_timeout&quot;</span>: <span class="hljs-string">&quot;72h&quot;</span>&#125;</code></pre></div><p>另外两个配置基本一样只用更改 node_name 为 consul_client2 和 consul_client3 即可。</p><h4 id="启动-client-节点"><a href="#启动-client-节点" class="headerlink" title="启动 client 节点"></a>启动 client 节点</h4><p>分别依次执行启动client，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">$ docker run -d --name consul_client1 --net static-net --ip 172.20.0.5 -h consul4 -v /opt/consul/client_conf/consul_client1_conf.json:/consul/config/consul_client1_conf.json consul:1.3.0 agent -config-dir /consul/config</code></pre></div><p>根据启动不同的 client 修改相应的容器和节点名称、IP、主机和配置文件。</p><h2 id="集群部署与配置"><a href="#集群部署与配置" class="headerlink" title="集群部署与配置"></a>集群部署与配置</h2><p>不使用配置文件的集群与配置部署</p><h3 id="启动consul-server1节点"><a href="#启动consul-server1节点" class="headerlink" title="启动consul_server1节点"></a>启动consul_server1节点</h3><div class="hljs code-wrapper"><pre><code class="hljs bash">$ docker run -d --name=consul-server1 --net host --ip 172.20.0.2 \             -p 8300:8300 \             -p 8301:8301 \             -p 8301:8301/udp \             -p 8302:8302/udp \             -p 8302:8302 \             -p 8400:8400 \             -p 8500:8500 \             -p 8600:8600 \             -h consul-server1 \             consul:1.3.0 agent -server -<span class="hljs-built_in">bind</span>=172.20.0.2 \             -bootstrap-expect=3 -node=consul-server1 \             advertise 192.168.56.76 \             -data-dir=/tmp/data-dir -client 0.0.0.0 -ui</code></pre></div><h3 id="启动consul-server2节点"><a href="#启动consul-server2节点" class="headerlink" title="启动consul_server2节点"></a>启动consul_server2节点</h3><div class="hljs code-wrapper"><pre><code class="hljs bash">$ docker run -d --name=consul-server2 --net static-net --ip 172.20.0.3 \             -p 9300:8300  \             -p 9301:8301 \             -p 9301:8301/udp \             -p 9302:8302/udp \             -p 9302:8302 \             -p 9400:8400 \             -p 9500:8500 \             -p 9600:8600 \             -h consul-server2 \             consul:1.3.0 agent -server -<span class="hljs-built_in">bind</span>=172.20.0.3 \             -join=192.168.56.76  \             -node=consul-server2 \             -data-dir=/tmp/data-dir -client 0.0.0.0 -ui</code></pre></div><h3 id="启动consul-server3节点"><a href="#启动consul-server3节点" class="headerlink" title="启动consul_server3节点"></a>启动consul_server3节点</h3><div class="hljs code-wrapper"><pre><code class="hljs bash">$ docker run -d --name=consul-server3 --restart=always \             -p 10300:8300  \             -p 10301:8301 \             -p 10301:8301/udp \             -p 10302:8302/udp \             -p 10302:8302 \             -p 10400:8400 \             -p 10500:8500 \             -p 10600:8600 \             -h consul-server3 \             consul:1.3.0 agent -server -<span class="hljs-built_in">bind</span>=172.20.0.4 \             -join=192.168.56.76 -node-id=$(uuidgen | awk <span class="hljs-string">&#x27;&#123;print tolower($0)&#125;&#x27;</span>) \             -node=consul-server3 \             -data-dir=/tmp/data-dir -client 0.0.0.0 -ui</code></pre></div><h3 id="启动consul-client1节点"><a href="#启动consul-client1节点" class="headerlink" title="启动consul_client1节点"></a>启动consul_client1节点</h3><div class="hljs code-wrapper"><pre><code class="hljs bash">$ docker run -d --name=consul-client1 --net static-net --ip 172.20.0.5 \            -p 11300:8300 \            -p 11301:8301 \            -p 11301:8301/udp \            -p 11302:8302/udp \            -p 11302:8302 \            -p 11400:8400 \            -p 11500:8500 \            -p 11600:8600 \            -h consul-client1 \            consul:1.3.0 agent -<span class="hljs-built_in">bind</span>=172.20.0.5 \            -retry-join=172.20.0.2 \            -node=consul-client1 -client 0.0.0.0 -ui</code></pre></div><h2 id="集群监控与跟踪"><a href="#集群监控与跟踪" class="headerlink" title="集群监控与跟踪"></a>集群监控与跟踪</h2><h3 id="查看server日志"><a href="#查看server日志" class="headerlink" title="查看server日志"></a>查看server日志</h3><p>查看<code>consu_serverl</code>的日志，追踪运行情况：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo docker logs -f consul_server1</code></pre></div><p>当3个<code>Server</code>节点都启动并正常运行时，观察<code>consul_server2</code>和<code>consul_server3</code>的进程日志，可以发现<code>consul_server1</code>被选举为<code>leader</code>节点，也就是这个<strong>数据中心</strong>的<code>Server Master</code>。</p><p>再次查看<code>consul_server1</code>节点的进程启动日志：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo docker logs -f consul_srver1</code></pre></div><p>观察日志发现，<code>consul_server2</code>和<code>consul_server3</code>都成功join到了<code>consul_server1</code>所在的数据中心<code>dc1</code>。当集群中有3台<code>Consul Server</code>启动时，<code>consul_server1</code>被选举为<code>dc1</code>中的主节点。然后，<code>consul_server1</code>会通过心跳检查的方式，不断地对<code>consul_server2</code>和<code>consul_server3</code>进行健康检查。</p><h3 id="查看client日志"><a href="#查看client日志" class="headerlink" title="查看client日志"></a>查看client日志</h3><p>查看<code>consu_clientl</code>的日志，追踪运行情况：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo docker ps -f consul_client1</code></pre></div><p>可以发现：<code>consul_client1</code>是以<code>Client</code>模式启动运行的。启动后完成后，把<code>dc1</code>数据中心中的以<code>Server</code>模式启动的节点<code>consul_server1</code>、<code>consul_server2</code>和<code>consul_server3</code>都添加到<strong>本地缓存列表</strong>中。当客户端向<code>consul_client1</code>发起服务发现的请求后，<code>consul_client1</code>会通过<code>RPC</code>将请求转发给<code>Server</code>节点中的其中一台做处理。</p><h3 id="查看集群状态"><a href="#查看集群状态" class="headerlink" title="查看集群状态"></a>查看集群状态</h3><div class="hljs code-wrapper"><pre><code class="hljs bash">$ docker <span class="hljs-built_in">exec</span> -t consul_server1 consul membersNode            Address          Status  Type    Build  Protocol  DC   Segmentconsul_server1  172.20.0.2:8301  alive   server  1.3.0  2         dc1  &lt;all&gt;consul_server2  172.20.0.3:8301  alive   server  1.3.0  2         dc1  &lt;all&gt;consul_server3  172.20.0.4:8301  alive   server  1.3.0  2         dc1  &lt;all&gt;consul_client1  172.20.0.5:8301  alive   client  1.3.0  2         dc1  &lt;default&gt;</code></pre></div><p><code>dc1</code>数据中心中的4个节点<code>consul_server1</code>, <code>consul_server2</code>, <code>consul_server3</code>和<code>consul_server4</code>分别成功启动，<code>Status</code>表示他们的状态，都为<code>alive</code>。<code>consul_server1</code>, <code>consul_server2</code>, <code>consul_server3</code>以<code>Server</code>模式启动，而<code>consul_client1</code>以<code>Client</code>模式启动。</p><p>与之前启动的一样。DC表示数据中心，都是dc1。</p><h3 id="节点异常consul的处理"><a href="#节点异常consul的处理" class="headerlink" title="节点异常consul的处理"></a>节点异常consul的处理</h3><ul><li>LEADER 挂了<br>leader挂了，consul会重新选取出新的leader，只要超过一半的SERVER还活着，集群是可以正常工作的。consul1是leader，所以把这个容器停了。</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash">$ docker stop consul_server1</code></pre></div><p>看看其他节点的日志（consul_server2）：</p><p>日志打印，心跳检查consul_server1的ip超时，接着开始选举。consul_server2被选举为新的leader。我们查看下现在的leader：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">$ curl http://172.17.0.33:8500/v1/status/leader<span class="hljs-string">&quot;172.20.0.3:8300&quot;</span></code></pre></div><blockquote><p>172.20.0.3 就是 consul_server2节点的IP</p></blockquote><h3 id="拉取Registrator的镜像"><a href="#拉取Registrator的镜像" class="headerlink" title="拉取Registrator的镜像"></a>拉取Registrator的镜像</h3><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo docker pull gliderlabs/registrator</code></pre></div><h3 id="启动Registrator节点"><a href="#启动Registrator节点" class="headerlink" title="启动Registrator节点"></a>启动Registrator节点</h3><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo docker run -d --name=registrator \             -v /var/run/docker.sock:/tmp/docker.sock \             --net=host \             gliderlabs/registrator -ip=<span class="hljs-string">&quot;192.168.56.76&quot;</span> consul://172.20.0.2:8500</code></pre></div><blockquote><p><code>--net：</code>指定为host表明使用主机模式。</p><p><code>-ip：</code>用于指定宿主机的IP地址，用于健康检查的通信地址。</p><p><code>consul://192.168.56.76:8500:</code> 使用Consul作为服务注册表，指定具体的Consul通信地址进行服务注册和注销（注意：8500是Consul对外暴露的HTTP通信端口）。</p></blockquote><p>查看<code>Registrator</code>的容器进程启动日志：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo docker logs -f registrator</code></pre></div><p><code>Registrator</code>在启动过程完成了以下几步操作：</p><ol><li>查看Consul数据中心的leader节点，作为服务注册表；</li><li>同步当前宿主机的启用容器，以及所有的服务端口；</li><li>分别将各个容器发布的服务地址/端口注册到Consul的服务注册列表。</li></ol><h3 id="查看Consul的注册状态"><a href="#查看Consul的注册状态" class="headerlink" title="查看Consul的注册状态"></a>查看Consul的注册状态</h3><p><code>Consul</code>提供了一个<code>Web UI</code>来可视化<strong>服务注册列表</strong>、<strong>通信节点</strong>、<strong>数据中心</strong>和<strong>键/值存储</strong>等，直接访问宿主机的<code>8500</code>端口。</p><p><strong>服务注册列表</strong>：</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-xVUlBeaQ-1599612136677)(assets/1541719660720.png)]</p><p><code>NODES</code>节点下挂载着<code>dc1</code>数据中心中的所有的<code>Consul</code>节点，包括<code>Consul Server</code>和<code>Client</code>。</p><p><strong>通信节点列表</strong>：</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-2FP30a9c-1599612136679)(assets/1541719699164.png)]</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>部署完了，那么可以看看怎么用这个东东了。</p><h3 id="注册个服务"><a href="#注册个服务" class="headerlink" title="注册个服务"></a>注册个服务</h3><p>使用HTTP API 注册个服务，使用<a href="%5Bhttps://www.consul.io/api/agent/service.html%5D(https://link.jianshu.com/?t=https://www.consul.io/api/agent/service.html">接口API</a> API)调用</p><p>调用 <a href="https://link.jianshu.com/?t=http://consul:8500/v1/agent/service/register">http://192.168.56.76:8500/v1/agent/service/register</a> PUT 注册一个服务。request body:</p><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;  <span class="hljs-attr">&quot;ID&quot;</span>: <span class="hljs-string">&quot;userServiceId&quot;</span>, <span class="hljs-comment">//服务id</span>  <span class="hljs-attr">&quot;Name&quot;</span>: <span class="hljs-string">&quot;userService&quot;</span>, <span class="hljs-comment">//服务名</span>  <span class="hljs-attr">&quot;Tags&quot;</span>: [              <span class="hljs-comment">//服务的tag，自定义，可以根据这个tag来区分同一个服务名的服务</span>    <span class="hljs-string">&quot;primary&quot;</span>,    <span class="hljs-string">&quot;v1&quot;</span>  ],  <span class="hljs-attr">&quot;Address&quot;</span>: <span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-comment">//服务注册到consul的IP，服务发现，发现的就是这个IP</span>  <span class="hljs-attr">&quot;Port&quot;</span>: <span class="hljs-number">8000</span>,          <span class="hljs-comment">//服务注册consul的PORT，发现的就是这个PORT</span>  <span class="hljs-attr">&quot;EnableTagOverride&quot;</span>: <span class="hljs-literal">false</span>,  <span class="hljs-attr">&quot;Check&quot;</span>: &#123;             <span class="hljs-comment">//健康检查部分</span>    <span class="hljs-attr">&quot;DeregisterCriticalServiceAfter&quot;</span>: <span class="hljs-string">&quot;90m&quot;</span>,    <span class="hljs-attr">&quot;HTTP&quot;</span>: <span class="hljs-string">&quot;http://www.baidu.com&quot;</span>, <span class="hljs-comment">//指定健康检查的URL，调用后只要返回20X，consul都认为是健康的</span>    <span class="hljs-attr">&quot;Interval&quot;</span>: <span class="hljs-string">&quot;10s&quot;</span>   <span class="hljs-comment">//健康检查间隔时间，每隔10s，调用一次上面的URL</span>  &#125;&#125;</code></pre></div><h3 id="调用服务"><a href="#调用服务" class="headerlink" title="调用服务"></a>调用服务</h3><p>使用curl调用服务</p><div class="hljs code-wrapper"><pre><code class="hljs json">curl http://192.168.56.76:8500/v1/agent/service/register -X PUT -i -H &quot;Content-Type:application/json&quot; -d &#x27;&#123; &quot;ID&quot;: &quot;userServiceId&quot;,   &quot;Name&quot;: &quot;userService&quot;, &quot;Tags&quot;: [   &quot;primary&quot;,   <span class="hljs-string">&quot;v1&quot;</span> ], &quot;Address&quot;: &quot;127.0.0.1&quot;, &quot;Port&quot;: 8000, &quot;EnableTagOverride&quot;: false, &quot;Check&quot;: &#123;   &quot;DeregisterCriticalServiceAfter&quot;: &quot;90m&quot;,   &quot;HTTP&quot;: &quot;http://www.baidu.com&quot;,   &quot;Interval&quot;: &quot;10s&quot; &#125;&#125;&#x27;</code></pre></div><p>OK，注册了一个服务</p><h3 id="发现个服务"><a href="#发现个服务" class="headerlink" title="发现个服务"></a>发现个服务</h3><p>刚刚注册了名为userService的服务，我们现在发现（查询）下这个服务</p><div class="hljs code-wrapper"><pre><code class="hljs bash">curl http://172.20.0.2:8500/v1/catalog/service/userService</code></pre></div><p>返回的响应：</p><div class="hljs code-wrapper"><pre><code class="hljs json">[    &#123;        <span class="hljs-attr">&quot;Address&quot;</span>: <span class="hljs-string">&quot;172.17.0.33&quot;</span>,        <span class="hljs-attr">&quot;CreateIndex&quot;</span>: <span class="hljs-number">880</span>,        <span class="hljs-attr">&quot;ID&quot;</span>: <span class="hljs-string">&quot;e6e9a8cb-c47e-4be9-b13e-a24a1582e825&quot;</span>,        <span class="hljs-attr">&quot;ModifyIndex&quot;</span>: <span class="hljs-number">880</span>,        <span class="hljs-attr">&quot;Node&quot;</span>: <span class="hljs-string">&quot;consul3&quot;</span>,        <span class="hljs-attr">&quot;NodeMeta&quot;</span>: &#123;&#125;,        <span class="hljs-attr">&quot;ServiceAddress&quot;</span>: <span class="hljs-string">&quot;127.0.0.1&quot;</span>,        <span class="hljs-attr">&quot;ServiceEnableTagOverride&quot;</span>: <span class="hljs-literal">false</span>,        <span class="hljs-attr">&quot;ServiceID&quot;</span>: <span class="hljs-string">&quot;userServiceId&quot;</span>,        <span class="hljs-attr">&quot;ServiceName&quot;</span>: <span class="hljs-string">&quot;userService&quot;</span>,        <span class="hljs-attr">&quot;ServicePort&quot;</span>: <span class="hljs-number">8000</span>,        <span class="hljs-attr">&quot;ServiceTags&quot;</span>: [            <span class="hljs-string">&quot;primary&quot;</span>,            <span class="hljs-string">&quot;v1&quot;</span>        ],        <span class="hljs-attr">&quot;TaggedAddresses&quot;</span>: &#123;            <span class="hljs-attr">&quot;lan&quot;</span>: <span class="hljs-string">&quot;172.17.0.33&quot;</span>,            <span class="hljs-attr">&quot;wan&quot;</span>: <span class="hljs-string">&quot;172.17.0.33&quot;</span>        &#125;    &#125;]</code></pre></div><p>内容有了吧，这个就是我们刚刚注册的服务的信息，就可以获取到</p><blockquote><p>服务的名称是“userService”<br>服务地址是“127.0.0.1”<br>服务的端口是“8000”</p></blockquote><h3 id="存储个K-V"><a href="#存储个K-V" class="headerlink" title="存储个K/V"></a>存储个K/V</h3><p>设置一个值到user/config/connections 内容为5</p><div class="hljs code-wrapper"><pre><code class="hljs bash">$ docker <span class="hljs-built_in">exec</span> -t consul1 consul kv put user/config/connections 5</code></pre></div><p>获取特定的值</p><div class="hljs code-wrapper"><pre><code class="hljs bash">$ docker <span class="hljs-built_in">exec</span> -t consul1 consul kv get -detailed user/config/connections</code></pre></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>启动<code>Registrator</code>以后，宿主机中的所有容器把服务都注册到<code>Consul</code>的<code>SERVICES</code>上，测试完成！</p><p><strong>单数据中心</strong>的<code>Consul</code>集群的搭建就完成了！！！后续章节我会介绍如何使用<code>Registrator</code>进行服务注册的<strong>标签化</strong>。然后通过<code>docker</code>部署<strong>多实例</strong>的<code>Web</code>容器来实现基于<code>HTTP</code>的<code>RESTful Service</code>和基于<code>TCP</code>的<code>RPC Service</code>的<strong>服务注册</strong>和<strong>健康检查定义</strong>，并演示如何以<strong>标签</strong>标识一个服务的多个实例。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>docker官网镜像</p><p><a href="https://hub.docker.com/_/consul/">https://hub.docker.com/_/consul/</a></p><p><a href="https://blog.csdn.net/liuzhuchen/article/details/81913562">https://blog.csdn.net/liuzhuchen/article/details/81913562</a> 详细参数说明</p><p><a href="https://www.jianshu.com/p/f8746b81d65d">https://www.jianshu.com/p/f8746b81d65d</a></p><p>nomad</p><p><a href="https://www.cnblogs.com/magic-chenyang/p/7975677.html">https://www.cnblogs.com/magic-chenyang/p/7975677.html</a></p><p><a href="http://www.cnblogs.com/magic-chenyang/p/7975724.html">http://www.cnblogs.com/magic-chenyang/p/7975724.html</a></p><p>官网</p><p><a href="https://www.consul.io/">https://www.consul.io/</a></p><p>集群安装配置</p><p><a href="https://juejin.im/post/5b2a6b606fb9a00e594c676d">https://juejin.im/post/5b2a6b606fb9a00e594c676d</a></p><p>安装与配置gliderlabs/registrator具有可插入后端的Docker服务注册表桥</p><p><a href="https://hub.docker.com/r/gliderlabs/registrator/">https://hub.docker.com/r/gliderlabs/registrator/</a></p><p>consul 入门</p><p><a href="http://www.10tiao.com/html/357/201705/2247485185/1.html">http://www.10tiao.com/html/357/201705/2247485185/1.html</a></p><p>使用jenkins、docker、consul、nginx搭建支持自动化构建部署以及弹性伸缩的集群系统详细教程</p><p><a href="https://blog.csdn.net/qq_22152261/article/details/76099579">https://blog.csdn.net/qq_22152261/article/details/76099579</a></p><p>consul-template &amp; nginx</p><p><a href="https://tonybai.com/2018/09/10/setup-service-discovery-and-load-balance-based-on-consul/">https://tonybai.com/2018/09/10/setup-service-discovery-and-load-balance-based-on-consul/</a></p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">## 总结</span>启动`Registrator`以后，宿主机中的所有容器把服务都注册到`Consul`的`SERVICES`上，测试完成！**单数据中心**的`Consul`集群的搭建就完成了！！！后续章节我会介绍如何使用`Registrator`进行服务注册的**标签化**。然后通过`docker`部署**多实例**的`Web`容器来实现基于`HTTP`的`RESTful Service`和基于`TCP`的`RPC Service`的**服务注册**和**健康检查定义**，并演示如何以**标签**标识一个服务的多个实例。<span class="hljs-comment">## 参考</span>docker官网镜像https://hub.docker.com/_/consul/https://blog.csdn.net/liuzhuchen/article/details/81913562 详细参数说明https://www.jianshu.com/p/f8746b81d65dnomadhttps://www.cnblogs.com/magic-chenyang/p/7975677.htmlhttp://www.cnblogs.com/magic-chenyang/p/7975724.html官网https://www.consul.io/集群安装配置https://juejin.im/post/5b2a6b606fb9a00e594c676d安装与配置gliderlabs/registrator具有可插入后端的Docker服务注册表桥https://hub.docker.com/r/gliderlabs/registrator/consul 入门http://www.10tiao.com/html/357/201705/2247485185/1.html使用jenkins、docker、consul、nginx搭建支持自动化构建部署以及弹性伸缩的集群系统详细教程https://blog.csdn.net/qq_22152261/article/details/76099579consul-template &amp; nginxhttps://tonybai.com/2018/09/10/setup-service-discovery-and-load-balance-based-on-consul/</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>middle-component</category>
      
    </categories>
    
    
    <tags>
      
      <tag>consul</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>frp</title>
    <link href="/2021/01/07/basic-connect-frp/"/>
    <url>/2021/01/07/basic-connect-frp/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么需要内网穿透功能"><a href="#为什么需要内网穿透功能" class="headerlink" title="为什么需要内网穿透功能"></a>为什么需要内网穿透功能</h2><p><strong>从公网中访问自己的私有设备向来是一件难事儿。</strong><br>自己的主力台式机、NAS等等设备，它们可能处于路由器后，或者运营商因为IP地址短缺不给你分配公网IP地址。如果我们想直接访问到这些设备（远程桌面，远程文件，SSH等等），一般来说要通过一些转发或者P2P组网软件的帮助。<br>我有一台计算机位于一个很复杂的局域网中，我想要实现远程桌面和文件访问，目前来看其所处的网络环境很难通过简单的端口映射将其暴露在公网之中，我试过这么几种方法：</p><ol><li>远程桌面使用TeamViewer。可用，但需要访问端也拥有TeamViewer软件，不是很方便，希望能使用Windows自带的远程桌面。且TeamViewer不易实现远程文件访问。</li><li>使用蒲公英VPN软件进行组网，可用，但免费版本网络速度极慢，体验不佳，几乎无法正常使用。</li><li>使用花生壳软件进行DDNS解析，可用，但同第二点所述，免费版本有带宽限制，无法实际使用。</li><li><strong>搭建frp服务器进行内网穿透，可用且推荐，可以达到不错的速度，且理论上可以开放任何想要的端口，可以实现的功能远不止远程桌面或者文件共享。</strong></li></ol><h2 id="frp是什么"><a href="#frp是什么" class="headerlink" title="frp是什么"></a>frp是什么</h2><p>简单地说，<a href="https://github.com/fatedier/frp/blob/master/README_zh.md">frp</a>就是一个<a href="https://www.zhihu.com/question/24723688">反向代理软件</a>，它体积轻量但功能很强大，可以<strong>使处于内网或防火墙后的设备对外界提供服务</strong>，它支持HTTP、TCP、UDP等众多协议。我们今天仅讨论TCP和UDP相关的内容。<br>截至本文完成，frp的最新版本为v0.22.0，本文使用最新版本。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>搭建一个完整的frp服务链，我们需要</p><ol><li>VPS一台（也可以是具有公网IP的实体机）</li><li>访问目标设备（就是你最终要访问的设备）</li><li>简单的Linux基础（会用cp等几个简单命令即可）</li></ol><h3 id="VPS相关"><a href="#VPS相关" class="headerlink" title="VPS相关"></a>VPS相关</h3><ul><li>因为frp的原理是利用服务端（所准备的VPS）进行转发，因而VPS的速度直接决定了之后连接的质量，请根据自己的需要选择相应主机配置。</li><li>我使用了DigitalOcean的新加坡机房，北京移动、中国教育网下测试速度尚可。</li><li>系统使用Ubuntu 16.04.5 x64，frp客户端和服务端本身同时均支持Linux和Windows，且配置方法一样，请根据实际环境自行测试，如果你是新建的VPS，那选择Ubuntu 16.04.5 x64就可以了。</li></ul><h2 id="服务端设置"><a href="#服务端设置" class="headerlink" title="服务端设置"></a>服务端设置</h2><p>SSH连接到VPS之后运行如下命令查看处理器架构，根据架构下载不同版本的frp<br><code>arch</code><br>查看结果，如果是“X86_64“即可选择”amd64”，<br>运行如下命令，根据架构不同，选择相应版本并进行下载<br><code>wget https://github.com/fatedier/frp/releases/download/v0.22.0/frp_0.22.0_linux_amd64.tar.gz</code><br>然后解压<br><code>tar -zxvf frp_0.22.0_linux_amd64.tar.gz</code><br>文件夹改个名，方便使用<br><code>cp -r frp_0.22.0_linux_amd64 frp</code><br>把解压出来的文件夹复制到你想要的目录下，为了方便我直接放在用户目录下了，进入该目录<br><code>cd frp</code><br>查看一下文件<br><code>ls -a</code><br>我们只需要关注如下几个文件</p><ul><li>frps</li><li>frps.ini</li><li>frpc</li><li>frpc.ini</li></ul><p>前两个文件（s结尾代表server）分别是服务端程序和服务端配置文件，后两个文件（c结尾代表client）分别是客户端程序和客户端配置文件。<br>因为我们正在配置服务端，可以删除客户端的两个文件<br><code>rm frpc</code><br><code>rm frpc.ini</code><br>然后修改frps.ini文件<br><code>vim frps.ini</code><br>这个文件应有如下格式</p><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-section">[common]</span><span class="hljs-attr">bind_port</span> = <span class="hljs-number">7000</span><span class="hljs-attr">dashboard_port</span> = <span class="hljs-number">7500</span><span class="hljs-attr">token</span> = <span class="hljs-number">12345678</span><span class="hljs-attr">dashboard_user</span> = admin<span class="hljs-attr">dashboard_pwd</span> = admin<span class="hljs-attr">vhost_http_port</span> = <span class="hljs-number">10080</span><span class="hljs-attr">vhost_https_port</span> = <span class="hljs-number">10443</span></code></pre></div><blockquote><p>如果没有必要，端口均可使用默认值，token、user和password项请自行设置。</p></blockquote><ul><li>“bind_port”表示用于客户端和服务端连接的端口，这个端口号我们之后在配置客户端的时候要用到。</li><li>“dashboard_port”是服务端仪表板的端口，若使用7500端口，在配置完成服务启动后可以通过浏览器访问 x.x.x.x:7500 （其中x.x.x.x为VPS的IP）查看frp服务运行信息。</li><li>“token”是用于客户端和服务端连接的口令，请自行设置并记录，稍后会用到。</li><li>“dashboard_user”和“dashboard_pwd”表示打开仪表板页面登录的用户名和密码，自行设置即可。</li><li>“vhost_http_port”和“vhost_https_port”用于反向代理HTTP主机时使用，本文不涉及HTTP协议，因而照抄或者删除这两条均可。</li></ul><p>编辑完成后保存（vim保存如果不会请自行搜索）。<br>之后我们就可以运行frps的服务端了<br><code>./frps -c frps.ini</code><br>如果看到屏幕输出这样一段内容，即表示运行正常，如果出现错误提示，请检查上面的步骤。</p><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-number">2019</span><span class="hljs-regexp">/01/</span><span class="hljs-number">12</span> <span class="hljs-number">15</span>:<span class="hljs-number">22</span>:<span class="hljs-number">39</span> [I] [service.go:<span class="hljs-number">130</span>] frps tcp listen on <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>:<span class="hljs-number">7000</span><span class="hljs-number">2019</span><span class="hljs-regexp">/01/</span><span class="hljs-number">12</span> <span class="hljs-number">15</span>:<span class="hljs-number">22</span>:<span class="hljs-number">39</span> [I] [service.go:<span class="hljs-number">172</span>] http service listen on <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>:<span class="hljs-number">10080</span><span class="hljs-number">2019</span><span class="hljs-regexp">/01/</span><span class="hljs-number">12</span> <span class="hljs-number">15</span>:<span class="hljs-number">22</span>:<span class="hljs-number">39</span> [I] [service.go:<span class="hljs-number">193</span>] https service listen on <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>:<span class="hljs-number">10443</span><span class="hljs-number">2019</span><span class="hljs-regexp">/01/</span><span class="hljs-number">12</span> <span class="hljs-number">15</span>:<span class="hljs-number">22</span>:<span class="hljs-number">39</span> [I] [service.go:<span class="hljs-number">216</span>] Dashboard listen on <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>:<span class="hljs-number">7500</span><span class="hljs-number">2019</span><span class="hljs-regexp">/01/</span><span class="hljs-number">12</span> <span class="hljs-number">15</span>:<span class="hljs-number">22</span>:<span class="hljs-number">39</span> [I] [root.go:<span class="hljs-number">210</span>] Start frps success</code></pre></div><p>此时访问 x.x.x.x:7500 并使用自己设置的用户名密码登录，即可看到仪表板界面</p><p><img src="https://s2.ax1x.com/2019/01/12/FjUf76.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="frp服务端仪表板界面">frp服务端仪表板界面</p><h2 id="服务端后台运行"><a href="#服务端后台运行" class="headerlink" title="服务端后台运行"></a>服务端后台运行</h2><p>至此，我们的服务端仅运行在前台，如果Ctrl+C停止或者关闭SSH窗口后，frps均会停止运行，因而我们使用 <a href="https://ehlxr.me/2017/01/18/Linux-%E7%9A%84-nohup-%E5%91%BD%E4%BB%A4%E7%9A%84%E7%94%A8%E6%B3%95/">nohup命令</a>将其运行在后台。</p><blockquote><p>nohup后台程序管理或关闭相关命令可自行查询资料，上面这个连接中也有所提及。</p></blockquote><p><code>nohup ./frps -c frps.ini &amp;</code><br>输出如下内容即表示正常运行</p><div class="hljs code-wrapper"><pre><code class="hljs lua">nohup: ignoring <span class="hljs-built_in">input</span> <span class="hljs-keyword">and</span> appending <span class="hljs-built_in">output</span> to <span class="hljs-string">&#x27;nohup.out&#x27;</span></code></pre></div><p>此时可先使用Ctrl+C关闭nohup，frps依然会在后台运行，使用jobs命令查看后台运行的程序<br><code>jobs</code><br>在结果中我们可以看到frps正在后台正常运行</p><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-selector-attr">[1]</span>+  Running                 nohup ./frps -c frps<span class="hljs-selector-class">.ini</span> &amp;</code></pre></div><p>此时访问 x.x.x.x:7500 依然可以打开仪表板界面，至此，服务端即设置完成，你可以关闭SSH窗口了。</p><h2 id="客户端设置"><a href="#客户端设置" class="headerlink" title="客户端设置"></a>客户端设置</h2><blockquote><p>frp的客户端就是我们想要真正进行访问的那台设备，大多数情况下应该会是一台Windows主机，因而本文使用Windows主机做例子；Linux配置方法类似，不再赘述。</p></blockquote><p>同样地，根据客户端设备的情况选择相应的frp程序进行<a href="https://github.com/fatedier/frp/releases">下载</a>，Windows下下载和解压等步骤不再描述。<br>假定你下载了“frp_0.22.0_windows_amd64.zip”，将其解压在了C盘根目录下，并且将文件夹重命名为“frp”，可以删除其中的frps和frps.ini文件。<br>用文本编辑器打开frpc.ini，与服务端类似，内容如下。</p><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-section">[common]</span><span class="hljs-attr">server_addr</span> = x.x.x.x<span class="hljs-attr">server_port</span> = <span class="hljs-number">7000</span><span class="hljs-attr">token</span> = won517574356<span class="hljs-section">[rdp]</span><span class="hljs-attr">type</span> = tcp<span class="hljs-attr">local_ip</span> = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>           <span class="hljs-attr">local_port</span> = <span class="hljs-number">3389</span><span class="hljs-attr">remote_port</span> = <span class="hljs-number">7001</span>  <span class="hljs-section">[smb]</span><span class="hljs-attr">type</span> = tcp<span class="hljs-attr">local_ip</span> = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><span class="hljs-attr">local_port</span> = <span class="hljs-number">445</span><span class="hljs-attr">remote_port</span> = <span class="hljs-number">7002</span></code></pre></div><p>其中common字段下的三项即为服务端的设置。</p><ul><li>“server_addr”为服务端IP地址，填入即可。</li><li>“server_port”为服务器端口，填入你设置的端口号即可，如果未改变就是7000</li><li>“token”是你在服务器上设置的连接口令，原样填入即可。</li></ul><h2 id="自定义规则"><a href="#自定义规则" class="headerlink" title="自定义规则"></a>自定义规则</h2><p>frp实际使用时，会按照端口号进行对应的转发，原理如下图所示。</p><p><img src="https://s2.ax1x.com/2019/01/12/FjUW0x.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="frp的原理">frp的原理</p><p>上面frpc.ini的rdp、smb字段都是自己定义的规则，自定义端口对应时格式如下。</p><ul><li>“[xxx]”表示一个规则名称，自己定义，便于查询即可。</li><li>“type”表示转发的协议类型，有TCP和UDP等选项可以选择，如有需要请自行查询frp手册。</li><li>“local_port”是本地应用的端口号，按照实际应用工作在本机的端口号填写即可。</li><li>“remote_port”是该条规则在服务端开放的端口号，自己填写并记录即可。</li></ul><blockquote><p>RDP，即Remote Desktop 远程桌面，Windows的RDP默认端口是3389，协议为TCP，建议使用frp远程连接前，在局域网中测试好，能够成功连接后再使用frp穿透连接。</p><p>SMB，即Windows文件共享所使用的协议，默认端口号445，协议TCP，本条规则可实现远程文件访问。</p></blockquote><p>配置完成frpc.ini后，就可以运行frpc了</p><blockquote><p>frpc程序不能直接双击运行！</p></blockquote><p>使用命令提示符或Powershell进入该目录下<br><code>cd C:\frp</code><br>并执行<br><code>./frpc -c frpc.ini</code><br>运行frpc程序，窗口中输出如下内容表示运行正常。</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">2019</span>/<span class="hljs-number">01</span>/<span class="hljs-number">12</span> <span class="hljs-number">16</span>:<span class="hljs-number">14</span>:<span class="hljs-number">56</span><span class="hljs-meta"> [I] [service.go:205] login to server success, get run id [2b65b4e58a5917ac], server udp port [0]</span><span class="hljs-attribute">2019</span>/<span class="hljs-number">01</span>/<span class="hljs-number">12</span> <span class="hljs-number">16</span>:<span class="hljs-number">14</span>:<span class="hljs-number">56</span><span class="hljs-meta"> [I] [proxy_manager.go:136] [2b65b4e58a5917ac] proxy added: [rdp smb]</span><span class="hljs-attribute">2019</span>/<span class="hljs-number">01</span>/<span class="hljs-number">12</span> <span class="hljs-number">16</span>:<span class="hljs-number">14</span>:<span class="hljs-number">56</span><span class="hljs-meta"> [I] [control.go:143] [smb] start proxy success</span><span class="hljs-meta">2019/01/12 16:14:56 [I] [control.go:143] [rdp] start proxy success</span></code></pre></div><p>不要关闭命令行窗口，此时可以在局域网外使用相应程序访问 x.x.x.x:xxxx （IP为VPS的IP，端口为自定义的remote_port）即可访问到相应服务。</p><h2 id="客户端后台运行及开机自启"><a href="#客户端后台运行及开机自启" class="headerlink" title="客户端后台运行及开机自启"></a>客户端后台运行及开机自启</h2><p>frpc运行时始终有一个命令行窗口运行在前台，影响美观，我们可以使用一个批处理文件来将其运行在后台，而且可以双击执行，每次打开frpc不用再自己输命令了。<br>在任何一个目录下新建一个文本文件并将其重命名为“frpc.bat”，编辑，粘贴如下内容并保存。</p><div class="hljs code-wrapper"><pre><code class="hljs dos">@<span class="hljs-built_in">echo</span> off<span class="hljs-keyword">if</span> &quot;%<span class="hljs-number">1</span>&quot; == &quot;h&quot; <span class="hljs-keyword">goto</span> beginmshta vbscript:createobject(&quot;wscript.shell&quot;).run(&quot;&quot;&quot;%~nx0&quot;&quot; h&quot;,<span class="hljs-number">0</span>)(window.close)&amp;&amp;<span class="hljs-keyword">exit</span>:begin<span class="hljs-comment">REM</span><span class="hljs-built_in">cd</span> C:\frpfrpc -c frpc.ini<span class="hljs-keyword">exit</span></code></pre></div><blockquote><p>将cd后的路径更改为你的frpc实际存放的目录。</p></blockquote><p>之后直接运行这个 .bat 文件即可启动frpc并隐藏窗口（可在任务管理器中退出）。<br>至于开机启动，把这个 .bat 文件直接扔进Windows的开机启动文件夹就好了 :)<br>至此，客户端配置完成，之后就是你自己根据需要在frpc.ini后追加规则即可。<br>强烈建议你在使用frp直接测试内网穿透前，先在局域网内测试好相关功能的正常使用，并配置好可能会影响的Windows防火墙等内容，在内网调试通过后再使用frp进行内网穿透测试。</p>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>frp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>frp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vncserver</title>
    <link href="/2021/01/05/basic-connect-vncserver/"/>
    <url>/2021/01/05/basic-connect-vncserver/</url>
    
    <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><div class="hljs code-wrapper"><pre><code class="hljs shell">sh -c &quot;$(curl -x 192.168.31.225:10822 -fsSl https://raw.githubusercontent.com/czy1024/luna-linux-conf/master/vnc/vnc_install.sh)&quot;</code></pre></div><p>VNC Client就不用说了，单文件版，双击就能运行。</p><p>VNC Server安装如下：</p><ol><li><strong>ssh到你的server，然后输入以下命令安装tiger vnc</strong>：</li></ol><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo apt install tigervnc-standalone-server tigervnc-xorg-extension tigervnc-viewer</code></pre></div><ol><li><strong>如果你没有任何桌面的话，可以输入以下命令安装过gnome桌面</strong>：</li></ol><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo apt install ubuntu-gnome-desktopsudo systemctl enable gdmsudo systemctl start gdm</code></pre></div><ol><li><strong>配置vnc的登陆密码，直接输入以下命令，输入两次密码即可（最多只能输入8位）</strong>：</li></ol><div class="hljs code-wrapper"><pre><code class="hljs shell">vncpasswd</code></pre></div><ol><li><strong>配置vnc使用gnome桌面</strong>：</li></ol><div class="hljs code-wrapper"><pre><code class="hljs shell">nano ~/.vnc/xstartup</code></pre></div><p>然后将以下内容粘贴进去，并保存：</p><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/sh</span><span class="hljs-meta">#</span><span class="bash"> Uncomment the following two lines <span class="hljs-keyword">for</span> normal desktop:</span>export XKL_XMODMAP_DISABLE=1unset SESSION_MANAGER<span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">exec</span> /etc/X11/xinit/xinitrc</span>unset DBUS_SESSION_BUS_ADDRESSgnome-panel &amp;gnmoe-settings-daemon &amp;metacity &amp;nautilus &amp;gnome-terminal &amp;</code></pre></div><p>如果你使用的xfce桌面，就粘贴如下代码：</p><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/sh</span> unset SESSION_MANAGER unset DBUS_SESSION_BUS_ADDRESS startxfce4 &amp; [ -x /etc/vnc/xstartup ] &amp;&amp; exec /etc/vnc/xstartup [ -r $HOME/.Xresources ] &amp;&amp; xrdb $HOME/.Xresources xsetroot -solid grey</code></pre></div><ol><li><strong>启动TigerVNC，直接输入</strong><code>vncserver</code><strong>看到如下结果就成功了</strong><br><img src="https://img-blog.csdnimg.cn/20191121141703662.jpg" alt="在这里插入图片描述"><br>但是别着急连,因为还不能用. 输入<code>netstat -ntupl|grep vnc</code>查看tiger vnc的端口监听状况:<br><img src="https://img-blog.csdnimg.cn/20191121141940642.jpg" alt="在这里插入图片描述"><br>发现它只是监听了127.0.0.1本地地址，没有监听外网地址。输入<code>vncserver -kill :*</code>关闭vncserver（实际上是关闭了所有vnc开启的桌面，更多命令参考请输入<code>vncserver --help</code>），然后再输入<code>vncserver -localhost no</code>，开启外网的监听。<br><img src="https://img-blog.csdnimg.cn/20191121142528917.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9jYXRzaGl0b25lLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到已经监听0.0.0.0了，端口5901。<br>如果你使用ECS或者有防火墙的话，可能会有一些安全策略上的配置需要你放行该端口。<br>至此，你可以开启VNC Viewer进行远程了。<br><img src="https://img-blog.csdnimg.cn/20191121145230255.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9jYXRzaGl0b25lLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>(1) VNC server输入IP和端口的方式（中间用两个冒号分隔）。</p><p>(2) 如果远程之后你发现是<strong>灰屏而且鼠标指针是个十字</strong>的话，表明需要安装gnome缺失组件：</p><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo apt-get install --no-install-recommends ubuntu-desktop gnome-panel gnome-settings-daemon metacity nautilus gnome-terminal -y</code></pre></div><p>然后再安装dpi</p><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo apt-get install xfonts-100dpisudo apt-get install xfonts-75dpi</code></pre></div><h3 id="图赏"><a href="#图赏" class="headerlink" title="图赏"></a>图赏</h3><p><img src="https://img-blog.csdnimg.cn/20191121144358233.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9jYXRzaGl0b25lLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><blockquote><p>Inspired by<br><a href="https://www.cyberciti.biz/faq/install-and-configure-tigervnc-server-on-ubuntu-18-04/">1.Install and Configure TigerVNC server on Ubuntu 18.04</a><br><a href="https://blog.csdn.net/ypbsyy/article/details/80096757">2.VNC连接Ubuntu 16.04桌面灰色的问题解决</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>vnc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vncserver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis</title>
    <link href="/2021/01/04/redis/"/>
    <url>/2021/01/04/redis/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在Web应用发展的初期，那时关系型数据库受到了较为广泛的关注和应用，原因是因为那时候Web站点基本上访问和并发不高、交互也较少。而在后来，随着访问量的提升，使用关系型数据库的Web站点多多少少都开始在性能上出现了一些瓶颈，而瓶颈的源头一般是在磁盘的I/O上。而随着互联网技术的进一步发展，各种类型的应用层出不穷，这导致在当今云计算、大数据盛行的时代，对性能有了更多的需求，主要体现在以下四个方面：</p><ol><li>低延迟的读写速度：应用快速地反应能极大地提升用户的满意度</li><li>支撑海量的数据和流量：对于搜索这样大型应用而言，需要利用PB级别的数据和能应对百万级的流量</li><li>大规模集群的管理：系统管理员希望分布式应用能更简单的部署和管理</li><li>庞大运营成本的考量：IT部门希望在硬件成本、软件成本和人力成本能够有大幅度地降低</li></ol><p>为了克服这一问题，NoSQL应运而生，它同时具备了高性能、可扩展性强、高可用等优点，受到广泛开发人员和仓库管理人员的青睐。</p><h3 id="Redis是什么"><a href="#Redis是什么" class="headerlink" title="Redis是什么"></a>Redis是什么</h3><p>Redis是现在最受欢迎的NoSQL数据库之一，Redis是一个使用ANSI C编写的开源、包含多种数据结构、支持网络、基于内存、可选持久性的键值对存储数据库，其具备如下特性：</p><ul><li>基于内存运行，性能高效</li><li>支持分布式，理论上可以无限扩展</li><li>key-value存储系统</li><li>开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API</li></ul><p>相比于其他数据库类型，Redis具备的特点是：</p><ul><li>C/S通讯模型</li><li>单进程单线程模型</li><li>丰富的数据类型</li><li>操作具有原子性</li><li>持久化</li><li>高并发读写</li><li>支持lua脚本</li></ul><p>哪些大厂在使用Redis？</p><ul><li>github</li><li>twitter</li><li>微博</li><li>Stack Overflow</li><li>阿里巴巴</li><li>百度</li><li>美团</li><li>搜狐</li></ul><h4 id="Redis的应用场景有哪些？"><a href="#Redis的应用场景有哪些？" class="headerlink" title="Redis的应用场景有哪些？"></a>Redis的应用场景有哪些？</h4><p>Redis 的应用场景包括：缓存系统（“热点”数据：高频读、低频写）、计数器、消息队列系统、排行榜、社交网络和实时系统。</p><p> <img src="https://i.loli.net/2021/01/19/H8lWRphECVtYGk2.png" alt="img"></p><h3 id="Redis的数据类型及主要特性"><a href="#Redis的数据类型及主要特性" class="headerlink" title="Redis的数据类型及主要特性"></a>Redis的数据类型及主要特性</h3><p>Redis提供的数据类型主要分为5种自有类型和一种自定义类型，这5种自有类型包括：String类型、哈希类型、列表类型、集合类型和顺序集合类型。</p><p><img src="https://i.loli.net/2021/01/19/dzZCyliWpQwqRhT.png" alt="img"></p><h4 id="String类型："><a href="#String类型：" class="headerlink" title="String类型："></a>String类型：</h4><p>它是一个二进制安全的字符串，意味着它不仅能够存储字符串、还能存储图片、视频等多种类型, 最大长度支持512M。</p><p>对每种数据类型，Redis都提供了丰富的操作命令，如：</p><ul><li>GET/MGET</li><li>SET/SETEX/MSET/MSETNX</li><li>INCR/DECR</li><li>GETSET</li><li>DEL</li></ul><h4 id="哈希类型："><a href="#哈希类型：" class="headerlink" title="哈希类型："></a>哈希类型：</h4><p>该类型是由field和关联的value组成的map。其中，field和value都是字符串类型的。</p><p>Hash的操作命令如下：</p><ul><li>HGET/HMGET/HGETALL</li><li>HSET/HMSET/HSETNX</li><li>HEXISTS/HLEN</li><li>HKEYS/HDEL</li><li>HVALS</li></ul><h4 id="列表类型："><a href="#列表类型：" class="headerlink" title="列表类型："></a>列表类型：</h4><p>该类型是一个插入顺序排序的字符串元素集合, 基于双链表实现。</p><p>List的操作命令如下：</p><ul><li>LPUSH/LPUSHX/LPOP/RPUSH/RPUSHX/RPOP/LINSERT/LSET</li><li>LINDEX/LRANGE</li><li>LLEN/LTRIM</li></ul><h4 id="集合类型："><a href="#集合类型：" class="headerlink" title="集合类型："></a>集合类型：</h4><p>Set类型是一种无顺序集合, 它和List类型最大的区别是：集合中的元素没有顺序, 且元素是唯一的。</p><p>Set类型的底层是通过哈希表实现的，其操作命令为：</p><ul><li>SADD/SPOP/SMOVE/SCARD</li><li>SINTER/SDIFF/SDIFFSTORE/SUNION</li></ul><p>Set类型主要应用于：在某些场景，如社交场景中，通过交集、并集和差集运算，通过Set类型可以非常方便地查找共同好友、共同关注和共同偏好等社交关系。</p><h4 id="顺序集合类型："><a href="#顺序集合类型：" class="headerlink" title="顺序集合类型："></a>顺序集合类型：</h4><p>ZSet是一种有序集合类型，每个元素都会关联一个double类型的分数权值，通过这个权值来为集合中的成员进行从小到大的排序。与Set类型一样，其底层也是通过哈希表实现的。</p><p>ZSet命令：</p><ul><li>ZADD/ZPOP/ZMOVE/ZCARD/ZCOUNT</li><li>ZINTER/ZDIFF/ZDIFFSTORE/ZUNION</li></ul><h3 id="Redis的数据结构"><a href="#Redis的数据结构" class="headerlink" title="Redis的数据结构"></a>Redis的数据结构</h3><p>Redis的数据结构如下图所示：</p><p><img src="https://i.loli.net/2021/01/19/dY6Qa2FX4nyPj7C.png" alt="img"></p><p>关于上表中的部分释义：</p><ol><li>压缩列表是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数，要么就是长度比较短的字符串，Redis就会使用压缩列表来做列表键的底层实现</li><li>整数集合是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现</li></ol><p>如下是定义一个Struct数据结构的例子：</p><p><img src="https://czy1024.github.io/luna-image-bed/img/139239-20191126141036706-1247302576.png" alt="img"></p><h4 id="简单动态字符串SDS-Simple-Dynamic-String"><a href="#简单动态字符串SDS-Simple-Dynamic-String" class="headerlink" title="简单动态字符串SDS (Simple Dynamic String)"></a>简单动态字符串SDS (Simple Dynamic String)</h4><p>基于C语言中传统字符串的缺陷，Redis自己构建了一种名为简单动态字符串的抽象类型，简称SDS，其结构如下：</p><p><img src="https://czy1024.github.io/luna-image-bed/img/139239-20191126141052157-436992972.png" alt="img"></p><p>SDS几乎贯穿了Redis的所有数据结构，应用十分广泛。</p><h4 id="SDS的特点"><a href="#SDS的特点" class="headerlink" title="SDS的特点"></a>SDS的特点</h4><p>和C字符串相比，SDS的特点如下：</p><p><img src="https://czy1024.github.io/luna-image-bed/img/139239-20191126141103927-1852926069.png" alt="img"></p><p>　　1. 常数复杂度获取字符串长度</p><p>　　　　Redis中利用SDS字符串的len属性可以直接获取到所保存的字符串的长<br>　　　　度，直接将获取字符串长度所需的复杂度从C字符串的O(N)降低到了O(1)。</p><p>　　2. 减少修改字符串时导致的内存重新分配次数</p><p>　　　　通过C字符串的特性，我们知道对于一个包含了N个字符的C字符串来说，其底层实现总是N+1个字符长的数组（额外一个空字符结尾）</p><p>　　　　那么如果这个时候需要对字符串进行修改，程序就需要提前对这个C字符串数组进行一次内存重分配（可能是扩展或者释放）　</p><p>　　　　而内存重分配就意味着是一个耗时的操作。</p><p>Redis巧妙的使用了SDS避免了C字符串的缺陷。在SDS中，buf数组的长度不一定就是字符串的字符数量加一，buf数组里面可以包含未使用的字节，而这些未使用的字节由free属性记录。</p><p>与此同时，SDS采用了<strong>空间预分配</strong>的策略，避免C字符串每一次修改时都需要进行内存重分配的耗时操作，将内存重分配从原来的每修改N次就分配N次——&gt;降低到了修改N次最多分配N次。</p><p>如下是Redis对SDS的简单定义：</p><p><img src="https://czy1024.github.io/luna-image-bed/img/139239-20191126141239967-123973180.png" alt="img"> </p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvqmb7qezrj60bb0bwdgx02.jpg" alt="img"></p><h3 id="Redis特性1：事务"><a href="#Redis特性1：事务" class="headerlink" title="Redis特性1：事务"></a>Redis特性1：事务</h3><ul><li>命令序列化，按顺序执行</li><li>原子性</li><li>三阶段: 开始事务 - 命令入队 - 执行事务</li><li>命令：MULTI/EXEC/DISCARD</li></ul><h3 id="Redis特性2：发布订阅-Pub-Sub"><a href="#Redis特性2：发布订阅-Pub-Sub" class="headerlink" title="Redis特性2：发布订阅(Pub/Sub)"></a>Redis特性2：发布订阅(Pub/Sub)</h3><ul><li>Pub/sub是一种消息通讯模式</li><li>Pub发送消息, Sub接受消息</li><li>Redis客户端可以订阅任意数量的频道</li><li>“fire and forgot”, 发送即遗忘</li><li>命令：Publish/Subscribe/Psubscribe/UnSub</li></ul><p>　　<img src="https://i.loli.net/2021/01/19/u5pyEk47B2dKDHC.png" alt="img"></p><h3 id="Redis特性3：Stream"><a href="#Redis特性3：Stream" class="headerlink" title="Redis特性3：Stream"></a>Redis特性3：Stream</h3><ul><li>Redis 5.0新增</li><li>等待消费</li><li>消费组(组内竞争)</li><li>消费历史数据</li><li>FIFO</li></ul><p><img src="https://i.loli.net/2021/01/19/5RsvUW9X81aLdVl.png" alt="img"></p><p>以上就是Redis的基本概念，下面我们将介绍在开发过程中可能会踩到的“坑”。</p><h3 id="Redis常见问题解析：击穿"><a href="#Redis常见问题解析：击穿" class="headerlink" title="Redis常见问题解析：击穿"></a>Redis常见问题解析：击穿</h3><p>概念：在Redis获取某一key时, 由于key不存在, 而必须向DB发起一次请求的行为, 称为“Redis击穿”。</p><p><img src="https://i.loli.net/2021/01/19/KXzoAb5Wf8xjMpB.png" alt="img"></p><p>引发击穿的原因：</p><ul><li>第一次访问</li><li>恶意访问不存在的key</li><li>Key过期</li></ul><p>合理的规避方案：</p><ul><li>服务器启动时, 提前写入</li><li>规范key的命名, 通过中间件拦截</li><li>对某些高频访问的Key，设置合理的TTL或永不过期</li></ul><h3 id="Redis常见问题解析：雪崩"><a href="#Redis常见问题解析：雪崩" class="headerlink" title="Redis常见问题解析：雪崩"></a>Redis常见问题解析：雪崩</h3><p>概念：Redis缓存层由于某种原因宕机后，所有的请求会涌向存储层，短时间内的高并发请求可能会导致存储层挂机，称之为“Redis雪崩”。</p><p>合理的规避方案：</p><ul><li>使用Redis集群</li><li>限流</li></ul><h3 id="Redis在产品开发中的应用实践"><a href="#Redis在产品开发中的应用实践" class="headerlink" title="Redis在产品开发中的应用实践"></a>Redis在产品开发中的应用实践</h3><p>为此，我很高兴的为大家介绍，葡萄城架构师Jim将在2019-11-27 14：00 为大家带来一场公开课，其中 Jim除了为大家讲解Redis的基础，同时也会实际演示他所在的项目组使用Redis时碰到的问题以及解决方案，对于刚接触Redis的同学来说，更具参考意义和学习价值，欢迎大家届时参加，公开课地址：<a href="https://live.vhall.com/661463644%E3%80%82">https://live.vhall.com/661463644。</a></p><ul><li>后端采用nodeJS</li><li>使用Azure的Redis服务</li><li>Redis的使用场景</li></ul><p>　　　　- token缓存, 用于令牌验证</p><p>　　　　- IP白名单</p><p>碰到的问题</p><ul><li>“网络抖动”或者Redis服务异常导致Redis访问超时</li><li>Redis客户端驱动稳定性问题</li></ul><p>　　　　- 连接池 “Broken connection” 问题</p><p>　　　　- JS的Promise引出的Redis重置问题</p><p>下面我们来简单了解一下Redis的进阶知识。</p><h3 id="进阶之Redis协议简介"><a href="#进阶之Redis协议简介" class="headerlink" title="进阶之Redis协议简介"></a>进阶之Redis协议简介</h3><p>Redis客户端通讯协议：RESP(Redis Serialization Protocol)，其特点是：</p><ul><li>简单</li><li>解析速度快</li><li>可读性好</li></ul><p>Redis集群内部通讯协议：RECP(Redis Cluster Protocol ) ，其特点是：</p><ul><li>每一个node两个tcp 连接</li><li>一个负责client-server通讯(P: 6379)</li><li>一个负责node之间通讯(P: 10000 + 6379)</li></ul><p> <img src="https://i.loli.net/2021/01/19/1kqa8y9d3guoKNx.png" alt="img"></p><p>Redis协议支持的数据类型：</p><ul><li><p>简单字符(首字节: “+”)</p><p> 　　“+OK\r\n”</p></li><li><p>错误(首字节: “-”)</p><p> 　　“-error msg\r\n”</p></li><li><p>数字(首字节: “:”)</p><p> 　　“:123\r\n”</p></li><li><p>批量字符(首字节: “$”)</p><p> 　　“&amp;hello\r\nWhoa re you\r\n”</p></li><li><p>数组(首字节: “*”)</p><p> 　　“*0\r\n”</p><div class="hljs code-wrapper"><pre><code>　　“*-1\r\n”</code></pre></div></li></ul><h3 id="除了Redis，还有什么NoSQL型数据库"><a href="#除了Redis，还有什么NoSQL型数据库" class="headerlink" title="除了Redis，还有什么NoSQL型数据库"></a>除了Redis，还有什么NoSQL型数据库</h3><p>市面上类似于Redis，同样是NoSQL型的数据库有很多，如下图所示，除了Redis，还有MemCache、Cassadra和Mongo。下面，我们就分别对这几个数据库做一下简要的介绍：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvqmard27zj608w0aswez02.jpg" alt="img"></p><p><strong>Memcache****：</strong>这是一个和Redis非常相似的数据库，但是它的数据类型没有Redis丰富。Memcache由LiveJournal的Brad Fitzpatrick开发，作为一套分布式的高速缓存系统，被许多网站使用以提升网站的访问速度，对于一些大型的、需要频繁访问数据库的网站访问速度的提升效果十分显著。</p><p><strong>Apache Cassandra****：</strong>（社区内一般简称为C*）这是一套开源分布式NoSQL数据库系统。它最初由Facebook开发，用于储存收件箱等简单格式数据，集Google BigTable的数据模型与Amazon Dynamo的完全分布式架构于一身。Facebook于2008将 Cassandra 开源，由于其良好的可扩展性和性能，被 Apple、Comcast、Instagram、Spotify、eBay、Rackspace、Netflix等知名网站所采用，成为了一种流行的分布式结构化数据存储方案。</p><p><strong>MongoDB</strong>：是一个基于分布式文件存储、面向文档的NoSQL数据库，由C++编写，旨在为WEB应用提供可扩展的高性能数据存储解决方案。MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系型数据库的，它支持的数据结构非常松散，是一种类似json的BSON格式。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>middle-component</category>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>apt-get</title>
    <link href="/2021/01/01/linux-apt-get/"/>
    <url>/2021/01/01/linux-apt-get/</url>
    
    <content type="html"><![CDATA[<h2 id="镜像源网站"><a href="#镜像源网站" class="headerlink" title="镜像源网站"></a>镜像源网站</h2><p>Ubuntu、Python、Nodejs、MySQL、Git、Chromium、Docker、Homebrew 等一系列的常用开源系统、软件都是国外开发的，下载地址位于国外，从国内访问、下载、更新</p><h3 id="清华源镜像"><a href="#清华源镜像" class="headerlink" title="清华源镜像"></a>清华源镜像</h3><blockquote><p><a href="https://mirrors.tuna.tsinghua.edu.cn/">https://mirrors.tuna.tsinghua.edu.cn/</a></p></blockquote><p>可能是最好的国内镜像站，最吸引人的特点是1）帮助文件最全面最好用；2）镜像源数量最多。是最推荐的镜像源。</p><h3 id="腾讯源"><a href="#腾讯源" class="headerlink" title="腾讯源"></a>腾讯源</h3><blockquote><p><a href="https://mirrors.cloud.tencent.com/">https://mirrors.cloud.tencent.com/</a></p></blockquote><p>访问很快，无论是电信移动还是教育网等环境都不用担心访问速度。</p><p>软件数量和帮助文件尽管略逊于清华源，但还不错了，比阿里源好不少。</p><h3 id="阿里源"><a href="#阿里源" class="headerlink" title="阿里源"></a>阿里源</h3><blockquote><p><a href="https://developer.aliyun.com/mirror/">https://developer.aliyun.com/mirror/</a></p></blockquote><p>特点是不差钱，所以访问网速很快，无论是电信移动还是教育网等环境。</p><p>不足之处是镜像源数量较少，比腾讯源少，很多软件目前都没有，比如 GitLab。</p><h3 id="华为源"><a href="#华为源" class="headerlink" title="华为源"></a>华为源</h3><blockquote><p><a href="https://mirrors.huaweicloud.com/">https://mirrors.huaweicloud.com/</a></p></blockquote><p>软件数量还行，比阿里源多。</p><p>有一些华为自家的。也有个别其他镜像源没有的，比如 ChromeDriver，似乎在其他镜像站没找到过。</p><h3 id="中科大源"><a href="#中科大源" class="headerlink" title="中科大源"></a>中科大源</h3><blockquote><p><a href="http://mirrors.ustc.edu.cn/">http://mirrors.ustc.edu.cn/</a></p></blockquote><h3 id="上海交大源"><a href="#上海交大源" class="headerlink" title="上海交大源"></a>上海交大源</h3><p><a href="https://mirrors.sjtug.sjtu.edu.cn/#/">https://mirrors.sjtug.sjtu.edu.cn/#/</a></p><h3 id="北京外国语大学源"><a href="#北京外国语大学源" class="headerlink" title="北京外国语大学源"></a>北京外国语大学源</h3><p><a href="https://mirrors.bfsu.edu.cn/">https://mirrors.bfsu.edu.cn/</a></p><p>是清华源的姊妹站，维护和运营由清华源提供，本质上跟清华源是一样的。</p><p>官方公告显示：网络接入 CERNET2 IPv6 和中国移动 IPv4 线路，支持 HTTP/HTTPS/RSYNC 访问，如果在使用 TUNA 镜像时遇到负载过高、速度过慢等问题，可以尝试切换至北外镜像站以获得更佳的体验。</p><h3 id="网易源"><a href="#网易源" class="headerlink" title="网易源"></a>网易源</h3><blockquote><p><a href="http://mirrors.163.com/">http://mirrors.163.com/</a></p></blockquote><p>软件数量较少。</p><h3 id="豆瓣-Python-PyPI-镜像"><a href="#豆瓣-Python-PyPI-镜像" class="headerlink" title="豆瓣 Python PyPI 镜像"></a>豆瓣 Python PyPI 镜像</h3><blockquote><p><a href="http://pypi.doubanio.com/simple/">http://pypi.doubanio.com/simple/</a></p></blockquote><p>Python pip 广泛使用的国内源。</p><h3 id="淘宝-NPM-镜像"><a href="#淘宝-NPM-镜像" class="headerlink" title="淘宝 NPM 镜像"></a>淘宝 NPM 镜像</h3><blockquote><p><a href="https://developer.aliyun.com/mirror/NPM">https://developer.aliyun.com/mirror/NPM</a></p></blockquote><p>Nodejs npm/cnpm 方面可能最好用的国内源。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>考虑镜像源的选择大致主要为 3 方面：</p><ul><li>覆盖的软件数量</li><li>访问速度，从各地、各宽带运营商的访问速度</li><li>帮助文件</li></ul><p>总体来说，首推清华源，在覆盖软件数量和帮助文件方面堪称国内最好的镜像站。</p><p>访问速度方面，大型商业公司、尤其是云服务商（没错，指的是腾讯源、阿里源和华为源）的镜像站会做得更好，毕竟钱多、基础设施广。</p><p>在细分领域方面，特定领域有固有的特定选择。例如 Nodejs npm 的话淘宝的 cnpm 是不二的选择。又例如，Anaconda 由于授权原因，似乎只有清华源在内的几个大学的镜像站拿到了授权，腾讯、阿里等商业公司的镜像站不知道是没拿到授权还是懒得申请授权，并未上线 Anaconda 镜像。</p><h2 id="Ubuntu20-apt-源"><a href="#Ubuntu20-apt-源" class="headerlink" title="Ubuntu20 apt 源"></a>Ubuntu20 apt 源</h2><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 备份原文件</span>cp /etc/apt/sources.list /etc/apt/sources.list.copysudo cat &gt; /etc/apt/sources.list &lt;&lt;<span class="hljs-string">EOF </span><span class="hljs-string"></span><span class="hljs-string"># ubuntu 20.10</span><span class="hljs-string"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><span class="hljs-string">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ groovy main restricted universe multiverse</span><span class="hljs-string"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ groovy main restricted universe multiverse</span><span class="hljs-string">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ groovy-updates main restricted universe multiverse</span><span class="hljs-string"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ groovy-updates main restricted universe multiverse</span><span class="hljs-string">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ groovy-backports main restricted universe multiverse</span><span class="hljs-string"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ groovy-backports main restricted universe multiverse</span><span class="hljs-string">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ groovy-security main restricted universe multiverse</span><span class="hljs-string"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ groovy-security main restricted universe multiverse</span><span class="hljs-string"></span><span class="hljs-string"># 预发布软件源，不建议启用</span><span class="hljs-string"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ groovy-proposed main restricted universe multiverse</span><span class="hljs-string"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ groovy-proposed main restricted universe multiverse</span><span class="hljs-string">EOF</span><span class="hljs-comment"># 更新源</span>sudo apt-get update</code></pre></div><p>apt-get 命令适用于 deb 包管理式的 Linux 操作系统（Debian、Ubuntu等），主要用于自动从互联网软件仓库中搜索、下载、安装、升级、卸载软件或操作系统。</p><p>Ubuntu 软件包查找: <a href="https://links.jianshu.com/go?to=https://packages.ubuntu.com/">https://packages.ubuntu.com/</a></p><h3 id="1-安装-软件包"><a href="#1-安装-软件包" class="headerlink" title="1. 安装 软件包"></a>1. 安装 软件包</h3><p>apt-get install PackageName                    // 普通安装<br> apt-get install PackageName=VersionName     // 安装指定包的指定版本<br> apt-get –reinstall install PackageName     // 重新安装</p><p>apt-get build-dep PackageName               // 安装源码包所需要的编译环境<br> apt-get -f install                                        // 修复依赖关系</p><p>apt-get source PackageName                  // 下载软件包的源码</p><h3 id="2-卸载-软件包"><a href="#2-卸载-软件包" class="headerlink" title="2. 卸载 软件包"></a>2. 卸载 软件包</h3><p>apt-get remove PackageName              // 删除软件包, 保留配置文件</p><p>apt-get –purge remove PackageName      // 删除软件包, 同时删除配置文件<br> apt-get purge PackageName               // 删除软件包, 同时删除配置文件</p><p>apt-get autoremove PackageName          // 删除软件包, 同时删除为满足依赖<br> // 而自动安装且不再使用的软件包</p><p>apt-get –purge autoremove PackageName  // 删除软件包, 删除配置文件,<br> // 删除不再使用的依赖包</p><p>apt-get clean &amp;&amp; apt-get autoclean      // 清除 已下载的软件包 和 旧软件包</p><h3 id="3-更新-软件包"><a href="#3-更新-软件包" class="headerlink" title="3. 更新 软件包"></a>3. 更新 软件包</h3><p>apt-get update                               // 更新安装源（Source）<br> apt-get upgrade                             // 更新已安装的软件包<br> apt-get dist-upgrade                      // 更新已安装的软件包（识别并处理依赖关系的改变）</p><h3 id="4-查询-软件包"><a href="#4-查询-软件包" class="headerlink" title="4. 查询 软件包"></a>4. 查询 软件包</h3><p>dpkg -l                                                  // 列出已安装的所有软件包</p><p>apt-cache search PackageName         // 搜索软件包<br> apt-cache show PackageName            // 获取软件包的相关信息, 如说明、大小、版本等</p><p>apt-cache depends PackageName       // 查看该软件包需要哪些依赖包<br> apt-cache rdepends PackageName      // 查看该软件包被哪些包依赖<br> apt-get check                                         // 检查是否有损坏的依赖</p><h3 id="5-apt-get-–help"><a href="#5-apt-get-–help" class="headerlink" title="5. apt-get –help"></a>5. apt-get –help</h3><p>执行命令: apt-get –help，输出:</p><p>apt 1.0.1ubuntu2，用于 amd64 构架，编译于 Dec  8 2016 16:23:38<br> 用法： apt-get [选项] 命令<br> 　　 apt-get [选项] install|remove 软件包1 [软件包2 …]<br> 　　 apt-get [选项] source 软件包1 [软件包2 …]</p><p>apt-get 是一个用于下载和安装软件包的简易命令行界面。<br> 最常用命令是 update 和 install。</p><h3 id="命令："><a href="#命令：" class="headerlink" title="命令："></a>命令：</h3><p>update - 取回更新的软件包列表信息<br> upgrade - 进行一次升级<br> install - 安装新的软件包(注：软件包名称是 libc6 而非 libc6.deb)<br> remove - 卸载软件包<br> autoremove - 卸载所有自动安装且不再使用的软件包<br> purge - 卸载并清除软件包的配置<br> source - 下载源码包文件<br> build-dep - 为源码包配置所需的编译依赖关系<br> dist-upgrade - 发布版升级，见 apt-get(8)<br> dselect-upgrade - 根据 dselect 的选择来进行升级<br> clean - 删除所有已下载的包文件<br> autoclean - 删除已下载的旧包文件<br> check - 核对以确认系统的依赖关系的完整性<br> changelog - 下载指定软件包，并显示其changelog<br> download - 下载指定的二进制包到当前目录</p><h3 id="选项："><a href="#选项：" class="headerlink" title="选项："></a>选项：</h3><p>-h  本帮助文档。<br> -q  让输出可作为日志 - 不显示进度<br> -qq 除了错误外，什么都不输出<br> -d  仅仅下载 - 【不】安装或解开包文件<br> -s  不作实际操作。只是依次模拟执行命令<br> -y  对所有询问都回答是(Yes)，同时不作任何提示<br> -f  当出现破损的依赖关系时，程序将尝试修正系统<br> -m  当有包文件无法找到时，程序仍尝试继续执行<br> -u  显示已升级的软件包列表<br> -b  在下载完源码包后，编译生成相应的软件包<br> -V  显示详尽的版本号<br> -c=? 读取指定配置文件<br> -o=? 设置任意指定的配置选项，例如 -o dir::cache=/tmp<br> 请查阅 apt-get(8)、sources.list(5) 和 apt.conf(5)的参考手册<br> 以获取更多信息和选项。</p><h2 id="Centos7-yum-源"><a href="#Centos7-yum-源" class="headerlink" title="Centos7 yum 源"></a>Centos7 yum 源</h2><div class="hljs code-wrapper"><pre><code class="hljs bash">CentOS 8sudo sed -e <span class="hljs-string">&#x27;s|^mirrorlist=|#mirrorlist=|g&#x27;</span> \         -e <span class="hljs-string">&#x27;s|^#baseurl=http://mirror.centos.org/$contentdir|baseurl=https://mirrors.ustc.edu.cn/centos|g&#x27;</span> \         -i.bak \         /etc/yum.repos.d/CentOS-Base.repo \         /etc/yum.repos.d/CentOS-Extras.repo \         /etc/yum.repos.d/CentOS-AppStream.repoCentOS 6   &amp;   CentOS 7sudo sed -e <span class="hljs-string">&#x27;s|^mirrorlist=|#mirrorlist=|g&#x27;</span> \         -e <span class="hljs-string">&#x27;s|^#baseurl=http://mirror.centos.org/centos|baseurl=https://mirrors.ustc.edu.cn/centos|g&#x27;</span> \         -i.bak \         /etc/yum.repos.d/CentOS-Base.repo更新缓存yum makecache</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#备份</span>sudo cp /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak<span class="hljs-comment"># 注意名字</span>sudo cat &gt; /etc/yum.repos.d/CentOS-Base.repo &lt;&lt;<span class="hljs-string">EOF </span><span class="hljs-string">#https://mirrors.tuna.tsinghua.edu.cn/help/centos/</span><span class="hljs-string"></span><span class="hljs-string"># CentOS-Base.repo</span><span class="hljs-string">#</span><span class="hljs-string"># The mirror system uses the connecting IP address of the client and the</span><span class="hljs-string"># update status of each mirror to pick mirrors that are updated to and</span><span class="hljs-string"># geographically close to the client.  You should use this for CentOS updates</span><span class="hljs-string"># unless you are manually picking other mirrors.</span><span class="hljs-string">#</span><span class="hljs-string"># If the mirrorlist= does not work for you, as a fall back you can try the</span><span class="hljs-string"># remarked out baseurl= line instead.</span><span class="hljs-string">#</span><span class="hljs-string">#</span><span class="hljs-string"></span><span class="hljs-string"></span><span class="hljs-string">[base]</span><span class="hljs-string">name=CentOS-$releasever - Base</span><span class="hljs-string">baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/os/$basearch/</span><span class="hljs-string">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=os</span><span class="hljs-string">enabled=1</span><span class="hljs-string">gpgcheck=1</span><span class="hljs-string">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-7</span><span class="hljs-string"></span><span class="hljs-string">#released updates</span><span class="hljs-string">[updates]</span><span class="hljs-string">name=CentOS-$releasever - Updates</span><span class="hljs-string">baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/updates/$basearch/</span><span class="hljs-string">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=updates</span><span class="hljs-string">enabled=1</span><span class="hljs-string">gpgcheck=1</span><span class="hljs-string">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-7</span><span class="hljs-string"></span><span class="hljs-string"></span><span class="hljs-string"></span><span class="hljs-string">#additional packages that may be useful</span><span class="hljs-string">[extras]</span><span class="hljs-string">name=CentOS-$releasever - Extras</span><span class="hljs-string">baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/extras/$basearch/</span><span class="hljs-string">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=extras</span><span class="hljs-string">enabled=1</span><span class="hljs-string">gpgcheck=1</span><span class="hljs-string">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-7</span><span class="hljs-string"></span><span class="hljs-string"></span><span class="hljs-string"></span><span class="hljs-string">#additional packages that extend functionality of existing packages</span><span class="hljs-string">[centosplus]</span><span class="hljs-string">name=CentOS-$releasever - Plus</span><span class="hljs-string">baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/centosplus/$basearch/</span><span class="hljs-string">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=centosplus</span><span class="hljs-string">gpgcheck=1</span><span class="hljs-string">enabled=0</span><span class="hljs-string">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-7</span><span class="hljs-string">EOF</span></code></pre></div><h2 id="Centos8-yum-源"><a href="#Centos8-yum-源" class="headerlink" title="Centos8 yum 源"></a>Centos8 yum 源</h2><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#备份</span>sudo cp /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak<span class="hljs-comment">#  注意名字</span>sudo cat &gt; /etc/yum.repos.d/CentOS-Base.repo &lt;&lt;<span class="hljs-string">EOF </span><span class="hljs-string"># CentOS-Base.repo</span><span class="hljs-string">#</span><span class="hljs-string"># The mirror system uses the connecting IP address of the client and the</span><span class="hljs-string"># update status of each mirror to pick mirrors that are updated to and</span><span class="hljs-string"># geographically close to the client.  You should use this for CentOS updates</span><span class="hljs-string"># unless you are manually picking other mirrors.</span><span class="hljs-string">#</span><span class="hljs-string"># If the mirrorlist= does not work for you, as a fall back you can try the </span><span class="hljs-string"># remarked out baseurl= line instead.</span><span class="hljs-string">#</span><span class="hljs-string">#</span><span class="hljs-string"> </span><span class="hljs-string">[base]</span><span class="hljs-string">name=CentOS-$releasever - Base - mirrors.aliyun.com</span><span class="hljs-string">failovermethod=priority</span><span class="hljs-string">baseurl=https://mirrors.aliyun.com/centos/$releasever/BaseOS/$basearch/os/</span><span class="hljs-string">        http://mirrors.aliyuncs.com/centos/$releasever/BaseOS/$basearch/os/</span><span class="hljs-string">        http://mirrors.cloud.aliyuncs.com/centos/$releasever/BaseOS/$basearch/os/</span><span class="hljs-string">gpgcheck=1</span><span class="hljs-string">gpgkey=https://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-Official</span><span class="hljs-string"> </span><span class="hljs-string">#additional packages that may be useful</span><span class="hljs-string">[extras]</span><span class="hljs-string">name=CentOS-$releasever - Extras - mirrors.aliyun.com</span><span class="hljs-string">failovermethod=priority</span><span class="hljs-string">baseurl=https://mirrors.aliyun.com/centos/$releasever/extras/$basearch/os/</span><span class="hljs-string">        http://mirrors.aliyuncs.com/centos/$releasever/extras/$basearch/os/</span><span class="hljs-string">        http://mirrors.cloud.aliyuncs.com/centos/$releasever/extras/$basearch/os/</span><span class="hljs-string">gpgcheck=1</span><span class="hljs-string">gpgkey=https://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-Official</span><span class="hljs-string"> </span><span class="hljs-string">#additional packages that extend functionality of existing packages</span><span class="hljs-string">[centosplus]</span><span class="hljs-string">name=CentOS-$releasever - Plus - mirrors.aliyun.com</span><span class="hljs-string">failovermethod=priority</span><span class="hljs-string">baseurl=https://mirrors.aliyun.com/centos/$releasever/centosplus/$basearch/os/</span><span class="hljs-string">        http://mirrors.aliyuncs.com/centos/$releasever/centosplus/$basearch/os/</span><span class="hljs-string">        http://mirrors.cloud.aliyuncs.com/centos/$releasever/centosplus/$basearch/os/</span><span class="hljs-string">gpgcheck=1</span><span class="hljs-string">enabled=0</span><span class="hljs-string">gpgkey=https://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-Official</span><span class="hljs-string"> </span><span class="hljs-string">[PowerTools]</span><span class="hljs-string">name=CentOS-$releasever - PowerTools - mirrors.aliyun.com</span><span class="hljs-string">failovermethod=priority</span><span class="hljs-string">baseurl=https://mirrors.aliyun.com/centos/$releasever/PowerTools/$basearch/os/</span><span class="hljs-string">        http://mirrors.aliyuncs.com/centos/$releasever/PowerTools/$basearch/os/</span><span class="hljs-string">        http://mirrors.cloud.aliyuncs.com/centos/$releasever/PowerTools/$basearch/os/</span><span class="hljs-string">gpgcheck=1</span><span class="hljs-string">enabled=0</span><span class="hljs-string">gpgkey=https://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-Official</span><span class="hljs-string"></span><span class="hljs-string"></span><span class="hljs-string">[AppStream]</span><span class="hljs-string">name=CentOS-$releasever - AppStream - mirrors.aliyun.com</span><span class="hljs-string">failovermethod=priority</span><span class="hljs-string">baseurl=https://mirrors.aliyun.com/centos/$releasever/AppStream/$basearch/os/</span><span class="hljs-string">        http://mirrors.aliyuncs.com/centos/$releasever/AppStream/$basearch/os/</span><span class="hljs-string">        http://mirrors.cloud.aliyuncs.com/centos/$releasever/AppStream/$basearch/os/</span><span class="hljs-string">gpgcheck=1</span><span class="hljs-string">gpgkey=https://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-Official</span><span class="hljs-string"></span><span class="hljs-string">EOF</span></code></pre></div><h3 id="yum简介"><a href="#yum简介" class="headerlink" title="yum简介"></a>yum简介</h3><blockquote><p>对于熟悉Centos的小伙伴都应该很熟悉。</p></blockquote><ul><li>Yum（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及CentOS中的<a href="https://links.jianshu.com/go?to=https://baike.baidu.com/item/Shell">Shell</a>前端软件包管理器。基于<a href="https://links.jianshu.com/go?to=https://baike.baidu.com/item/RPM">RPM</a>包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。—<a href="https://links.jianshu.com/go?to=https://baike.baidu.com/item/yum/2835771?fr=aladdin">百度百科</a></li></ul><h3 id="命令解析"><a href="#命令解析" class="headerlink" title="命令解析"></a>命令解析</h3><ul><li>格式</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash">yum [<span class="hljs-built_in">command</span>] [package] -y|q</code></pre></div><blockquote><p>options</p></blockquote><ul><li>install</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 安装nginx软件包</span>yum install nginx</code></pre></div><ul><li>search</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#  搜索软件包</span>yum search nginx</code></pre></div><ul><li>list</li></ul><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-comment"># 显示指定安装包安装软件详情</span>yum <span class="hljs-keyword">list</span> nginx<span class="hljs-comment"># 显示所有已安装以及可以安装的软件包</span>yum <span class="hljs-keyword">list</span><span class="hljs-comment"># 显示所有软件包</span>yum <span class="hljs-keyword">list</span> all</code></pre></div><ul><li>remove</li></ul><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-meta"># 移除软件包</span>yum <span class="hljs-keyword">remove</span> nginx</code></pre></div><ul><li>earse</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 移除软件包</span>yum earse nginx</code></pre></div><ul><li>update</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 升级软件包</span>yum update nginx</code></pre></div><ul><li>check-update</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 检查可以更新的软件</span>yum check-update</code></pre></div><ul><li>info</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 显示安装包信息</span>yum info nginx</code></pre></div><ul><li>provides</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 列出软件包提供哪些文件</span>yum provides<span class="hljs-comment"># 列出哪些软件包提供nginx</span>yum provides */nginx</code></pre></div><ul><li>grouplist</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 列出可以用groupinstall安装的组</span>yum grouplist</code></pre></div><ul><li>groupInstall</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 安装中文组支持</span>yum groupinstall <span class="hljs-string">&quot;Chinese Support&quot;</span></code></pre></div><ul><li>groupremove</li></ul><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-meta"># 移除中文组支持</span>yum <span class="hljs-keyword">group</span> <span class="hljs-keyword">remove</span> <span class="hljs-string">&quot;Chinese Support&quot;</span></code></pre></div><ul><li>deposit</li></ul><div class="hljs code-wrapper"><pre><code class="hljs undefined">* 查看nginx依赖yum deplist nginx</code></pre></div><ul><li>clear</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 清除缓存目录下的软件包</span>yum clear nginx<span class="hljs-comment"># 清除缓存目录下的header</span>yum clean header<span class="hljs-comment"># 清除所有的缓存</span>yum clean all</code></pre></div><ul><li>repolist</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 查看软件仓库</span>yum repolist</code></pre></div><h3 id="搭建yum仓库"><a href="#搭建yum仓库" class="headerlink" title="搭建yum仓库"></a>搭建yum仓库</h3><blockquote><p>关于yum仓库</p></blockquote><ul><li><p>所在位置</p><p><img src="https://upload-images.jianshu.io/upload_images/7819706-1f04b1f7b48a726a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/639/format/webp" alt="img"></p><p>仓库所在位置</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs ruby">[base]name=CentOS-<span class="hljs-variable">$releasever</span> - Basemirrorlist=<span class="hljs-symbol">http:</span>/<span class="hljs-regexp">/mirrorlist.centos.org/</span><span class="hljs-string">?r</span>elease=<span class="hljs-variable">$releasever</span>&amp;arch=<span class="hljs-variable">$basearch</span>&amp;repo=os&amp;infra=$infra<span class="hljs-comment">#baseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/</span>gpgcheck=<span class="hljs-number">1</span>gpgkey=<span class="hljs-symbol">file:</span>/<span class="hljs-regexp">//etc</span><span class="hljs-regexp">/pki/rpm</span>-gpg/RPM-GPG-KEY-CentOS-<span class="hljs-number">7</span></code></pre></div><blockquote><p>本地yum仓库</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 下载对应的镜像文件</span><span class="hljs-comment"># 挂载到/mnt</span>mount -o loop /dev/cdrom /mnt <span class="hljs-comment">#光盘 </span>mount -o loop -t iso9660 /home/sunky/mydisk.iso /mnt/vcdrom  <span class="hljs-comment">#ios镜像文件</span><span class="hljs-comment"># 创建文件</span>vim /etc/yum.repo.d test.repo[<span class="hljs-built_in">test</span>]name=<span class="hljs-string">&quot;test&quot;</span>baseurl=<span class="hljs-string">&quot;file:///mnt&quot;</span><span class="hljs-built_in">enable</span>=1gpgcheck=0</code></pre></div><blockquote><p>远端http仓库</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs undefined">和上雷同，略</code></pre></div><blockquote><p>远端ftp仓库</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs undefined">和上雷同，略</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>system</category>
      
      <category>linux</category>
      
      <category>ubuntu</category>
      
    </categories>
    
    
    <tags>
      
      <tag>apt-get</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx all</title>
    <link href="/2021/01/01/nginx-all/"/>
    <url>/2021/01/01/nginx-all/</url>
    
    <content type="html"><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>Nginx是lgor Sysoev为俄罗斯访问量第二的rambler.ru站点设计开发的。从2004年发布至今，凭借开源的力量，已经接近成熟与完善。</p><p>Nginx功能丰富，可作为HTTP服务器，也可作为反向代理服务器，邮件服务器。支持FastCGI、SSL、Virtual Host、URL Rewrite、Gzip等功能。并且支持很多第三方的模块扩展。</p><p>Nginx的稳定性、功能集、示例配置文件和低系统资源的消耗让他后来居上，在全球活跃的网站中有12.18%的使用比率，大约为2220万个网站。</p><p>牛逼吹的差不多啦，如果你还不过瘾，你可以百度百科或者一些书上找到这样的夸耀，比比皆是。</p><hr><h2 id="Nginx常用功能"><a href="#Nginx常用功能" class="headerlink" title="Nginx常用功能"></a>Nginx常用功能</h2><p>1、Http代理，反向代理：作为web服务器最常用的功能之一，尤其是反向代理。</p><p>这里我给来2张图，对正向代理与反响代理做个诠释，具体细节，大家可以翻阅下资料。</p><p><img src="https://www.runoob.com/wp-content/uploads/2018/08/1535725078-5993-20160202133724350-1807373891.jpg" alt="img"></p><p>Nginx在做反向代理时，提供性能稳定，并且能够提供配置灵活的转发功能。Nginx可以根据不同的正则匹配，采取不同的转发策略，比如图片文件结尾的走文件服务器，动态页面走web服务器，只要你正则写的没问题，又有相对应的服务器解决方案，你就可以随心所欲的玩。并且Nginx对返回结果进行错误页跳转，异常判断等。如果被分发的服务器存在异常，他可以将请求重新转发给另外一台服务器，然后自动去除异常服务器。</p><hr><h2 id="2、负载均衡"><a href="#2、负载均衡" class="headerlink" title="2、负载均衡"></a>2、负载均衡</h2><p>Nginx提供的负载均衡策略有2种：内置策略和扩展策略。内置策略为轮询，加权轮询，Ip hash。扩展策略，就天马行空，只有你想不到的没有他做不到的啦，你可以参照所有的负载均衡算法，给他一一找出来做下实现。</p><p>上3个图，理解这三种负载均衡算法的实现</p><p><img src="https://www.runoob.com/wp-content/uploads/2018/08/1535725078-8303-20160202133753382-1863657242.jpg" alt="img"></p><p>Ip hash算法，对客户端请求的ip进行hash操作，然后根据hash结果将同一个客户端ip的请求分发给同一台服务器进行处理，可以解决session不共享的问题。</p><p><img src="https://www.runoob.com/wp-content/uploads/2018/08/1535725078-1224-20160201162405944-676557632.jpg" alt="img"></p><hr><h2 id="3、web缓存"><a href="#3、web缓存" class="headerlink" title="3、web缓存"></a>3、web缓存</h2><p>Nginx可以对不同的文件做不同的缓存处理，配置灵活，并且支持FastCGI_Cache，主要用于对FastCGI的动态程序进行缓存。配合着第三方的ngx_cache_purge，对制定的URL缓存内容可以的进行增删管理。</p><hr><h2 id="4、Nginx相关地址"><a href="#4、Nginx相关地址" class="headerlink" title="4、Nginx相关地址"></a>4、Nginx相关地址</h2><p>源码：<a href="https://trac.nginx.org/nginx/browser">https://trac.nginx.org/nginx/browser</a></p><p>官网：<a href="http://www.nginx.org/">http://www.nginx.org/</a></p><hr><h2 id="Nginx配置文件结构"><a href="#Nginx配置文件结构" class="headerlink" title="Nginx配置文件结构"></a>Nginx配置文件结构</h2><p>如果你下载好啦，你的安装文件，不妨打开conf文件夹的nginx.conf文件，Nginx服务器的基础配置，默认的配置也存放在此。</p><p>在 nginx.conf 的注释符号为： <strong>#</strong></p><p>默认的 nginx 配置文件 nginx.conf 内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-comment">#user  nobody;</span><span class="hljs-attribute">worker_processes</span>  <span class="hljs-number">1</span>;<span class="hljs-comment">#error_log  logs/error.log;</span><span class="hljs-comment">#error_log  logs/error.log  notice;</span><span class="hljs-comment">#error_log  logs/error.log  info;</span><span class="hljs-comment">#pid        logs/nginx.pid;</span><span class="hljs-section">events</span> &#123;    <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>;&#125;<span class="hljs-section">http</span> &#123;    <span class="hljs-attribute">include</span>       mime.types;    <span class="hljs-attribute">default_type</span>  application/octet-stream;    <span class="hljs-comment">#log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span>    <span class="hljs-comment">#                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span>    <span class="hljs-comment">#                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span>    <span class="hljs-comment">#access_log  logs/access.log  main;</span>    <span class="hljs-attribute">sendfile</span>        <span class="hljs-literal">on</span>;    <span class="hljs-comment">#tcp_nopush     on;</span>    <span class="hljs-comment">#keepalive_timeout  0;</span>    <span class="hljs-attribute">keepalive_timeout</span>  <span class="hljs-number">65</span>;    <span class="hljs-comment">#gzip  on;</span>    <span class="hljs-section">server</span> &#123;        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;        <span class="hljs-attribute">server_name</span>  localhost;        <span class="hljs-comment">#charset koi8-r;</span>        <span class="hljs-comment">#access_log  logs/host.access.log  main;</span>        <span class="hljs-attribute">location</span> / &#123;            <span class="hljs-attribute">root</span>   html;            <span class="hljs-attribute">index</span>  index.html index.htm;        &#125;        <span class="hljs-comment">#error_page  404              /404.html;</span>        <span class="hljs-comment"># redirect server error pages to the static page /50x.html</span>        <span class="hljs-comment">#</span>        <span class="hljs-attribute">error_page</span>   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.html;        <span class="hljs-attribute">location</span> = /50x.html &#123;            <span class="hljs-attribute">root</span>   html;        &#125;        <span class="hljs-comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span>        <span class="hljs-comment">#</span>        <span class="hljs-comment">#location ~ \.php$ &#123;</span>        <span class="hljs-comment">#    proxy_pass   http://127.0.0.1;</span>        <span class="hljs-comment">#&#125;</span>        <span class="hljs-comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span>        <span class="hljs-comment">#</span>        <span class="hljs-comment">#location ~ \.php$ &#123;</span>        <span class="hljs-comment">#    root           html;</span>        <span class="hljs-comment">#    fastcgi_pass   127.0.0.1:9000;</span>        <span class="hljs-comment">#    fastcgi_index  index.php;</span>        <span class="hljs-comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span>        <span class="hljs-comment">#    include        fastcgi_params;</span>        <span class="hljs-comment">#&#125;</span>        <span class="hljs-comment"># deny access to .htaccess files, if Apache&#x27;s document root</span>        <span class="hljs-comment"># concurs with nginx&#x27;s one</span>        <span class="hljs-comment">#</span>        <span class="hljs-comment">#location ~ /\.ht &#123;</span>        <span class="hljs-comment">#    deny  all;</span>        <span class="hljs-comment">#&#125;</span>    &#125;    <span class="hljs-comment"># another virtual host using mix of IP-, name-, and port-based configuration</span>    <span class="hljs-comment">#</span>    <span class="hljs-comment">#server &#123;</span>    <span class="hljs-comment">#    listen       8000;</span>    <span class="hljs-comment">#    listen       somename:8080;</span>    <span class="hljs-comment">#    server_name  somename  alias  another.alias;</span>    <span class="hljs-comment">#    location / &#123;</span>    <span class="hljs-comment">#        root   html;</span>    <span class="hljs-comment">#        index  index.html index.htm;</span>    <span class="hljs-comment">#    &#125;</span>    <span class="hljs-comment">#&#125;</span>    <span class="hljs-comment"># HTTPS server</span>    <span class="hljs-comment">#</span>    <span class="hljs-comment">#server &#123;</span>    <span class="hljs-comment">#    listen       443 ssl;</span>    <span class="hljs-comment">#    server_name  localhost;</span>    <span class="hljs-comment">#    ssl_certificate      cert.pem;</span>    <span class="hljs-comment">#    ssl_certificate_key  cert.key;</span>    <span class="hljs-comment">#    ssl_session_cache    shared:SSL:1m;</span>    <span class="hljs-comment">#    ssl_session_timeout  5m;</span>    <span class="hljs-comment">#    ssl_ciphers  HIGH:!aNULL:!MD5;</span>    <span class="hljs-comment">#    ssl_prefer_server_ciphers  on;</span>    <span class="hljs-comment">#    location / &#123;</span>    <span class="hljs-comment">#        root   html;</span>    <span class="hljs-comment">#        index  index.html index.htm;</span>    <span class="hljs-comment">#    &#125;</span>    <span class="hljs-comment">#&#125;</span>&#125;</code></pre></div><p><strong>nginx 文件结构</strong></p><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-string">...</span>              <span class="hljs-comment">#全局块</span>events &#123;         <span class="hljs-comment">#events块</span>   <span class="hljs-string">...</span>&#125;http      <span class="hljs-comment">#http块</span>&#123;    <span class="hljs-string">...</span>   <span class="hljs-comment">#http全局块</span>    server        <span class="hljs-comment">#server块</span>    &#123;         <span class="hljs-string">...</span>       <span class="hljs-comment">#server全局块</span>        location [PATTERN]   <span class="hljs-comment">#location块</span>        &#123;            <span class="hljs-string">...</span>        &#125;        location [PATTERN]         &#123;            <span class="hljs-string">...</span>        &#125;    &#125;    server    &#123;      <span class="hljs-string">...</span>    &#125;    <span class="hljs-string">...</span>     <span class="hljs-comment">#http全局块</span>&#125;</code></pre></div><ul><li>1、<strong>全局块</strong>：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。</li><li>2、<strong>events块</strong>：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。</li><li>3、<strong>http块</strong>：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。</li><li>4、<strong>server块</strong>：配置虚拟主机的相关参数，一个http中可以有多个server。</li><li>5、<strong>location块</strong>：配置请求的路由，以及各种页面的处理情况。</li></ul><p>下面给大家上一个配置文件，作为理解。</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-comment">########### 每个指令必须有分号结束。#################</span><span class="hljs-comment">#user administrator administrators;  #配置用户或者组，默认为nobody nobody。</span><span class="hljs-comment">#worker_processes 2;  #允许生成的进程数，默认为1</span><span class="hljs-comment">#pid /nginx/pid/nginx.pid;   #指定nginx进程运行文件存放地址</span><span class="hljs-attribute">error_log</span> log/error.log <span class="hljs-literal">debug</span>;  <span class="hljs-comment">#制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg</span><span class="hljs-section">events</span> &#123;    <span class="hljs-attribute">accept_mutex</span> <span class="hljs-literal">on</span>;   <span class="hljs-comment">#设置网路连接序列化，防止惊群现象发生，默认为on</span>    <span class="hljs-attribute">multi_accept</span> <span class="hljs-literal">on</span>;  <span class="hljs-comment">#设置一个进程是否同时接受多个网络连接，默认为off</span>    <span class="hljs-comment">#use epoll;      #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport</span>    <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>;    <span class="hljs-comment">#最大连接数，默认为512</span>&#125;<span class="hljs-section">http</span> &#123;    <span class="hljs-attribute">include</span>       mime.types;   <span class="hljs-comment">#文件扩展名与文件类型映射表</span>    <span class="hljs-attribute">default_type</span>  application/octet-stream; <span class="hljs-comment">#默认文件类型，默认为text/plain</span>    <span class="hljs-comment">#access_log off; #取消服务日志    </span>    <span class="hljs-attribute">log_format</span> myFormat <span class="hljs-string">&#x27;$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for&#x27;</span>; <span class="hljs-comment">#自定义格式</span>    <span class="hljs-attribute">access_log</span> log/access.log myFormat;  <span class="hljs-comment">#combined为日志格式的默认值</span>    <span class="hljs-attribute">sendfile</span> <span class="hljs-literal">on</span>;   <span class="hljs-comment">#允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。</span>    <span class="hljs-attribute">sendfile_max_chunk</span> <span class="hljs-number">100k</span>;  <span class="hljs-comment">#每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。</span>    <span class="hljs-attribute">keepalive_timeout</span> <span class="hljs-number">65</span>;  <span class="hljs-comment">#连接超时时间，默认为75s，可以在http，server，location块。</span>    <span class="hljs-attribute">upstream</span> mysvr &#123;         <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:7878</span>;      <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.10.121:3333</span> backup;  <span class="hljs-comment">#热备</span>    &#125;    <span class="hljs-attribute">error_page</span> <span class="hljs-number">404</span> https://www.baidu.com; <span class="hljs-comment">#错误页</span>    <span class="hljs-section">server</span> &#123;        <span class="hljs-attribute">keepalive_requests</span> <span class="hljs-number">120</span>; <span class="hljs-comment">#单连接请求上限次数。</span>        <span class="hljs-attribute">listen</span>       <span class="hljs-number">4545</span>;   <span class="hljs-comment">#监听端口</span>        <span class="hljs-attribute">server_name</span>  <span class="hljs-number">127.0.0.1</span>;   <span class="hljs-comment">#监听地址       </span>        <span class="hljs-attribute">location</span>  ~*^.+$ &#123;       <span class="hljs-comment">#请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。</span>           <span class="hljs-comment">#root path;  #根目录</span>           <span class="hljs-comment">#index vv.txt;  #设置默认页</span>           <span class="hljs-attribute">proxy_pass</span>  http://mysvr;  <span class="hljs-comment">#请求转向mysvr 定义的服务器列表</span>           <span class="hljs-attribute">deny</span> <span class="hljs-number">127.0.0.1</span>;  <span class="hljs-comment">#拒绝的ip</span>           <span class="hljs-attribute">allow</span> <span class="hljs-number">172.18.5.54</span>; <span class="hljs-comment">#允许的ip           </span>        &#125;     &#125;&#125;</code></pre></div><p>上面是nginx的基本配置，需要注意的有以下几点：</p><p>1、几个常见配置项：</p><ul><li>1.$remote_addr 与 $http_x_forwarded_for 用以记录客户端的ip地址；</li><li>2.$remote_user ：用来记录客户端用户名称；</li><li>3.$time_local ： 用来记录访问时间与时区；</li><li>4.$request ： 用来记录请求的url与http协议；</li><li>5.$status ： 用来记录请求状态；成功是200；</li><li>6.$body_bytes_s ent ：记录发送给客户端文件主体内容大小；</li><li>7.$http_referer ：用来记录从那个页面链接访问过来的；</li><li>8.$http_user_agent ：记录客户端浏览器的相关信息；</li></ul><p>2、惊群现象：一个网路连接到来，多个睡眠的进程被同时叫醒，但只有一个进程能获得链接，这样会影响系统性能。</p><p>3、每个指令必须有分号结束。</p>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux user group</title>
    <link href="/2020/12/25/linux-user-group/"/>
    <url>/2020/12/25/linux-user-group/</url>
    
    <content type="html"><![CDATA[<h1 id="1-用户组操作"><a href="#1-用户组操作" class="headerlink" title="1 用户组操作"></a>1 用户组操作</h1><p>创建<code>admin</code>用户组，指定组编号，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">groupadd -g 777 admin</code></pre></div><p><img src="https://img-blog.csdnimg.cn/20200623220944164.png" alt="在这里插入图片描述"></p><blockquote><p>其他用户组相关命令：</p><ul><li>删除xxx用户组：<code>groupdel xxx</code></li><li>修改用户组groupb名称为groupa：<code>groupmod -n groupa groupb</code></li></ul></blockquote><h1 id="2-用户操作"><a href="#2-用户操作" class="headerlink" title="2 用户操作"></a>2 用户操作</h1><h2 id="2-1-创建用户"><a href="#2-1-创建用户" class="headerlink" title="2.1 创建用户"></a>2.1 创建用户</h2><p>创建<code>crane</code>用户，并归属到<code>admin</code>用户组中</p><div class="hljs code-wrapper"><pre><code class="hljs bash">useradd -g admin crane</code></pre></div><p><img src="https://img-blog.csdnimg.cn/2020062322143654.png" alt="在这里插入图片描述"></p><h2 id="2-2-修改用户密码"><a href="#2-2-修改用户密码" class="headerlink" title="2.2 修改用户密码"></a>2.2 修改用户密码</h2><p>修改用户<code>crane</code>的密码</p><div class="hljs code-wrapper"><pre><code class="hljs bash">passwd crane</code></pre></div><p><img src="https://img-blog.csdnimg.cn/20200623221658719.png" alt="在这里插入图片描述"></p><h2 id="2-3-用户权限"><a href="#2-3-用户权限" class="headerlink" title="2.3 用户权限"></a>2.3 用户权限</h2><p>为用户<code>crane</code>添加<code>sudo</code>权限：<br>使用<code>root</code>用户执行<code>visudo</code>命令，编辑文件，添加一行<code>crane</code>相关的信息，如下图</p><div class="hljs code-wrapper"><pre><code class="hljs bash">visudo</code></pre></div><p><img src="https://img-blog.csdnimg.cn/20200623222751147.png" alt="在这里插入图片描述"></p><h2 id="2-4-切换用户"><a href="#2-4-切换用户" class="headerlink" title="2.4 切换用户"></a>2.4 切换用户</h2><p>切换用户到<code>crane</code></p><div class="hljs code-wrapper"><pre><code class="hljs bash">su crane</code></pre></div><p><img src="https://img-blog.csdnimg.cn/20200623221911376.png" alt="在这里插入图片描述"></p><h2 id="用户更改-usermod"><a href="#用户更改-usermod" class="headerlink" title="用户更改 usermod"></a>用户更改 usermod</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><div class="hljs code-wrapper"><pre><code class="hljs bnf">usermod [-LU][-c <span class="hljs-attribute">&lt;备注&gt;</span>][-d <span class="hljs-attribute">&lt;登入目录&gt;</span>][-e <span class="hljs-attribute">&lt;有效期限&gt;</span>][-f <span class="hljs-attribute">&lt;缓冲天数&gt;</span>][-g <span class="hljs-attribute">&lt;群组&gt;</span>][-G <span class="hljs-attribute">&lt;群组&gt;</span>][-l <span class="hljs-attribute">&lt;帐号名称&gt;</span>][-s <span class="hljs-attribute">&lt;shell&gt;</span>][-u <span class="hljs-attribute">&lt;uid&gt;</span>][用户帐号]**参数说明**：- -c<span class="hljs-attribute">&lt;备注&gt;</span> 　修改用户帐号的备注文字。- -d登入目录&gt; 　修改用户登入时的目录。- -e<span class="hljs-attribute">&lt;有效期限&gt;</span> 　修改帐号的有效期限。- -f<span class="hljs-attribute">&lt;缓冲天数&gt;</span> 　修改在密码过期后多少天即关闭该帐号。- -g<span class="hljs-attribute">&lt;群组&gt;</span> 　修改用户所属的群组。- -G<span class="hljs-attribute">&lt;群组&gt;</span> 　修改用户所属的附加群组。- -l<span class="hljs-attribute">&lt;帐号名称&gt;</span> 　修改用户帐号名称。- -L 　锁定用户密码，使密码无效。- -s<span class="hljs-attribute">&lt;shell&gt;</span> 　修改用户登入后所使用的shell。- -u<span class="hljs-attribute">&lt;uid&gt;</span> 　修改用户ID。- -U 　解除密码锁定。</code></pre></div><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>更改登录目录</p><div class="hljs code-wrapper"><pre><code class="hljs gradle"># usermod -d <span class="hljs-regexp">/home/</span>hnlinux root</code></pre></div><p>改变用户的uid</p><div class="hljs code-wrapper"><pre><code class="hljs vala"><span class="hljs-meta"># usermod -u 777 root</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>system</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux automount</title>
    <link href="/2020/12/24/linux-auto-mount/"/>
    <url>/2020/12/24/linux-auto-mount/</url>
    
    <content type="html"><![CDATA[<h3 id="一、-etc-fstab文件的作用"><a href="#一、-etc-fstab文件的作用" class="headerlink" title="一、/etc/fstab文件的作用"></a>一、/etc/fstab文件的作用</h3><p>　　磁盘被手动挂载之后都必须把挂载信息写入/etc/fstab这个文件中，否则下次开机启动时仍然需要重新挂载。<br>　　系统开机时会主动读取/etc/fstab这个文件中的内容，根据文件里面的配置挂载磁盘。这样我们只需要将磁盘的挂载信息写入这个文件中我们就不需要每次开机启动之后手动进行挂载了。</p><h3 id="二、挂载的限制"><a href="#二、挂载的限制" class="headerlink" title="二、挂载的限制"></a>二、挂载的限制</h3><p>　　在说明这个文件的作用之前我想先强调一下挂载的限制。<br>　　1. 根目录是必须挂载的，而且一定要先于其他mount point被挂载。因为mount是所有目录的跟目录，其他木有都是由根目录 /衍生出来的。<br>　　2. 挂载点必须是已经存在的目录。<br>　　3. 挂载点的指定可以任意，但必须遵守必要的系统目录架构原则<br>　　4. 所有挂载点在同一时间只能被挂载一次<br>　　5. 所有分区在同一时间只能挂在一次<br>　　6. 若进行卸载，必须将工作目录退出挂载点（及其子目录）之外。</p><h3 id="三、-etc-fstab文件中的参数"><a href="#三、-etc-fstab文件中的参数" class="headerlink" title="三、/etc/fstab文件中的参数"></a>三、/etc/fstab文件中的参数</h3><p>　　查看/etc/fstab文件。</p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># cat /etc/fstab </span></code></pre></div><p>　　这是我的linux环境中/etc/fstab文件中的内容</p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># /etc/fstab: static file system information.</span><span class="hljs-comment">#</span><span class="hljs-comment"># Use &#x27;blkid&#x27; to print the universally unique identifier for a</span><span class="hljs-comment"># device; this may be used with UUID= as a more robust way to name devices</span><span class="hljs-comment"># that works even if disks are added and removed. See fstab(5).</span><span class="hljs-comment">#</span><span class="hljs-comment"># &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;</span><span class="hljs-comment"># / was on /dev/sda1 during installation</span>UUID=2095f3a3-960c-466d-92fe-3f3be1dc0fd3 /               ext4    errors=remount-ro 0       1<span class="hljs-comment"># swap was on /dev/sda5 during installation</span>UUID=3d0e5364-4082-4644-92a9-6d4afa28d143 none            swap    sw              0       0</code></pre></div><p>　　在文件中我已经把每一列都做出来表示方便识别，我们可以看到一共有六列。</p><h5 id="第一列：Device：磁盘设备文件或者该设备的Label或者UUID"><a href="#第一列：Device：磁盘设备文件或者该设备的Label或者UUID" class="headerlink" title="第一列：Device：磁盘设备文件或者该设备的Label或者UUID"></a>第一列：Device：磁盘设备文件或者该设备的Label或者UUID</h5><p>　　1）查看分区的label和uuid<br>　　Label就是分区的标签，在最初安装系统时填写的挂载点就是标签的名字。可以通过查看一个分区的superblock中的信息找到UUID和Label name。<br>　　例如:我们要查看/dev/sda1这个设备的uuid和label name</p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># dumpe2fs -h /dev/sda11</span>dumpe2fs 1.42.13 (17-May-2015)Filesystem volume name:   &lt;none&gt;  //Label nameLast mounted on:          /Filesystem UUID:          2095f3a3-960c-466d-92fe-3f3be1dc0fd3 //UUIDFilesystem magic number:  0xEF53Filesystem revision <span class="hljs-comment">#:    1 (dynamic)</span>Filesystem features:      has_journal ext_attr resize_inode dir_index filetype needs_recovery extent flex_bg sparse_super large_file huge_file uninit_bg dir_nlink extra_isizeFilesystem flags:         signed_directory_hash Default mount options:    user_xattr aclFilesystem state:         clean...</code></pre></div><p>　　简单点的方式我们可以通过命令blkid来查看</p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># blkid</span>/dev/sda1: UUID=<span class="hljs-string">&quot;2095f3a3-960c-466d-92fe-3f3be1dc0fd3&quot;</span> TYPE=<span class="hljs-string">&quot;ext4&quot;</span> PARTUUID=<span class="hljs-string">&quot;8c98aa8e-01&quot;</span>/dev/sda5: UUID=<span class="hljs-string">&quot;3d0e5364-4082-4644-92a9-6d4afa28d143&quot;</span> TYPE=<span class="hljs-string">&quot;swap&quot;</span> PARTUUID=<span class="hljs-string">&quot;8c98aa8e-05&quot;</span>/dev/sdb1: UUID=<span class="hljs-string">&quot;a37f9605-44ee-4fbd-9943-69fd47928f87&quot;</span> TYPE=<span class="hljs-string">&quot;ext4&quot;</span> PARTUUID=<span class="hljs-string">&quot;d86506b9-01&quot;</span>/dev/sdc1: UUID=<span class="hljs-string">&quot;00dbb3ac-c544-402b-98e1-f15d93a7bb53&quot;</span> TYPE=<span class="hljs-string">&quot;ext4&quot;</span> PARTUUID=<span class="hljs-string">&quot;79e762ca-01&quot;</span></code></pre></div><p>　　2）使用设备名和label及uuid作为标识的不同<br>　　<strong>使用设备名称（/dev/sda)来挂载分区时是被固定死的，一旦磁盘的插槽顺序发生了变化，就会出现名称不对应的问题。因为这个名称是会改变的。</strong><br>　　<strong>不过使用label挂载就不用担心插槽顺序方面的问题。不过要随时注意你的Label name。至于UUID，每个分区被格式化以后都会有一个UUID作为唯一的标识号。使用uuid挂载的话就不用担心会发生错乱的问题了。</strong></p><h5 id="第二列：Mount-point：设备的挂载点，就是你要挂载到哪个目录下。"><a href="#第二列：Mount-point：设备的挂载点，就是你要挂载到哪个目录下。" class="headerlink" title="第二列：Mount point：设备的挂载点，就是你要挂载到哪个目录下。"></a>第二列：Mount point：设备的挂载点，就是你要挂载到哪个目录下。</h5><h5 id="第三列：filesystem：磁盘文件系统的格式，包括ext2、ext3、reiserfs、nfs、vfat等"><a href="#第三列：filesystem：磁盘文件系统的格式，包括ext2、ext3、reiserfs、nfs、vfat等" class="headerlink" title="第三列：filesystem：磁盘文件系统的格式，包括ext2、ext3、reiserfs、nfs、vfat等"></a>第三列：filesystem：磁盘文件系统的格式，包括ext2、ext3、reiserfs、nfs、vfat等</h5><h5 id="第四列：parameters：文件系统的参数"><a href="#第四列：parameters：文件系统的参数" class="headerlink" title="第四列：parameters：文件系统的参数"></a>第四列：parameters：文件系统的参数</h5><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Async/sync</td><td>设置是否为同步方式运行，默认为async</td></tr><tr><td>auto/noauto</td><td>当下载mount -a 的命令时，此文件系统是否被主动挂载。默认为auto</td></tr><tr><td>rw/ro</td><td>是否以以只读或者读写模式挂载</td></tr><tr><td>exec/noexec</td><td>限制此文件系统内是否能够进行”执行”的操作</td></tr><tr><td>user/nouser</td><td>是否允许用户使用mount命令挂载</td></tr><tr><td>suid/nosuid</td><td>是否允许SUID的存在</td></tr><tr><td>Usrquota</td><td>启动文件系统支持磁盘配额模式</td></tr><tr><td>Grpquota</td><td>启动文件系统对群组磁盘配额模式的支持</td></tr><tr><td>Defaults</td><td>同时具有rw,suid,dev,exec,auto,nouser,async等默认参数的设置</td></tr></tbody></table><h5 id="第五列：能否被dump备份命令作用：dump是一个用来作为备份的命令。通常这个参数的值为0或者1"><a href="#第五列：能否被dump备份命令作用：dump是一个用来作为备份的命令。通常这个参数的值为0或者1" class="headerlink" title="第五列：能否被dump备份命令作用：dump是一个用来作为备份的命令。通常这个参数的值为0或者1"></a>第五列：能否被dump备份命令作用：dump是一个用来作为备份的命令。通常这个参数的值为0或者1</h5><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>0</td><td>代表不要做dump备份</td></tr><tr><td>1</td><td>代表要每天进行dump的操作</td></tr><tr><td>2</td><td>代表不定日期的进行dump操作</td></tr></tbody></table><h5 id="第六列：是否检验扇区：开机的过程中，系统默认会以fsck检验我们系统是否为完整（clean）。"><a href="#第六列：是否检验扇区：开机的过程中，系统默认会以fsck检验我们系统是否为完整（clean）。" class="headerlink" title="第六列：是否检验扇区：开机的过程中，系统默认会以fsck检验我们系统是否为完整（clean）。"></a>第六列：是否检验扇区：开机的过程中，系统默认会以fsck检验我们系统是否为完整（clean）。</h5><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>0</td><td>不要检验</td></tr><tr><td>1</td><td>最早检验（一般根目录会选择）</td></tr><tr><td>2</td><td>1级别检验完成之后进行检验</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>system</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux crontabs</title>
    <link href="/2020/12/24/linux-crontabs/"/>
    <url>/2020/12/24/linux-crontabs/</url>
    
    <content type="html"><![CDATA[<h2 id="格式说明与范例"><a href="#格式说明与范例" class="headerlink" title="格式说明与范例"></a>格式说明与范例</h2><p><img src="https://images2015.cnblogs.com/blog/513841/201608/513841-20160812102124078-171184924.png" alt="img"></p><ul><li><ul><li><ul><li><ul><li><ul><li>   command</li></ul></li></ul></li></ul></li></ul></li></ul><p>分　 时　  日　 月     周　     命令</p> <div class="hljs code-wrapper"><pre><code class="hljs bash">第1列表示分钟1～59 每分钟用*或者 */1表示第2列表示小时1～23（0表示0点）第3列表示日期1～31第4列表示月份1～12第5列标识号星期0～6（0表示星期天）第6列要运行的命令</code></pre></div><p>在以上各个字段中，还可以使用以下特殊字符：</p><p>星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。</p><p>逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”</p><p>中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”</p><p>正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。</p><div class="hljs code-wrapper"><pre><code class="hljs bash">安装crontab：yum install crontabs || apt-get install crontab服务操作说明：/sbin/service crond start //启动服务/sbin/service crond stop //关闭服务/sbin/service crond restart //重启服务/sbin/service crond reload //重新载入配置查看crontab服务状态：service crond status手动启动crontab服务：service crond start查看crontab服务是否已设置为开机启动，执行命令：ntsysv加入开机自动启动：chkconfig –level 35 crond on基础命令：-e 表示编辑当前的crontab-l 表示列表显示当前的crontab任务-r 表示删除当前用户的crontab-i 表示删除crontab时给予提示信息</code></pre></div><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><div class="hljs code-wrapper"><pre><code class="hljs bash">Cron表达式范例：             每隔5秒执行一次：*/5 * * * * ?              每隔1分钟执行一次：0 */1 * * * ?              每天23点执行一次：0 0 23 * * ?              每天凌晨1点执行一次：0 0 1 * * ?              每月1号凌晨1点执行一次：0 0 1 1 * ?              每月最后一天23点执行一次：0 0 23 L * ?              每周星期天凌晨1点实行一次：0 0 1 ? * L1、每天6:00执行 0 6 * * * root /home/mvp/osyunwei.sh 2、每周六凌晨4:00执行 0 4 * * 6 root /home/mvp/osyunwei.sh 3、每周六凌晨4:05执行 5 4 * * 6 root /home/mvp/osyunwei.sh  4、每周六凌晨4:15执行 15 4 * * 6 root /home/mvp/osyunwei.sh 5、每周六凌晨4:25执行 25 4 * * 6 root /home/mvp/osyunwei.sh 6、每周六凌晨4:35执行 35 4 * * 6 root /home/mvp/osyunwei.sh 7、每周六凌晨5:00执行 5 * * 6 root /home/mvp/osyunwei.sh 8、每天8:40执行 40 8 * * * root /home/mvp/osyunwei.sh 9、每天8:30执行 30 8 * * * root /home/mvp/osyunwei.sh 10、每周一到周五的11:41开始，每隔10分钟执行一次    <span class="hljs-comment">#值得借鉴</span> 41,51 11 * * 1-5   root /home/mvp/osyunwei.sh 或者 1-59/10 12-23 * * 1-5   root /home/mvp/osyunwei.sh 11、在每天的10:31开始，每隔2小时重复一次 31 10-23/2 * * * root   /home/mvp/osyunwei.sh 12、每天15:00执行 0 15 * * *  root /home/mvp/osyunwei.sh 13、每天的10:30开始，每隔2小时重复一次 30 10-23/2 * * * root  /home/mvp/osyunwei.sh 14、每天15:30执行 30 15 * * *  root /home/mvp/osyunwei.sh 15、每天17:50执行 50 17 * * *  root /home/mvp/osyunwei.sh 16、每天8:00执行 0 8 * * *  root  /home/mvp/osyunwei.sh 17、每天18:00执行 0 18 * * *  root  /home/mvp/osyunwei.sh 18、每天8:30执行 30 8 * * *  root  /home/mvp/osyunwei.sh 19、每天20:30 30 20 * * *  root /home/mvp/osyunwei.sh 20、每周一到周五2:00 0 2 * * 1-5 root /home/mvp/osyunwei.sh 21、每周一到周五9:30 30 9 * * 1-5 root /home/mvp/osyunwei.sh 22、每周一到周五8:00，每周一到周五9:00 0 8,9 * * 1-5  root /home/mvp/osyunwei.sh 23、每天23:59 59 23 * * *  root  /home/mvp/osyunwei.sh 24、每周六23:59 59 23 * * 6  root    /home/mvp/osyunwei.sh 25、每天0:30 30 0 * * *  root  /home/mvp/osyunwei.sh 26、每周一到周五9:25到11:35之间、13:00到15:00之间，每隔10分钟运行一次 分区段写值得借鉴 25,35,45,55  9 * * 1-5  root   /home/mvp/osyunwei.sh 5-59/10  10 * * 1-5  root   /home/mvp/osyunwei.sh 5,15,25,35  11 * * 1-5  root   /home/mvp/osyunwei.sh */10  13-15 * * 1-5  root   /home/mvp/osyunwei.sh 27、每周一到周五8:30、8:50、9:30、10:00、10:30、11:00、11:30、13:30、14:00、14:30、5:00分别执行一次 30,50 8 * * 1-5  root  /home/mvp/osyunwei.sh 30 9 * * 1-5  root  /home/mvp/osyunwei.sh */30 10-11 * * 1-5  root  /home/mvp/osyunwei.sh 30 13 * * 1-5  root  /home/mvp/osyunwei.sh 0,30 14-15 * * 1-5  root  /home/mvp/osyunwei.sh 28、每天23:50执行 50 23 * * *  root  /home/mvp/osyunwei.sh 29、每天10:00、16:00执行 0 10,16 * * *  root /home/mvp/osyunwei.sh 30、每天5:30执行 30 5 * * *  root  /home/mvp/osyunwei.sh 31、每周一到周五9:30执行 30 9 * * 1-5  root  /home/mvp/osyunwei.sh 32、每周一到周五13:00执行 0 13 * * 1-5  root  /home/mvp/osyunwei.sh 33、每天7:51执行 51 7 * * *  root /home/mvp/osyunwei.sh 34、每天7:53、12:40分别执行一次 53 7 * * *  root /home/mvp/osyunwei.sh 40 12 * * *  root /home/mvp/osyunwei.sh 35、每天7:55执行 55 7 * * *  root  /home/mvp/osyunwei.sh 36、每天8:10、16:00、20:00分别执行一次 10 8 * * *  root  /home/mvp/osyunwei.sh 0 16 * * *  root  /home/mvp/osyunwei.sh 0 20 * * *  root  /home/mvp/osyunwei.sh 37、每天7:57、8:00分别执行一次 57 7 * * *  root  /home/mvp/osyunwei.sh 0 8 * * *  root  /home/mvp/osyunwei.sh              在26分、29分、33分执行一次：0 26,29,33 * * * ?              每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 * * ? 实例1：每1分钟执行一次<span class="hljs-built_in">command</span> 命令： * * * * * <span class="hljs-built_in">command</span>   实例2：每小时的第3和第15分钟执行 命令： 3,15 * * * * <span class="hljs-built_in">command</span>   实例3：在上午8点到11点的第3和第15分钟执行 命令： 3,15 8-11 * * * <span class="hljs-built_in">command</span>   实例4：每隔两天的上午8点到11点的第3和第15分钟执行 命令： 3,15 8-11 */2 * * <span class="hljs-built_in">command</span>   实例5：每个星期一的上午8点到11点的第3和第15分钟执行 命令： 3,15 8-11 * * 1 <span class="hljs-built_in">command</span>   实例6：每晚的21:30重启smb  命令： 30 21 * * * /etc/init.d/smb restart   实例7：每月1、10、22日的4 : 45重启smb  命令： 45 4 1,10,22 * * /etc/init.d/smb restart   实例8：每周六、周日的1 : 10重启smb 命令： 10 1 * * 6,0 /etc/init.d/smb restart   实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb  命令： 0,30 18-23 * * * /etc/init.d/smb restart   实例10：每星期六的晚上11 : 00 pm重启smb  命令： 0 23 * * 6 /etc/init.d/smb restart   实例11：每一小时重启smb  命令： * */1 * * * /etc/init.d/smb restart   实例12：晚上11点到早上7点之间，每隔一小时重启smb  命令： * 23-7/1 * * * /etc/init.d/smb restart   实例13：每月的4号与每周一到周三的11点重启smb  命令： 0 11 4 * mon-wed /etc/init.d/smb restart   实例14：一月一号的4点重启smb  命令： 0 4 1 jan * /etc/init.d/smb restart 实例15：每小时执行/etc/cron.hourly目录内的脚本 命令： 01   *   *   *   *     root run-parts /etc/cron.hourly 说明： run-parts这个参数了，如果去掉这个参数的话，后面就可以写要运行的某个脚本名，而不是目录名了</code></pre></div><h2 id="三、其他问题"><a href="#三、其他问题" class="headerlink" title="三、其他问题"></a>三、其他问题</h2><h4 id="注意环境变量问题"><a href="#注意环境变量问题" class="headerlink" title="注意环境变量问题"></a>注意环境变量问题</h4><p>有时我们创建了一个crontab，但是这个任务却无法自动执行，而手动执行这个任务却没有问题，这种情况一般是由于在crontab文件中没有配置环境变量引起的。</p><p>在crontab文件中定义多个调度任务时，需要特别注意的一个问题就是环境变量的设置，因为我们手动执行某个任务时，是在当前shell环境下进行的，程序当然能找到环境变量，而系统自动执行任务调度时，是不会加载任何环境变量的，因此，就需要在crontab文件中指定任务运行所需的所有环境变量，这样，系统执行任务调度时就没有问题了。</p><p>不要假定cron知道所需要的特殊环境，它其实并不知道。所以你要保证在shelll脚本中提供所有必要的路径和环境变量，除了一些自动设置的全局变量。所以注意如下3点：</p><p>1）脚本中涉及文件路径时写全局路径；</p><p>2）脚本执行要用到java或其他环境变量时，通过source命令引入环境变量，如：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">cat start_cbp.sh\<span class="hljs-comment">#!/bin/sh</span><span class="hljs-built_in">source</span> /etc/profile<span class="hljs-built_in">export</span> RUN_CONF=/home/d139/conf/platform/cbp/cbp_jboss.conf/usr/<span class="hljs-built_in">local</span>/jboss-4.0.5/bin/run.sh -c mev &amp;</code></pre></div><p>3）当手动执行脚本OK，但是crontab死活不执行时。这时必须大胆怀疑是环境变量惹的祸，并可以尝试在crontab中直接引入环境变量解决问题。如：</p><p>0 * * * * . /etc/profile;/bin/sh /var/www/java/audit_no_count/bin/restart_audit.sh</p><h4 id="注意清理系统用户的邮件日志"><a href="#注意清理系统用户的邮件日志" class="headerlink" title="注意清理系统用户的邮件日志"></a>注意清理系统用户的邮件日志</h4><p>每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户，这样日积月累，日志信息会非常大，可能会影响系统的正常运行，因此，将每条任务进行重定向处理非常重要。</p><p>例如，可以在crontab文件中设置如下形式，忽略日志输出：</p><p>0 */3 * * * /usr/local/apache2/apachectl restart &gt;/dev/null 2&gt;&amp;1</p><p>“/dev/null 2&gt;&amp;1”表示先将标准输出重定向到/dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，这样日志输出问题就解决了。</p><h4 id="系统级任务调度与用户级任务调度"><a href="#系统级任务调度与用户级任务调度" class="headerlink" title="系统级任务调度与用户级任务调度"></a>系统级任务调度与用户级任务调度</h4><p>系统级任务调度主要完成系统的一些维护操作，用户级任务调度主要完成用户自定义的一些任务，可以将用户级任务调度放到系统级任务调度来完成（不建议这么做），但是反过来却不行，root用户的任务调度操作可以通过“crontab –uroot –e”来设置，也可以将调度任务直接写入/etc/crontab文件，需要注意的是，如果要定义一个定时重启系统的任务，就必须将任务放到/etc/crontab文件，即使在root用户下创建一个定时重启系统的任务也是无效的。</p><h4 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h4><p>新创建的cron job，不会马上执行，至少要过2分钟才执行。如果重启cron则马上执行。</p><p>当crontab突然失效时，可以尝试/etc/init.d/crond restart解决问题。或者查看日志看某个job有没有执行/报错tail -f /var/log/cron。</p><p>千万别乱运行crontab -r。它从Crontab目录（/var/spool/cron）中删除用户的Crontab文件。删除了该用户的所有crontab都没了。</p><p>在crontab中%是有特殊含义的，表示换行的意思。如果要用的话必须进行转义%，如经常用的date ‘+%Y%m%d’在crontab里是不会执行的，应该换成date ‘+%Y%m%d’。    </p>]]></content>
    
    
    <categories>
      
      <category>system</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux practice</title>
    <link href="/2020/12/24/linux-practice/"/>
    <url>/2020/12/24/linux-practice/</url>
    
    <content type="html"><![CDATA[<div class="hljs code-wrapper"><pre><code class="hljs bash"> <span class="hljs-comment">#！/bin/bash</span><span class="hljs-comment"># 系统安装断开网卡</span><span class="hljs-comment"># 安装vmtools</span><span class="hljs-comment"># 重启打开网卡</span><span class="hljs-comment"># 更换镜像源</span>sudo cat &gt; /etc/apt/sources.list &lt;&lt;<span class="hljs-string">EOF </span><span class="hljs-string"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><span class="hljs-string">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse</span><span class="hljs-string"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse</span><span class="hljs-string">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse</span><span class="hljs-string"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse</span><span class="hljs-string">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</span><span class="hljs-string"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</span><span class="hljs-string">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse</span><span class="hljs-string"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse</span><span class="hljs-string"></span><span class="hljs-string"># 预发布软件源，不建议启用</span><span class="hljs-string"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse</span><span class="hljs-string"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse</span><span class="hljs-string">EOF</span><span class="hljs-comment"># 更新源</span>apt-get update<span class="hljs-comment"># 安装vim net-tools lsscsi</span>sudo apt-get install vim net-tools lsscsi -y<span class="hljs-comment"># 添加挂在硬盘 p113</span><span class="hljs-comment"># 首先在虚拟机添加硬盘 使用命令刷新硬盘热拔插</span>partprobe<span class="hljs-comment"># 查看所有插入硬盘</span>lsscsi<span class="hljs-comment"># 选择硬盘创建分区</span>fdisk /dev/sdb1<span class="hljs-comment"># new :新建一个分区 pritn: 打印分区信息 type: 设置分区类型 write: 写入磁盘</span>    <span class="hljs-comment"># 1:设置为第一个分区 1:分区从硬盘第1个柱面开始 +1G:分区大小 </span><span class="hljs-comment"># 格式化分区</span>mkfs.ext4 /dev/sdb1<span class="hljs-comment"># 挂在指定目录</span>mkdir musicmount /dev/sdb1 /music<span class="hljs-comment"># 取消挂载</span>umount /music<span class="hljs-comment"># 修改 /etc/fstab 实现自动挂在</span><span class="hljs-comment"># 首先查看分区的label和uuid</span><span class="hljs-comment"># 简单</span>blkid<span class="hljs-comment"># 复杂</span>dumpe2fs -h /dev/sdb1<span class="hljs-comment"># 　使用设备名称（/dev/sda)来挂载分区时是被固定死的，一旦磁盘的插槽顺序发生了变化，就会出现名称不对应的问题。因为这个名称是会改变的。</span><span class="hljs-comment">#　　不过使用label挂载就不用担心插槽顺序方面的问题。不过要随时注意你的Label name。至于UUID，每个分区被格式化以后都会有一个UUID作为唯一的标识号。使用uuid挂载的话就不用担心会发生错乱的问题了。</span><span class="hljs-comment"># 具体参数见 https://czy1024.github.io/blog/blog/autoMount.html</span>vim /etc/fstab<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;eg: UUID=2ccac64a-01cc-4fc7-ae85-ad7ea1fca89c /music    ext4   defaults    0     0&quot;</span><span class="hljs-comment"># 重启后 执行 mountpoint  music/ 查看是否配置成功</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;此时的music只是45行创建的测试目录&quot;</span><span class="hljs-comment"># 交换分区  磁盘如被挂在无法转为交换分区</span><span class="hljs-comment"># 查看交换分区</span>swapon -s <span class="hljs-comment"># 将分区转为交换分区</span>mkswap /dev/sdb1<span class="hljs-comment"># 激活</span>swapon /dev/sdb1<span class="hljs-comment"># 取消激活交换分区</span>swapoff /dev/sdb1<span class="hljs-comment"># 压缩解压见  https://czy1024.github.io/blog/blog/linux_tar.html</span><span class="hljs-comment"># 用户操作  https://czy1024.github.io/blog/blog/linux_user_group.html</span>adduser luna-1 <span class="hljs-comment"># 添加用户 生成目录</span>useradd luna-2 <span class="hljs-comment"># 添加用户 生成目录</span><span class="hljs-comment"># usermod </span><span class="hljs-comment"># 进程管理</span>ps -aux | grep xxx<span class="hljs-comment"># 杀死进程 参数 1 (HUP)：重新加载进程。9 (KILL)：杀死一个进程。 15 (TERM)：正常停止一个进程。</span><span class="hljs-built_in">kill</span> -9 pidkillall xxx<span class="hljs-comment"># 进程启动后台执行 输出重定向</span><span class="hljs-comment"># 后台执行echo &quot;hello&quot; 并将输出到pro.log 文件</span>nohup <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello&quot;</span> &gt; /tmp/pro.log &amp;<span class="hljs-comment"># 网络配置</span><span class="hljs-comment"># 先ifconfig 查看网卡名称</span><span class="hljs-string">&quot;</span><span class="hljs-string">auto ens33</span><span class="hljs-string">iface ens33 inet static　  # 设置静态IP，动态的是将static修改为dhcp，如果设置为动态IP无法设置虚拟网卡</span><span class="hljs-string">address 172.16.2.95　　　  # 如果为动态IP以下的都不用配置。</span><span class="hljs-string">netmask 255.255.255.0        # 子网掩码</span><span class="hljs-string">gateway 172.16.254.254     # 网关 -&gt;上级路由</span><span class="hljs-string">&quot;</span><span class="hljs-comment"># 重启网卡</span>/etc/init.d/networking restart<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;安装ssh&quot;</span>sudo apt-get install openssh-server -ysudo /etc/init.d/ssh restart<span class="hljs-comment"># vim /etc/ssh/sshd_config</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;开启root登陆&quot;</span>sed -i <span class="hljs-string">&#x27;s/#PermitRootLogin prohibit-password/PermitRootLogin yes/g&#x27;</span> /etc/ssh/sshd_configsudo /etc/init.d/ssh restart<span class="hljs-comment"># 免密登录 将客户端公钥放入服务器authorized_keys文件</span><span class="hljs-comment">#客户端执行: scp ~/.ssh/id_rsa.pub  root@172.16.22.2:/tmp/id_rsa.pub </span><span class="hljs-comment">#服务端执行: cat /tmp/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><span class="hljs-comment"># systemctl</span><span class="hljs-comment"># 启动</span>systemctl  start sshd<span class="hljs-comment"># 停止</span>systemctl  stop sshd<span class="hljs-comment"># 开机自启动</span>systemctl <span class="hljs-built_in">enable</span> sshd<span class="hljs-comment">#取消开机运行</span>systemctl <span class="hljs-built_in">disable</span> sshd <span class="hljs-comment"># 创建自定义服务模仿 cat /etc/systemd/system/sshd.service</span><span class="hljs-comment"># 网络安全</span><span class="hljs-comment"># nmap 官网:http://www.nmap.com.cn/</span><span class="hljs-comment"># 扫描端口 将指定ip 1-65535端口扫描结果保存到 /tmp/result.txt</span>nmap -sS -O -p1-65535 ip -o /tmp/result.txt<span class="hljs-comment"># iptables 限制ip访问22</span>iptables -A INPUT -p tcp --dport 22 -s 192.168.100.1/24 -j DROP<span class="hljs-comment"># 查看规则</span>iptables -nL --line-number<span class="hljs-comment"># 清除规则</span>iptables -D INPUT 1<span class="hljs-comment"># shell 编程 锁定用户id大于多少的用户 脚本地址: https://github.com/czy1024/luna-linux-conf/blob/master/ubuntu/lockuser_if_userid_gt_x.sh</span>vim userlock.shchmod +x ./userlock.sh<span class="hljs-comment"># 锁定用户id大于100的用户</span>./userlock.sh 1000<span class="hljs-comment"># 用户计划</span>at 16:00<span class="hljs-comment"># 输入命令后 ctrl + D 结束</span><span class="hljs-comment"># 使用脚本</span>at 16:00 -f ~/luna<span class="hljs-comment"># atq查看设置的计划</span><span class="hljs-comment"># 删除计划</span>atrm x <span class="hljs-comment"># x为查询的任务编号</span>apt-get install crontabs<span class="hljs-comment"># crontab 三个文件</span><span class="hljs-comment"># 系统管理 root用户: /etc/crontab 系统任务 /etc/cron.d 实际工作中与前一个地位相同</span><span class="hljs-comment"># 用于每天,每小时,没星期等文件分别在 /etc/cron.xxxx</span><span class="hljs-comment"># 普通用户的在 /var/spool/cron 目录 以用户名命名</span><span class="hljs-comment"># 为普通用户安装crontab filename 为用户名</span>crontab filename<span class="hljs-comment"># -e 编辑器打开,完成编辑后保存提交 -l 列出用户的crontab文件的内容 -r 删除自己的crontab 文件</span><span class="hljs-comment"># 管理员可建立 /etc/cron.allow 和 /etc/cron.deny 表示用户是否可以创建计划任务 并且 allow&gt;deny</span><span class="hljs-comment"># 并且管理员可用 -u 指定操作用户</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;eg: sudo crontab -u luna luna_make&quot;</span> <span class="hljs-comment"># 给luna 指定crontab 文件 luna_make</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;eg: sudo crontab -u luna -r&quot;</span> <span class="hljs-comment"># 删除luna 的crontab文件</span><span class="hljs-comment">#实例：晚上11点到早上7点之间，每隔一小时重启smb </span>sudo cat &gt; /etc/crontab &lt;&lt;<span class="hljs-string">EOF </span><span class="hljs-string">* 23-7/1 * * * /etc/init.d/smb restart</span><span class="hljs-string">EOF</span><span class="hljs-comment"># 详见 https://czy1024.github.io/blog/blog/linux_crontab.html</span><span class="hljs-comment"># shell 编程 禁止用户id大于多少的用户提交计划 </span><span class="hljs-comment">#脚本地址: https://github.com/czy1024/luna-linux-conf/blob/master/ubuntu/uncrontab_if_user_gt_x.sh</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>system</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux top</title>
    <link href="/2020/12/24/linux-top/"/>
    <url>/2020/12/24/linux-top/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-top命令的用法详细详解"><a href="#Linux-top命令的用法详细详解" class="headerlink" title="Linux top命令的用法详细详解"></a><a href="">Linux top命令的用法详细详解</a></h1><p>**查看多核CPU命令<br>**mpstat -P ALL 和 sar -P ALL </p><p><img src="http://files.jb51.net/file_images/article/201308/201308230923349.gif" alt="img"> </p><p><strong>说明：</strong>sar -P ALL &gt; aaa.txt  重定向输出内容到文件 aaa.txt</p><p>top命令经常用来监控<a href="http://lib.csdn.net/base/linux">Linux</a>的系统状况，比如cpu、内存的使用，程序员基本都知道这个命令，但比较奇怪的是能用好它的人却很少，例如top监控视图中内存数值的含义就有不少的曲解。</p><p>本文通过一个运行中的WEB服务器的top监控截图，讲述top视图中的各种数据的含义，还包括视图中各进程（任务）的字段的排序。</p><p><strong>top进入视图</strong></p><p><img src="http://files.jb51.net/file_images/article/201308/2013082309233410.jpg" alt="top视图 01"></p><p>**top视图 01<br>**【top视图 01】是刚进入top的基本视图，我们来结合这个视图讲解各个数据的含义。</p><p>第一行：<br>10:01:23 — 当前系统时间<br>126 days, 14:29 — 系统已经运行了126天14小时29分钟（在这期间没有重启过）<br>2 users — 当前有2个用户登录系统<br>load average: 1.15, 1.42, 1.44 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。</p><p>load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。</p><p>第二行：<br>Tasks — 任务（进程），系统现在共有183个进程，其中处于运行中的有1个，182个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。</p><p>第三行：cpu状态<br>6.7% us — 用户空间占用CPU的百分比。<br>0.4% sy — 内核空间占用CPU的百分比。<br>0.0% ni — 改变过优先级的进程占用CPU的百分比<br>92.9% id — 空闲CPU百分比<br>0.0% wa — IO等待占用CPU的百分比<br>0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比<br>0.0% si — 软中断（Software Interrupts）占用CPU的百分比</p><p>在这里CPU的使用比率和windows概念不同，如果你不理解用户空间和内核空间，需要充充电了。</p><p>第四行：内存状态<br>8306544k total — 物理内存总量（8GB）<br>7775876k used — 使用中的内存总量（7.7GB）<br>530668k free — 空闲内存总量（530M）<br>79236k buffers — 缓存的内存量 （79M）</p><p>第五行：swap交换分区<br>2031608k total — 交换区总量（2GB）<br>2556k used — 使用的交换区总量（2.5M）<br>2029052k free — 空闲交换区总量（2GB）<br>4231276k cached — 缓冲的交换区总量（4GB）</p><p>这里要说明的是不能用windows的内存概念理解这些数据，如果按windows的方式此台服务器“危矣”：8G的内存总量只剩下530M的可用内存。Linux的内存管理有其特殊性，复杂点需要一本书来说明，这里只是简单说点和我们传统概念（windows）的不同。</p><p>第四行中使用中的内存总量（used）指的是现在系统内核控制的内存数，空闲内存总量（free）是内核还未纳入其管控范围的数量。纳入内核管理的内存不见得都在使用中，还包括过去使用过的现在可以被重复利用的内存，内核并不把这些可被重新使用的内存交还到free中去，因此在<a href="http://lib.csdn.net/base/linux">linux</a>上free内存会越来越少，但不用为此担心。</p><p>如果出于习惯去计算可用内存数，这里有个近似的计算公式：第四行的free + 第四行的buffers + 第五行的cached，按这个公式此台服务器的可用内存：530668+79236+4231276 = 4.7GB。</p><p>对于内存监控，在top里我们要时刻监控第五行swap交换分区的used，如果这个数值在不断的变化，说明内核在不断进行内存和swap的数据交换，这是真正的内存不够用了。</p><p>第六行是空行<br>第七行以下：各进程（任务）的状态监控<br>PID — 进程id<br>USER — 进程所有者<br>PR — 进程优先级<br>NI — nice值。负值表示高优先级，正值表示低优先级<br>VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES<br>RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA<br>SHR — 共享内存大小，单位kb<br>S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程<br>%CPU — 上次更新到现在的CPU时间占用百分比<br>%MEM — 进程使用的物理内存百分比<br>TIME+ — 进程使用的CPU时间总计，单位1/100秒<br>COMMAND — 进程名称（命令名/命令行）</p><p>**多U多核CPU监控<br>**在top基本视图中，按键盘数字“1”，可监控每个逻辑CPU的状况：</p><p><img src="http://files.jb51.net/file_images/article/201308/2013082309233411.jpg" alt="top视图 02"></p><p><strong>top视图 02</strong></p><p>观察上图，服务器有16个逻辑CPU，实际上是4个物理CPU。</p><p>**进程字段排序<br>**默认进入top时，各进程是按照CPU的占用量来排序的，在【top视图 01】中进程ID为14210的<a href="http://lib.csdn.net/base/java">Java</a>进程排在第一（cpu占用100%），进程ID为14183的java进程排在第二（cpu占用12%）。可通过键盘指令来改变排序字段，比如想监控哪个进程占用MEM最多，我一般的使用方法如下：</p><p>\1. 敲击键盘“b”（打开/关闭加亮效果），top的视图变化如下：</p><p><img src="http://files.jb51.net/file_images/article/201308/2013082309233412.jpg" alt="top视图 03"></p><p><strong>top视图 03</strong></p><p>我们发现进程id为10704的“top”进程被加亮了，top进程就是视图第二行显示的唯一的运行态（runing）的那个进程，可以通过敲击“y”键关闭或打开运行态进程的加亮效果。</p><p>\2. 敲击键盘“x”（打开/关闭排序列的加亮效果），top的视图变化如下：</p><p><img src="http://files.jb51.net/file_images/article/201308/2013082309233413.jpg" alt="top视图 04"></p><p><strong>top视图 04</strong></p><p>可以看到，top默认的排序列是“%CPU”。</p><p>\3. 通过”shift + &gt;”或”shift + &lt;”可以向右或左改变排序列，下图是按一次”shift + &gt;”的效果图：</p><p><img src="http://files.jb51.net/file_images/article/201308/2013082309233414.jpg" alt="top视图 05"></p><p><strong>top视图 05</strong></p><p>视图现在已经按照%MEM来排序了。</p><p><strong>改变进程显示字段</strong></p><p>\1. 敲击“f”键，top进入另一个视图，在这里可以编排基本视图中的显示字段：</p><p><img src="http://files.jb51.net/file_images/article/201308/2013082309233415.jpg" alt="top视图 06"></p><p><strong>top视图 06</strong></p><p>这里列出了所有可在top基本视图中显示的进程字段，有”<em>”并且标注为大写字母的字段是可显示的，没有”</em>”并且是小写字母的字段是不显示的。如果要在基本视图中显示“CODE”和“DATA”两个字段，可以通过敲击“r”和“s”键：</p><p><img src="http://files.jb51.net/file_images/article/201308/2013082309233416.jpg" alt="top视图 07"></p><p><strong>top视图 07</strong></p><p>\2. “回车”返回基本视图，可以看到多了“CODE”和“DATA”两个字段：</p><p><img src="http://files.jb51.net/file_images/article/201308/2013082309233417.jpg" alt="top视图 08"></p><p>top视图 08</p><p>**top命令的补充<br>**top命令是Linux上进行系统监控的首选命令，但有时候却达不到我们的要求，比如当前这台服务器，top监控有很大的局限性。这台服务器运行着websphere集群，有两个节点服务，就是【top视图 01】中的老大、老二两个java进程，top命令的监控最小单位是进程，所以看不到我关心的java线程数和客户连接数，而这两个指标是java的web服务非常重要的指标，通常我用ps和netstate两个命令来补充top的不足。</p><p>监控java线程数：<br>ps -eLf | grep java | wc -l</p><p>监控网络客户连接数：<br>netstat -n | grep tcp | grep 侦听端口 | wc -l</p><p>满载一船星辉,在星辉斑斓里放歌</p>]]></content>
    
    
    <categories>
      
      <category>system</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逻辑运算符</title>
    <link href="/2020/11/28/other-logical-operations/"/>
    <url>/2020/11/28/other-logical-operations/</url>
    
    <content type="html"><![CDATA[<h2 id="逻辑运算符-and-or-nor"><a href="#逻辑运算符-and-or-nor" class="headerlink" title="逻辑运算符(and, or, nor)"></a>逻辑运算符(and, or, nor)</h2><p>and &amp; </p><p>规则: 1&amp;1 = 1; 1&amp;0 = 0; 0&amp;1 = 0; 0&amp;0 =0</p><p>运用：and al, 10111111B</p><p>将0位对应的数值置为0</p><p>将1位对应的数值保持不变</p><p>or |</p><p>规则：1|1 = 1； 1|0 = 1； 0|1 = 1； 0|0 = 0</p><p>运用：or al， 10111111B</p><p>将0位对用的数值保持不变</p><p>将1位对应的数值置为1</p><p>xor ^</p><p>异或，英文为exclusive OR，缩写成xor</p><p>异或（eor）是一个数学运算符。它应用于<a href="https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97/7224729">逻辑运算</a>。异或的数学符号为“⊕”，计算机符号为“eor”。其运算法则为：</p><p>a⊕b = (¬a ∧ b) ∨ (a ∧¬b)</p><p>规则：1^1 = 0; 1^0 = 1; 0^1 = 1; 0^0 = 0</p><p>运用：a^b^b == a;</p><p>小技巧：不用第三个变量交换变量内容</p><p>a = a^b; </p><p>b = a^b;  //此时 b = a0; </p><p>a = a^b;  //此时 a = (a0^b0)^a0 = b0;</p><p>nor</p><p>同或运算 = 异或运算  ^  1</p><p>​           (A  ^  B)  ^  1 </p><p>相同出1，不同出0</p><p>&amp;&amp;  </p><p>并且</p><p>|| </p><p>或者</p><p>！</p><p>非 取反</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring RestTemplate</title>
    <link href="/2020/11/24/spring-rest-template/"/>
    <url>/2020/11/24/spring-rest-template/</url>
    
    <content type="html"><![CDATA[<h1 id="掌握-Spring-之-RestTemplate"><a href="#掌握-Spring-之-RestTemplate" class="headerlink" title="掌握 Spring 之 RestTemplate"></a>掌握 Spring 之 RestTemplate</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Java 服务端开发领域里，Spring 是绕不开的话题，尤其是现在微服务概念盛行，Spring Boot 的出现更是给 Spring 注入了新的活力，除此之外还有 Spring Cloud，这些框架让 Spring 技术体系更加丰富。Spring 从 2014 年的 1.0.0 版本迭代到 现在的 5.2.0 M1 版本，紧随着 Java 语言发展，不断引入新的特性和功能。本文关注的是 Spring 框架中 <code>RestTemplate</code> 内容，可以减少我们平时开发常使用的 <code>HttpClient</code> API 依赖。文章所涉及的示例 Demo 详见Github 地址：<a href="https://github.com/wrcj12138aaa/resttemplate/tree/master">Resttemplate demo</a> 。感谢小七同学的认真校对，如果有任何技术问题或者文章纰漏，欢迎留言联系，一起交流探讨 😁。</p><h2 id="认识-RestTemplate"><a href="#认识-RestTemplate" class="headerlink" title="认识 RestTemplate"></a>认识 <code>RestTemplate</code></h2><p>首先在我们学习使用 <code>RestTemplate</code> 之前，先认识下这个类，来看 Spring 官方怎么描述的。 从官方 API 文档 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html">RestTemplate javadoc</a> 可以找该类的描述如下：</p><blockquote><p>Synchronous client to perform HTTP requests, exposing a simple, template method API over underlying HTTP client libraries such as the JDK HttpURLConnection, Apache HttpComponents, and others. The RestTemplate offers templates for common scenarios by HTTP method, in addition to the generalized exchange and execute methods that support of less frequent cases.</p></blockquote><p>从这里可以清楚地了解到 <code>RestTemplate</code> 采用同步方式执行 HTTP 请求的类，底层使用 JDK 原生 <code>HttpURLConnection</code> API ，或者 <code>HttpComponents</code>等其他 HTTP 客户端请求类库。还有一处强调的就是 <code>RestTemplate</code> 提供模板化的方法让开发者能更简单地发送 HTTP 请求。</p><p>值得注意的是，<code>RestTemplate</code> 类是在 Spring Framework 3.0 开始引入的，这里我们使用的 Spring 版本为当前最新的 GA 版本 5.1.6。而在 5.0 以上，官方标注了更推荐使用非阻塞的响应式 HTTP 请求处理类 <code>org.springframework.web.reactive.client.WebClient</code> 来替代 <code>RestTemplate</code>，尤其是对应异步请求处理的场景上 。</p><p>这里我们先简单总结下什么是 <code>RestTemplate</code> ： <code>RestTemplate</code> 就是 Spring 封装的处理同步 HTTP 请求的类。具体如何使用这个类进行 HTTP 请求操作，可见文章的实战部分。</p><p>接下来我们看下 <code>RestTemplate</code> 类提供的 API 有哪些,<code>RestTemplate</code> 提供了将近 30 个请求方法，其中多数是单个方法重载实现，这里我主要参考官方文档 <a href="https://docs.spring.io/spring/docs/5.1.6.RELEASE/spring-framework-reference/integration.html#rest-client-access">rest-client-access</a> 进行如下分类：</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><code>getForObject</code></td><td>通过 GET 请求获得响应结果</td></tr><tr><td><code>getForEntity</code></td><td>通过 GET 请求获取 <code>ResponseEntity</code> 对象，包容有状态码，响应头和响应数据</td></tr><tr><td><code>headForHeaders</code></td><td>以 HEAD 请求资源返回所有响应头信息</td></tr><tr><td><code>postForLocation</code></td><td>用 POST 请求创建资源，并返回响应数据中响应头的字段 <code>Location</code> 的数据</td></tr><tr><td><code>postForObject</code></td><td>通过 POST 请求创建资源，获得响应结果</td></tr><tr><td><code>put</code></td><td>通过 PUT 方式请求来创建或者更新资源</td></tr><tr><td><code>patchForObject</code></td><td>通过 PATH 方式请求来更新资源，并获得响应结果。(JDK <code>HttpURLConnection</code> 不支持 PATH 方式请求，其他 HTTP 客户端库支持)</td></tr><tr><td><code>delete</code></td><td>通过 DELETE 方式删除资源</td></tr><tr><td><code>optionsForAllow</code></td><td>通过 ALLOW 方式请求来获得资源所允许访问的所有 HTTP 方法，可用看某个请求支持哪些请求方式</td></tr><tr><td><code>exchange</code></td><td>更通用版本的请求处理方法，接受一个 <code>RequestEntity</code> 对象，可以设置路径，请求头，请求信息等，最后返回一个 <code>ResponseEntity</code> 实体</td></tr><tr><td><code>execute</code></td><td>最通用的执行 HTTP 请求的方法，上面所有方法都是基于 <code>execute</code> 的封装，全面控制请求信息，并通过回调接口获得响应数据</td></tr></tbody></table><p>看到那么多方法也记不全，为了更好理解，可以简单看下 <code>RestTemplate</code> 的类层级体系，通过官方源代码就能看到:</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Interface specifying a basic set of RESTful operations.</span><span class="hljs-comment"> * Implemented by &#123;<span class="hljs-doctag">@link</span> RestTemplate&#125;. Not often used directly, but a useful</span><span class="hljs-comment"> * option to enhance testability, as it can easily be mocked or stubbed.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Arjen Poutsma</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Juergen Hoeller</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 3.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> RestTemplate</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RestOperations</span> </span>&#123;    ...&#125;</code></pre></div><p>其实 <code>RestTemplate</code> 类的请求方法都是来自 <code>RestOperations</code> 接口的，根据这个名字就可以大概知道这个接口主要就是提供了 RESTful 请求操作的接口，如 GET，POST，PUT，DELETE 等，具体信息可以参见 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/client/RestOperations.html">RestOperation javadoc</a>。</p><p><img src="/img/springrest/1.jpg" alt="RestTemplate 类层次图"></p><blockquote><p>关于 RESTful：</p><p>来自Wikipedia 定义：<strong>表现层状态转换</strong>，一种设计提供万维网络服务的<a href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E4%BB%B6%E6%9E%B6%E6%A7%8B">软件构建风格</a>，又简称为 REST。</p><p><strong>用 URL 定位资源，用 HTTP 动词描述操作，如 GET,POST,DELETE,PUT</strong>，简单来说通过 URL 就知道访问什么资源，通过 HTTP Method 就知道执行什么操作，通过 HTTP Status Code 就知道执行结果。</p></blockquote><h2 id="实战-RestTemplate"><a href="#实战-RestTemplate" class="headerlink" title="实战 RestTemplate"></a>实战 <code>RestTemplate</code></h2><p>好了，简单认识了 <code>RestTemplate</code> 类之后，我们先牛刀小试，看看如何上手使用。</p><h3 id="1-生成-Demo-项目，导入-IDE"><a href="#1-生成-Demo-项目，导入-IDE" class="headerlink" title="1. 生成 Demo 项目，导入 IDE"></a>1. 生成 Demo 项目，导入 IDE</h3><p>为了能快速搭建一个 Demo，我们这边用 Spring Boot 框架搭建，首先用官方提供的 <a href="https://start.spring.io/">Spring Initializr</a> 来生成快速构建项目骨架，选择 Spring Boot 版本 2.1.4,其底层依赖的 Spring Framework 版本为最新发布版本 5.1.6，对于 POM 依赖只选择一个 Web 模块即可，这样便于快速搭建 Web 应用。</p><p><img src="/img/springrest/2.jpg" alt="spring initializr"></p><p>点击生成工程按钮，就可以下载到项目的压缩包，解压后用自己常用的 IDE 导入项目，项目结构整理如下：</p><p><img src="/img/springrest/3.jpg" alt="项目骨架"></p><p>项目中 <code>ResttemplateApplication.java</code> 为整个程序的引导类，用于启动项目。</p><h3 id="2-编写请求控制器类-ProductController"><a href="#2-编写请求控制器类-ProductController" class="headerlink" title="2. 编写请求控制器类 ProductController"></a>2. 编写请求控制器类 ProductController</h3><p>首先为了能够使用 <code>RestTemplate</code> 发送多种方式 HTTP 请求，先本地构建接受 HTTP 请求的产品控制器，新建包 <code>com.one.learn.resttemplate.controller</code>,新建产品 Controller <code>ProductController</code> , 代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/product&quot;)</span><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductController</span> </span>&#123;    <span class="hljs-meta">@GetMapping(&quot;/get_product1&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">get_product1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Product(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;ProductA&quot;</span>, BigDecimal.valueOf(<span class="hljs-number">6666.0</span>));    &#125;    <span class="hljs-meta">@GetMapping(&quot;/get_product2&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">get_product2</span><span class="hljs-params">(Integer id)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Product(id, <span class="hljs-string">&quot;ProductC&quot;</span>, BigDecimal.valueOf(<span class="hljs-number">6666.0</span>));    &#125;    <span class="hljs-meta">@GetMapping(&quot;/get_product3&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get_product3</span><span class="hljs-params">(Product product)</span> </span>&#123;        <span class="hljs-keyword">return</span> product.toString();    &#125;    <span class="hljs-meta">@PostMapping(&quot;/post_product1&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">post_product1</span><span class="hljs-params">(Product product)</span> </span>&#123;        <span class="hljs-keyword">return</span> product.toString();    &#125;    <span class="hljs-meta">@PostMapping(&quot;/post_product2&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">post_product2</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Product product)</span> </span>&#123;        <span class="hljs-keyword">return</span> product.toString();    &#125;    <span class="hljs-meta">@DeleteMapping(&quot;/delete/&#123;id&#125;&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span> </span>&#123;        String result = String.format(<span class="hljs-string">&quot;编号为%s的产品删除成功&quot;</span>, id);        System.out.println(result);        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@PutMapping(&quot;/update&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">updateByPut</span><span class="hljs-params">(Product product)</span> </span>&#123;        String result = product.toString() + <span class="hljs-string">&quot; 更新成功&quot;</span>;        System.out.println(result);        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@PostMapping(&quot;/upload&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">upload</span><span class="hljs-params">(MultipartRequest request)</span> </span>&#123;        <span class="hljs-comment">// Spring MVC 使用 MultipartRequest 接受带文件的 HTTP 请求</span>        MultipartFile file = request.getFile(<span class="hljs-string">&quot;file&quot;</span>);         String originalFilename = file.getOriginalFilename();        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;upload success filename: &quot;</span> + originalFilename;    &#125;&#125;</code></pre></div><p>在<code>Product</code> 控制器中涉及的实体类 <code>Product</code> 创建在 <code>com.one.learn.resttemplate.bean</code> 包下，代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> BigDecimal price;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Product</span><span class="hljs-params">()</span> </span>&#123;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Product</span><span class="hljs-params">(Integer id, String name, BigDecimal price)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.price = price;    &#125;    <span class="hljs-comment">// 省去 setter getter 方法</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Product&#123;&quot;</span> +                <span class="hljs-string">&quot;id=&#x27;&quot;</span> + id + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&quot;, price=&#x27;&quot;</span> + price + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre></div><p>有了这些类，就可以利用程序引导类 <code>ResttemplateApplication</code> 启动 Spring Boot 项目，一个简单的 Web 应用就诞生了,监听 8080 端口，结果如下图所示：</p><p><img src="/img/springrest/4.jpg" alt="项目启动"></p><p>我们可以简单测试一下，打开浏览器，访问 <code>http://localhost:8080/product/get_product1</code>，会看到如图所示的结果：</p><p><img src="/img/springrest/5.jpg" alt="项目访问"></p><h3 id="3-编写测试类用-RestTemplate-发送-HTTP-请求"><a href="#3-编写测试类用-RestTemplate-发送-HTTP-请求" class="headerlink" title="3. 编写测试类用 RestTemplate 发送 HTTP 请求"></a>3. 编写测试类用 RestTemplate 发送 HTTP 请求</h3><p>有了 Web 服务，接下来该使用 <code>RestTemplate</code> 来发送请求并处理响应了。我们在 <code>test</code> 文件下新建一个测试类 <code>com.one.learn.resttemplate.RestTemplateTests</code>,代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RestTemplateTests</span> </span>&#123;    RestTemplate restTemplate = <span class="hljs-keyword">null</span>;    <span class="hljs-meta">@Before</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>&#123;        restTemplate = <span class="hljs-keyword">new</span> RestTemplate();    &#125;    &#125;</code></pre></div><p>这里我们通过编写测试方法来用 <code>RestTemplate</code> API 实现对 <code>Product</code> 控制器各个接口的请求。</p><h4 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h4><p>我们先最简单的下手，尝试用 <code>RestTemplate</code> 访问请求路径为 <code>product/get_product1</code>, 一个不带任何参数 的 GET 请求，代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGet_product1</span><span class="hljs-params">()</span> </span>&#123;   String url = <span class="hljs-string">&quot;http://localhost:8080/product/get_product1&quot;</span>;   <span class="hljs-comment">//方式一：GET 方式获取 JSON 串数据</span>   String result = restTemplate.getForObject(url, String.class);   System.out.println(<span class="hljs-string">&quot;get_product1返回结果：&quot;</span> + result);   Assert.hasText(result, <span class="hljs-string">&quot;get_product1返回结果为空&quot;</span>);   <span class="hljs-comment">//方式二：GET 方式获取 JSON 数据映射后的 Product 实体对象</span>   Product product = restTemplate.getForObject(url, Product.class);   System.out.println(<span class="hljs-string">&quot;get_product1返回结果：&quot;</span> + product);   Assert.notNull(product, <span class="hljs-string">&quot;get_product1返回结果为空&quot;</span>);   <span class="hljs-comment">//方式三：GET 方式获取包含 Product 实体对象 的响应实体 ResponseEntity 对象,用 getBody() 获取</span>   ResponseEntity&lt;Product&gt; responseEntity = restTemplate.getForEntity(url, Product.class);   System.out.println(<span class="hljs-string">&quot;get_product1返回结果：&quot;</span> + responseEntity);   Assert.isTrue(responseEntity.getStatusCode().equals(HttpStatus.OK), <span class="hljs-string">&quot;get_product1响应不成功&quot;</span>);   &#125;</code></pre></div><p>首先看下运行测试方法 <code>testGet_product1</code> 后控制台的输出日志：</p><div class="hljs code-wrapper"><pre><code class="hljs java">...get_product1返回结果：&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;ProductA&quot;</span>,<span class="hljs-string">&quot;price&quot;</span>:<span class="hljs-number">6666.0</span>&#125;...get_product1返回结果：Product&#123;id=<span class="hljs-string">&#x27;1&#x27;</span>, name=<span class="hljs-string">&#x27;ProductA&#x27;</span>, price=<span class="hljs-string">&#x27;6666.0&#x27;</span>&#125;...get_product1返回结果：&lt;<span class="hljs-number">200</span>,Product&#123;id=<span class="hljs-string">&#x27;1&#x27;</span>, name=<span class="hljs-string">&#x27;ProductA&#x27;</span>, price=<span class="hljs-string">&#x27;6666.0&#x27;</span>&#125;,[Content-Type:<span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>, Transfer-Encoding:<span class="hljs-string">&quot;chunked&quot;</span>, Date:<span class="hljs-string">&quot;Thu, 09 May 2019 15:37:25 GMT&quot;</span>]&gt;...</code></pre></div><p>可以看到 <code>testGet_product1</code> 请求都是成功响应并获取到了数据，从上面代码上看是不是很简单。现在来点略复杂的请求方式，使用 <code>RestTemplate</code> API 中 <code>exchange</code> 和 <code>execute</code> 方法发送 GET 请求，可以更加细粒度控制请求的行为，如 <code>Header</code> 信息，数据处理方式等,同样在 <code>testGet_product1</code> 方法里添加代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGet_product1</span><span class="hljs-params">()</span> </span>&#123;    String url = <span class="hljs-string">&quot;http://localhost:8080/product/get_product1&quot;</span>;    <span class="hljs-comment">//....</span>        <span class="hljs-comment">//方式一： 构建请求实体 HttpEntity 对象，用于配置 Header 信息和请求参数</span>    MultiValueMap header = <span class="hljs-keyword">new</span> LinkedMultiValueMap();    header.add(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE);    HttpEntity&lt;Object&gt; requestEntity = <span class="hljs-keyword">new</span> HttpEntity&lt;&gt;(header);    <span class="hljs-comment">//方式二： 执行请求获取包含 Product 实体对象 的响应实体 ResponseEntity 对象,用 getBody() 获取</span>    ResponseEntity&lt;Product&gt; exchangeResult = restTemplate.exchange(url, HttpMethod.GET, requestEntity, Product.class);    System.out.println(<span class="hljs-string">&quot;get_product1返回结果：&quot;</span> + exchangeResult);    Assert.isTrue(exchangeResult.getStatusCode().equals(HttpStatus.OK), <span class="hljs-string">&quot;get_product1响应不成功&quot;</span>);    <span class="hljs-comment">//方式三： 根据 RequestCallback 接口实现类设置Header信息,用 ResponseExtractor 接口实现类读取响应数据</span>    String executeResult = restTemplate.execute(url, HttpMethod.GET, request -&gt; &#123;        request.getHeaders().add(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE);    &#125;, (clientHttpResponse) -&gt; &#123;        InputStream body = clientHttpResponse.getBody();        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[body.available()];        body.read(bytes);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(bytes);    &#125;); <span class="hljs-comment">// 备注：这里使用了 Java8 特性：Lambda 表达式语法，若未接触 Lambda 表达式后可以使用匿名内部类代替实现</span>    System.out.println(<span class="hljs-string">&quot;get_product1返回结果：&quot;</span> + executeResult);    Assert.hasText(executeResult, <span class="hljs-string">&quot;get_product1返回结果为空&quot;</span>);&#125;</code></pre></div><p>同样再运行测试方法 <code>testGet_product1</code> 后控制台的输出日志：</p><div class="hljs code-wrapper"><pre><code class="hljs java">...get_product1返回结果：&lt;<span class="hljs-number">200</span>,Product&#123;id=<span class="hljs-string">&#x27;1&#x27;</span>, name=<span class="hljs-string">&#x27;ProductA&#x27;</span>, price=<span class="hljs-string">&#x27;6666.0&#x27;</span>&#125;,[Content-Type:<span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>, Transfer-Encoding:<span class="hljs-string">&quot;chunked&quot;</span>, Date:<span class="hljs-string">&quot;Thu, 09 May 2019 16:00:22 GMT&quot;</span>]&gt;...get_product1返回结果：&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;ProductA&quot;</span>,<span class="hljs-string">&quot;price&quot;</span>:<span class="hljs-number">6666.0</span>&#125;...</code></pre></div><p>结果也都是正常返回，说明执行的请求都是正确的。</p><p>现在来尝试执行带有参数的 GET 请求，同样的方式编写一个新的测试方法，实现代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGet_product2</span><span class="hljs-params">()</span> </span>&#123;    String url = <span class="hljs-string">&quot;http://localhost:8080/product/get_product2/id=&#123;id&#125;&quot;</span>;    <span class="hljs-comment">//方式一：将参数的值存在可变长度参数里，按照顺序进行参数匹配</span>    ResponseEntity&lt;Product&gt; responseEntity = restTemplate.getForEntity(url, Product.class, <span class="hljs-number">101</span>);    System.out.println(responseEntity);    Assert.isTrue(responseEntity.getStatusCode().equals(HttpStatus.OK), <span class="hljs-string">&quot;get_product2 请求不成功&quot;</span>);    Assert.notNull(responseEntity.getBody().getId(), <span class="hljs-string">&quot;get_product2  传递参数不成功&quot;</span>);    <span class="hljs-comment">//方式二：将请求参数以键值对形式存储到 Map 集合中，用于请求时URL上的拼接</span>    Map&lt;String, Object&gt; uriVariables = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    uriVariables.put(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-number">101</span>);    Product result = restTemplate.getForObject(url, Product.class, uriVariables);    System.out.println(result);    Assert.notNull(result.getId(), <span class="hljs-string">&quot;get_product2  传递参数不成功&quot;</span>);&#125;</code></pre></div><p>正常运行结果如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java">...&lt;<span class="hljs-number">200</span>,Product&#123;id=<span class="hljs-string">&#x27;101&#x27;</span>, name=<span class="hljs-string">&#x27;ProductC&#x27;</span>, price=<span class="hljs-string">&#x27;6666.0&#x27;</span>&#125;,[Content-Type:<span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>, Transfer-Encoding:<span class="hljs-string">&quot;chunked&quot;</span>, Date:<span class="hljs-string">&quot;Fri, 10 May 2019 14:53:41 GMT&quot;</span>]&gt;...Product&#123;id=<span class="hljs-string">&#x27;101&#x27;</span>, name=<span class="hljs-string">&#x27;ProductC&#x27;</span>, price=<span class="hljs-string">&#x27;6666.0&#x27;</span>&#125;...</code></pre></div><h4 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h4><p>了解完如何用 <code>RestTemplate</code> API 发送 GET 请求后，再看下平时也很常见的 POST 请求如何使用。由于 POST 请求数据的内容类型 <code>Content-Type</code> 不同，发送 POST 请求情况相对就多了，我们这里以常用的 <code>application/x-www-form-urlencoded</code> 和 <code>application/json</code> 这两种内容类型为例子。</p><ul><li><p>发送 <code>Content-Type</code> 为 <code>application/x-www-form-urlencoded</code> 的 POST 请求：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testPost_product1</span><span class="hljs-params">()</span> </span>&#123;    String url = <span class="hljs-string">&quot;http://localhost:8080/product/post_product1&quot;</span>;Product product = <span class="hljs-keyword">new</span> Product(<span class="hljs-number">201</span>, <span class="hljs-string">&quot;Macbook&quot;</span>, BigDecimal.valueOf(<span class="hljs-number">10000</span>));  <span class="hljs-comment">// 设置请求的 Content-Type 为 application/x-www-form-urlencoded</span>    MultiValueMap&lt;String, String&gt; header = <span class="hljs-keyword">new</span> LinkedMultiValueMap();    header.add(HttpHeaders.CONTENT_TYPE, (MediaType.APPLICATION_FORM_URLENCODED_VALUE));        <span class="hljs-comment">//方式二： 将请求参数值以 K=V 方式用 &amp; 拼接，发送请求使用</span>    String productStr = <span class="hljs-string">&quot;id=&quot;</span> + product.getId() + <span class="hljs-string">&quot;&amp;name=&quot;</span> + product.getName() + <span class="hljs-string">&quot;&amp;price=&quot;</span> + product.getPrice();    HttpEntity&lt;String&gt; request = <span class="hljs-keyword">new</span> HttpEntity&lt;&gt;(productStr, header);    ResponseEntity&lt;String&gt; exchangeResult = restTemplate.exchange(url, HttpMethod.POST, request, String.class);    System.out.println(<span class="hljs-string">&quot;post_product1: &quot;</span> + exchangeResult);    Assert.isTrue(exchangeResult.getStatusCode().equals(HttpStatus.OK), <span class="hljs-string">&quot;post_product1 请求不成功&quot;</span>);    <span class="hljs-comment">//方式一： 将请求参数以键值对形式存储在 MultiValueMap 集合，发送请求时使用</span>    MultiValueMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> LinkedMultiValueMap();    map.add(<span class="hljs-string">&quot;id&quot;</span>, (product.getId()));    map.add(<span class="hljs-string">&quot;name&quot;</span>, (product.getName()));    map.add(<span class="hljs-string">&quot;price&quot;</span>, (product.getPrice()));    HttpEntity&lt;MultiValueMap&gt; request2 = <span class="hljs-keyword">new</span> HttpEntity&lt;&gt;(map, header);    ResponseEntity&lt;String&gt; exchangeResult2 = restTemplate.exchange(url, HttpMethod.POST, request2, String.class);    System.out.println(<span class="hljs-string">&quot;post_product1： &quot;</span> + exchangeResult2);    Assert.isTrue(exchangeResult.getStatusCode().equals(HttpStatus.OK), <span class="hljs-string">&quot;post_product1 请求不成功&quot;</span>);&#125;</code></pre></div><p>对应的输出日志如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java">...post_product1: &lt;<span class="hljs-number">200</span>,Product&#123;id=<span class="hljs-string">&#x27;201&#x27;</span>, name=<span class="hljs-string">&#x27;Macbook&#x27;</span>, price=<span class="hljs-string">&#x27;10000&#x27;</span>&#125;,[Content-Type:<span class="hljs-string">&quot;text/plain;charset=UTF-8&quot;</span>, Content-Length:<span class="hljs-string">&quot;48&quot;</span>, Date:<span class="hljs-string">&quot;Fri, 10 May 2019 16:07:43 GMT&quot;</span>]&gt;...post_product1： &lt;<span class="hljs-number">200</span>,Product&#123;id=<span class="hljs-string">&#x27;201&#x27;</span>, name=<span class="hljs-string">&#x27;Macbook&#x27;</span>, price=<span class="hljs-string">&#x27;10000&#x27;</span>&#125;,[Content-Type:<span class="hljs-string">&quot;text/plain;charset=UTF-8&quot;</span>, Content-Length:<span class="hljs-string">&quot;48&quot;</span>, Date:<span class="hljs-string">&quot;Fri, 10 May 2019 16:07:43 GMT&quot;</span>]&gt;</code></pre></div></li><li><p>发送 <code>Content-Type</code> 为 <code>application/json</code> 的 POST 请求：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testPost_product2</span><span class="hljs-params">()</span> </span>&#123;    String url = <span class="hljs-string">&quot;http://localhost:8080/product/post_product2&quot;</span>;       <span class="hljs-comment">// 设置请求的 Content-Type 为 application/json</span>    MultiValueMap&lt;String, String&gt; header = <span class="hljs-keyword">new</span> LinkedMultiValueMap();    header.put(HttpHeaders.CONTENT_TYPE, Arrays.asList(MediaType.APPLICATION_JSON_VALUE));    <span class="hljs-comment">// 设置 Accept 向服务器表明客户端可处理的内容类型</span>    header.put(HttpHeaders.ACCEPT, Arrays.asList(MediaType.APPLICATION_JSON_VALUE));    <span class="hljs-comment">// 直接将实体 Product 作为请求参数传入，底层利用 Jackson 框架序列化成 JSON 串发送请求</span>    HttpEntity&lt;Product&gt; request = <span class="hljs-keyword">new</span> HttpEntity&lt;&gt;(<span class="hljs-keyword">new</span> Product(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Macbook&quot;</span>, BigDecimal.valueOf(<span class="hljs-number">10000</span>)), header);    ResponseEntity&lt;String&gt; exchangeResult = restTemplate.exchange(url, HttpMethod.POST, request, String.class);    System.out.println(<span class="hljs-string">&quot;post_product2: &quot;</span> + exchangeResult);    Assert.isTrue(exchangeResult.getStatusCode().equals(HttpStatus.OK), <span class="hljs-string">&quot;post_product2 请求不成功&quot;</span>);&#125;</code></pre></div><p>验证的输出日志如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java">···post_product2: &lt;<span class="hljs-number">200</span>,Product&#123;id=<span class="hljs-string">&#x27;2&#x27;</span>, name=<span class="hljs-string">&#x27;Macbook&#x27;</span>, price=<span class="hljs-string">&#x27;10000&#x27;</span>&#125;,[Content-Type:<span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>, Content-Length:<span class="hljs-string">&quot;46&quot;</span>, Date:<span class="hljs-string">&quot;Fri, 10 May 2019 16:09:11 GMT&quot;</span>]&gt;···</code></pre></div></li></ul><h4 id="DELETE-请求-和-PUT-请求"><a href="#DELETE-请求-和-PUT-请求" class="headerlink" title="DELETE 请求 和 PUT 请求"></a>DELETE 请求 和 PUT 请求</h4><p>DELETE 请求和 PUT 请求属于 RESTful 请求方式的两种，但通常不会被使用到，这里也只是简单演示下，具体代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// DELETE 方法请求</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDelete</span><span class="hljs-params">()</span> </span>&#123;   String url = <span class="hljs-string">&quot;http://localhost:8080/product/delete/&#123;id&#125;&quot;</span>;   restTemplate.delete(url, <span class="hljs-number">101</span>);&#125;<span class="hljs-comment">// PUT 方法请求</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testPut</span><span class="hljs-params">()</span> </span>&#123;    String url = <span class="hljs-string">&quot;http://localhost:8080/product/update&quot;</span>;    Map&lt;String, ?&gt; variables = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    MultiValueMap&lt;String, String&gt; header = <span class="hljs-keyword">new</span> LinkedMultiValueMap();    header.put(HttpHeaders.CONTENT_TYPE, Arrays.asList(MediaType.APPLICATION_FORM_URLENCODED_VALUE));    Product product = <span class="hljs-keyword">new</span> Product(<span class="hljs-number">101</span>, <span class="hljs-string">&quot;iWatch&quot;</span>, BigDecimal.valueOf(<span class="hljs-number">2333</span>));    String productStr = <span class="hljs-string">&quot;id=&quot;</span> + product.getId() + <span class="hljs-string">&quot;&amp;name=&quot;</span> + product.getName() + <span class="hljs-string">&quot;&amp;price=&quot;</span> + product.getPrice();    HttpEntity&lt;String&gt; request = <span class="hljs-keyword">new</span> HttpEntity&lt;&gt;(productStr, header);    restTemplate.put(url, request);&#125;</code></pre></div><h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><p>现在我们再试下如何使用 <code>RestTemplate</code> API 进行文件上传,也比较简单，首先看下实现代码:</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUploadFile</span><span class="hljs-params">()</span> </span>&#123;    String url = <span class="hljs-string">&quot;http://localhost:8080/product/upload&quot;</span>;    MultiValueMap&lt;String, Object&gt; body = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;();    FileSystemResource file = <span class="hljs-keyword">new</span> FileSystemResource(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;/Users/One/Desktop/b.txt&quot;</span>));    body.add(<span class="hljs-string">&quot;file&quot;</span>, file);    MultiValueMap&lt;String, String&gt; header = <span class="hljs-keyword">new</span> LinkedMultiValueMap();    header.put(HttpHeaders.CONTENT_TYPE, Arrays.asList(MediaType.MULTIPART_FORM_DATA_VALUE));    HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; requestEntity = <span class="hljs-keyword">new</span> HttpEntity&lt;&gt;(body, header);    ResponseEntity&lt;String&gt; responseEntity = restTemplate.postForEntity(url, requestEntity, String.class);    System.out.println(<span class="hljs-string">&quot;upload: &quot;</span> + responseEntity);    Assert.isTrue(responseEntity.getStatusCode().equals(HttpStatus.OK), <span class="hljs-string">&quot;upload 请求不成功&quot;</span>);&#125;</code></pre></div><p>如果需要上传文件类型数据，就只能使用 POST 请求，并且内容类型为 <code>multipart/form-data</code>,需要手动给 <code>Header</code> 指定这个 <code>Content-Type</code>。而需要上传的文件可以用 <code>FileSystemResource</code> 对象封装，表示了一个文件资源，同时服务端需要用 <code>MultipartRequest</code> 对象来获取文件数据。结合已运行的 Web 服务，运行上述测试方法即可得到下面日志输出:</p><div class="hljs code-wrapper"><pre><code class="hljs java">...upload: &lt;<span class="hljs-number">200</span>,upload success filename: b.txt,[Content-Type:<span class="hljs-string">&quot;text/plain;charset=UTF-8&quot;</span>, Content-Length:<span class="hljs-string">&quot;30&quot;</span>, Date:<span class="hljs-string">&quot;Fri, 10 May 2019 17:00:45 GMT&quot;</span>]&gt;...</code></pre></div><h2 id="进阶-RestTemplate"><a href="#进阶-RestTemplate" class="headerlink" title="进阶 RestTemplate"></a>进阶 RestTemplate</h2><p>到这里我们就学习了 <code>RestTemplate</code> API 请求数据的几种常见方式，现在来进一步地深入使用 <code>RestTemplate</code>。</p><h3 id="底层-HTTP-请求库切换"><a href="#底层-HTTP-请求库切换" class="headerlink" title="底层 HTTP 请求库切换"></a>底层 HTTP 请求库切换</h3><p>我们首先看下官方文档的描述：</p><blockquote><p>The default constructor uses java.net.HttpURLConnection to perform requests. You can switch to a different HTTP library with an implementation of ClientHttpRequestFactory. There is built-in support for the following:</p><ul><li>Apache HttpComponents</li><li>Netty</li><li>OkHttp</li></ul></blockquote><p>从上面可以看出 <code>RestTemplate</code> 默认使用 JDK 原生的 <code>java.net.HttpURLConnection</code> 执行请求。而除此之外，Spring 还封装了 Apache HttpComponents， Netty， OkHttp 三种请求库，第一个就是我们平常用的 <code>HttpClient</code> API 相关的库，而 <a href="https://netty.io/">Netty</a> 则是一个性能高的NIO 请求处理网络库，<a href="https://square.github.io/okhttp">OkHttp</a> 为功能丰富且高效的网络框架，多用于 Android 程序。</p><p>而我们上文采用默认的构造器方法创建的 <code>RestTemplate</code> 实例，即采用了 JDK 原生的网络 API。想要切换，只需要在构造方法中传入特定 <code>ClientHttpRequestFactory</code> 实现类即可,如下代码：</p><div class="hljs code-wrapper"><pre><code class="hljs haxe">RestTemplate template = <span class="hljs-keyword">new</span> <span class="hljs-type">RestTemplate</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">HttpComponentsClientHttpRequestFactory</span>());</code></pre></div><p>我们查看 <code>RestTemplate</code> 源码找不到默认采用JDK <code>HttpURLConnection</code> API 的代码，那就根据前文给出 <code>RestTemplate</code> 类层次图向上查找，可以在父类 <code>HttpAccessor</code> 上能找到如下代码：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpAccessor</span> </span>&#123;<span class="hljs-comment">// ...</span><span class="hljs-keyword">private</span> ClientHttpRequestFactory requestFactory = <span class="hljs-keyword">new</span> SimpleClientHttpRequestFactory();<span class="hljs-comment">// ...</span>&#125;</code></pre></div><p>而 Spring 对工厂类 <code>SimpleClientHttpRequestFactory</code> 描述为: <code>implementation that uses standard JDK facilities</code>， 也正说明了默认构造 <code>RestTemplate</code> 实例的行为都会直接使用 JDK 网络 API。</p><h3 id="请求超时设置"><a href="#请求超时设置" class="headerlink" title="请求超时设置"></a>请求超时设置</h3><p>通常我们会对 HTTP 请求类进行执行行为的定制，例如调用超时时间设置，连接时长的限制等，而采用默认的 <code>HttpURLConnection</code> 默认的配置时， 从 <code>SimpleClientHttpRequestFactory</code> 源码类可以看到是没有超时限制，也就意味着无限等待请求响应：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// RestTemplate 默认超时设置</span>...<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> connectTimeout = -<span class="hljs-number">1</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> readTimeout = -<span class="hljs-number">1</span>;...</code></pre></div><p>那么我们该如何调整超时时间,可以参考如下代码：</p><div class="hljs code-wrapper"><pre><code class="hljs java">RestTemplate customRestTemplate = <span class="hljs-keyword">new</span> RestTemplate(getClientHttpRequestFactory());<span class="hljs-function"><span class="hljs-keyword">private</span> SimpleClientHttpRequestFactory <span class="hljs-title">getClientHttpRequestFactory</span><span class="hljs-params">()</span> </span>&#123;    SimpleClientHttpRequestFactory clientHttpRequestFactory            = <span class="hljs-keyword">new</span> SimpleClientHttpRequestFactory();    <span class="hljs-comment">// 连接超时设置 10s</span>    clientHttpRequestFactory.setConnectTimeout(<span class="hljs-number">10_000</span>);    <span class="hljs-comment">// 读取超时设置 10s</span>    clientHttpRequestFactory.setReadTimeout(<span class="hljs-number">10_000</span>);    <span class="hljs-keyword">return</span> clientHttpRequestFactory;&#125;</code></pre></div><p>如果要调整 <code>HttpComponentsClient</code> 的超时设置，可以参考文章<a href="https://howtodoinjava.com/spring-boot2/resttemplate-timeout-example/">resttemplate-timeout-example</a> 。当然除了java设置超时时间之外，还有更多参数进行定制，这里就不一一列举，可以参考文章 <a href="https://howtodoinjava.com/spring-restful/resttemplate-httpclient-java-config/">resttemplate-httpclient-java-config</a> 进一步学习。</p><p>到这里我们对 <code>RestTemplate</code> 的学习告一段落，如果有兴趣可以进一步研究下相关源码，有机会尝试使起来吧。😁</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RestTemplate</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mybatis动态sql</title>
    <link href="/2020/11/04/mybatis-autosql/"/>
    <url>/2020/11/04/mybatis-autosql/</url>
    
    <content type="html"><![CDATA[<h3 id="MyBatis的动态SQL是基于OGNL表达式的，它可以帮助我们方便的在SQL语句中实现某些逻辑。"><a href="#MyBatis的动态SQL是基于OGNL表达式的，它可以帮助我们方便的在SQL语句中实现某些逻辑。" class="headerlink" title="MyBatis的动态SQL是基于OGNL表达式的，它可以帮助我们方便的在SQL语句中实现某些逻辑。"></a>MyBatis的动态SQL是基于OGNL表达式的，它可以帮助我们方便的在SQL语句中实现某些逻辑。</h3><p>MyBatis中用于实现动态SQL的元素主要有：</p><ul><li>if</li><li>where</li><li>set</li><li>choose（when，otherwise）</li><li>trim</li><li>foreach  </li></ul><h3 id="（1）if标签"><a href="#（1）if标签" class="headerlink" title="（1）if标签"></a>（1）if标签</h3><p>此时如果CNAINDCLABASINFID为null，此语句很可能报错或查询结果为空。此时我们使用if动态sql语句先进行判断，如果值为null或等于空字符串，我们就不进行此条件的判断，增加灵活性。</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span><span class="hljs-keyword">where</span><span class="hljs-operator">&gt;</span>   com.CNAINDCLABASINFID = #&#123;industryNum&#125;   <span class="hljs-operator">&lt;</span>if test<span class="hljs-operator">=</span>&quot;id!=null and id!=&#x27;&#x27;&quot;<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span><span class="hljs-operator">!</span><span class="hljs-comment">-- 项目编号 --&gt;</span>      and bas.id = #&#123;id&#125;   <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>if<span class="hljs-operator">&gt;</span>   <span class="hljs-operator">&lt;</span>if test<span class="hljs-operator">=</span>&quot;projectName!=null and projectName!=&#x27;&#x27;&quot;<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span><span class="hljs-operator">!</span><span class="hljs-comment">-- 项目名称 --&gt;</span>      and bas.PROJECT_NAME = #&#123;projectName&#125;   <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>if<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">where</span><span class="hljs-operator">&gt;</span></code></pre></div><h3 id="（2）if-where-条件判断"><a href="#（2）if-where-条件判断" class="headerlink" title="（2）if + where 条件判断"></a>（2）if + where 条件判断</h3><p>如上所示</p><h3 id="（3）if-set-更新语句"><a href="#（3）if-set-更新语句" class="headerlink" title="（3）if + set 更新语句"></a>（3）if + set 更新语句</h3><p>当update语句中没有使用if标签时，如果有一个参数为null，都会导致错误。<br>当在update语句中使用if标签时，如果前面的if没有执行，则或导致逗号多余错误。使用set标签可以将动态的配置SET 关键字，和剔除追加到条件末尾的任何不相关的逗号。<strong>如果set包含的内容为空的话则会出错。</strong></p><p>使用if+set标签修改后，如果某项为null则不进行更新，而是保持数据库原值。如下示例：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span>update id<span class="hljs-operator">=</span>&quot;editRateAnalysTask&quot; parameterType<span class="hljs-operator">=</span>&quot;RateAnalystScale&quot; <span class="hljs-operator">&gt;</span>UPDATE STUDENT_TBL<span class="hljs-operator">&lt;</span><span class="hljs-keyword">set</span><span class="hljs-operator">&gt;</span>   <span class="hljs-operator">&lt;</span>if test<span class="hljs-operator">=</span>&quot;studentName != null and studentName != &#x27;&#x27; &quot;<span class="hljs-operator">&gt;</span>      STUDENT_TBL.STUDENT_NAME = #&#123;studentName&#125;,   <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>if<span class="hljs-operator">&gt;</span>   <span class="hljs-operator">&lt;</span>if test<span class="hljs-operator">=</span>&quot;studentSex != null and studentSex != &#x27;&#x27; &quot;<span class="hljs-operator">&gt;</span>      STUDENT_TBL.STUDENT_SEX = #&#123;studentSex&#125;,   <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>if<span class="hljs-operator">&gt;</span>   <span class="hljs-operator">&lt;</span>if test<span class="hljs-operator">=</span>&quot;studentBirthday != null &quot;<span class="hljs-operator">&gt;</span>      STUDENT_TBL.STUDENT_BIRTHDAY = #&#123;studentBirthday&#125;,   <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>if<span class="hljs-operator">&gt;</span>   <span class="hljs-operator">&lt;</span>if test<span class="hljs-operator">=</span>&quot;studentPhoto != null &quot;<span class="hljs-operator">&gt;</span>      STUDENT_TBL.STUDENT_PHOTO = #&#123;studentPhoto, javaType=byte[], jdbcType=BLOB, typeHandler=org.apache.ibatis.type.BlobTypeHandler&#125;,   <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>if<span class="hljs-operator">&gt;</span>   <span class="hljs-operator">&lt;</span>if test<span class="hljs-operator">=</span>&quot;classId != &#x27;&#x27; &quot;<span class="hljs-operator">&gt;</span>      STUDENT_TBL.CLASS_ID = #&#123;classId&#125;   <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>if<span class="hljs-operator">&gt;</span>   <span class="hljs-operator">&lt;</span>if test<span class="hljs-operator">=</span>&quot;placeId != &#x27;&#x27; &quot;<span class="hljs-operator">&gt;</span>      STUDENT_TBL.PLACE_ID = #&#123;placeId&#125;   <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>if<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">set</span><span class="hljs-operator">&gt;</span>WHERE STUDENT_TBL.STUDENT_ID = #&#123;studentId&#125;;<span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>update<span class="hljs-operator">&gt;</span></code></pre></div><h3 id="（4）choose-when-otherwise"><a href="#（4）choose-when-otherwise" class="headerlink" title="（4）choose (when,otherwise)"></a>（4）choose (when,otherwise)</h3><p>​    有时候我们并不想应用所有的条件，而只是想从多个选项中选择一个。而使用if标签时，只要test中的表达式为true，就会执行if标签中的条件。MyBatis提供了choose 元素。if标签是与(and)的关系，而choose标签是或（or）的关系.</p><p>​    choose标签是按顺序判断其内部when标签中的test条件出否成立，如果有一个成立，则choose结束<strong>。</strong>当choose中所有when的条件都不满则时，则执行otherwise中的sql。类似于Java 的switch 语句，choose为switch，when为case，otherwise则为default。</p><p>例如下面例子，同样把所有可以限制的条件都写上，方面使用。choose会从上到下选择一个when标签的test为true的sql执行。安全考虑，我们使用where将choose包起来，放置关键字多于错误。</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span><span class="hljs-keyword">select</span> id<span class="hljs-operator">=</span>&quot;&quot;<span class="hljs-operator">&gt;</span>   <span class="hljs-keyword">SELECT</span> ST.STUDENT_ID,   ST.STUDENT_NAME,   ST.STUDENT_SEX,   ST.STUDENT_BIRTHDAY,   ST.STUDENT_PHOTO,   ST.CLASS_ID,   ST.PLACE_ID   <span class="hljs-keyword">FROM</span> STUDENT_TBL ST   <span class="hljs-operator">&lt;</span><span class="hljs-keyword">where</span><span class="hljs-operator">&gt;</span>      <span class="hljs-operator">&lt;</span>choose<span class="hljs-operator">&gt;</span>         <span class="hljs-operator">&lt;</span><span class="hljs-keyword">when</span> test<span class="hljs-operator">=</span>&quot;studentName !=null &quot;<span class="hljs-operator">&gt;</span>            ST.STUDENT_NAME LIKE CONCAT(CONCAT(&#x27;%&#x27;, #&#123;studentName, jdbcType=VARCHAR&#125;),&#x27;%&#x27;)         <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">when</span> <span class="hljs-operator">&gt;</span>         <span class="hljs-operator">&lt;</span><span class="hljs-keyword">when</span> test<span class="hljs-operator">=</span>&quot;studentSex != null and studentSex != &#x27;&#x27; &quot;<span class="hljs-operator">&gt;</span>            AND ST.STUDENT_SEX = #&#123;studentSex, jdbcType=INTEGER&#125;         <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">when</span> <span class="hljs-operator">&gt;</span>         <span class="hljs-operator">&lt;</span><span class="hljs-keyword">when</span> test<span class="hljs-operator">=</span>&quot;studentBirthday != null &quot;<span class="hljs-operator">&gt;</span>            AND ST.STUDENT_BIRTHDAY = #&#123;studentBirthday, jdbcType=DATE&#125;         <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">when</span> <span class="hljs-operator">&gt;</span>         <span class="hljs-operator">&lt;</span><span class="hljs-keyword">when</span> test<span class="hljs-operator">=</span>&quot;classId != null and classId!= &#x27;&#x27; &quot;<span class="hljs-operator">&gt;</span>            AND ST.CLASS_ID = #&#123;classId, jdbcType=VARCHAR&#125;         <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">when</span> <span class="hljs-operator">&gt;</span>         <span class="hljs-operator">&lt;</span><span class="hljs-keyword">when</span> test<span class="hljs-operator">=</span>&quot;classEntity != null and classEntity.classId !=null and classEntity.classId !=&#x27; &#x27; &quot;<span class="hljs-operator">&gt;</span>            AND ST.CLASS_ID = #&#123;classEntity.classId, jdbcType=VARCHAR&#125;         <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">when</span> <span class="hljs-operator">&gt;</span>         <span class="hljs-operator">&lt;</span><span class="hljs-keyword">when</span> test<span class="hljs-operator">=</span>&quot;placeId != null and placeId != &#x27;&#x27; &quot;<span class="hljs-operator">&gt;</span>            AND ST.PLACE_ID = #&#123;placeId, jdbcType=VARCHAR&#125;         <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">when</span> <span class="hljs-operator">&gt;</span>         <span class="hljs-operator">&lt;</span><span class="hljs-keyword">when</span> test<span class="hljs-operator">=</span>&quot;placeEntity != null and placeEntity.placeId != null and placeEntity.placeId != &#x27;&#x27; &quot;<span class="hljs-operator">&gt;</span>            AND ST.PLACE_ID = #&#123;placeEntity.placeId, jdbcType=VARCHAR&#125;         <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">when</span> <span class="hljs-operator">&gt;</span>         <span class="hljs-operator">&lt;</span><span class="hljs-keyword">when</span> test<span class="hljs-operator">=</span>&quot;studentId != null and studentId != &#x27;&#x27; &quot;<span class="hljs-operator">&gt;</span>            AND ST.STUDENT_ID = #&#123;studentId, jdbcType=VARCHAR&#125;         <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">when</span> <span class="hljs-operator">&gt;</span>         <span class="hljs-operator">&lt;</span>otherwise<span class="hljs-operator">&gt;</span>         <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>otherwise<span class="hljs-operator">&gt;</span>      <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>choose<span class="hljs-operator">&gt;</span>   <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">where</span><span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">select</span><span class="hljs-operator">&gt;</span></code></pre></div><h3 id="（5）trim标签"><a href="#（5）trim标签" class="headerlink" title="（5）trim标签"></a>（5）trim标签</h3><p>trim元素的主要功能是可以在自己包含的内容前加上某些前缀，也可以在其后加上某些后缀，与之对应的属性是<strong>prefix</strong>和<strong>suffix</strong>；可以把包含内容的首部某些内容覆盖，即忽略，也可以把尾部的某些内容覆盖，对应的属性是<strong>prefixOverrides</strong>和<strong>suffixOverrides</strong>。正因为trim有这样的功能，所以我们也可以非常简单的利用trim来代替where/set标签的功能，示例代码如下：</p><p><strong>trim代替where标签：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">　<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> 　　<span class="hljs-operator">&lt;</span>trim prefix<span class="hljs-operator">=</span>&quot;WHERE&quot; prefixoverride<span class="hljs-operator">=</span>&quot;AND |OR&quot;<span class="hljs-operator">&gt;</span>　　　　&lt;if test=&quot;name != null and name.length()&gt;0&quot;&gt; AND name=#&#123;name&#125;&lt;/if&gt;　　　　&lt;if test=&quot;gender != null and gender.length()&gt;0&quot;&gt; AND gender=#&#123;gender&#125;&lt;/if&gt;　　<span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>trim<span class="hljs-operator">&gt;</span></code></pre></div><p>假如说name和gender的值都不为null的话打印的SQL为：select * from user where   name = ‘xx’ and gender = ‘xx’</p><p>　　在红色标记的地方是不存在第一个and的，上面两个属性的意思如下：</p><p>　　prefix：前缀　　　　　　</p><p>　　prefixoverride：去掉第一个and或者是or</p><p><strong>trim代替set标签：</strong></p><p>update user</p><div class="hljs code-wrapper"><pre><code class="hljs sql">　　<span class="hljs-operator">&lt;</span>trim prefix<span class="hljs-operator">=</span>&quot;set&quot; suffixoverride<span class="hljs-operator">=</span>&quot;,&quot; suffix<span class="hljs-operator">=</span>&quot; where id = #&#123;id&#125; &quot;<span class="hljs-operator">&gt;</span>　　　　&lt;if test=&quot;name != null and name.length()&gt;0&quot;&gt; name=#&#123;name&#125; , &lt;/if&gt;　　　　&lt;if test=&quot;gender != null and gender.length()&gt;0&quot;&gt; gender=#&#123;gender&#125; ,  &lt;/if&gt;　　<span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>trim<span class="hljs-operator">&gt;</span></code></pre></div><p>假如说name和gender的值都不为null的话打印的SQL为：update user set name=’xx’ , gender=’xx’   where id=’x’</p><p>　　在红色标记的地方不存在逗号，而且自动加了一个set前缀和where后缀，上面三个属性的意义如下，其中prefix意义如上：</p><p>　　suffixoverride：去掉最后一个逗号（也可以是其他的标记，就像是上面前缀中的and一样）</p><p>　　suffix：后缀</p><h3 id="（6）foreach-标签"><a href="#（6）foreach-标签" class="headerlink" title="（6）foreach 标签"></a>（6）foreach 标签</h3><p>foreach的主要用在构建in条件中，它可以在SQL语句中进行迭代一个集合。<strong>foreach元素的属性主要有item，index，collection，open，separator，close。</strong></p><ul><li><strong>item</strong>表示集合中每一个元素进行迭代时的别名；</li><li><strong>index</strong>指定一个名字，用于表示在迭代过程中，每次迭代到的位置；</li><li><strong>open</strong>表示该语句以什么开始；</li><li><strong>separator</strong>表示在每次进行迭代之间以什么符号作为分隔符；</li><li><strong>close</strong>表示以什么结束；</li></ul><p>在使用foreach的时候最关键的也是最容易出错的就是 <strong>collection</strong> 属性，该属性是必须指定的，但是在不同情况下，该属性的值是不一样的，主要有一下3种情况： </p><ul><li>如果传入的是单参数且参数类型是一个List的时候，collection属性值为list</li><li>如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array</li><li>如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了，当然单参数也可以封装成map，实际上如果你在传入参数的时候，在MyBatis里面也是会把它封装成一个Map的，map的key就是参数名，所以这⁄⁄⁄个时候collection属性值就是传入的List或array对象在自己封装的map里面的key</li></ul><h4 id="1）单参数List的类型："><a href="#1）单参数List的类型：" class="headerlink" title="1）单参数List的类型："></a>1）单参数List的类型：</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span><span class="hljs-keyword">select</span> id<span class="hljs-operator">=</span>&quot;dynamicForeachTest&quot; resultType<span class="hljs-operator">=</span>&quot;Blog&quot;<span class="hljs-operator">&gt;</span>      <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_blog <span class="hljs-keyword">where</span> id <span class="hljs-keyword">in</span>      <span class="hljs-operator">&lt;</span>foreach collection<span class="hljs-operator">=</span>&quot;list&quot; index<span class="hljs-operator">=</span>&quot;index&quot; item<span class="hljs-operator">=</span>&quot;item&quot; <span class="hljs-keyword">open</span><span class="hljs-operator">=</span>&quot;(&quot; separator<span class="hljs-operator">=</span>&quot;,&quot; <span class="hljs-keyword">close</span><span class="hljs-operator">=</span>&quot;)&quot;<span class="hljs-operator">&gt;</span>          #&#123;item&#125;      <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>foreach<span class="hljs-operator">&gt;</span>  <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">select</span><span class="hljs-operator">&gt;</span></code></pre></div><p>上述collection的值为list，对应的Mapper是这样的：</p><div class="hljs code-wrapper"><pre><code class="hljs sql">public List<span class="hljs-operator">&lt;</span>Blog<span class="hljs-operator">&gt;</span> dynamicForeachTest(List<span class="hljs-operator">&lt;</span><span class="hljs-type">Integer</span><span class="hljs-operator">&gt;</span> ids);</code></pre></div><h4 id="2）单参数array数组的类型："><a href="#2）单参数array数组的类型：" class="headerlink" title="2）单参数array数组的类型："></a>2）单参数array数组的类型：</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span><span class="hljs-keyword">select</span> id<span class="hljs-operator">=</span>&quot;dynamicForeach2Test&quot; resultType<span class="hljs-operator">=</span>&quot;Blog&quot;<span class="hljs-operator">&gt;</span>      <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_blog <span class="hljs-keyword">where</span> id <span class="hljs-keyword">in</span>      <span class="hljs-operator">&lt;</span>foreach collection<span class="hljs-operator">=</span>&quot;array&quot; index<span class="hljs-operator">=</span>&quot;index&quot; item<span class="hljs-operator">=</span>&quot;item&quot; <span class="hljs-keyword">open</span><span class="hljs-operator">=</span>&quot;(&quot; separator<span class="hljs-operator">=</span>&quot;,&quot; <span class="hljs-keyword">close</span><span class="hljs-operator">=</span>&quot;)&quot;<span class="hljs-operator">&gt;</span>          #&#123;item&#125;      <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>foreach<span class="hljs-operator">&gt;</span>  <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">select</span><span class="hljs-operator">&gt;</span></code></pre></div><p>上述collection为array，对应的Mapper代码：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Blog&gt; <span class="hljs-title">dynamicForeach2Test</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] ids)</span></span>;</code></pre></div><h4 id="3）自己把参数封装成Map的类型"><a href="#3）自己把参数封装成Map的类型" class="headerlink" title="3）自己把参数封装成Map的类型"></a>3）自己把参数封装成Map的类型</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span><span class="hljs-keyword">select</span> id<span class="hljs-operator">=</span>&quot;dynamicForeach3Test&quot; resultType<span class="hljs-operator">=</span>&quot;Blog&quot;<span class="hljs-operator">&gt;</span>      select * from t_blog where title like &quot;%&quot;#&#123;title&#125;&quot;%&quot; and id in      <span class="hljs-operator">&lt;</span>foreach collection<span class="hljs-operator">=</span>&quot;ids&quot; index<span class="hljs-operator">=</span>&quot;index&quot; item<span class="hljs-operator">=</span>&quot;item&quot; <span class="hljs-keyword">open</span><span class="hljs-operator">=</span>&quot;(&quot; separator<span class="hljs-operator">=</span>&quot;,&quot; <span class="hljs-keyword">close</span><span class="hljs-operator">=</span>&quot;)&quot;<span class="hljs-operator">&gt;</span>          #&#123;item&#125;      <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>foreach<span class="hljs-operator">&gt;</span>  <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">select</span><span class="hljs-operator">&gt;</span></code></pre></div><p>上述collection的值为ids，是传入的参数Map的key，对应的Mapper代码：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Blog&gt; <span class="hljs-title">dynamicForeach3Test</span><span class="hljs-params">(Map&lt;String, Object&gt; params)</span></span>;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>middle-component</category>
      
      <category>mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mybatis原理</title>
    <link href="/2020/11/04/mybatis-princpal/"/>
    <url>/2020/11/04/mybatis-princpal/</url>
    
    <content type="html"><![CDATA[<h2 id="MyBatis工作流程简述"><a href="#MyBatis工作流程简述" class="headerlink" title="MyBatis工作流程简述"></a>MyBatis工作流程简述</h2><p><strong>传统工作模式：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;InputStream inputStream = Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);SqlSessionFactory factory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);SqlSession sqlSession = factory.openSession();String name = <span class="hljs-string">&quot;tom&quot;</span>;List&lt;User&gt; list = sqlSession.selectList(<span class="hljs-string">&quot;com.demo.mapper.UserMapper.getUserByName&quot;</span>,params);&#125;</code></pre></div><ol><li>创建SqlSessionFactoryBuilder对象，调用build(inputstream)方法读取并解析配置文件，返回SqlSessionFactory对象</li><li>由SqlSessionFactory创建SqlSession 对象，没有手动设置的话事务默认开启</li><li>调用SqlSession中的api，传入Statement Id和参数，内部进行复杂的处理，最后调用jdbc执行SQL语句，封装结果返回。</li></ol><hr><p><strong>使用Mapper接口：</strong><br>由于面向接口编程的趋势，MyBatis也实现了通过接口调用mapper配置文件中的SQL语句</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">//前三步都相同</span>InputStream inputStream = Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);SqlSessionFactory factory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);SqlSession sqlSession = factory.openSession();<span class="hljs-comment">//这里不再调用SqlSession 的api，而是获得了接口对象，调用接口中的方法。</span>UserMapper mapper = sqlSession.getMapper(UserMapper.class);List&lt;User&gt; list = mapper.getUserByName(<span class="hljs-string">&quot;tom&quot;</span>);&#125;</code></pre></div><h2 id="原生MyBatis原理分析"><a href="#原生MyBatis原理分析" class="headerlink" title="原生MyBatis原理分析"></a>原生MyBatis原理分析</h2><h2 id="初始化工作"><a href="#初始化工作" class="headerlink" title="初始化工作"></a>初始化工作</h2><h3 id="解析配置文件"><a href="#解析配置文件" class="headerlink" title="解析配置文件"></a>解析配置文件</h3><div class="hljs code-wrapper"><pre><code class="hljs java">InputStream inputStream = Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<span class="hljs-comment">//这一行代码正是初始化工作的开始。</span>SqlSessionFactory factory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</code></pre></div><p>进入源码分析：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 1.我们最初调用的build</span><span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title">build</span><span class="hljs-params">(InputStream inputStream)</span> </span>&#123;<span class="hljs-comment">//调用了重载方法</span>    <span class="hljs-keyword">return</span> build(inputStream, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);  &#125;<span class="hljs-comment">// 2.调用的重载方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title">build</span><span class="hljs-params">(InputStream inputStream, String environment, Properties properties)</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-comment">//  XMLConfigBuilder是专门解析mybatis的配置文件的类</span>      XMLConfigBuilder parser = <span class="hljs-keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);      <span class="hljs-comment">//这里又调用了一个重载方法。parser.parse()的返回值是Configuration对象</span>      <span class="hljs-keyword">return</span> build(parser.parse());    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;      <span class="hljs-keyword">throw</span> ExceptionFactory.wrapException(<span class="hljs-string">&quot;Error building SqlSession.&quot;</span>, e);    &#125; <span class="hljs-comment">//省略部分代码</span>  &#125;</code></pre></div><p>下面进入对配置文件解析部分：</p><p>首先对Configuration对象进行介绍：</p><blockquote><p>Configuration对象的结构和xml配置文件的对象几乎相同。</p><p>回顾一下xml中的配置标签有哪些：</p><blockquote><p>properties（属性），settings（设置），typeAliases（类型别名），typeHandlers（类型处理器），objectFactory（对象工厂），mappers（映射器）等</p></blockquote><p>Configuration也有对应的对象属性来封装它们：<br><img src="https://i.loli.net/2021/04/19/ZnUdxmWcGEzgoq9.png" alt="在这里插入图片描述"><br>也就是说，<code>初始化配置文件信息的本质就是创建Configuration对象，将解析的xml数据封装到Configuration内部的属性中。</code></p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//在创建XMLConfigBuilder时，它的构造方法中解析器XPathParser已经读取了配置文件</span><span class="hljs-comment">//3. 进入XMLConfigBuilder 中的 parse()方法。</span><span class="hljs-function"><span class="hljs-keyword">public</span> Configuration <span class="hljs-title">parse</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (parsed) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BuilderException(<span class="hljs-string">&quot;Each XMLConfigBuilder can only be used once.&quot;</span>);    &#125;    parsed = <span class="hljs-keyword">true</span>;    <span class="hljs-comment">//parser是XPathParser解析器对象，读取节点内数据，&lt;configuration&gt;是MyBatis配置文件中的顶层标签</span>    parseConfiguration(parser.evalNode(<span class="hljs-string">&quot;/configuration&quot;</span>));    <span class="hljs-comment">//最后返回的是Configuration 对象</span>    <span class="hljs-keyword">return</span> configuration;&#125;<span class="hljs-comment">//4. 进入parseConfiguration方法</span><span class="hljs-comment">//此方法中读取了各个标签内容并封装到Configuration中的属性中。</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseConfiguration</span><span class="hljs-params">(XNode root)</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-comment">//issue #117 read properties first</span>      propertiesElement(root.evalNode(<span class="hljs-string">&quot;properties&quot;</span>));      Properties settings = settingsAsProperties(root.evalNode(<span class="hljs-string">&quot;settings&quot;</span>));      loadCustomVfs(settings);      loadCustomLogImpl(settings);      typeAliasesElement(root.evalNode(<span class="hljs-string">&quot;typeAliases&quot;</span>));      pluginElement(root.evalNode(<span class="hljs-string">&quot;plugins&quot;</span>));      objectFactoryElement(root.evalNode(<span class="hljs-string">&quot;objectFactory&quot;</span>));      objectWrapperFactoryElement(root.evalNode(<span class="hljs-string">&quot;objectWrapperFactory&quot;</span>));      reflectorFactoryElement(root.evalNode(<span class="hljs-string">&quot;reflectorFactory&quot;</span>));      settingsElement(settings);      <span class="hljs-comment">// read it after objectFactory and objectWrapperFactory issue #631</span>      environmentsElement(root.evalNode(<span class="hljs-string">&quot;environments&quot;</span>));      databaseIdProviderElement(root.evalNode(<span class="hljs-string">&quot;databaseIdProvider&quot;</span>));      typeHandlerElement(root.evalNode(<span class="hljs-string">&quot;typeHandlers&quot;</span>));      mapperElement(root.evalNode(<span class="hljs-string">&quot;mappers&quot;</span>));    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BuilderException(<span class="hljs-string">&quot;Error parsing SQL Mapper Configuration. Cause: &quot;</span> + e, e);    &#125;&#125;</code></pre></div><p>到此对xml配置文件的解析就结束了（下文会对部分解析做详细介绍），回到步骤 2. 中调用的重载build方法。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 5. 调用的重载方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title">build</span><span class="hljs-params">(Configuration config)</span> </span>&#123;<span class="hljs-comment">//创建了DefaultSqlSessionFactory对象，传入Configuration对象。</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultSqlSessionFactory(config);  &#125;</code></pre></div><h3 id="配置类方式"><a href="#配置类方式" class="headerlink" title="配置类方式"></a>配置类方式</h3><p>发散一下思路，既然解析xml是对Configuration中的属性进行复制，那么我们同样可以在一个类中创建Configuration对象，手动设置其中属性的值来达到配置的效果。</p><h2 id="执行SQL"><a href="#执行SQL" class="headerlink" title="执行SQL"></a>执行SQL</h2><p>先简单介绍<strong>SqlSession</strong>：</p><blockquote><p>SqlSession是一个接口，它有两个实现类：DefaultSqlSession（默认）和SqlSessionManager（弃用，不做介绍）<br>SqlSession是MyBatis中用于和数据库交互的<code>顶层类</code>，通常将它与ThreadLocal绑定，一个会话使用一个SqlSession，并且在使用完毕后需要close。<br><img src="https://i.loli.net/2021/04/19/sgclvkANYuZ8Tzf.png" alt="在这里插入图片描述"><br>SqlSession中的两个最重要的参数，configuration与初始化时的相同，Executor为执行器，</p></blockquote><p><strong>Executor：</strong></p><blockquote><p>Executor也是一个接口，他有三个常用的实现类BatchExecutor（重用语句并执行批量更新），ReuseExecutor（重用预处理语句prepared statements），SimpleExecutor（普通的执行器，默认）。</p></blockquote><h3 id="SqlSession-API方式"><a href="#SqlSession-API方式" class="headerlink" title="SqlSession API方式"></a>SqlSession API方式</h3><p>继续分析，初始化完毕后，我们就要执行SQL了：</p><div class="hljs code-wrapper"><pre><code class="hljs java">SqlSession sqlSession = factory.openSession();String name = <span class="hljs-string">&quot;tom&quot;</span>;List&lt;User&gt; list = sqlSession.selectList(<span class="hljs-string">&quot;com.demo.mapper.UserMapper.getUserByName&quot;</span>,params);</code></pre></div><p>获得sqlSession</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//6. 进入openSession方法。</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> SqlSession <span class="hljs-title">openSession</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">//getDefaultExecutorType()传递的是SimpleExecutor</span>    <span class="hljs-keyword">return</span> openSessionFromDataSource(configuration.getDefaultExecutorType(), <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);  &#125;<span class="hljs-comment">//7. 进入openSessionFromDataSource。</span><span class="hljs-comment">//ExecutorType 为Executor的类型，TransactionIsolationLevel为事务隔离级别，autoCommit是否开启事务</span><span class="hljs-comment">//openSession的多个重载方法可以指定获得的SeqSession的Executor类型和事务的处理</span><span class="hljs-function"><span class="hljs-keyword">private</span> SqlSession <span class="hljs-title">openSessionFromDataSource</span><span class="hljs-params">(ExecutorType execType, TransactionIsolationLevel level, <span class="hljs-keyword">boolean</span> autoCommit)</span> </span>&#123;    Transaction tx = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">final</span> Environment environment = configuration.getEnvironment();      <span class="hljs-keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);      <span class="hljs-comment">//根据参数创建指定类型的Executor</span>      <span class="hljs-keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);      <span class="hljs-comment">//返回的是DefaultSqlSession</span>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;      closeTransaction(tx); <span class="hljs-comment">// may have fetched a connection so lets call close()</span>      <span class="hljs-keyword">throw</span> ExceptionFactory.wrapException(<span class="hljs-string">&quot;Error opening session.  Cause: &quot;</span> + e, e);    &#125; <span class="hljs-keyword">finally</span> &#123;      ErrorContext.instance().reset();    &#125;  &#125;</code></pre></div><p>执行sqlsession中的api</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//8.进入selectList方法，多个重载方法。</span><span class="hljs-keyword">public</span> &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">selectList</span><span class="hljs-params">(String statement)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.selectList(statement, <span class="hljs-keyword">null</span>);&#125;<span class="hljs-keyword">public</span> &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">selectList</span><span class="hljs-params">(String statement, Object parameter)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.selectList(statement, parameter, RowBounds.DEFAULT);&#125;<span class="hljs-keyword">public</span> &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">selectList</span><span class="hljs-params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-comment">//根据传入的全限定名+方法名从映射的Map中取出MappedStatement对象</span>      MappedStatement ms = configuration.getMappedStatement(statement);      <span class="hljs-comment">//调用Executor中的方法处理</span>      <span class="hljs-keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;      <span class="hljs-keyword">throw</span> ExceptionFactory.wrapException(<span class="hljs-string">&quot;Error querying database.  Cause: &quot;</span> + e, e);    &#125; <span class="hljs-keyword">finally</span> &#123;      ErrorContext.instance().reset();    &#125; &#125;</code></pre></div><hr><p>介绍一下<strong>MappedStatement</strong> ：</p><ul><li><strong>作用：</strong> MappedStatement与Mapper配置文件中的一个select/update/insert/delete节点相对应。mapper中配置的标签都被封装到了此对象中，主要用途是描述一条SQL语句。</li><li><strong>初始化过程：</strong>回顾刚开始介绍的加载配置文件的过程中，会对mybatis-config.xml中的各个标签都进行解析，其中有 mappers标签用来引入<code>mapper.xml文件</code>或者配置<code>mapper接口</code>的目录。</li></ul><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span> &gt;</span>   select * from user where id=#&#123;id&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><p>这样的一个select标签会在<code>初始化配置文件时</code>被解析封装成一个<code>MappedStatement</code>对象，然后存储在Configuration对象的mappedStatements属性中，mappedStatements 是一个HashMap，存储时<code>key = 全限定类名 + 方法名，value = 对应的MappedStatement对象</code>。</p><ul><li>在configuration中对应的属性为</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java">Map&lt;String, MappedStatement&gt; mappedStatements = <span class="hljs-keyword">new</span> StrictMap&lt;MappedStatement&gt;(<span class="hljs-string">&quot;Mapped Statements collection&quot;</span>)</code></pre></div><ul><li>在XMLConfigBuilder中的处理：</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseConfiguration</span><span class="hljs-params">(XNode root)</span> </span>&#123;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// 省略其他标签的处理</span>    mapperElement(root.evalNode(<span class="hljs-string">&quot;mappers&quot;</span>));  &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BuilderException(<span class="hljs-string">&quot;Error parsing SQL Mapper Configuration. Cause: &quot;</span> + e, e);  &#125;&#125;</code></pre></div><hr><p>继续源码中的步骤，进入 executor.query()</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//此方法在SimpleExecutor的父类BaseExecutor中实现</span><span class="hljs-keyword">public</span> &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">query</span><span class="hljs-params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<span class="hljs-comment">//根据传入的参数动态获得SQL语句，最后返回用BoundSql对象表示</span>    BoundSql boundSql = ms.getBoundSql(parameter);    <span class="hljs-comment">//为本次查询创建缓存的Key</span>    CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);    <span class="hljs-keyword">return</span> query(ms, parameter, rowBounds, resultHandler, key, boundSql); &#125; <span class="hljs-comment">//进入query的重载方法中</span><span class="hljs-keyword">public</span> &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">query</span><span class="hljs-params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;    ErrorContext.instance().resource(ms.getResource()).activity(<span class="hljs-string">&quot;executing a query&quot;</span>).object(ms.getId());    <span class="hljs-keyword">if</span> (closed) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ExecutorException(<span class="hljs-string">&quot;Executor was closed.&quot;</span>);    &#125;    <span class="hljs-keyword">if</span> (queryStack == <span class="hljs-number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;      clearLocalCache();    &#125;    List&lt;E&gt; list;    <span class="hljs-keyword">try</span> &#123;      queryStack++;      list = resultHandler == <span class="hljs-keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="hljs-keyword">null</span>;      <span class="hljs-keyword">if</span> (list != <span class="hljs-keyword">null</span>) &#123;        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);      &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// 如果缓存中没有本次查找的值，那么从数据库中查询</span>        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);      &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;      queryStack--;    &#125;    <span class="hljs-keyword">if</span> (queryStack == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;        deferredLoad.load();      &#125;      <span class="hljs-comment">// issue #601</span>      deferredLoads.clear();      <span class="hljs-keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;        <span class="hljs-comment">// issue #482</span>        clearLocalCache();      &#125;    &#125;    <span class="hljs-keyword">return</span> list;  &#125;<span class="hljs-comment">//从数据库查询</span><span class="hljs-keyword">private</span> &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">queryFromDatabase</span><span class="hljs-params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;    List&lt;E&gt; list;    localCache.putObject(key, EXECUTION_PLACEHOLDER);    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-comment">// 查询的方法</span>      list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);    &#125; <span class="hljs-keyword">finally</span> &#123;      localCache.removeObject(key);    &#125;    <span class="hljs-comment">// 将查询结果放入缓存</span>    localCache.putObject(key, list);    <span class="hljs-keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;      localOutputParameterCache.putObject(key, parameter);    &#125;    <span class="hljs-keyword">return</span> list;  &#125;<span class="hljs-comment">// SimpleExecutor中实现父类的doQuery抽象方法</span><span class="hljs-keyword">public</span> &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">doQuery</span><span class="hljs-params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;    Statement stmt = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span> &#123;      Configuration configuration = ms.getConfiguration();      <span class="hljs-comment">// 传入参数创建StatementHanlder对象来执行查询</span>      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);      <span class="hljs-comment">// 创建jdbc中的statement对象</span>      stmt = prepareStatement(handler, ms.getStatementLog());      <span class="hljs-comment">// StatementHandler进行处理</span>      <span class="hljs-keyword">return</span> handler.query(stmt, resultHandler);    &#125; <span class="hljs-keyword">finally</span> &#123;      closeStatement(stmt);    &#125;  &#125;<span class="hljs-comment">// 创建Statement的方法</span><span class="hljs-function"><span class="hljs-keyword">private</span> Statement <span class="hljs-title">prepareStatement</span><span class="hljs-params">(StatementHandler handler, Log statementLog)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;    Statement stmt;    <span class="hljs-comment">//条代码中的getConnection方法经过重重调用最后会调用openConnection方法，从连接池中获得连接。</span>    Connection connection = getConnection(statementLog);    stmt = handler.prepare(connection, transaction.getTimeout());    handler.parameterize(stmt);    <span class="hljs-keyword">return</span> stmt;  &#125;<span class="hljs-comment">//从连接池获得连接的方法</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">openConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;    <span class="hljs-keyword">if</span> (log.isDebugEnabled()) &#123;      log.debug(<span class="hljs-string">&quot;Opening JDBC Connection&quot;</span>);    &#125;    <span class="hljs-comment">//从连接池获得连接</span>    connection = dataSource.getConnection();    <span class="hljs-keyword">if</span> (level != <span class="hljs-keyword">null</span>) &#123;      connection.setTransactionIsolation(level.getLevel());    &#125;    setDesiredAutoCommit(autoCommit);  &#125;<span class="hljs-comment">//进入StatementHandler进行处理的query，StatementHandler中默认的是PreparedStatementHandler</span><span class="hljs-keyword">public</span> &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">query</span><span class="hljs-params">(Statement statement, ResultHandler resultHandler)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;    PreparedStatement ps = (PreparedStatement) statement;    <span class="hljs-comment">//原生jdbc的执行</span>    ps.execute();    <span class="hljs-comment">//处理结果返回。</span>    <span class="hljs-keyword">return</span> resultSetHandler.handleResultSets(ps);  &#125;</code></pre></div><h3 id="接口方式"><a href="#接口方式" class="headerlink" title="接口方式"></a>接口方式</h3><p>回顾一下写法：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">//前三步都相同</span>InputStream inputStream = Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);SqlSessionFactory factory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);SqlSession sqlSession = factory.openSession();<span class="hljs-comment">//这里不再调用SqlSession 的api，而是获得了接口对象，调用接口中的方法。</span>UserMapper mapper = sqlSession.getMapper(UserMapper.class);List&lt;User&gt; list = mapper.getUserByName(<span class="hljs-string">&quot;tom&quot;</span>);&#125;</code></pre></div><p>思考一个问题，通常的Mapper接口我们都没有实现的方法却可以使用，是为什么呢？答案很简单 <code>动态代理</code></p><hr><p>开始之前介绍一下MyBatis初始化时对接口的处理：MapperRegistry是Configuration中的一个属性，它内部维护一个HashMap用于存放mapper接口的<code>工厂类</code>，每个接口对应一个工厂类。mappers中可以配置接口的包路径，或者某个具体的接口类。</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.demo.mapper.UserMapper&quot;</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.demo.mapper&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span></code></pre></div><ul><li>当解析mappers标签时，它会判断解析到的是mapper配置文件时，会再将对应配置文件中的增删改查标签一 一封装成MappedStatement对象，存入mappedStatements中。（上文介绍了）</li><li>当判断解析到接口时，会创建此接口对应的MapperProxyFactory对象，存入HashMap中，key = 接口的字节码对象，value = 此接口对应的MapperProxyFactory对象。</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//MapperRegistry类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapperRegistry</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Configuration config;  <span class="hljs-comment">//这个类中维护一个HashMap存放MapperProxyFactory</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();  <span class="hljs-comment">//解析到接口时添加接口工厂类的方法</span>  <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addMapper</span><span class="hljs-params">(Class&lt;T&gt; type)</span> </span>&#123;    <span class="hljs-keyword">if</span> (type.isInterface()) &#123;      <span class="hljs-keyword">if</span> (hasMapper(type)) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BindingException(<span class="hljs-string">&quot;Type &quot;</span> + type + <span class="hljs-string">&quot; is already known to the MapperRegistry.&quot;</span>);      &#125;      <span class="hljs-keyword">boolean</span> loadCompleted = <span class="hljs-keyword">false</span>;      <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">//重点在这行，以接口类的class对象为key，value为其对应的工厂对象，构造方法中指定了接口对象</span>        knownMappers.put(type, <span class="hljs-keyword">new</span> MapperProxyFactory&lt;&gt;(type));        <span class="hljs-comment">// It&#x27;s important that the type is added before the parser is run</span>        <span class="hljs-comment">// otherwise the binding may automatically be attempted by the</span>        <span class="hljs-comment">// mapper parser. If the type is already known, it won&#x27;t try.</span>        MapperAnnotationBuilder parser = <span class="hljs-keyword">new</span> MapperAnnotationBuilder(config, type);        parser.parse();        loadCompleted = <span class="hljs-keyword">true</span>;      &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">if</span> (!loadCompleted) &#123;          knownMappers.remove(type);        &#125;      &#125;    &#125;  &#125;&#125;</code></pre></div><hr><p>正文：<br>进入sqlSession.getMapper(UserMapper.class)中</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//DefaultSqlSession中的getMapper</span><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getMapper</span><span class="hljs-params">(Class&lt;T&gt; type)</span> </span>&#123;    <span class="hljs-keyword">return</span> configuration.&lt;T&gt;getMapper(type, <span class="hljs-keyword">this</span>);&#125;<span class="hljs-comment">//configuration中的给getMapper</span><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getMapper</span><span class="hljs-params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;    <span class="hljs-keyword">return</span> mapperRegistry.getMapper(type, sqlSession);&#125;<span class="hljs-comment">//MapperRegistry中的getMapper</span><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getMapper</span><span class="hljs-params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;<span class="hljs-comment">//从MapperRegistry中的HashMap中拿MapperProxyFactory</span>    <span class="hljs-keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);    <span class="hljs-keyword">if</span> (mapperProxyFactory == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BindingException(<span class="hljs-string">&quot;Type &quot;</span> + type + <span class="hljs-string">&quot; is not known to the MapperRegistry.&quot;</span>);    &#125;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-comment">// 通过动态代理工厂生成示例。</span>      <span class="hljs-keyword">return</span> mapperProxyFactory.newInstance(sqlSession);    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BindingException(<span class="hljs-string">&quot;Error getting mapper instance. Cause: &quot;</span> + e, e);    &#125;&#125;<span class="hljs-comment">//MapperProxyFactory类中的newInstance方法</span> <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">newInstance</span><span class="hljs-params">(SqlSession sqlSession)</span> </span>&#123; <span class="hljs-comment">// 创建了JDK动态代理的Handler类</span>    <span class="hljs-keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="hljs-keyword">new</span> MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);    <span class="hljs-comment">// 调用了重载方法</span>    <span class="hljs-keyword">return</span> newInstance(mapperProxy);  &#125;<span class="hljs-comment">//MapperProxy类，实现了InvocationHandler接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapperProxy</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span>, <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-comment">//省略部分源码</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SqlSession sqlSession;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;T&gt; mapperInterface;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache;    <span class="hljs-comment">// 构造，传入了SqlSession，说明每个session中的代理对象的不同的！</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MapperProxy</span><span class="hljs-params">(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache)</span> </span>&#123;    <span class="hljs-keyword">this</span>.sqlSession = sqlSession;    <span class="hljs-keyword">this</span>.mapperInterface = mapperInterface;    <span class="hljs-keyword">this</span>.methodCache = methodCache;  &#125;    <span class="hljs-comment">//省略部分源码</span>&#125;<span class="hljs-comment">//重载的方法，由动态代理创建新示例返回。</span><span class="hljs-function"><span class="hljs-keyword">protected</span> T <span class="hljs-title">newInstance</span><span class="hljs-params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;    <span class="hljs-keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="hljs-keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy); &#125;</code></pre></div><p>在动态代理返回了示例后，我们就可以直接调用mapper类中的方法了，说明在MapperProxy中的invoke方法中已经为我们实现了方法。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-comment">//判断调用是是不是Object中定义的方法，toString，hashCode这类非。是的话直接放行。</span>      <span class="hljs-keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;        <span class="hljs-keyword">return</span> method.invoke(<span class="hljs-keyword">this</span>, args);      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isDefaultMethod(method)) &#123;        <span class="hljs-keyword">return</span> invokeDefaultMethod(proxy, method, args);      &#125;    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;      <span class="hljs-keyword">throw</span> ExceptionUtil.unwrapThrowable(t);    &#125;     <span class="hljs-keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);    <span class="hljs-comment">// 重点在这：MapperMethod最终调用了执行的方法</span>    <span class="hljs-keyword">return</span> mapperMethod.execute(sqlSession, args);  &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">execute</span><span class="hljs-params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;    Object result;    <span class="hljs-comment">//判断mapper中的方法类型，最终调用的还是SqlSession中的方法</span>    <span class="hljs-keyword">switch</span> (command.getType()) &#123;      <span class="hljs-keyword">case</span> INSERT: &#123;    Object param = method.convertArgsToSqlCommandParam(args);        result = rowCountResult(sqlSession.insert(command.getName(), param));        <span class="hljs-keyword">break</span>;      &#125;      <span class="hljs-keyword">case</span> UPDATE: &#123;        Object param = method.convertArgsToSqlCommandParam(args);        result = rowCountResult(sqlSession.update(command.getName(), param));        <span class="hljs-keyword">break</span>;      &#125;      <span class="hljs-keyword">case</span> DELETE: &#123;        Object param = method.convertArgsToSqlCommandParam(args);        result = rowCountResult(sqlSession.delete(command.getName(), param));        <span class="hljs-keyword">break</span>;      &#125;      <span class="hljs-keyword">case</span> SELECT:        <span class="hljs-keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;          executeWithResultHandler(sqlSession, args);          result = <span class="hljs-keyword">null</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.returnsMany()) &#123;          result = executeForMany(sqlSession, args);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.returnsMap()) &#123;          result = executeForMap(sqlSession, args);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.returnsCursor()) &#123;          result = executeForCursor(sqlSession, args);        &#125; <span class="hljs-keyword">else</span> &#123;          Object param = method.convertArgsToSqlCommandParam(args);          result = sqlSession.selectOne(command.getName(), param);          <span class="hljs-keyword">if</span> (method.returnsOptional() &amp;&amp;              (result == <span class="hljs-keyword">null</span> || !method.getReturnType().equals(result.getClass()))) &#123;            result = Optional.ofNullable(result);          &#125;        &#125;        <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> FLUSH:        result = sqlSession.flushStatements();        <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">default</span>:        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BindingException(<span class="hljs-string">&quot;Unknown execution method for: &quot;</span> + command.getName());    &#125;    <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BindingException(<span class="hljs-string">&quot;Mapper method &#x27;&quot;</span> + command.getName()          + <span class="hljs-string">&quot; attempted to return null from a method with a primitive return type (&quot;</span> + method.getReturnType() + <span class="hljs-string">&quot;).&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> result;  &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>middle-component</category>
      
      <category>mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git-start</title>
    <link href="/2020/10/12/basic-git-start/"/>
    <url>/2020/10/12/basic-git-start/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-使用"><a href="#Git-使用" class="headerlink" title="Git 使用"></a>Git 使用</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Git 是目前世界上被最广泛使用的现代软件版本管理系统（Version Control System）。Git 本身亦是一个成熟并处于活跃开发状态的开源项目，今天惊人数量的软件项目依赖 Git 进行版本管理，这些项目包括开源以及各种商业软件。Git 在职业软件开发者中拥有良好的声誉，Git 目前支持绝大多数的操作系统以及 IDE（Integrated Development Environments）。</p><p>Git 最初是由 Linux 操作系统内核的创造者 Linus Torvalds 在 2005 年创造，Git 第一个可用版本是 Linus 花了两周时间用C写出来的。Git 第一个版本就实现了 Git 源码自托管，一个月之内，Linux系统的源码也已经由 Git 管理了！</p><p>Git 的第一个提交源码仅有约1000行，但是已经实现了Git的基本设计原理，比如初始化仓库、提交代码、查看代码diff、读取提交信息等，Git 定义了三个区：工作区（workspace）、暂存区（index）、版本库（commit history），也实现了三类重要的 Git 对象：blob、tree、commit。本文将从源码上分析 Git 的第一个提交并挖掘背后优秀的设计原理。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><h4 id="获取源码"><a href="#获取源码" class="headerlink" title="获取源码"></a>获取源码</h4><p>在Github上可以找到Git的仓库镜像：<br>        <a href="https://github.com/git/git.git">https://github.com/git/git.git</a></p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 获取 git 源码</span>$ git <span class="hljs-built_in">clone</span> https://github.com/git/git.git<span class="hljs-comment"># 查看第一个提交</span>$ git <span class="hljs-built_in">log</span> --date-order --reversecommit e83c5163316f89bfbde7d9ab23ca2e25604af290Author: Linus Torvalds &lt;torvalds@ppc970.osdl.org&gt;Date:   Thu Apr 7 15:13:13 2005 -0700    Initial revision of <span class="hljs-string">&quot;git&quot;</span>, the information manager from hell<span class="hljs-comment"># 变更为第一个提交，指定commit-id</span>$ git reset --hard e83c5163316f89bfbde7d9ab23ca2e25604af290</code></pre></div><h4 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h4><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> tree <span class="hljs-literal">-h</span>.├── [<span class="hljs-number">2.4</span><span class="hljs-type">K</span>]  cache.h├── [ <span class="hljs-number">503</span>]  <span class="hljs-built_in">cat</span><span class="hljs-operator">-file</span>.c                  <span class="hljs-comment"># 查看objects文件</span>├── [<span class="hljs-number">4.0</span><span class="hljs-type">K</span>]  commit<span class="hljs-literal">-tree</span>.c               <span class="hljs-comment"># 提交tree</span>├── [<span class="hljs-number">1.2</span><span class="hljs-type">K</span>]  init<span class="hljs-literal">-db</span>.c                   <span class="hljs-comment"># 初始化仓库</span>├── [ <span class="hljs-number">970</span>]  Makefile├── [<span class="hljs-number">5.5</span><span class="hljs-type">K</span>]  <span class="hljs-built_in">read-cache</span>.c                <span class="hljs-comment"># 读取当前索引文件内容</span>├── [<span class="hljs-number">8.2</span><span class="hljs-type">K</span>]  README├── [ <span class="hljs-number">986</span>]  <span class="hljs-built_in">read-tree</span>.c                 <span class="hljs-comment"># 读取tree</span>├── [<span class="hljs-number">2.0</span><span class="hljs-type">K</span>]  <span class="hljs-built_in">show-diff</span>.c                 <span class="hljs-comment"># 查看diff内容</span>├── [<span class="hljs-number">5.3</span><span class="hljs-type">K</span>]  <span class="hljs-built_in">update-cache</span>.c              <span class="hljs-comment"># 添加文件或目录</span>└── [<span class="hljs-number">1.4</span><span class="hljs-type">K</span>]  <span class="hljs-built_in">write-tree</span>.c                <span class="hljs-comment"># 写入到tree</span><span class="hljs-comment"># 统计代码行数，总共1089行</span><span class="hljs-variable">$</span> find . <span class="hljs-string">&quot;(&quot;</span> <span class="hljs-literal">-name</span> <span class="hljs-string">&quot;*.c&quot;</span> <span class="hljs-operator">-or</span> <span class="hljs-literal">-name</span> <span class="hljs-string">&quot;*.h&quot;</span> <span class="hljs-operator">-or</span> <span class="hljs-literal">-name</span> <span class="hljs-string">&quot;Makefile&quot;</span> <span class="hljs-string">&quot;)&quot;</span> <span class="hljs-literal">-print</span> | xargs wc <span class="hljs-literal">-l</span> ... <span class="hljs-number">1089</span> total</code></pre></div><h4 id="编译-1"><a href="#编译-1" class="headerlink" title="编译"></a>编译</h4><p>编译第一个提交的Git会有编译问题，需要更改Makefile添加相关的依赖库：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git diff ./Makefile... -LIBS= -lssl+LIBS= -lssl -lz -lcrypto...</code></pre></div><p>编译：</p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 编译</span>$ make</code></pre></div><p>只支持在 linux 平台上编译运行。</p><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>Write programs that do one thing and do it well.<br>——Unix philosophy</p><p>查看编译生成的可执行文件，总共有7个：</p><h4 id=""><a href="#" class="headerlink" title=""></a><img src="/blog/img/git-1.jpg"></h4><p>命令使用过程：</p><h4 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="/blog/img/git-2.jpg"></h4><h4 id="init-db：初始化仓库"><a href="#init-db：初始化仓库" class="headerlink" title="init-db：初始化仓库"></a>init-db：初始化仓库</h4><h5 id="命令说明"><a href="#命令说明" class="headerlink" title="命令说明"></a><strong>命令说明</strong></h5><div class="hljs code-wrapper"><pre><code class="hljs bash">$ init-db</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">创建目录：<span class="hljs-string">.dircache</span>。创建目录：<span class="hljs-string">.dircache/objects</span>。在 <span class="hljs-string">.dircache/objects</span> 中创建了从 00 ~ ff 共256个目录。<span class="hljs-string">.dircache/</span> 是Git的工作目录，最新版本的Git工作目录为 <span class="hljs-string">.git/</span> 。运行示例<span class="hljs-comment"># 运行init-db初始化仓库</span>$ init-dbdefaulting to private storage area <span class="hljs-comment"># 查看初始化后的目录结构</span>$ tree . -a.└── <span class="hljs-string">.dircache</span>                   <span class="hljs-comment"># git工作目录</span>    └── objects                 <span class="hljs-comment"># objects文件</span>        ├── 00        ├── 01        ├── 02        ├── <span class="hljs-string">......</span>              <span class="hljs-comment"># 省略</span>        ├── fe        └── ff258 directories, 0 files</code></pre></div><p>最新版本Git使用 git init . 初始化仓库，而且初始化工作目录为 .git/，初始化后，.git/ 目录中的文件和功能也非常丰富，包括 .git/HEAD、.git/refs/ 、.git/info/ 等，以及很多的 hooks 示例：.git/hooks/**.sample。</p><h4 id="update-cache：添加文件或目录"><a href="#update-cache：添加文件或目录" class="headerlink" title="update-cache：添加文件或目录"></a>update-cache：添加文件或目录</h4><p>update-cache 主要是把工作区的修改文件提交到暂存区。工作区、暂存区等说明见下文【设计原理】 。</p><h4 id="命令使用"><a href="#命令使用" class="headerlink" title="命令使用"></a>命令使用</h4><div class="hljs code-wrapper"><pre><code class="hljs bash">$ update-cache &lt;file&gt; ...</code></pre></div><h4 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h4><p>读取并解析索引文件 ：.dircache/index。<br>遍历多个文件，读取并生成变更文件信息（文件名称、文件内容sha1值、日期、大小等），写入到索引文件中。<br>遍历多个文件，读取并压缩变更文件，存储到objects文件中，该文件为blob对象。</p><p>如果是刚初始化的仓库，会自动创建索引文件。索引文件说明见下文【设计原理 - 索引文件】。blob对象的文件格式及说明见下文【设计原理 - blob对象】。sha1值说明见下文【设计原理 - 哈希算法】。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 新增README.md文件</span>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello git&quot;</span> &gt; README.md<span class="hljs-comment"># 提交</span>$ update-cache README.md<span class="hljs-comment"># 查看索引文件</span>$ hexdump -C .dircache/index00000000  43 52 49 44 01 00 00 00  01 00 00 00 af a4 <span class="hljs-built_in">fc</span> 8e  |CRID............|00000010  5e 34 9d dd 31 8b 4c 8e  15 ca 32 05 5a e9 a4 c8  |^4..1.L...2.Z...|00000020  af bd 4c 5f bf fb 41 37  af bd 4c 5f bf fb 41 37  |..L_..A7..L_..A7|00000030  00 03 01 00 91 16 d2 04  b4 81 00 00 ee 03 00 00  |................|00000040  ee 03 00 00 0a 00 00 00  bb 12 25 52 ab 7b 40 20  |..........%R.&#123;@ |00000050  b5 f6 12 cc 3b bd d5 b4  3d 1f d3 a8 09 00 52 45  |....;...=.....RE|00000060  41 44 4d 45 2e 6d 64 00                           |ADME.md.|00000068<span class="hljs-comment"># 查看objects内容，sha1值从索引文件中获取</span>$ cat-file bb122552ab7b4020b5f612cc3bbdd5b43d1fd3a8temp_git_file_61uTTP: blob$ cat ./temp_git_file_RwpU8bhello git</code></pre></div><h4 id="cat-file：查看objects文件内容"><a href="#cat-file：查看objects文件内容" class="headerlink" title="cat-file：查看objects文件内容"></a>cat-file：查看objects文件内容</h4><p>cat-file 根据sha1值查看暂存区中的objects文件内容。cat-file 是一个辅助工具，在正常的开发工作流中一般不会使用到。</p><h4 id="命令使用-1"><a href="#命令使用-1" class="headerlink" title="命令使用"></a>命令使用</h4><div class="hljs code-wrapper"><pre><code class="hljs bash">$ cat-file &lt;sha1&gt;</code></pre></div><h4 id="运行流程-1"><a href="#运行流程-1" class="headerlink" title="运行流程"></a>运行流程</h4><p>根据入参sha1值定位objects文件，比如 .dircache/objects/46/4b392e2c8c7d2d13d90e6916e6d41defe8bb6a<br>读取该objects文件内容，解压得到真实数据。<br>写入到临时文件 temp_git_file_XXXXXX（随机不重复文件）。</p><p>objects内容为压缩格式，基于zlib压缩算法，objects说明见【设计原理 - objects 文件】。</p><h4 id="运行示例"><a href="#运行示例" class="headerlink" title="运行示例"></a>运行示例</h4><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># cat-file 会把内容读取到temp_git_file_rLcGKX</span>$ cat-file 82f8604c3652fa5762899b5ff73eb37bef2da795temp_git_file_tBTXFM: blob<span class="hljs-comment"># 查看 temp_git_file_tBTXFM 文件内容</span>$ cat ./temp_git_file_tBTXFM hello git!</code></pre></div><h4 id="show-diff：查看diff内容"><a href="#show-diff：查看diff内容" class="headerlink" title="show-diff：查看diff内容"></a>show-diff：查看diff内容</h4><p>查看工作区和暂存区中的文件差异。</p><p><strong>命令使用</strong></p><div class="hljs code-wrapper"><pre><code class="hljs maxima">$ <span class="hljs-built_in">show</span>-<span class="hljs-built_in">diff</span></code></pre></div><p><strong>运行流程</strong></p><p>读取并解析索引文件：.dircache/index。<br>循环遍历变更文件信息，比较工作区中的文件信息和索引文件中记录的文件信息差异。<br>无差异，显示 : ok。<br>有差异，调用 diff 命令输出差异内容。</p><p><strong>运行示例</strong></p><div class="hljs code-wrapper"><pre><code class="hljs reasonml"># 创建文件并提交到暂存区$ echo <span class="hljs-string">&quot;hello git!&quot;</span> &gt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">README</span>.</span></span>md$ update-cache <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">README</span>.</span></span>md# 当前无差异$ show-diff<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">README</span>.</span></span>md: ok# 更改<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">README</span>.</span></span>md$ echo <span class="hljs-string">&quot;hello world!&quot;</span> &gt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">README</span>.</span></span>md# 查看diff$ show-diff<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">README</span>.</span></span>md:  <span class="hljs-number">82</span>f8604c3652fa5762899b5ff73eb37bef2da795--- -   <span class="hljs-number">2020</span>-<span class="hljs-number">08</span>-<span class="hljs-number">31</span> <span class="hljs-number">17</span>:<span class="hljs-number">33</span>:<span class="hljs-number">50.047881667</span> +<span class="hljs-number">0800</span>+++ <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">README</span>.</span></span>md   <span class="hljs-number">2020</span>-<span class="hljs-number">08</span>-<span class="hljs-number">31</span> <span class="hljs-number">17</span>:<span class="hljs-number">33</span>:<span class="hljs-number">47.827740680</span> +<span class="hljs-number">0800</span>@@ -<span class="hljs-number">1</span> +<span class="hljs-number">1</span> @@-hello git!+hello world!</code></pre></div><h4 id="write-tree：写入到tree"><a href="#write-tree：写入到tree" class="headerlink" title="write-tree：写入到tree"></a>write-tree：写入到tree</h4><p>write-tree 作用将保存在索引文件中的多个objects对象归并到一个类型为tree的objects文件中，该文件即Git中重要的对象：tree。</p><p><strong>命令使用</strong></p><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">write-tree</span></code></pre></div><p><strong>运行流程</strong></p><p>读取并解析索引文件：.dircache/index。<br>循环遍历变更文件信息，按照指定格式编排变更文件信息及内容。<br>压缩并存储到objects文件中，该object文件为tree对象。</p><p>tree对象的文件格式及相关说明见下文【设计原理 - tree对象】。</p><p><strong>运行示例</strong></p><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-comment"># 提交</span><span class="hljs-variable">$</span> <span class="hljs-built_in">write-tree</span>c771b3ab2fe3b7e43099290d3e99a3e8c414ec72<span class="hljs-comment"># 查看objects内容</span><span class="hljs-variable">$</span> <span class="hljs-built_in">cat</span><span class="hljs-operator">-file</span>  c771b3ab2fe3b7e43099290d3e99a3e8c414ec72temp_git_file_r90ft5: tree<span class="hljs-variable">$</span> <span class="hljs-built_in">cat</span> ./temp_git_file_r90ft5<span class="hljs-number">100664</span> README.md��`L6<span class="hljs-built_in">R</span>�Wb��_�&gt;�&#123;�-��</code></pre></div><h4 id="read-tree：读取tree"><a href="#read-tree：读取tree" class="headerlink" title="read-tree：读取tree"></a>read-tree：读取tree</h4><p>read-tree 读取并解析指定sha1值的tree对象，输出变更文件的信息。</p><p><strong>命令使用</strong></p><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">read-tree</span> &lt;sha1&gt;</code></pre></div><p><strong>运行步骤</strong></p><p>解析sha1值。<br>读取对应sha1值的object对象。<br>输出变更文件的属性、路径、sha1值。</p><p><strong>运行示例</strong></p><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-comment"># 提交</span><span class="hljs-variable">$</span> <span class="hljs-built_in">write-tree</span>c771b3ab2fe3b7e43099290d3e99a3e8c414ec72<span class="hljs-comment"># 读取tree对象</span><span class="hljs-variable">$</span> <span class="hljs-built_in">read-tree</span>  c771b3ab2fe3b7e43099290d3e99a3e8c414ec72<span class="hljs-number">100664</span> README.md (<span class="hljs-number">82</span>f8604c3652fa5762899b5ff73eb37bef2da795)</code></pre></div><h4 id="commit-tree：提交tree"><a href="#commit-tree：提交tree" class="headerlink" title="commit-tree：提交tree"></a>commit-tree：提交tree</h4><p>commit-tree 把本地变更提交到版本库里，具体是基于一个tree对象的sha1值创建一个commit对象。</p><p><strong>命令使用</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml">$ commit-tree <span class="hljs-tag">&lt;<span class="hljs-name">sha1</span>&gt;</span> [-p <span class="hljs-tag">&lt;<span class="hljs-name">sha1</span>&gt;</span>]* &lt; changelog</code></pre></div><p><strong>运行流程</strong></p><p>参数解析。<br>获取用户名称、用户邮件、提交日期。<br>写入tree信息。<br>写入parent信息。<br>写入author、commiter信息。<br>写入comments（注释）。<br>压缩并存储到objects文件中，该object文件为commit对象。</p><p>commit对象的文件格式及说明见下文【设计原理 - commit对象】。</p><p><strong>运行示例</strong></p><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-comment"># 写入到tree</span><span class="hljs-variable">$</span> <span class="hljs-built_in">write-tree</span> c771b3ab2fe3b7e43099290d3e99a3e8c414ec72<span class="hljs-comment"># 提交tree</span><span class="hljs-variable">$</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;first commit&quot;</span> &gt; changelog<span class="hljs-variable">$</span> commit<span class="hljs-literal">-tree</span> c771b3ab2fe3b7e43099290d3e99a3e8c414ec72 &lt; changelogCommitting initial tree c771b3ab2fe3b7e43099290d3e99a3e8c414ec72<span class="hljs-number">7</span>ea820bd363e24f5daa5de8028d77d88260503d9<span class="hljs-comment"># 查看commit对象内容</span><span class="hljs-variable">$</span> <span class="hljs-built_in">cat</span><span class="hljs-operator">-file</span> <span class="hljs-number">7</span>ea820bd363e24f5daa5de8028d77d88260503d9temp_git_file_CIfJsg: commit<span class="hljs-variable">$</span> <span class="hljs-built_in">cat</span> temp_git_file_CIfJsgtree c771b3ab2fe3b7e43099290d3e99a3e8c414ec72author Xiaowen Xia &lt;chenan.xxw@aos<span class="hljs-literal">-hw09</span>&gt; Tue Sep  <span class="hljs-number">1</span> <span class="hljs-number">10</span>:<span class="hljs-number">56</span>:<span class="hljs-number">16</span> <span class="hljs-number">2020</span>committer Xiaowen Xia &lt;chenan.xxw@aos<span class="hljs-literal">-hw09</span>&gt; Tue Sep  <span class="hljs-number">1</span> <span class="hljs-number">10</span>:<span class="hljs-number">56</span>:<span class="hljs-number">16</span> <span class="hljs-number">2020</span>first commit</code></pre></div><h4 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h4><blockquote><p>Write programs to work together.<br>——Unix philosophy</p></blockquote><p>与传统的集中式版本控制系统（CVCS）相反，Git 从一开始就设计成了去中心化的分布式系统，每个开发者本地工作区都是一个完整的版本库，拥有本地的代码仓库。另外，Git 的设计初衷是为了让更多的开发者一起开发软件。</p><p>该版本 Git 定义了三种对象：</p><p>blob 对象：保存着文件快照。<br>tree 对象：记录着目录结构和 blob 对象索引。<br>commit 对象：包含着指向前述 tree 对象的指针和所有提交信息。</p><p>三种对象相互之间的关系如下：</p><p><img src="/blog/img/nginx-3.jpg" alt="image.png"></p><p>另外，Git 也定义了三个区，工作区（workspace），暂存区（index）和版本库（commit history）：</p><ul><li>工作区（workspace）：我们直接修改代码的地方。</li><li>暂存区（index）：数据暂时存放的区域，用于在工作区和版本库之间进行数据交流。</li><li>版本库（commit history）：存放已经提交的数据。</li></ul><p>每个可执行文件的具体分工是：init-db 用来创建一个初始化仓库，update-cache 会将 工作区 的变更写到 索引文件 （index）中，write-tree 会将之前的所有变更整理成 tree 对象，commit-tree 会将 指定的 tree 对象写到本地版本库中。另外，show-diff 用来查看 工作区 和 暂存区 中的文件差异，read-tree 用来读取 tree对象 的信息。</p><p>由此可以绘制一个简单的Git开发工作流：</p><p><img src="/blog/img/nginx-4.jpg" alt="image.png"></p><h4 id="objects-文件"><a href="#objects-文件" class="headerlink" title="objects 文件"></a>objects 文件</h4><p>objects文件是载体，用来存储Git中的3个重要对象：blob、tree、commit。</p><p>objects文件的存储目录默认为.dircache/objects，也可以通过环境变量： SHA1_FILE_DIRECTORY 指定。文件路径和名称根据sha1值决定，取sha1值的第一个字节的hex值为目录，其他字节的hex值为名称，比如sha1值为：<br>0277ec89d7ba8c46a16d86f219b21cfe09a611e1<br>的对象文件存储路径为：<br>.dircache/objects/02/77ec89d7ba8c46a16d86f219b21cfe09a611e1</p><p>为了节约存储，同时也能存储多个信息，objects文件内容都是经过 zlib 压缩过的。objects文件的格式由 + + &lt;要存储的内容&gt; 组成，其中 可以是”blob”（blob对象）、”tree”（tree对象）、”commit”（commit对象）。</p><p>使用 cat-file 可以查看object文件是什么类型的对象。</p><p>.dircache/objects 目录结构如下：</p><div class="hljs code-wrapper"><pre><code class="hljs llvm">$ tree .git/objects.git/objects├── <span class="hljs-number">02</span>│   └── <span class="hljs-number">77</span>ec<span class="hljs-number">89</span>d<span class="hljs-number">7</span>ba<span class="hljs-number">8</span><span class="hljs-keyword">c</span><span class="hljs-number">46</span>a<span class="hljs-number">16</span>d<span class="hljs-number">86</span>f<span class="hljs-number">219</span>b<span class="hljs-number">21</span>cfe<span class="hljs-number">09</span>a<span class="hljs-number">611e1</span>├── ......                                          # 省略├── be│   ├── adb<span class="hljs-number">5</span>bac<span class="hljs-number">00</span><span class="hljs-keyword">c</span><span class="hljs-number">74</span><span class="hljs-keyword">c</span><span class="hljs-number">97</span>da<span class="hljs-number">7</span>f<span class="hljs-number">471905</span>ab<span class="hljs-number">0</span>da<span class="hljs-number">8</span>b<span class="hljs-number">50229</span><span class="hljs-keyword">c</span>│   └── ee<span class="hljs-number">7</span>b<span class="hljs-number">5e8</span>ab<span class="hljs-number">6</span>ae<span class="hljs-number">1</span><span class="hljs-keyword">c</span><span class="hljs-number">0</span><span class="hljs-keyword">c</span><span class="hljs-number">1</span>f<span class="hljs-number">3</span>cfa<span class="hljs-number">2</span><span class="hljs-keyword">c</span><span class="hljs-number">4643</span>aacdb<span class="hljs-number">30</span>b<span class="hljs-number">9</span>b├── ......                                          # 省略├── <span class="hljs-keyword">c</span><span class="hljs-number">9</span>│   └── f<span class="hljs-number">6098</span>f<span class="hljs-number">3</span>ba<span class="hljs-number">06</span>cf<span class="hljs-number">96e1248</span>e<span class="hljs-number">9</span>f<span class="hljs-number">39270883</span>ba<span class="hljs-number">0e82</span>e├── ......                                          # 省略├── cf│   ├── <span class="hljs-number">631</span>abbf<span class="hljs-number">3</span><span class="hljs-keyword">c</span><span class="hljs-number">4</span>cec<span class="hljs-number">0911</span>cb<span class="hljs-number">60</span><span class="hljs-keyword">cc</span><span class="hljs-number">307</span>f<span class="hljs-number">3</span>dce<span class="hljs-number">4</span>f<span class="hljs-number">7</span>a<span class="hljs-number">000</span>│   └── <span class="hljs-number">9e478</span>ab<span class="hljs-number">3</span>fc<span class="hljs-number">98680684</span><span class="hljs-keyword">cc</span><span class="hljs-number">7090e84644363</span>a<span class="hljs-number">4054</span>├── ......                                          # 省略└── ff</code></pre></div><p>问：为什么 .dircache/objects/ 目录下面要以sha1值前一个字节的hex值作为子目录？</p><h4 id="blob-对象"><a href="#blob-对象" class="headerlink" title="blob 对象"></a>blob 对象</h4><p>运行 update-cache 会生成 blob 对象。</p><p>blob 对象用于存储变更文件内容，其实就代表一个变更文件快照。blob 对象由 + + 拼装并压缩：</p><p><img src="/blog/img/git-5.jpg" alt="image.png"></p><p>使用 cat-file 查看 blob 对象内容：</p><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-comment"># 查看 blob 对象内容</span><span class="hljs-variable">$</span> <span class="hljs-built_in">cat</span><span class="hljs-operator">-file</span> <span class="hljs-number">82</span>f8604c3652fa5762899b5ff73eb37bef2da795temp_git_file_tBTXFM: blob<span class="hljs-variable">$</span> <span class="hljs-built_in">cat</span> ./temp_git_file_tBTXFM hello git!</code></pre></div><h4 id="tree-对象"><a href="#tree-对象" class="headerlink" title="tree 对象"></a>tree 对象</h4><p>运行 write-tree 会生成 tree 对象。</p><p>tree 对象用于存储多个提交文件的信息。tree 对象由 + + 文件模式 + 文件名称 + 文件sha1值 拼装并压缩：</p><p><img src="/blog/img/git-6.jpg" alt="image.png"></p><p>文件sha1值 使用binary格式存储，占用20字节。</p><p>使用 cat-file 查看 tree 对象内容：</p><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-comment"># 查看 tree 对象内容</span><span class="hljs-variable">$</span> <span class="hljs-built_in">cat</span><span class="hljs-operator">-file</span>  c771b3ab2fe3b7e43099290d3e99a3e8c414ec72temp_git_file_r90ft5: tree<span class="hljs-variable">$</span> <span class="hljs-built_in">cat</span> ./temp_git_file_r90ft5<span class="hljs-number">100664</span> README.md��`L6<span class="hljs-built_in">R</span>�Wb��_�&gt;�&#123;�-��</code></pre></div><p>文件sha1值 使用binary格式存储，所以打印的时候会有乱码。</p><h4 id="commit-对象"><a href="#commit-对象" class="headerlink" title="commit 对象"></a>commit 对象</h4><p>运行 commit-tree 会生成 commit 对象。</p><p>commit 对象存储一次提交的信息，包括所在的tree信息，parent信息以及提交的作者等信息。commit 对象由 + + + * + + + 拼装并压缩：</p><p><img src="/blog/img/git-7.jpg" alt="image.png"></p><p>tree sha1值 和 parent sha1值 使用hex字符串格式存储，占用40字节。</p><p>使用 cat-file 查看 commit 对象内容：</p><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-comment"># 查看 commit 对象内容</span><span class="hljs-variable">$</span> <span class="hljs-built_in">cat</span><span class="hljs-operator">-file</span> <span class="hljs-number">7</span>ea820bd363e24f5daa5de8028d77d88260503d9temp_git_file_CIfJsg: commit<span class="hljs-variable">$</span> <span class="hljs-built_in">cat</span> temp_git_file_CIfJsgtree c771b3ab2fe3b7e43099290d3e99a3e8c414ec72author Xiaowen Xia &lt;chenan.xxw@aos<span class="hljs-literal">-hw09</span>&gt; Tue Sep  <span class="hljs-number">1</span> <span class="hljs-number">10</span>:<span class="hljs-number">56</span>:<span class="hljs-number">16</span> <span class="hljs-number">2020</span>committer Xiaowen Xia &lt;chenan.xxw@aos<span class="hljs-literal">-hw09</span>&gt; Tue Sep  <span class="hljs-number">1</span> <span class="hljs-number">10</span>:<span class="hljs-number">56</span>:<span class="hljs-number">16</span> <span class="hljs-number">2020</span>first commit</code></pre></div><h4 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h4><p>索引文件默认路径为：.dircache/index。索引文件用来存储变更文件的相关信息，当运行 update-cache 时会添加变更文件的信息到索引文件中。</p><p>同时也有一个叫 .dircache/index.lock 的文件，该文件存在时表示当前工作区被锁定，无法进行提交操作。</p><p>使用 hexdump 命令可以查看到索引文件内容：</p><div class="hljs code-wrapper"><pre><code class="hljs tap">$ hexdump -C .dircache/index 00000000 <span class="hljs-number"> 43 </span>52<span class="hljs-number"> 49 </span>44<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 00 </span>00 <span class="hljs-number"> 01 </span>00<span class="hljs-number"> 00 </span>00 ae<span class="hljs-number"> 73 </span>c4 f2  |CRID.........s..|00000010  ce<span class="hljs-number"> 32 </span>c9 6f<span class="hljs-number"> 13 </span>20 0d<span class="hljs-number"> 56 </span> 9c e8 cf 0d d3<span class="hljs-number"> 75 </span>10 c8  |.2.o. .V.....u..|00000020 <span class="hljs-number"> 94 </span>ad 4c 5f f4 5c<span class="hljs-number"> 42 </span>06 <span class="hljs-number"> 94 </span>ad 4c 5f f4 5c<span class="hljs-number"> 42 </span>06  |..L_.B...L_.B.|00000030 <span class="hljs-number"> 00 </span>03<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 91 </span>16 d2<span class="hljs-number"> 04 </span> b4<span class="hljs-number"> 81 </span>00<span class="hljs-number"> 00 </span>ee<span class="hljs-number"> 03 </span>00<span class="hljs-number"> 00 </span> |................|00000040  ee<span class="hljs-number"> 03 </span>00<span class="hljs-number"> 00 </span>0b<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span> a3 f4 a0<span class="hljs-number"> 66 </span>c5<span class="hljs-number"> 46 </span>39<span class="hljs-number"> 78 </span> |...........f.F9x|00000050  1e<span class="hljs-number"> 30 </span>19 a3<span class="hljs-number"> 20 </span>42 e3<span class="hljs-number"> 82 </span><span class="hljs-number"> 84 </span>ee<span class="hljs-number"> 31 </span>54<span class="hljs-number"> 09 </span>00<span class="hljs-number"> 52 </span>45  |.0.. B....1T..RE|00000060 <span class="hljs-number"> 41 </span>44 4d<span class="hljs-number"> 45 </span>2e 6d<span class="hljs-number"> 64 </span>00                           |ADME.md.|</code></pre></div><p>.dircache/index 索引文件使用二进制存储相关内容，该文件由 文件头 + 变更文件信息 组成：</p><p><img src="/blog/img/git-8.jpg" alt="image.png"></p><p>文件头大小为32字节，一个变更文件信息大小至少是63字节。其中：文件头中的sha1值由整个索引文件内容（文件头 + 变更文件信息）计算得到的。变更文件信息的sha1值由变更文件内容（压缩后）计算得到的。</p><h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p>该 Git 版本中使用的哈希算法为 sha1算法 ，代码中使用的是 OpenSSL 库中提供的sha1算法。</p><p>目前 Git 已经有了新的选择：sha256算法 ，且目前正在做 sha1 到 sha256 的迁移。</p><div class="hljs code-wrapper"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;openssl/sha.h&gt;static <span class="hljs-built_in">int</span> verify<span class="hljs-constructor">_hdr(<span class="hljs-params">struct</span> <span class="hljs-params">cache_header</span> <span class="hljs-operator">*</span><span class="hljs-params">hdr</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">long</span> <span class="hljs-params">size</span>)</span>&#123;  SHA_CTX c;  unsigned <span class="hljs-built_in">char</span> sha1<span class="hljs-literal">[<span class="hljs-number">20</span>]</span>;        <span class="hljs-comment">/* 省略 */</span>  <span class="hljs-comment">/* 计算索引文件头sha1值 */</span>  <span class="hljs-constructor">SHA1_Init(&amp;<span class="hljs-params">c</span>)</span>;  <span class="hljs-constructor">SHA1_Update(&amp;<span class="hljs-params">c</span>, <span class="hljs-params">hdr</span>, <span class="hljs-params">offsetof</span>(<span class="hljs-params">struct</span> <span class="hljs-params">cache_header</span>, <span class="hljs-params">sha1</span>)</span>);  <span class="hljs-constructor">SHA1_Update(&amp;<span class="hljs-params">c</span>, <span class="hljs-params">hdr</span>+1, <span class="hljs-params">size</span> - <span class="hljs-params">sizeof</span>(<span class="hljs-operator">*</span><span class="hljs-params">hdr</span>)</span>);  <span class="hljs-constructor">SHA1_Final(<span class="hljs-params">sha1</span>, &amp;<span class="hljs-params">c</span>)</span>;  <span class="hljs-comment">/* 省略 */</span>  return <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="总结与思考"><a href="#总结与思考" class="headerlink" title="总结与思考"></a>总结与思考</h3><blockquote><p>Use software leverage to your advantage.</p></blockquote><p>——Unix philosophy</p><h4 id="好的代码不是写出来的，是改出来的"><a href="#好的代码不是写出来的，是改出来的" class="headerlink" title="好的代码不是写出来的，是改出来的"></a>好的代码不是写出来的，是改出来的</h4><p>Git 的第一个提交中，虽然实现了 Git 的分布式核心思想，以及三种对象，三个区等核心概念，但是 Git 的灵魂功能比如分支策略、远程仓库、日志系统、git hooks 等功能都是后面逐步迭代出来的。</p><h4 id="关于细节"><a href="#关于细节" class="headerlink" title="关于细节"></a>关于细节</h4><p>问：为什么 .dircache/objects/ 目录下面要以 sha1 值前一个字节的 hex 值作为子目录？</p><p>答：ext3 文件系统下，一个目录下只能有 32000 个一级子文件，如果都把 objects 文件存储到一个 .git/objects/ 目录里，很大概率会达到上限。同时要是一个目录下面子文件太多，那文件查找效率会降低很多。</p><h4 id="关于代码质量"><a href="#关于代码质量" class="headerlink" title="关于代码质量"></a>关于代码质量</h4><p>Git 的第一次提交源码，从代码质量、数据结构上看其实并没有多少参考价值，反而我还发现了很多可以优化的地方，比如：</p><ul><li>异常处理不完善，经常出现段错误（SegmentFault）。</li><li>存在几处内存泄漏的地方，比如 write-tree.c &gt; main函数 &gt; buffer内存块 。</li><li>从索引文件中读取到的变更文件信息使用数组存储，涉及到了比较多的申请释放操作，性能上是有损失的，可以优化成链表存储。</li></ul><p>不过这些都不重要，重要的是 Git 的设计原理和思想。</p>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue-project</title>
    <link href="/2020/09/27/vue-project/"/>
    <url>/2020/09/27/vue-project/</url>
    
    <content type="html"><![CDATA[<h1 id="项目一些思路"><a href="#项目一些思路" class="headerlink" title="项目一些思路"></a>项目一些思路</h1><h3 id="一-项目基本设置"><a href="#一-项目基本设置" class="headerlink" title="一. 项目基本设置"></a>一. 项目基本设置</h3><h4 id="1-1-目录结构"><a href="#1-1-目录结构" class="headerlink" title="1.1. 目录结构"></a>1.1. 目录结构</h4><ul><li>network</li><li>components -&gt; common/content</li><li>pages -&gt; 路由分层</li><li>common </li><li>assets</li><li>router</li><li>store</li></ul><h4 id="1-2-设置CSS初始化和全局样式"><a href="#1-2-设置CSS初始化和全局样式" class="headerlink" title="1.2. 设置CSS初始化和全局样式"></a>1.2. 设置CSS初始化和全局样式</h4><ul><li>initialize.css</li><li>base.css</li></ul><h4 id="1-3-tabbar的封装"><a href="#1-3-tabbar的封装" class="headerlink" title="1.3. tabbar的封装"></a>1.3. tabbar的封装</h4><ul><li>封装HYTabbar</li><li>封装HYTabbarItem</li><li>响应点击切换的设计</li><li>封装完成后，使用时对HYTabbar重新包装</li></ul><h4 id="1-4-axios的封装"><a href="#1-4-axios的封装" class="headerlink" title="1.4. axios的封装"></a>1.4. axios的封装</h4><ul><li>创建axios实例</li><li>拦截响应，返回.data数据</li><li>根据传入的options发送请求，并且调用对应resolve和reject</li></ul><h3 id="二-首先开发"><a href="#二-首先开发" class="headerlink" title="二. 首先开发"></a>二. 首先开发</h3><h4 id="2-1-navbar的封装和使用"><a href="#2-1-navbar的封装和使用" class="headerlink" title="2.1. navbar的封装和使用"></a>2.1. navbar的封装和使用</h4><ul><li>封装navbar包含三个插槽：left、center、right</li><li>设置navbar相关的样式</li><li>使用navbar实现首页的导航栏</li></ul><h4 id="2-2-请求首页数据"><a href="#2-2-请求首页数据" class="headerlink" title="2.2. 请求首页数据"></a>2.2. 请求首页数据</h4><ul><li>封装请求首页更多数据</li><li>将banner数据放在banners变量中</li><li>将recommend数据放在recommends变量中</li></ul><h4 id="2-3-根据Swiper封装HomeSwiper"><a href="#2-3-根据Swiper封装HomeSwiper" class="headerlink" title="2.3. 根据Swiper封装HomeSwiper"></a>2.3. 根据Swiper封装HomeSwiper</h4><ul><li>使用Swiper和SwiperItem</li><li>传入banners进行展示</li></ul><h4 id="2-4-封装FeatureView"><a href="#2-4-封装FeatureView" class="headerlink" title="2.4. 封装FeatureView"></a>2.4. 封装FeatureView</h4><ul><li>传入recommends数据，进行展示</li></ul><h4 id="2-5-封装RecommendView"><a href="#2-5-封装RecommendView" class="headerlink" title="2.5. 封装RecommendView"></a>2.5. 封装RecommendView</h4><ul><li>展示一张图片即可</li></ul><h4 id="2-6-封装tabControl"><a href="#2-6-封装tabControl" class="headerlink" title="2.6. 封装tabControl"></a>2.6. 封装tabControl</h4><ul><li>基本结构的封装</li><li>监听点击</li></ul><h4 id="2-7-请求和保存商品数据"><a href="#2-7-请求和保存商品数据" class="headerlink" title="2.7. 请求和保存商品数据"></a>2.7. 请求和保存商品数据</h4><ul><li>定义goodsList变量，用于存储请求到的商品数据</li><li>根据type和page请求商品数据</li><li>将商品数据保存起来</li></ul><h4 id="2-8-封装GoodsList和GoodsListItem"><a href="#2-8-封装GoodsList和GoodsListItem" class="headerlink" title="2.8. 封装GoodsList和GoodsListItem"></a>2.8. 封装GoodsList和GoodsListItem</h4><ul><li>展示商品列表，封装GoodsList</li><li>列表中每一个商品，封装GoodsListItem</li><li>注意CSS属性的设置即可</li></ul><h4 id="2-9-滚动的封装Scroll"><a href="#2-9-滚动的封装Scroll" class="headerlink" title="2.9. 滚动的封装Scroll"></a>2.9. 滚动的封装Scroll</h4><ul><li>学习BetterScroll的使用</li><li>安装better-scroll</li><li>封装一个独立的组件，用于作为滚动组件：Scroll</li><li>组件内代码的封装：<ul><li>1.创建BetterScroll对象，并且传入DOM和选项（probeType、click、pullUpLoad）</li><li>2.监听scroll事件，该事件会返回一个position</li><li>3.监听pullingUp事件，监听到该事件进行上拉加载更多</li><li>4.封装刷新的方法：this.scroll.refresh()</li><li>5.封装滚动的方法：this.scroll.scrollTo(x, y, time)</li><li>6.封装完成刷新的方法：this.scroll.finishedPullUp</li></ul></li></ul><h4 id="2-10-上拉加载更多"><a href="#2-10-上拉加载更多" class="headerlink" title="2.10. 上拉加载更多"></a>2.10. 上拉加载更多</h4><ul><li>通过Scroll监听上拉加载更多。</li><li>在Home中加载更多的数据。</li><li>请求数据完成后，调动finishedPullUp</li></ul><h4 id="2-11-返回顶部"><a href="#2-11-返回顶部" class="headerlink" title="2.11. 返回顶部"></a>2.11. 返回顶部</h4><ul><li>封装BackTop组件</li><li>定义一个常量，用于决定在什么数值下显示BackTop组件</li><li>监听滚动，决定BackTop的显示和隐藏</li><li>监听BackTop的点击，点击时，调用scrollTo返回顶部</li></ul><h4 id="2-12-tabControl的停留"><a href="#2-12-tabControl的停留" class="headerlink" title="2.12. tabControl的停留"></a>2.12. tabControl的停留</h4><ul><li>重新添加一个tabControl组件（需要设置定位，否则会被盖住）</li><li>在updated钩子中获取tabControl的offsetTop</li><li>判断是否滚动超过了offsetTop来决定是否显示新添加的tabControl</li></ul>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kali高级测试环境</title>
    <link href="/2020/09/19/kali-3/"/>
    <url>/2020/09/19/kali-3/</url>
    
    <content type="html"><![CDATA[<h1 id="第三章-高级测试环境"><a href="#第三章-高级测试环境" class="headerlink" title="第三章 高级测试环境"></a>第三章 高级测试环境</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>既然我们已经了解了 Kali Linux 所包含的工具，现在我们要调查一些真实世界的场景。我们进行的许多攻击都有意在有漏洞的软件和系统上执行。但是，当你使用 Kali 攻击一个系统时，它不可能像我们当前的测试平台那样没有防护。</p><p>这一章中，我们会探索一些技巧，来建立起一些真实的测试环境。在当前的信息技术水平中，多数公司都使用平台即服务（PAAS）解决方案，云服务器主机，或者使用小型网络，它们由桌面、服务器和防火墙（单独）或防火墙和路由的组合组成。我们会建立这些环境，之后对它们发起攻击。</p><p>我们所有攻击的目的都是获取 root 级别的访问。</p><h2 id="3-1-熟悉-VirtualBox"><a href="#3-1-熟悉-VirtualBox" class="headerlink" title="3.1 熟悉 VirtualBox"></a>3.1 熟悉 VirtualBox</h2><p>在第一章（安装和启动Kali）中，我们简要谈多了 VirtualBox 的用法，便于在虚拟环境中安装 Kali Linux。VirtualBox 是 Oracle 的现有产品，并且作为应用运行在宿主操作系统上。它通过创建虚拟环境允许操作系统安装并运行。这个工具极其重要，可以提供靶机来测试你的 Kali Linux 技巧。</p><p>这一章中，我们会极大依赖VirtualBox，并且会修改它的配置来得到我们希望的网络配置类型。我们将这一节作为每个场景单元的起点，所以关键要熟悉这些步骤。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>需要因特网或内部网络的链接来完成这个模块。</p><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>让我们通过打开VirtualBox 来开始：</p><ol><li><p>启动VirtualBox ，并点击<code>New</code>来开启虚拟机向导：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn67imtenj60i407rmxm02.jpg" alt="img"></p></li><li><p>点击<code>Next</code>按钮，输入虚拟机的名称，并选择 OS 类型和版本：这一章中我们会使用 Linux、Solaris 或 Windows 操作系统。选择合适的操作系统并点击<code>Next</code>按钮来继续：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn678hnajj60dl0apq3f02.jpg" alt="img"></p></li><li><p>选择基本内存（RAM）的总量，它们会分配给虚拟机。我们使用默认值。点击<code>Next</code>。</p></li><li><p>为新的虚拟机创建新的虚拟硬盘，点击<code>Next</code>按钮。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn67dtaxxj60do0ap3z502.jpg" alt="img"></p></li><li><p>新的向导窗口会打开。保留默认的 VDI 文件类型，因为我们不打算使用其它可视化软件。</p></li><li><p>我们会在虚拟磁盘储存上保留默认选项。点击<code>Next</code>来继续。</p></li><li><p>设置虚拟磁盘文件位置和大小：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn679aflgj60hn0da3za02.jpg" alt="img"></p></li><li><p>检查设置是否正确，并且点击<code>Create</code>按钮来开始创建虚拟磁盘文件。</p></li><li><p>我们现在回到前一个向导，展示了虚拟机参数的汇总。点击<code>Create</code>来结束：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn67h9hjvj60i70doq3r02.jpg" alt="img"></p></li><li><p>创建新的虚拟机之后，我们准备好了安装操作系统，它刚刚在 VirtualBox中配置好。</p></li><li><p>在VirtualBox的主窗口中，选中我们刚刚创建的操作系统名称，之后点击<code>Settings</code>按钮：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn67d06glj605a07774902.jpg" alt="img"></p></li><li><p>既然基本的安装步骤已经完成了，我们现在使用下载的 ISO 文件作为虚拟光盘。这会节省你烧录物理 DVD 来完成安装的时间。在<code>Settings</code>界面，点击<code>Storage</code>菜单项：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn67ialn5j60bc0ae74m02.jpg" alt="img"></p></li><li><p>之后，在<code>Storage Tree</code>下面，选中<code>Controller: IDE</code>下面的<code>Empty</code>光盘图标。这会选择我们的“虚拟” CD/DVD ROM 驱动。在屏幕的右边，<code>Attribute</code>下面，点击光盘图标。在弹出的菜单中，从列表中选择你的 ISO 文件。如果 ISO 文件没有出现，选择<code>Choose a virtual CD/DVD disc file...</code>选项并找到你的 ISO。一旦你完成了这些步骤，点击<code>OK</code>按钮。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn67bmqh8j60i30a90t902.jpg" alt="img"></p></li><li><p>点击<code>Start</code>按钮，之后点击内部的新窗口，并执行安装。安装步骤在这一章的“安装到硬盘”中有所涉及。</p></li></ol><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>这一章以创建新的VirtualBox虚拟实例来开始，之后我们选择了我们的操作系统，并设置内存和硬盘大小。之后，我们选择了 ISO 文件，之后将 ISO 插入我们的虚拟 CD/DVD 驱动器中。最后，我们启动了虚拟环境，便于安装操作系统。</p><p>在这一章的剩余部分中，我们会使用VirtualBox作为所选工具来建立不同的环境。</p><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>我们所执行的操作可能会让主机不稳定甚至崩溃。VirtualBox提供了杰出的工具来备份虚拟环境：</p><ol><li><p>在主窗口中，点击你打算备份的虚拟服务器：</p></li><li><p>右击虚拟服务器，点击<code>Clone</code>菜单项：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn67aho7ij606s0aeq3202.jpg" alt="img"></p></li><li><p>在克隆窗口中，为你的新虚拟服务器输入名称。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn67b56zjj60b908zmxe02.jpg" alt="img"></p></li><li><p>点击<code>Next</code>，在随后的界面中，选择<code>Linked clone</code>或<code>Full clone</code>，它们在下面展示：</p><ul><li><code>Full clone</code>：在完整克隆的模式中，会创建完全独立的虚拟机备份。</li><li><code>Linked clone</code>：在链接克隆的模式中，会截取快照来创建备份。但是，链接克隆依赖于原始文件的功能。这会降低链接克隆的性能。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn679rbwcj60bc08xwex02.jpg" alt="img"></p></li><li><p>点击<code>Clone</code>并等待虚拟机克隆完成。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn67hrtpuj60cc05f3ym02.jpg" alt="img"></p></li></ol><h2 id="3-2-下载-Windows-靶机"><a href="#3-2-下载-Windows-靶机" class="headerlink" title="3.2 下载 Windows 靶机"></a>3.2 下载 Windows 靶机</h2><p>到目前为止，以及可见的未来中，微软的 Windows 系统都是许多个人和企业所选的操作系统。</p><p>幸运的是，微软提供了一种方法来获取测试操作系统。</p><h3 id="准备-1"><a href="#准备-1" class="headerlink" title="准备"></a>准备</h3><p>需要互联网或内部网络连接来完成这个模块。</p><h3 id="操作步骤-1"><a href="#操作步骤-1" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>下载 Windows 靶机的步骤如下所示：</p><ol><li><p>打开浏览器并访问 Microsoft Technet：<a href="http://technet.microsoft.com/en-us/ms376608">http://technet.microsoft.com/en-us/ms376608</a>。</p></li><li><p>在屏幕的右侧，点击<code>Downloads</code>链接：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn67c3028j60i40b50tm02.jpg" alt="img"></p></li><li><p>在<code>Download</code>菜单项中，选择<code>Evaluate new products</code>。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn67ee5t3j60bj0a0glt02.jpg" alt="img"></p></li><li><p>在下一个界面中，你可以选择要下载的东西，取决于你想要测试的产品。推荐你选择 Windows Server 2012，Windows 8 和 Windows 7。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn67ggad7j60ia0budgy02.jpg" alt="img"></p></li><li><p>一旦你下载了 ISO，请遵循这一章“熟悉VirtualBox”秘籍中的指南。</p></li></ol><h2 id="3-3-下载-Linux-靶机"><a href="#3-3-下载-Linux-靶机" class="headerlink" title="3.3 下载 Linux 靶机"></a>3.3 下载 Linux 靶机</h2><p>对于多数的面向 Web 的服务器的部署，Linux 是一种备选的操作系统。与 Windows 先比，它的开销相对较低（主流发行版免费），这使它成为多数云主机、PAAS和服务器环境的理想操作系统。</p><p>这个秘籍中，我们会示例如何下载多种 Linux 发行版。</p><h3 id="准备-2"><a href="#准备-2" class="headerlink" title="准备"></a>准备</h3><p>需要互联网或内部网络连接来完成这个模块。</p><h3 id="操作步骤-2"><a href="#操作步骤-2" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>下载 Linux 靶机的步骤如下所示：</p><ol><li><p>打开浏览器并访问 Distro Watch：<a href="http://www.distrowatch.com./">http://www.distrowatch.com。</a></p></li><li><p>你会看到超过 100 个 Linux 发行版的列表。推荐选择一个最小的发行版，而不是流行的版本（CentOS、Ubuntu、Fedora 和 Debian）。这个页面像下面这样：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn67cj867j60ic08rmyc02.jpg" alt="img"></p></li><li><p>一旦你下载了 ISO，请遵循这一章“熟悉VirtualBox”秘籍中的指南。</p></li></ol><h2 id="3-4-攻击-WordPress-和其它应用"><a href="#3-4-攻击-WordPress-和其它应用" class="headerlink" title="3.4 攻击 WordPress 和其它应用"></a>3.4 攻击 WordPress 和其它应用</h2><p>选择越来越多的公司在日常业务中使用 SAAS （软件及服务）工具。例如，公司普遍使用 WordPress作为网站的内容管理系统，或 Drupal 作为内部网络。在这些应用中定位漏洞的能力具有极大的价值。</p><p>收集被测试应用的一个很好的方式就是 [Turnkey Linux](<a href="http://www/">http://www</a>. turnkeylinux.org)。这个秘籍中，我们会下载流行的 WordPress Turnkey Linux 发行版。</p><h3 id="准备-3"><a href="#准备-3" class="headerlink" title="准备"></a>准备</h3><p>需要互联网或内部网络连接来完成这个模块。</p><h3 id="操作步骤-3"><a href="#操作步骤-3" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>攻击 WordPress 应用的步骤如下所示：</p><ol><li><p>打开浏览器并访问 Turnkey Linux 的主页：&lt;<a href="http://www/">http://www</a>. turnkeylinux.org&gt;。主页如图所示：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn67819v1j60i00epta902.jpg" alt="img"></p></li><li><p>有许多应用在这里列出，我推荐都试试它们，便于你发现漏洞并提升这方面的技能。但是，对于这个秘籍，我们只测试 WordPress。在<code>Instant Search</code>框中，输入<code>WordPress</code>。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn678xj2oj60dt0gsab602.jpg" alt="img"></p></li><li><p>在 WordPress 下载页面中，选择 ISO 镜像。下载完成后，请遵循这一章“熟悉VirtualBox”秘籍中的指南：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn67gqxkmj60fq05h0t802.jpg" alt="img"></p></li></ol><h3 id="更多-1"><a href="#更多-1" class="headerlink" title="更多"></a>更多</h3><p>既然我们加载的 WordPress 虚拟机，我们可以使用 WPScan 来攻击它了。WPScan 是个黑盒的 WordPress 安全扫描器，允许用户发现 WordPress 上的漏洞。</p><p>WPScan 接受多种参数，包括：</p><ul><li><code>-u &lt;目标域名或 url&gt;</code>：参数<code>u</code>允许你指定目标的域名。</li><li><code>-f</code>：参数<code>f</code>允许你强制检查WordPress是否安装。</li><li><code>-e[选项]</code>：参数<code>e</code>允许你设置枚举。</li></ul><p>让我们开始使用 WPScan。</p><blockquote><p>确保你的 WordPress虚拟机和 Kali Linux 虚拟机都开着，并使用<code>VirtualBox Host Only Adapter</code>网络设置。</p></blockquote><ol><li><p>在 Kali Linux 虚拟机中，加载器 WPScan 帮助文件：</p><p><code>wpscan -h</code></p><p>页面会像下面这样：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn67fwqr1j60gs0a6aat02.jpg" alt="img"></p></li><li><p>让我们对WordPress虚拟机执行基本的 WPScan测试。这里，我们靶机的IP地址是<code>192.168.56.102</code>。</p><p><code>wpscan –u 192.168.56.102</code></p></li><li><p>现在，让我们通过执行下列命令枚举用户名列表：</p><p><code>wpscan –u 192.186.56.102 –e u vp</code></p><p>页面会像下面这样：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn67evdn3j60ft0dlmy702.jpg" alt="img"></p></li><li><p>最后，我们通过使用<code>–wordlist &lt;文件路径&gt;</code>选项来提供单词列表：</p><p><code>wpscan –u 192.168.56.102 -e u --wordlist /root/wordlist.txt</code></p><p>页面会像下面这样：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn67fhz0vj60hh0fojsq02.jpg" alt="img"></p></li><li><p>这就结束了。我们已经成功获取了 WordPress 的密码。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>system</category>
      
      <category>linux</category>
      
      <category>kaili</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kaili</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安装和启动Kali</title>
    <link href="/2020/09/19/kali-1/"/>
    <url>/2020/09/19/kali-1/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-安装和启动Kali"><a href="#第一章-安装和启动Kali" class="headerlink" title="第一章 安装和启动Kali"></a>第一章 安装和启动Kali</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Kali Linux，简称Kali，是用于安全攻击的最新Linux发行版。它是BackTrack Linux的后继者。不像多数Linux发行版那样，Kali Linux用于渗透测试。渗透测试是一种通过模拟攻击评估计算机系统或网络安全性的方法。在整本书中，我们将会探索一些Kali Linux所提供的工具。</p><p>这一章涉及到Kali Linux在不同场景下的的安装和启动，从插入Kali Linux DVD到配置网络。</p><p>对于本书中所有秘籍，我们都要使用以64位GNOME作为窗口管理器（WM）和架构的Kali Linux（<a href="http://www.kali.org/downloads/%EF%BC%89%E3%80%82%E7%84%B6%E8%80%8C%EF%BC%8C%E4%BD%BF%E7%94%A8KDE%E4%BD%9C%E4%B8%BAWM%E7%9A%84%E7%94%A8%E6%B3%95%E5%B9%B6%E4%B8%8D%E5%9C%A8%E8%BF%99%E6%9C%AC%E4%B9%A6%E9%87%8C%E6%B6%89%E5%8F%8A%EF%BC%8C%E4%BD%A0%E5%BA%94%E8%AF%A5%E8%83%BD%E5%A4%9F%E9%81%B5%E5%BE%AA%E8%BF%99%E4%BA%9B%E7%A7%98%E7%B1%8D%EF%BC%8C%E5%B9%B6%E6%B2%A1%E6%9C%89%E5%A4%9A%E5%B0%91%E9%97%AE%E9%A2%98%E3%80%82">http://www.Kali.org/downloads/）。然而，使用KDE作为WM的用法并不在这本书里涉及，你应该能够遵循这些秘籍，并没有多少问题。</a></p><h2 id="1-1-安装到硬盘"><a href="#1-1-安装到硬盘" class="headerlink" title="1.1 安装到硬盘"></a>1.1 安装到硬盘</h2><p>硬盘的安装是最基本的操作之一。这个任务需要我们不带DVD运行Kali来完成。</p><blockquote><p>执行这个秘籍中的步骤会抹掉你的硬盘，并把Kali标记为你电脑上的主操作系统。</p></blockquote><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>在解释整个过程之前，需要满足以下要求：</p><ul><li>为KaliLinux的安装准备最小8GB的空闲磁盘空间（然而我们推荐至少25GB来存放这本书中额外的程序和生成的词汇表）。</li><li>最小512MB的内存。</li><li>在<a href="http://www.kali.org/downloads/">KaliLinux的下载页面</a>下载Kali Linux。</li></ul><p>让我们开始安装吧。</p><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><ol><li><p>在光驱中插入Kali Linux Live DVD来开始。你会看到它的启动菜单。选择<code>Graphical install</code>（图形化安装）。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn60tayfvj60hs0dd0t702.jpg" alt="/img/kaili"></p></li><li><p>选择语言。这里我们选择<code>English</code>（英语）。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn613cg79j60m70gu75802.jpg" alt="/img/kaili"></p></li><li><p>选择你的位置。这里我们选择<code>United States</code>（美国）。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn6167oz8j60m30gjdgs02.jpg" alt="/img/kaili"></p></li><li><p>选择你的键盘配置。这里我们选择<code>American English</code>（美国英语）。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn61ag0afj60m10get9e02.jpg" alt="/img/kaili"></p></li><li><p>下面要完成网络服务配置。输入主机名称，这里我们输入<code>Kali</code>。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn61d6nngj60m70a5dgf02.jpg" alt="/img/kaili"></p></li><li><p>下面，我们需要输入域名。这里我们输入<code>kali.secureworks. com</code>。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn61gx8opj60m50a0wf202.jpg" alt="/img/kaili"></p></li><li><p>现在你会看到输入root密码的地方，需要输入两次。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn61k783rj60m70gfmyk02.jpg" alt="/img/kaili"></p></li><li><p>选择你的时区，这里我们选择<code>Eastern</code>（东方）。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn61nxxmqj60ma0dfgmb02.jpg" alt="/img/kaili"></p></li><li><p>我们现在可以选择磁盘分区方式。你会看到四个选项。选择<code>Guided - use entire disk</code>，这会便于你分区。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn61rb0v8j60m50bo3zf02.jpg" alt="/img/kaili"></p></li><li><p>在这一步，你需要知道你的磁盘会被抹掉，点击<code>Continue</code>（继续）。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn61vybyaj60m4091wf002.jpg" alt="/img/kaili"></p></li><li><p>下面，你有机会选择三个分区方式之一：所有文件放在一个分区、分离<code>/home</code>、以及分离<code>/home/user/var</code>和<code>/tmp</code>。考虑到Kali用于渗透测试，分区不需要也不必要（即使这对于你的桌面主操作系统是个好主意）。这里我们选择<code>All files in one partition</code>（所有文件放在一个分区）并点击<code>Continue</code>（继续）。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn6207cylj60m50bhdgi02.jpg" alt="/img/kaili"></p></li><li><p>一旦你看到了一个界面，让你知道将要对你磁盘执行的改动，选择<code>Yes</code>之后点击<code>Continue</code>（继续）。要注意这是撤销抹掉你磁盘所有数据的最后机会。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn625s4kaj60m30c474v02.jpg" alt="/img/kaili"></p></li><li><p>下面，你会被询问是否希望链接到网络镜像。网络镜像允许你接收到Kali的更新。这里我们选择<code>Yes</code>之后点击<code>Continue</code>（继续）。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn62e6xb4j60m40aj74o02.jpg" alt="/img/kaili"></p></li><li><p>你可以通过点击<code>Continue</code>（继续）跳过HTTP代理界面。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn62mn1yuj60m20a7gm502.jpg" alt="/img/kaili"></p></li><li><p>最后，你会被询问来安装GRUB启动器到主引导记录（MBR）中。选择<code>Yes</code>之后点击<code>Continue</code>（继续）。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn63464syj60m30b775402.jpg" alt="/img/kaili"></p></li><li><p>祝贺你现在完成了Kali Linux的安装！点击<code>Continue</code>，系统会重启并展示登录界面。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn636u6whj60m2090wex02.jpg" alt="/img/kaili"></p></li></ol><h2 id="1-2-安装到U盘或持久存储器中"><a href="#1-2-安装到U盘或持久存储器中" class="headerlink" title="1.2 安装到U盘或持久存储器中"></a>1.2 安装到U盘或持久存储器中</h2><p>Kali Linux U盘能够持久化储存系统设置，以及在U盘中永久升级和安装新的软件包，并让我们将个人定制的Kali Linux随时带在身上。</p><p>多亏了Win32 Disk Imager，我们可以为大多数Linux发行版创建可启动的U盘，包括持久化存储的Kali Linux。</p><h3 id="准备-1"><a href="#准备-1" class="headerlink" title="准备"></a>准备</h3><p>需要下列工具和准备工作以继续：</p><ul><li>FAT32格式的U盘，最小8GB。</li><li>Kali Linux ISO镜像。</li><li><a href="http://sourceforge.net/projects/win32diskimager/">Win32 Disk Imager</a>。</li><li>你可以从<a href="http://www.kali.org/downloads/">这里</a>下载Kali。</li></ul><h3 id="操作步骤-1"><a href="#操作步骤-1" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>让我们开始讲Kali Linux安装到U盘：</p><ol><li><p>插入格式化且可写入的U盘：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn63a0ox1j60ek042jrc02.jpg" alt="/img/kaili"></p></li><li><p>启动 Win32 Disk Imager。</p></li><li><p>点击目录图表，选择Kali Linux DVD ISO镜像的位置：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn652d1nnj60bp0623yl02.jpg" alt="/img/kaili"></p></li><li><p>确保<code>Space used to preserve files across reboots</code>（用于在启动中保存文件的空间）设置为4096。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn63dryyuj60et0aywey02.jpg" alt="/img/kaili"></p></li><li><p>选择我们的U盘，并点击OK按钮来开始创建可启动的U盘：</p></li><li><p>当它解压并复制DVD的文件到U盘，以及安装bootloader时，这个过程会花一些时间来完成。</p></li><li><p>安装完成之后，我们就可以重启电脑，从新创建的Kali Linux U盘以持久存储器来启动了。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn63hi1yoj60ef06qaa302.jpg" alt="/img/kaili"></p></li></ol><h2 id="1-3-在-VirtualBox-中安装"><a href="#1-3-在-VirtualBox-中安装" class="headerlink" title="1.3 在 VirtualBox 中安装"></a>1.3 在 VirtualBox 中安装</h2><p>这个秘籍会引导你使用知名的开源虚拟机软件VirtualBox，将Kali Linux安装在一个完全分离的访客操作系统中，它在你的宿主操作系统中。</p><h3 id="准备-2"><a href="#准备-2" class="headerlink" title="准备"></a>准备</h3><p>需要满足下列要求：</p><ul><li><a href="https://www.virtualbox.org/wiki/Downloads">VirtualBox</a> 的最新版本（本书编写时为4.2.16）。</li><li>Kali Linux ISO 镜像的副本。你可以在[这里](<a href="http://www/">http://www</a>. Kali.org/downloads/)下载。</li></ul><h3 id="操作步骤-2"><a href="#操作步骤-2" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>让我们在VirtualBox中安装Kali Linux：</p><ol><li><p>运行VirtualBox，点击<code>New</code>（新建）来启动虚拟机向导：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn63mq9v1j60lq09bq3h02.jpg" alt="/img/kaili"></p></li><li><p>点击<code>Next</code>（下一步）按钮，键入虚拟机的名称，并选择OS类型和版本。这里我们选择Linux类型和Ubuntu（64位）作为版本。点击<code>Next</code>按钮来继续：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn63pg9r3j60dj0ao0t702.jpg" alt="/img/kaili"></p></li><li><p>选择分配给虚拟机的基本内存（RAM）的总数。我们打算使用默认值，点击<code>Next</code>。</p></li><li><p>为新的虚拟机创建新的虚拟硬盘，点击<code>Next</code>按钮。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn63u818pj60dn0aomxr02.jpg" alt="/img/kaili"></p></li><li><p>一个新的向导窗口将会打开，保留默认的VDI文件类型，因为我们并不需要使用其它的虚拟机软件。</p></li><li><p>我们会保留默认选项作为虚拟机磁盘存储的详情。点击<code>Next</code>来继续：</p></li><li><p>设置虚拟机磁盘文件类型和大小：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn63yu0tyj60fu0byaal02.jpg" alt="/img/kaili"></p></li><li><p>检查设置是否正确，之后点击<code>Create</code>（创建）按钮来开始虚拟磁盘文件的创建。</p></li><li><p>我们将会返回前面的向导，带有虚拟机参数的概览。点击<code>Create</code>以结束：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn6433szsj60lr0gcgml02.jpg" alt="/img/kaili"></p></li><li><p>新的虚拟机创建之后，我们将要安装Kali Linux。</p></li><li><p>在VirtualBox的主窗口，高亮Kali Linux，之后点击<code>Settings</code>（设置）按钮：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn645ubcwj606808gjre02.jpg" alt="/img/kaili"></p></li><li><p>现在基本的安装步骤就完成了，我们需要让你将下载的ISO文件用于虚拟光盘。这会为你节省烧录物理DVD的时间来完成这个安装。在<code>Settings</code>界面中，点击<code>Storage</code>（存储器）菜单选项：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn648pbpjj60b90acjrn02.jpg" alt="/img/kaili"></p></li><li><p>下一步，在<code>Storage Tree</code>（存储器树形图）下面，高亮<code>Empty</code>（空）磁盘图标，它在<code>IDE Controller</code>（IDE控制器）的下面。这户选择我们的虚拟CD/DVD ROM驱动器。在屏幕的最右边，在 <code>Attributes</code>底下，点击光盘图表。在上面弹出的菜单上选择你的<code>Choose a virtual CD/DVD disc file...</code>（Kali Linux ISO CD/DVD光盘文件）选项，并找到你的ISO。一旦你完成了这些步骤，点击OK按钮。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn64al3avj60nq0dhmxw02.jpg" alt="/img/kaili"></p></li><li><p>点击Start（开始）按钮，之后点击里面的新窗口来进行安装。安装步骤在1.1节中已经包括了。</p><blockquote><p>安装VirtualBox 扩展包也允许我们通过添加USB2.0（EHCI）、VirtualBox RDP和 Intel PXE boot ROM的支持，来扩展虚拟机的功能。</p></blockquote></li></ol><h2 id="1-4-安装-VMware-Tools"><a href="#1-4-安装-VMware-Tools" class="headerlink" title="1.4 安装 VMware Tools"></a>1.4 安装 VMware Tools</h2><p>这个秘籍中，我们会展示如何使用 VMware Tools将Kali Linux安装在虚拟机中。</p><h3 id="准备-3"><a href="#准备-3" class="headerlink" title="准备"></a>准备</h3><p>需要满足下列要求：</p><ul><li>已经安装好的Kali Linux VMware 虚拟机。</li><li>网络连接。</li></ul><h3 id="操作步骤-3"><a href="#操作步骤-3" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>让我们开始将Kali Linux 安装到 VMware上：</p><ol><li><p>打开你的虚拟机的访客操作系统并连接到互联网，之后打开<code>Terminal</code>（终端）窗口，并键入下列命令来准备核心资源：</p><p><code>prepare-kernel-sources</code></p><blockquote><p>这些命令假设你使用Linux或者Mac OS。你不需要在Windows下执行它们。</p></blockquote></li><li><p>在VMware Workstaion的菜单栏上，访问<code>VM | Install VMware Tools…</code>：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn64ec0qvj608508j74e02.jpg" alt="/img/kaili"></p></li><li><p>将VMware Tools安装工具复制到临时目录下，之后将当前位置改为目标目录：</p><p><code>cp /media/VMware\ Tools/VMwareTools-8.8.2-590212.tar.gz /tmp/; cd /tmp</code></p><blockquote><p>根据你的VMware Tools来替换文件名：<code>VMwareTools--.tar.gz</code>。</p></blockquote></li><li><p>使用以下命令解压并安装：</p><p><code>tar zxpf VMwareTools-8.8.2-590212.tar.gz</code></p></li><li><p>进入VMware Tools的目录中，之后运行安装工具：</p><p><code>cd vmware-tools-distrib/ ./vmware-install.pl</code></p></li><li><p>按下回车键来接受每个配置询问的默认值；<code>vmware-config-tools.pl</code>脚本同上。</p></li><li><p>最后重启系统，工作就完成了。</p></li></ol><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>在第一步中，我们准备好了核心资源。之后，我们向访客操作系统插入了虚拟的 VMware Tools CD 。接着，我们创建了挂载点，并挂载虚拟CD。我们在临时目录中复制并解压了安装工具。最后我们保留默认配置来运行安装工具。</p><h2 id="1-5-修复启动画面"><a href="#1-5-修复启动画面" class="headerlink" title="1.5 修复启动画面"></a>1.5 修复启动画面</h2><p>我们首次启动新安装的Kali Linux系统时，会注意到启动画面消失了。为了手动修复它，我们需要解压<code>Initrd</code>，修改它，之后将它再次压缩。幸运的是，有一个由 Mati Aharoni（也称为“muts”，Kali Linux的创造者）编写的自动化bash脚本使这件事变得容易。</p><h3 id="操作步骤-4"><a href="#操作步骤-4" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>键入下列命令并且按下回车键来修复消失的启动画面：</p><div class="hljs code-wrapper"><pre><code class="hljs coq"><span class="hljs-built_in">fix</span>-splash</code></pre></div><h2 id="1-6-启动网络服务"><a href="#1-6-启动网络服务" class="headerlink" title="1.6 启动网络服务"></a>1.6 启动网络服务</h2><p>Kali Linux 自带了多种网络服务，它们在多种情况下可能很实用，并且默认是禁用的。这个秘籍中，我们会涉及到通过多种方法设置和启动每个服务的步骤。</p><h3 id="准备-4"><a href="#准备-4" class="headerlink" title="准备"></a>准备</h3><p>需要满足下列要求以继续：</p><ul><li>带有有效IP地址的网络连接。</li></ul><h3 id="操作步骤-5"><a href="#操作步骤-5" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>让我们开始启动默认服务：</p><ol><li><p>启动Apache服务器：</p><p><code>service apache2 start</code></p><p>我们可以通过浏览本地地址来验证服务器是否打开。</p></li><li><p>为了启动SSH服务，首次需要生成SSH密钥：</p><p><code>sshd-generate</code></p></li><li><p>启动SSH服务器：</p><p><code>service ssh start</code></p></li><li><p>使用<code>netstat</code>命令来验证服务器是否开启并正在监听：</p><p><code>netstat -tpan | grep 22</code></p></li><li><p>启动FTP服务器：</p><p><code>service pure-ftpd start</code></p></li><li><p>使用下列命令来验证FTP服务器：</p><p><code>netstat -ant | grep 21</code></p><blockquote><p>你也可以使用<code>ps-ef | grep 21</code>命令。</p></blockquote></li><li><p>使用下列命令来停止服务：</p><p><code>service  stop</code></p><p>其中``代表我们希望停止的网络服务，例如：</p><p><code>service apache2 stop</code></p></li><li><p>使用下列命令来在开机时启用服务：</p><p><code>update-rc.d –f  defaults</code></p><p>其中``代表打算启动的网络服务，例如：</p><p><code>update-rc.d –f ssh defaults</code></p><blockquote><p>你也可以在Kali Linux中通过<code>Services</code>（服务）菜单来完成它。从<code>Start</code>（开始）菜单开始，访问<code>Kali Linux | Services</code>。</p></blockquote></li></ol><h2 id="1-7-设置无线网络"><a href="#1-7-设置无线网络" class="headerlink" title="1.7 设置无线网络"></a>1.7 设置无线网络</h2><p>最后，我们来到了这一章的最后一个秘籍。这个秘籍中，我们会了解在安全状态下的无线网络连接步骤，通过Wicd Network Manager和提供加密的细节。无线网络的设置允许我们以无线方式使用Kali Linux。在真实的、合乎道德的渗透测试中，我们可以不依赖于网线而自由地使用所有常规桌面。</p><h3 id="操作步骤-6"><a href="#操作步骤-6" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>让我们开始设置无线网络：</p><ol><li><p>从桌面启动网络管理器，通过点击<code>Applications</code>（应用）菜单并且访问<code>Internet | Wicd Network Manager</code>，或者在终端窗口中键入下列命令：</p><p><code>wicd-gtk --no-tray</code></p></li><li><p>Wicd Network Manager会打开，并带有可用网络的列表：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn64jevjij60eq072dfw02.jpg" alt="/img/kaili"></p></li><li><p>点击<code>Properties</code>（属性）按钮来设定网络细节。完成之后点击OK。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn64lsugmj60bi0gpglu02.jpg" alt="/img/kaili"></p></li><li><p>最后，点击<code>Connect</code>（连接）按钮，就完成了。</p></li></ol><h3 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h3><p>这个秘籍中，我们总结了无线网络的设置方式。这个秘籍以启动网络管理器，和连接到我们的路由器作为开始。</p>]]></content>
    
    
    <categories>
      
      <category>system</category>
      
      <category>linux</category>
      
      <category>kaili</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kaili</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>定制 Kali Linux</title>
    <link href="/2020/09/19/kali-2/"/>
    <url>/2020/09/19/kali-2/</url>
    
    <content type="html"><![CDATA[<h1 id="第二章-定制-Kali-Linux"><a href="#第二章-定制-Kali-Linux" class="headerlink" title="第二章 定制 Kali Linux"></a>第二章 定制 Kali Linux</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这一章会向你介绍Kali的定制，便于你更好地利用它。我们会涉及到ATI和英伟达GPU技术的安装和配置，以及后面章节所需的额外工具。基于ATI和英伟达GPU的显卡允许我们使用它们的图像处理单元（GPU）来执行与CPU截然不同的操作。我们会以ProxyChains的安装和数字信息的加密来结束这一章。</p><h2 id="2-1-准备内核头文件"><a href="#2-1-准备内核头文件" class="headerlink" title="2.1 准备内核头文件"></a>2.1 准备内核头文件</h2><p>有时我们需要使用所需的内核头文件来编译代码。内核头文件是Linux内核的源文件。这个秘籍中，我们会解释准备内核头文件所需的步骤，便于以后使用。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>完成这个秘籍需要网络连接。</p><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>让我们开始准备内核头文件：</p><ol><li><p>我们首先通过执行下列命令升级发行版作为开始：</p><p><code>apt-get update</code></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn66oojd1j60jw0a5q5e02.jpg" alt="img"></p></li><li><p>下面，我们需要再次使用<code>apt-get</code>来准备内核头文件，执行下列命令：</p><p><code>apt-get install linux-headers - </code>uname –r``</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn66iaxafj60hf06jdgx02.jpg" alt="img"></p></li><li><p>复制下列目录以及其中的全部内容：</p><p><code>cd /usr/src/linux cp -rf include/generated/* include/linux/</code></p></li><li><p>我们现在已准备好编译需要内核头文件的代码。</p></li></ol><h2 id="2-2-安装-Broadcom-驱动"><a href="#2-2-安装-Broadcom-驱动" class="headerlink" title="2.2 安装 Broadcom 驱动"></a>2.2 安装 Broadcom 驱动</h2><p>在这个秘籍中，我们将要安装 Broadcom 官方的Linux混合无线驱动。 使用Broadcom 无线USB适配器可以让我们在Kali上连接我们的无线USB接入点。对于这本书的其余秘籍，我们假设Broadcom 无线驱动已经安装。</p><h3 id="准备-1"><a href="#准备-1" class="headerlink" title="准备"></a>准备</h3><p>完成这个秘籍需要网络连接。</p><h3 id="操作步骤-1"><a href="#操作步骤-1" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>让我们开始安装 Broadcom 驱动：</p><ol><li><p>打开终端窗口，从<a href="http://www.broadcom.com/support/802.11/linux_sta.php%E4%B8%8B%E8%BD%BD%E5%90%88%E9%80%82%E7%9A%84Broadcom">http://www.broadcom.com/support/802.11/linux_sta.php下载合适的Broadcom</a> 驱动：</p><p><code>cd /tmp/ wget http://www.broadcom.com/docs/linux_sta/hybrid-portsrc_ x86_64-v5_100_82_112.tar.gz</code></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn66pqvxcj60r008r40402.jpg" alt="img"></p></li><li><p>使用下列命令解压下载的驱动：</p><p><code>mkdir broadcom tar xvfz hybrid-portsrc_x86_64-v5_100_82_112.tar.gz –C /tmp/ broadcom</code></p></li><li><p>修改<code>wl_cfg80211.c</code>文件，由于5.100.82.112版本中有个bug，会阻止小于2.6.39内核版本上的编译：</p><p><code>vim /tmp/broadcom/src/wl/sys/wl_cfg80211.c</code></p><p>观察代码段的1814行：</p><p>```c</p><h1 id="if-LINUXVERSIONCODE-gt-KERNEL-VERSION-2-6-39"><a href="#if-LINUXVERSIONCODE-gt-KERNEL-VERSION-2-6-39" class="headerlink" title="if LINUXVERSIONCODE &gt; KERNEL_VERSION(2, 6, 39)"></a>if LINUX<em>VERSION</em>CODE &gt; KERNEL_VERSION(2, 6, 39)</h1><p>```</p><p>将其改为：</p><p>```c</p><h1 id="if-LINUXVERSIONCODE-gt-KERNEL-VERSION-2-6-39-1"><a href="#if-LINUXVERSIONCODE-gt-KERNEL-VERSION-2-6-39-1" class="headerlink" title="if LINUXVERSIONCODE &gt;= KERNEL_VERSION(2, 6, 39)"></a>if LINUX<em>VERSION</em>CODE &gt;= KERNEL_VERSION(2, 6, 39)</h1><p>```</p><p>并保存修改。</p></li><li><p>编译代码：</p><p><code>make clean make make install</code></p></li><li><p>更新依赖：</p><p><code>depmod -a</code></p></li><li><p>通过下列命令找到加载的模块：</p><p><code>lsmod | grep b43\|ssb\|bcma</code></p></li><li><p>通过执行下列命令移除发现的模块：</p><p><code>rmmod b43</code></p><p>其中``应为<code>b43</code>、<code>ssb</code>或<code>bcma</code>。</p></li><li><p>将模块加入黑名单，防止它们在系统启动中加载：</p><p><code>echo &quot;blacklist &quot; &gt;&gt; /etc/modprobe.d/blacklist.conf</code></p><p>其中``应为<code>b43</code>、<code>ssb</code>或<code>wl</code>。</p></li><li><p>最后，将新模块添加到Linux内核中，来使它成为启动进程的一部分：</p><p><code>modprobe wl</code></p></li></ol><h2 id="2-3-安装和配置ATI显卡驱动"><a href="#2-3-安装和配置ATI显卡驱动" class="headerlink" title="2.3 安装和配置ATI显卡驱动"></a>2.3 安装和配置ATI显卡驱动</h2><p>这个秘籍中，我们会详细讲解ATI显卡驱动的安装和配置，在此之前需要AMD Accelerated Parallel Processing (APP) SDK、OepnCL和CAL++。我们可以利用 ATI Stream技术的优势来运行计算密集型任务 – 它们通常运行在CPU上 – 使它们更快更高效地执行。更多ATI Stream技术相关的详细信息，请访问<a href="www.amd.com/stream">www.amd.com/stream</a>。</p><h3 id="准备-2"><a href="#准备-2" class="headerlink" title="准备"></a>准备</h3><p>需要网络连接来完成这个秘籍。同时在开始这个秘籍之前需要准备内核头文件，它在第一节有所涉及。</p><h3 id="操作步骤-2"><a href="#操作步骤-2" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>让我们开始安装和配置ATI驱动：</p><ol><li><p>下载系统所需的ATI显示驱动：</p><p><code>cd /tmp/ wget http://www2.ati.com/drivers/linux/amd-driver-installer-121-x86.x86_64.run</code></p><p>我们也可以从下面的网址下载显示驱动：[<a href="http://support/">http://support</a>. amd.com/us/gpudownload/Pages/index.aspx](<a href="http://support/">http://support</a>. amd.com/us/gpudownload/Pages/index.aspx)。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn66mhewjj60qn07fq4f02.jpg" alt="img"></p></li><li><p>通过键入下列命令来开始安装：</p><p><code>sh amd-driver-installer-12-1-x86.x86_64.run</code></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn66j6yxhj60eo0e3weu02.jpg" alt="img"></p></li><li><p>在安装完成之后，重启你的系统来使改变生效，并且避免不稳定。</p></li><li><p>为之后的步骤安装一些依赖：</p><p><code>apt-get install libroot-python-dev libboost-python-dev libboost1.40-all-dev cmake</code></p></li><li><p>下载并解压 AMD APP SDK，根据你的CPU架构：</p><p><code>wget http://developer.amd.com/Downloads/AMD-APP-SDK-v2.6-lnx64.tgz mkdir AMD-APP-SDK-v2.6-lnx64 tar zxvf AMD-APP-SDK-v2.6-lnx64.tgz –C /tmp/AMD-APP-SDK-v2.6-lnx64 cd AMD-APP-SDK-v2.6-lnx64</code></p></li><li><p>通过下列命令安装AMD APP SDK：</p><p><code>sh Install-AMD-APP.sh</code></p></li><li><p>在<code>.bashsrc</code>文件中设置ATI Stream的路径：</p><p><code>echo export ATISTREAMSDKROOT=/opt/AMDAPP/ &gt;&gt; ~/.bashrc source ~/.bashrc</code></p></li><li><p>下载并编译<code>calpp</code>：</p><p><code>cd /tmp/ svn co https://calpp.svn.sourceforge.net/svnroot/calpp calpp cd calpp/trunk cmake . make make install</code></p></li><li><p>下载并编译<code>pyrit</code>：</p><p><code>cd /tmp/ svn co http://pyrit.googlecode.com/svn/trunk/ pyrit_src cd pyrit_src/pyrit python setup.py build python setup.py install</code></p></li><li><p>构建并安装OpenCL：</p><p><code>cd /tmp/pyrit_src/cpyrit_opencl python setup.py build python setup.py install\</code></p></li><li><p>对<code>cpyrit_calpp</code>的安装做一些小修改：</p><p><code>cd /tmp/pyrit_source/cpyrit_calpp vi setup.py</code></p><p>找到下面这一行：</p><p><code>py VERSION = &#39;0.4.0-dev&#39;</code></p><p>把它改成：</p><p><code>py VERSION = &#39;0.4.1-dev&#39;</code></p><p>之后，找到下面这一行：</p><p><code>py CALPP_INC_DIRS.append(os.path.join(CALPP_INC_DIR, &#39;include&#39;))</code></p><p>把它改成：</p><p><code>py CALPP_INC_DIRS.append(os.path.join(CALPP_INC_DIR, &#39;include/CAL&#39;))</code></p></li><li><p>最后将ATI GPU模块添加到pyrit：</p><p><code>python setup.py build python setup.py install</code></p></li></ol><blockquote><p>为了展示可用的CAL++设备和CPU的核数，我们需要键入下列命令：</p><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">pyrit list_cores</span></code></pre></div><p>为了进行跑分，我们只需要键入：</p><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">pyrit benchmark</span></code></pre></div></blockquote><h2 id="2-4-安装和配置英伟达显卡驱动"><a href="#2-4-安装和配置英伟达显卡驱动" class="headerlink" title="2.4 安装和配置英伟达显卡驱动"></a>2.4 安装和配置英伟达显卡驱动</h2><p>这个秘籍中，我们会拥抱CUDA，英伟达的并行计算架构。在CUDA工具包的安装之后，首先会安装英伟达开发者显示驱动。通过使用GPU的威力，这会带来计算性能的戏剧性提升，它们通常用于一些类似密码破解的场合。</p><blockquote><p>有关CUDA的更多信息，请浏览<a href="http://www.nvidia.com/object/cuda_home_new.html">他们的官方网站</a>。</p></blockquote><h3 id="准备-3"><a href="#准备-3" class="headerlink" title="准备"></a>准备</h3><p>需要网络连接来完成这个秘籍。</p><p>同时需要在开始之前准备内核头文件，这在第一节中有所涉及。</p><p>为了完成英伟达驱动的安装，需要关闭X会话。</p><h3 id="操作步骤-3"><a href="#操作步骤-3" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>让我们开始安装和配置英伟达显卡驱动：</p><ol><li><p>下载英伟达开发者显示驱动，根据你的CPU架构：</p><p><code>cd /tmp/ wget http://developer.download.nvidia.com/compute/cuda/4_1/rel/ drivers/NVIDIA-Linux-x86_64-285.05.33.run</code></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn66lhozgj60rv06sjsn02.jpg" alt="img"></p></li><li><p>安装驱动：</p><p><code>chmod +x NVIDIA-Linux-x86_64-285.05.33.run ./NVIDIA-Linux-x86_64-285.05.33.run –kernel-source-path=&#39;/usr/src/ linux&#39;</code></p></li><li><p>下载CUDA工具包：</p><p><code>wget http://developer.download.nvidia.com/compute/cuda/4_1/rel/ toolkit/cudatoolkit_4.1.28_linux_64_ubuntu11.04.run</code></p></li><li><p>安装CUDA工具包到<code>/opt</code>：</p><p><code>chmod +x cudatoolkit_4.1.28_linux_64_ubuntu11.04.run ./cudatoolkit_4.1.28_linux_64_ubuntu11.04.runConfigure the environment variables required for nvcc to work: echo PATH=$PATH:/opt/cuda/bin &gt;&gt; ~/.bashrc echo LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/cuda/lib &gt;&gt; ~/.bashrc echo export PATH &gt;&gt; ~/.bashrc echo export LD_LIBRARY_PATH &gt;&gt; ~/.bashrc</code></p></li><li><p>运行以下命令来使变量生效：</p><p><code>source ~/.bashrc ldconfig</code></p></li><li><p>安装<code>pyrit</code>的依赖：</p><p><code>apt-get install libssl-dev python-dev python-scapy</code></p></li><li><p>下载并安装GPU增效工具<code>pyrit</code>：</p><p><code>svn co http://pyrit.googlecode.com/svn/trunk/ pyrit_src cd pyrit_src/pyrit python setup.py build python setup.py install</code></p></li><li><p>最后，将英伟达GPU模块添加到<code>pyrit</code>：</p><p><code>cd /tmp/pyrit_src/cpyrit_cuda python setup.py build python setup.py install</code></p></li></ol><blockquote><p>为了验证<code>nvcc</code>是否正确安装，我们需要键入下列命令：</p><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">nvcc -V</span></code></pre></div><p>为了进行跑分，我们只需要键入下列命令：</p><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">pyrit benchmark</span></code></pre></div></blockquote><h2 id="2-5-升级和配置额外的安全工具"><a href="#2-5-升级和配置额外的安全工具" class="headerlink" title="2.5 升级和配置额外的安全工具"></a>2.5 升级和配置额外的安全工具</h2><p>这个秘籍中，我们会涉及到升级Kali，以及配置一些额外的工具，它们对于之后的章节和秘籍十分实用。由于Kali的包在发布之间会不断升级，你很快就会发现比起之前在你的DVD中下载好的工具，又提供了一系列新的工具。我们会以升级来开始，之后获得Nessus的激活码，并以安装Squid来结束。</p><h3 id="操作步骤-4"><a href="#操作步骤-4" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>让我们开始进行升级，以及配置额外的安全工具。</p><ol><li><p>使用仓库中最新的修改来更新本地的包索引：</p><p><code>apt-get update</code></p></li><li><p>升级现有的包：</p><p><code>apt-get upgrade</code></p></li><li><p>升级到最新版本（如果可用的话）：</p><p><code>apt-get dist-upgrade</code></p></li><li><p>获得Nessus的激活码，通过在[这里]( <a href="http://www.nessus.org/">http://www.nessus.org/</a> products/nessus/nessus-plugins/obtain-an-activation-code)注册。</p></li><li><p>通过执行下列命令来激活Nessus：</p><p><code>/opt/nessus/bin/nessus-fetch --register A60F-XXXX-XXXX-XXXX-0006</code></p><p>其中<code>A60F-XXXX-XXXX-XXXX-0006</code>应为你的激活码。</p></li><li><p>为Nessus Web界面创建账户：</p><p><code>/opt/nessus/sbin/nessus-adduser</code></p></li><li><p>为了启动Nessus服务器，我们只需要执行下列命令：</p><p><code>/etc/init.d/nessusd start</code></p></li><li><p>安装Squid：</p><p><code>apt-get install squid3</code></p></li><li><p>阻止Squid在启动时自动运行：</p><p><code>update-rc.d -f squid3 remove</code></p></li></ol><blockquote><p>为了在仓库中找到特定的包，我们可以在<code>apt-get update</code>之后使用下列命令：</p><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">apt-cache search</span></code></pre></div><p>其中``是包名称或者正则表达式。</p></blockquote><h2 id="2-6-配置ProxyChains"><a href="#2-6-配置ProxyChains" class="headerlink" title="2.6 配置ProxyChains"></a>2.6 配置ProxyChains</h2><p>这个章节中，我们会强制指定应用的网络连接使用用户定义的代理列表，来打破接受者和发送者之间的直接连接。</p><h3 id="操作步骤-5"><a href="#操作步骤-5" class="headerlink" title="操作步骤"></a>操作步骤</h3><ol><li><p>打开ProxyChains的配置文件：</p><p><code>vim /etc/proxychains.conf</code></p></li><li><p>解除我们打算使用的链接类型的注释，这里是<code>dynamic_chain</code>：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn66k8nq2j60g20gm40m02.jpg" alt="img"></p></li><li><p>向列表中添加一些代理服务器：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn66hg25lj60bi0c3gmd02.jpg" alt="img"></p></li><li><p>使用我们的链式代理来解析目标主机：</p><p><code>proxyresolv www.targethost.com</code></p></li><li><p>现在可以在我们打算使用的应用上运行ProxyChains，例如<code>msfconsole</code>：</p><p><code>proxychains msfconsole</code></p></li></ol><h2 id="2-7-目录加密"><a href="#2-7-目录加密" class="headerlink" title="2.7 目录加密"></a>2.7 目录加密</h2><p>这一章的最后一个秘籍关于信息隐私。我们会使用TrueCrypt通过密钥来隐藏重要和私密的数字信息，远离公众的眼睛。</p><h3 id="操作步骤-6"><a href="#操作步骤-6" class="headerlink" title="操作步骤"></a>操作步骤</h3><ol><li><p>通过访问<code>Applications Menu | Kali | Forensics | Digital Anti Forensics | install truecrypt</code>来安装TrueCrypt。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn66qjexij60fb06jgmf02.jpg" alt="img"></p><p>点击<code>Install TrueCrypt</code>（安装TrueCrypt）并且遵循屏幕上的指导。</p></li><li><p>从<code>Applications Menu | Kali Linux | Forensics | Digital Anti Forensics | truecrypt</code>运行TrueCrypt，你会看到下面的窗口：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn66rn3moj60he0f5dgi02.jpg" alt="img"></p></li><li><p>点击<code>Create Volume</code>（新建卷）来启动<code>TrueCrypt Volume Creation Wizard</code>（TrueCrypt卷创建向导）。</p></li><li><p>保留默认选项并点击<code>Next</code>。</p></li><li><p>选择<code>Standard TrueCrypt</code>（标准TrueCrypt）模式并点击<code>Next</code>。</p></li><li><p>点击<code>Select File…</code>（选择文件）按钮并为新的TrueCrypt卷指定名称和路径。完成后点击<code>Save</code>（保存）。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn66ofyfpj60lg0c275102.jpg" alt="img"></p></li><li><p>点击<code>Next</code>按钮并选择打算使用的加密和哈希算法。</p></li><li><p>在下个屏幕中，我们会为容器指定空间总量。</p></li><li><p>现在我们需要为我们的卷键入密码。点击<code>Next</code>。</p></li><li><p>选择文件系统类型。</p></li><li><p>按需选择<code>Cross-Platform Support</code>（跨平台支持）。</p></li><li><p>在下个屏幕中，向导会让我们在窗口内移动鼠标，来增加加密密钥的密码强度。完成后点击<code>Format</code>（格式化）按钮。</p></li><li><p>格式化会开始，完成时TrueCrypt的卷就创建好了。按下<code>OK</code>或<code>Exit</code>（退出）。</p></li><li><p>我们现在回到TrupCrypt窗口。</p></li><li><p>从列表中选择一个<code>Slot</code>（槽）来解密我们的卷，点击<code>Select File…</code>（选择文件），并打开我们创建的卷。</p></li><li><p>点击<code>Mount</code>（挂载）并键入我们的密码，完成后点击<code>OK</code>。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn66naw50j60he0f5my802.jpg" alt="img"></p></li><li><p>我们现在可以通过在槽上双击或通过挂载目录来访问卷，以及在里面保存文件。当我们完成之后，只需要点击<code>Dismount All</code>（解除所有挂载）。</p></li></ol><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>这个秘籍中，我们配置了 Truecrypt，创建了保护卷，之后挂载了它。这是个用于保护数据安全性的实用工具。</p>]]></content>
    
    
    <categories>
      
      <category>system</category>
      
      <category>linux</category>
      
      <category>kaili</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kaili</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>easyCode</title>
    <link href="/2020/09/13/idea-easycode/"/>
    <url>/2020/09/13/idea-easycode/</url>
    
    <content type="html"><![CDATA[<h1 id="easyCode-代码生成"><a href="#easyCode-代码生成" class="headerlink" title="easyCode 代码生成"></a>easyCode 代码生成</h1><h5 id="dao"><a href="#dao" class="headerlink" title="dao"></a>dao</h5><div class="hljs code-wrapper"><pre><code class="hljs java">##定义初始变量#set($tableName = $tool.append($tableInfo.name, &quot;Mapper&quot;))##设置回调$!callback.setFileName($tool.append($tableName, <span class="hljs-string">&quot;.java&quot;</span>))$!callback.setSavePath($tool.append($tableInfo.savePath, <span class="hljs-string">&quot;/mapper&quot;</span>))##拿到主键#if(!$tableInfo.pkColumn.isEmpty())    #set($pk = $tableInfo.pkColumn.get(0))#end#if($tableInfo.savePackageName)package $!&#123;tableInfo.savePackageName&#125;.#&#123;end&#125;mapper;<span class="hljs-keyword">import</span> $!&#123;tableInfo.savePackageName&#125;.entity.$!&#123;tableInfo.name&#125;;<span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Mapper;<span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Param;<span class="hljs-keyword">import</span> javax.validation.constraints.*;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-comment">/**</span><span class="hljs-comment"><span class="hljs-doctag">@Author</span>: $&#123;author&#125;</span><span class="hljs-comment"><span class="hljs-doctag">@CreateTime</span>: $&#123;time.currTime(&quot;yyyy-MM-dd HH:mm:ss&quot;)&#125;</span><span class="hljs-comment">*/</span><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> $!</span>&#123;tableName&#125; &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 通过主键查询数据</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> $!pk.name 主键</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 对象</span><span class="hljs-comment">     */</span>    $!&#123;tableInfo.name&#125; getById(<span class="hljs-meta">@NotNull</span> $!pk.shortType $!pk.name);    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 通过实体不为空的属性作为筛选条件查询单个</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 条件</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 对象</span><span class="hljs-comment">     */</span>    $!&#123;tableInfo.name&#125; getByEntity($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;));    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 通过实体不为空的属性作为筛选条件查询列表</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 条件</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 对象列表</span><span class="hljs-comment">     */</span>    List&lt;$!&#123;tableInfo.name&#125;&gt; listByEntity($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;));        <span class="hljs-comment">/**</span><span class="hljs-comment">     * 通过Id列表作为筛选条件查询列表，列表长度不为0</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> list 列表</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 对象列表</span><span class="hljs-comment">     */</span>    List&lt;$!&#123;tableInfo.name&#125;&gt; listByIds(<span class="hljs-meta">@NotEmpty</span> List&lt;$!pk.shortType&gt; list);    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 新增实体属性不为null的列</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 影响行数</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> $!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)</span>)</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 批量新增所有列，列表长度不能为0，且列表id统一为null或者统一不为null</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> list 实例</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 影响行数</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertBatch</span><span class="hljs-params">(<span class="hljs-meta">@NotEmpty</span> List&lt;$!&#123;tableInfo.name&#125;&gt; list)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 通过主键修改实体属性不为null的列</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 影响行数</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> $!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)</span>)</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 通过表字段修改实体属性不为null的列</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> where 条件</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> where set</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 影响行数</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateByField</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> <span class="hljs-meta">@Param(&quot;where&quot;)</span> $!&#123;tableInfo.name&#125; where, <span class="hljs-meta">@NotNull</span> <span class="hljs-meta">@Param(&quot;set&quot;)</span> $!&#123;tableInfo.name&#125; set)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 通过主键修改实体列表，列表长度不能为0，注意：当实体属性为null时，对应的列也会别更新为null</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> list 列表</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 影响行数</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateBatch</span><span class="hljs-params">(<span class="hljs-meta">@NotEmpty</span> List&lt;$!&#123;tableInfo.name&#125;&gt; list)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 通过主键删除</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> $!pk.name 主键</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 影响行数</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteById</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> $!pk.shortType $!pk.name)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 通过实体非空属性删除</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实体</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 影响行数</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteByEntity</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> $!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)</span>)</span>;      <span class="hljs-comment">/**</span><span class="hljs-comment">     * 通过主键列表删除，列表长度不能为0</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> list 列表</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 影响行数</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteByIds</span><span class="hljs-params">(<span class="hljs-meta">@NotEmpty</span> List&lt;$!pk.shortType&gt; list)</span></span>;        <span class="hljs-comment">/**</span><span class="hljs-comment">     * 查询行数</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 影响行数</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countAll</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 通过实体非空查询行数</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实体</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 影响行数</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countByEntity</span><span class="hljs-params">($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)</span>)</span>;    &#125;</code></pre></div><h5 id="mapper"><a href="#mapper" class="headerlink" title="mapper"></a>mapper</h5><div class="hljs code-wrapper"><pre><code class="hljs xml">##引入mybatis支持$!mybatisSupport##设置保存名称与保存位置$!callback.setFileName($tool.append($!&#123;tableInfo.name&#125;, &quot;Mapper.xml&quot;))$!callback.setSavePath($tool.append($modulePath, &quot;/src/main/resources/mapper&quot;))##拿到主键#if(!$tableInfo.pkColumn.isEmpty())    #set($pk = $tableInfo.pkColumn.get(0))#end<span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;$!&#123;tableInfo.savePackageName&#125;.mapper.$!&#123;tableInfo.name&#125;Mapper&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;$!&#123;tableInfo.savePackageName&#125;.entity.$!&#123;tableInfo.name&#125;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;$!&#123;tableInfo.name&#125;ResultMap&quot;</span>&gt;</span>#foreach($column in $tableInfo.fullColumn)        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;$!column.name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;$!column.obj.name&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;$!column.ext.jdbcType&quot;</span>/&gt;</span>#end    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;table_field&quot;</span>&gt;</span>      #allSqlColumn()          <span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span>           <span class="hljs-comment">&lt;!--通过Id查询单个--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;$!&#123;tableInfo.name&#125;ResultMap&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;$pk.type&quot;</span>&gt;</span>        select          <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;table_field&quot;</span> /&gt;</span>        from $!tableInfo.obj.name        where $!pk.obj.name = #&#123;$!pk.name,jdbcType=$!pk.ext.jdbcType&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>    <span class="hljs-comment">&lt;!--通过实体不为空的属性作为筛选条件查询列表--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;listByEntity&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;$!&#123;tableInfo.name&#125;ResultMap&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;$!&#123;tableInfo.savePackageName&#125;.entity.$!&#123;tableInfo.name&#125;&quot;</span>&gt;</span>        select          <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;table_field&quot;</span> /&gt;</span>        from $!tableInfo.obj.name        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span>#foreach($column in $tableInfo.fullColumn)            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;$!column.name != null&quot;</span>&gt;</span>                and $!column.obj.name = #&#123;$!column.name,jdbcType=$!column.ext.jdbcType&#125;            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>#end        <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>    <span class="hljs-comment">&lt;!--通过实体不为空的属性作为筛选条件查询单个--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getByEntity&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;$!&#123;tableInfo.name&#125;ResultMap&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;$!&#123;tableInfo.savePackageName&#125;.entity.$!&#123;tableInfo.name&#125;&quot;</span>&gt;</span>        select          <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;table_field&quot;</span> /&gt;</span>        from $!tableInfo.obj.name        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span>#foreach($column in $tableInfo.fullColumn)            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;$!column.name != null&quot;</span>&gt;</span>                and $!column.obj.name = #&#123;$!column.name,jdbcType=$!column.ext.jdbcType&#125;            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>#end        <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>    <span class="hljs-comment">&lt;!--通过Id列表作为筛选条件查询列表，列表长度不为0--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;listByIds&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;$!&#123;tableInfo.name&#125;ResultMap&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span>        select          <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;table_field&quot;</span> /&gt;</span>        from $!tableInfo.obj.name        where $!pk.obj.name in        <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span>            #&#123;item&#125;        <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>    <span class="hljs-comment">&lt;!--新增实体属性不为null的列--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insert&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;$!pk.name&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;$!&#123;tableInfo.savePackageName&#125;.entity.$!&#123;tableInfo.name&#125;&quot;</span>&gt;</span>        insert into $!&#123;tableInfo.obj.name&#125;        <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span>#foreach($column in  $tableInfo.fullColumn)          <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;$!column.name != null&quot;</span>&gt;</span>             $!column.obj.name,          <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>#end                  <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;values (&quot;</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span>#foreach($column in  $tableInfo.fullColumn)          <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;$!column.name != null&quot;</span>&gt;</span>             #&#123;$!column.name,jdbcType=$!column.ext.jdbcType&#125;,          <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>#end        <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span>    <span class="hljs-comment">&lt;!--批量新增所有列，列表长度不能为0，且列表id统一为null或者统一不为null--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertBatch&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;$!pk.name&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span>        insert into $!&#123;tableInfo.obj.name&#125;         (#foreach($column in $tableInfo.fullColumn)$!&#123;column.obj.name&#125;#if($velocityHasNext), #end#end)        values        <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span>         (#foreach($column in $tableInfo.fullColumn)#&#123;item.$!&#123;column.name&#125;,jdbcType=$!column.ext.jdbcType&#125;#if($velocityHasNext), #end#end)        <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span>    <span class="hljs-comment">&lt;!--通过主键修改实体属性不为null的列--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;update&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;$!&#123;tableInfo.savePackageName&#125;.entity.$!&#123;tableInfo.name&#125;&quot;</span>&gt;</span>        update $!&#123;tableInfo.obj.name&#125;        <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>#foreach($column in $tableInfo.otherColumn)            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;$!column.name != null#if($column.type.equals(&quot;</span><span class="hljs-attr">java.lang.String</span>&quot;)) <span class="hljs-attr">and</span> $!<span class="hljs-attr">column.name</span> != <span class="hljs-string">&#x27;&#x27;</span>#<span class="hljs-attr">end</span>&quot;&gt;</span>                $!column.obj.name = #&#123;$!column.name,jdbcType=$!column.ext.jdbcType&#125;,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>#end        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>        where $!pk.obj.name = #&#123;$!pk.name,jdbcType=$!pk.ext.jdbcType&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span>    <span class="hljs-comment">&lt;!--通过表字段修改实体属性不为null的列--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateByField&quot;</span>&gt;</span>        update $!&#123;tableInfo.obj.name&#125;        <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>#foreach($column in $tableInfo.otherColumn)            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;where.$!&#123;column.name&#125; == null and set.$!&#123;column.name&#125; != null#if($column.type.equals(&quot;</span><span class="hljs-attr">java.lang.String</span>&quot;)) <span class="hljs-attr">and</span> <span class="hljs-attr">set.</span>$!&#123;<span class="hljs-attr">column.name</span>&#125; != <span class="hljs-string">&#x27;&#x27;</span>#<span class="hljs-attr">end</span>&quot;&gt;</span>                $!column.obj.name = #&#123;set.$!&#123;column.name&#125;,jdbcType=$!column.ext.jdbcType&#125;,            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>#end        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span>#foreach($column in $tableInfo.fullColumn)            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;where.$!&#123;column.name&#125; != null&quot;</span>&gt;</span>                and $!column.obj.name = #&#123;where.$!&#123;column.name&#125;,jdbcType=$!column.ext.jdbcType&#125;            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>#end        <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span>    <span class="hljs-comment">&lt;!--通过主键修改实体列表，列表长度不能为0，注意：当实体属性为null时，对应的列也会别更新为null--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateBatch&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span>        update $!&#123;tableInfo.obj.name&#125;        <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;set&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span>#foreach($column in $tableInfo.otherColumn)            <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;$!&#123;column.obj.name&#125; = case&quot;</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">&quot;end,&quot;</span>&gt;</span>                 <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span>                  when $!pk.obj.name = #&#123;item.$!pk.name&#125; then #&#123;item.$!column.name&#125;                 <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span>#end        <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span>        where $!pk.obj.name in        <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;index&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span>            #&#123;item.$!pk.name,jdbcType=$!pk.ext.jdbcType&#125;        <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span>        <span class="hljs-comment">&lt;!--通过主键删除--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;$pk.type&quot;</span>&gt;</span>        delete from $!&#123;tableInfo.obj.name&#125; where $!pk.obj.name = #&#123;$!pk.name,jdbcType=$!pk.ext.jdbcType&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span>    <span class="hljs-comment">&lt;!--通过实体非空属性删除--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteByEntity&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;$!&#123;tableInfo.savePackageName&#125;.entity.$!&#123;tableInfo.name&#125;&quot;</span>&gt;</span>        delete from $!&#123;tableInfo.obj.name&#125;        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span>#foreach($column in $tableInfo.otherColumn)            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;$!column.name != null&quot;</span>&gt;</span>                and $!column.obj.name = #&#123;$!column.name,jdbcType=$!column.ext.jdbcType&#125;            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>#end        <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span>        <span class="hljs-comment">&lt;!--通过主键列表删除，列表长度不能为0--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteByIds&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span>        delete from $!&#123;tableInfo.obj.name&#125; where $!pk.obj.name in        <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span>            #&#123;item&#125;        <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;countAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span>        select count($!pk.obj.name) from $!&#123;tableInfo.obj.name&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;countByEntity&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;$!&#123;tableInfo.savePackageName&#125;.entity.$!&#123;tableInfo.name&#125;&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span>        select count($!pk.obj.name) from $!&#123;tableInfo.obj.name&#125;        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span>#foreach($column in $tableInfo.fullColumn)            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;$!column.name != null&quot;</span>&gt;</span>                and $!column.obj.name = #&#123;$!column.name,jdbcType=$!column.ext.jdbcType&#125;            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>#end        <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><h5 id="service"><a href="#service" class="headerlink" title="service"></a>service</h5><div class="hljs code-wrapper"><pre><code class="hljs java">##定义初始变量#set($tableName = $tool.append($tableInfo.name, &quot;Service&quot;))##设置回调$!callback.setFileName($tool.append($tableName, <span class="hljs-string">&quot;.java&quot;</span>))$!callback.setSavePath($tool.append($tableInfo.savePath, <span class="hljs-string">&quot;/service&quot;</span>))##拿到主键#if(!$tableInfo.pkColumn.isEmpty())    #set($pk = $tableInfo.pkColumn.get(0))#end#if($tableInfo.savePackageName)package $!&#123;tableInfo.savePackageName&#125;.#&#123;end&#125;service;<span class="hljs-keyword">import</span> $!&#123;tableInfo.savePackageName&#125;.mapper.$!&#123;tableInfo.name&#125;Mapper;<span class="hljs-keyword">import</span> $!&#123;tableInfo.savePackageName&#125;.entity.$!&#123;tableInfo.name&#125;;<span class="hljs-keyword">import</span> com.github.pagehelper.PageHelper;<span class="hljs-keyword">import</span> com.github.pagehelper.PageInfo;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-comment">/**</span><span class="hljs-comment"><span class="hljs-doctag">@Author</span>: $&#123;author&#125;</span><span class="hljs-comment"><span class="hljs-doctag">@CreateTime</span>: $&#123;time.currTime(&quot;yyyy-MM-dd HH:mm:ss&quot;)&#125;</span><span class="hljs-comment">*/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> $!</span>&#123;tableName&#125; &#123;       <span class="hljs-comment">/**</span><span class="hljs-comment">     * 通过主键查询数据</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> $!pk.name 主键</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 对象</span><span class="hljs-comment">     */</span>    $!&#123;tableInfo.name&#125; getById($!pk.shortType $!pk.name);    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 通过实体不为空的属性作为筛选条件查询单个</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 条件</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 对象</span><span class="hljs-comment">     */</span>    $!&#123;tableInfo.name&#125; getByEntity($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;));    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 通过实体不为空的属性作为筛选条件查询列表</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 条件</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 对象列表</span><span class="hljs-comment">     */</span>    List&lt;$!&#123;tableInfo.name&#125;&gt; listByEntity($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;));        <span class="hljs-comment">/**</span><span class="hljs-comment">     * 条件分页查询</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> $!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 查询条件</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> page 起始标号</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pageSize 查询条目</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 对象列表</span><span class="hljs-comment">     */</span>    <span class="hljs-function">PageInfo <span class="hljs-title">listPageByEntity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> page, <span class="hljs-keyword">int</span> pageSize, $!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)</span>)</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 条件分页查询</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> page 起始标号</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pageSize 查询条目</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 对象列表</span><span class="hljs-comment">     */</span>    <span class="hljs-function">PageInfo <span class="hljs-title">listPage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> page, <span class="hljs-keyword">int</span> pageSize)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Id列表查询对象列表</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ids Id列表</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 对象列表</span><span class="hljs-comment">     */</span>    List&lt;$!&#123;tableInfo.name&#125;&gt; listByIds(List&lt;$!pk.shortType&gt; ids);    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 插入</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 对象</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 影响行数</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)</span>)</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 列表插入</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> list 列表对象</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 影响行数</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertBatch</span><span class="hljs-params">(List&lt;$!&#123;tableInfo.name&#125;&gt; list)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 更新</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 对象</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 影响行数</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)</span>)</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 列表更新</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> list 列表对象</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 影响行数</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateBatch</span><span class="hljs-params">(List&lt;$!&#123;tableInfo.name&#125;&gt; list)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 删除</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> $!pk.name 主键</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 影响行数</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteById</span><span class="hljs-params">($!pk.shortType $!pk.name)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 条件删除</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 对象</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 影响行数</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteByEntity</span><span class="hljs-params">($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)</span>)</span>;      <span class="hljs-comment">/**</span><span class="hljs-comment">     * 主键列表删除</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> list 主键列表</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 影响行数</span><span class="hljs-comment">     */</span>     <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteByIds</span><span class="hljs-params">(List&lt;$!pk.shortType&gt; list)</span></span>;         <span class="hljs-comment">/**</span><span class="hljs-comment">     * 数据条目</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 影响行数</span><span class="hljs-comment">     */</span>     <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countAll</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 条件查询数目</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 对象</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 影响行数</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countByEntity</span><span class="hljs-params">($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)</span>)</span>;&#125;</code></pre></div><h5 id="serviceImpl"><a href="#serviceImpl" class="headerlink" title="serviceImpl"></a>serviceImpl</h5><div class="hljs code-wrapper"><pre><code class="hljs java">##定义初始变量#set($tableName = $tool.append($tableInfo.name, &quot;ServiceImpl&quot;))##设置回调$!callback.setFileName($tool.append($tableName, <span class="hljs-string">&quot;.java&quot;</span>))$!callback.setSavePath($tool.append($tableInfo.savePath, <span class="hljs-string">&quot;/service/impl&quot;</span>))##拿到主键#if(!$tableInfo.pkColumn.isEmpty())    #set($pk = $tableInfo.pkColumn.get(0))#end#if($tableInfo.savePackageName)package $!&#123;tableInfo.savePackageName&#125;.#&#123;end&#125;service.impl;<span class="hljs-keyword">import</span> $!&#123;tableInfo.savePackageName&#125;.mapper.$!&#123;tableInfo.name&#125;Mapper;<span class="hljs-keyword">import</span> $!&#123;tableInfo.savePackageName&#125;.service.$!&#123;tableInfo.name&#125;Service;<span class="hljs-keyword">import</span> $!&#123;tableInfo.savePackageName&#125;.entity.$!&#123;tableInfo.name&#125;;<span class="hljs-keyword">import</span> javax.annotation.Resource;<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<span class="hljs-keyword">import</span> com.github.pagehelper.PageHelper;<span class="hljs-keyword">import</span> com.github.pagehelper.PageInfo;<span class="hljs-keyword">import</span> java.util.Date;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-comment">/**</span><span class="hljs-comment"><span class="hljs-doctag">@Author</span>: $&#123;author&#125;</span><span class="hljs-comment"><span class="hljs-doctag">@CreateTime</span>: $&#123;time.currTime(&quot;yyyy-MM-dd HH:mm:ss&quot;)&#125;</span><span class="hljs-comment">*/</span><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> $!</span>&#123;tableName&#125; implements $!&#123;tableInfo.name&#125;Service &#123;    <span class="hljs-meta">@Resource(type = $!&#123;tableInfo.name&#125;Mapper.class)</span>    <span class="hljs-keyword">private</span> $!&#123;tableInfo.name&#125;Mapper $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)Mapper;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> $!&#123;tableInfo.name&#125; getById($!pk.shortType $!pk.name) &#123;        <span class="hljs-keyword">return</span> $!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.getById($!&#123;pk.name&#125;);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> $!&#123;tableInfo.name&#125; getByEntity($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)) &#123;        <span class="hljs-keyword">return</span> $!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.getByEntity($!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> List&lt;$!&#123;tableInfo.name&#125;&gt; listByEntity($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)) &#123;        <span class="hljs-keyword">return</span> $!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.listByEntity($!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;);    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> PageInfo <span class="hljs-title">listPageByEntity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> page, <span class="hljs-keyword">int</span> pageSize, $!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)</span>) </span>&#123;        PageHelper.startPage(page,pageSize);        List&lt;$!&#123;tableInfo.name&#125;&gt; list = $!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.listByEntity($!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PageInfo(list);    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> PageInfo <span class="hljs-title">listPage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> page, <span class="hljs-keyword">int</span> pageSize)</span> </span>&#123;        PageHelper.startPage(page,pageSize);        List&lt;$!&#123;tableInfo.name&#125;&gt; list = $!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.listByEntity(<span class="hljs-keyword">new</span> $!&#123;tableInfo.name&#125;());        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PageInfo(list);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> List&lt;$!&#123;tableInfo.name&#125;&gt; listByIds(List&lt;$!pk.shortType&gt; ids) &#123;        <span class="hljs-keyword">return</span> $!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.listByIds(ids);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)</span>) </span>&#123;        Date date = <span class="hljs-keyword">new</span> Date();        $!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;.setCreateTime(date);        $!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;.setUpdateTime(date);        <span class="hljs-keyword">return</span> $!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.insert($!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;);    &#125;       <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">insertBatch</span><span class="hljs-params">(List&lt;$!&#123;tableInfo.name&#125;&gt; list)</span> </span>&#123;        <span class="hljs-keyword">return</span> $!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.insertBatch(list);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)</span>) </span>&#123;        $!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;.setUpdateTime(<span class="hljs-keyword">new</span> Date());        <span class="hljs-keyword">return</span> $!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.update($!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">updateBatch</span><span class="hljs-params">(List&lt;$!&#123;tableInfo.name&#125;&gt; list)</span> </span>&#123;        <span class="hljs-keyword">return</span> $!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.updateBatch(list);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">deleteById</span><span class="hljs-params">($!pk.shortType $!pk.name)</span> </span>&#123;        <span class="hljs-keyword">return</span> $!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.deleteById($!pk.name);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">deleteByEntity</span><span class="hljs-params">($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)</span>) </span>&#123;        <span class="hljs-keyword">return</span> $!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.deleteByEntity($!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;);    &#125;      <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">deleteByIds</span><span class="hljs-params">(List&lt;$!pk.shortType&gt; list)</span> </span>&#123;        <span class="hljs-keyword">return</span> $!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.deleteByIds(list);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countAll</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> $!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.countAll();    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countByEntity</span><span class="hljs-params">($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)</span>) </span>&#123;        <span class="hljs-keyword">return</span> $!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.countByEntity($!tool.firstLowerCase($!&#123;tableInfo.name&#125;));    &#125;&#125;</code></pre></div><h5 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h5><div class="hljs code-wrapper"><pre><code class="hljs java">##定义初始变量#set($tableName = $tool.append($tableInfo.name, &quot;Controller&quot;))##设置回调$!callback.setFileName($tool.append($tableName, <span class="hljs-string">&quot;.java&quot;</span>))$!callback.setSavePath($tool.append($tableInfo.savePath, <span class="hljs-string">&quot;/controller&quot;</span>))##拿到主键#if(!$tableInfo.pkColumn.isEmpty())    #set($pk = $tableInfo.pkColumn.get(0))#end#if($tableInfo.savePackageName)package $!&#123;tableInfo.savePackageName&#125;.#&#123;end&#125;controller;<span class="hljs-keyword">import</span> $!&#123;tableInfo.savePackageName&#125;.entity.$!&#123;tableInfo.name&#125;;<span class="hljs-keyword">import</span> $!&#123;tableInfo.savePackageName&#125;.service.$!&#123;tableInfo.name&#125;Service;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.*;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-comment">/**</span><span class="hljs-comment"><span class="hljs-doctag">@Author</span>: $&#123;author&#125;</span><span class="hljs-comment"><span class="hljs-doctag">@CreateTime</span>: $&#123;time.currTime(&quot;yyyy-MM-dd HH:mm:ss&quot;)&#125;</span><span class="hljs-comment">*/</span><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping(&quot;/$!tool.firstLowerCase($tableInfo.name)&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> $!</span>&#123;tableName&#125; &#123;        <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> $!&#123;tableInfo.name&#125;Service $!tool.firstLowerCase($tableInfo.name)Service;    <span class="hljs-meta">@GetMapping(&quot;/get/&#123;$!pk.name&#125;&quot;)</span>    <span class="hljs-keyword">public</span> ResultDTO&lt;$!&#123;tableInfo.name&#125;&gt; getById(<span class="hljs-meta">@PathVariable</span> $!pk.shortType $!pk.name) &#123;        $tableInfo.name $!tool.firstLowerCase($tableInfo.name) = $!&#123;tool.firstLowerCase($tableInfo.name)&#125;Service.getById(id);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResultDTO&lt;&gt;(<span class="hljs-keyword">true</span>, ResultCode.SUCCESS, ResultCode.MSG_SUCCESS, $!tool.firstLowerCase($tableInfo.name)!=<span class="hljs-keyword">null</span>?$!tool.firstLowerCase($tableInfo.name):<span class="hljs-keyword">new</span> $!&#123;tableInfo.name&#125;());    &#125;    <span class="hljs-meta">@GetMapping(&quot;/get&quot;)</span>    <span class="hljs-keyword">public</span> ResultDTO&lt;$!&#123;tableInfo.name&#125;&gt; getByEntity($tableInfo.name $!tool.firstLowerCase($tableInfo.name)) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResultDTO&lt;&gt;(<span class="hljs-keyword">true</span>, ResultCode.SUCCESS, ResultCode.MSG_SUCCESS, $!&#123;tool.firstLowerCase($tableInfo.name)&#125;Service.getByEntity($!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;));    &#125;    <span class="hljs-meta">@GetMapping(&quot;/list&quot;)</span>    <span class="hljs-keyword">public</span> ResultDTO&lt;List&lt;$!&#123;tableInfo.name&#125;&gt;&gt; list($tableInfo.name $!tool.firstLowerCase($tableInfo.name)) &#123;        List&lt;$tableInfo.name&gt; $!&#123;tool.firstLowerCase($tableInfo.name)&#125;List = $!&#123;tool.firstLowerCase($tableInfo.name)&#125;Service.listByEntity($!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResultDTO&lt;&gt;(<span class="hljs-keyword">true</span>, ResultCode.SUCCESS, ResultCode.MSG_SUCCESS, $!&#123;tool.firstLowerCase($tableInfo.name)&#125;List);    &#125;        <span class="hljs-meta">@GetMapping(&quot;/pageListByEntity/&#123;page&#125;/&#123;size&#125;&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResultDTO&lt;PageInfo&gt; <span class="hljs-title">listPageByEntity</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(value = &quot;page&quot;)</span><span class="hljs-keyword">int</span> page, <span class="hljs-meta">@PathVariable(value = &quot;size&quot;)</span><span class="hljs-keyword">int</span> size, $tableInfo.name $!tool.firstLowerCase($tableInfo.name)</span>) </span>&#123;        PageInfo pageInfo = $!&#123;tool.firstLowerCase($tableInfo.name)&#125;Service.listPageByEntity(page, size, $!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResultDTO&lt;&gt;(<span class="hljs-keyword">true</span>, ResultCode.SUCCESS, ResultCode.MSG_SUCCESS, pageInfo);    &#125;        <span class="hljs-meta">@GetMapping(&quot;/pageList/&#123;page&#125;/&#123;size&#125;&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResultDTO&lt;PageInfo&gt; <span class="hljs-title">listPage</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(value = &quot;page&quot;)</span><span class="hljs-keyword">int</span> page, <span class="hljs-meta">@PathVariable(value = &quot;size&quot;)</span><span class="hljs-keyword">int</span> size)</span> </span>&#123;        PageInfo pageInfo = $!&#123;tool.firstLowerCase($tableInfo.name)&#125;Service.listPage(page, size);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResultDTO&lt;&gt;(<span class="hljs-keyword">true</span>, ResultCode.SUCCESS, ResultCode.MSG_SUCCESS, pageInfo);    &#125;    <span class="hljs-meta">@PostMapping(&quot;/insert&quot;)</span>    <span class="hljs-keyword">public</span> ResultDTO&lt;$tableInfo.name&gt; insert(<span class="hljs-meta">@RequestBody</span> $tableInfo.name $!tool.firstLowerCase($tableInfo.name))&#123;        $!&#123;tool.firstLowerCase($tableInfo.name)&#125;Service.insert($!tool.firstLowerCase($tableInfo.name));        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResultDTO&lt;&gt;(<span class="hljs-keyword">true</span>, ResultCode.SUCCESS, ResultCode.MSG_SUCCESS, $!tool.firstLowerCase($tableInfo.name));    &#125;        <span class="hljs-meta">@PostMapping(&quot;/insertBatch&quot;)</span>    <span class="hljs-keyword">public</span> ResultDTO&lt;List&lt;$tableInfo.name&gt;&gt; insert(<span class="hljs-meta">@RequestBody</span> List&lt; $tableInfo.name&gt; $!tool.firstLowerCase($tableInfo.name)s)&#123;        $!&#123;tool.firstLowerCase($tableInfo.name)&#125;Service.insertBatch($!tool.firstLowerCase($tableInfo.name)s);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResultDTO&lt;&gt;(<span class="hljs-keyword">true</span>, ResultCode.SUCCESS, ResultCode.MSG_SUCCESS, $!tool.firstLowerCase($tableInfo.name)s);    &#125;    <span class="hljs-meta">@PutMapping(&quot;/update&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResultDTO&lt;Boolean&gt; <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> $tableInfo.name $!tool.firstLowerCase($tableInfo.name)</span>)</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResultDTO&lt;&gt;(<span class="hljs-keyword">true</span>, ResultCode.SUCCESS, ResultCode.MSG_SUCCESS, $!&#123;tool.firstLowerCase($tableInfo.name)&#125;Service.update($!tool.firstLowerCase($tableInfo.name))==<span class="hljs-number">1</span>);    &#125;        <span class="hljs-meta">@PutMapping(&quot;/updateBatch&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResultDTO&lt;Boolean&gt; <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> List&lt;$tableInfo.name&gt; $!tool.firstLowerCase($tableInfo.name)</span>s)</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResultDTO&lt;&gt;(<span class="hljs-keyword">true</span>, ResultCode.SUCCESS, ResultCode.MSG_SUCCESS, $!&#123;tool.firstLowerCase($tableInfo.name)&#125;Service.updateBatch($!tool.firstLowerCase($tableInfo.name)s) == $!tool.firstLowerCase($tableInfo.name)s.size());    &#125;    <span class="hljs-meta">@DeleteMapping(&quot;/delete/&#123;$!pk.name&#125;&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResultDTO&lt;Boolean&gt; <span class="hljs-title">deleteOne</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> $!pk.shortType $!pk.name)</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResultDTO&lt;&gt;(<span class="hljs-keyword">true</span>, ResultCode.SUCCESS, ResultCode.MSG_SUCCESS, $!&#123;tool.firstLowerCase($tableInfo.name)&#125;Service.deleteById($!pk.name)==<span class="hljs-number">1</span>);    &#125;        <span class="hljs-meta">@DeleteMapping(&quot;/deleteByEntity/&#123;$!pk.name&#125;&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResultDTO&lt;Boolean&gt; <span class="hljs-title">deleteOne</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> $tableInfo.name $!tool.firstLowerCase($tableInfo.name)</span>)</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResultDTO&lt;&gt;(<span class="hljs-keyword">true</span>, ResultCode.SUCCESS, ResultCode.MSG_SUCCESS, $!&#123;tool.firstLowerCase($tableInfo.name)&#125;Service.deleteByEntity($!tool.firstLowerCase($tableInfo.name)) == <span class="hljs-number">1</span>);    &#125;    <span class="hljs-meta">@DeleteMapping(&quot;/delete&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResultDTO&lt;Integer&gt; <span class="hljs-title">deleteBatch</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> List&lt;$!pk.shortType&gt; $!&#123;pk.name&#125;s)</span></span>&#123;        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> ($!&#123;pk.name&#125;s!=<span class="hljs-keyword">null</span>&amp;&amp;$!&#123;pk.name&#125;s.size()&gt;<span class="hljs-number">0</span>)&#123;             result = $!&#123;tool.firstLowerCase($tableInfo.name)&#125;Service.deleteByIds($!&#123;pk.name&#125;s);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResultDTO&lt;&gt;(<span class="hljs-keyword">true</span>, ResultCode.SUCCESS, ResultCode.MSG_SUCCESS, result);    &#125;&#125;</code></pre></div><h5 id="entity"><a href="#entity" class="headerlink" title="entity"></a>entity</h5><div class="hljs code-wrapper"><pre><code class="hljs java">##引入宏定义$!init$!define##使用宏定义设置回调（保存位置与文件后缀）#save(&quot;/entity&quot;, &quot;.java&quot;)##使用宏定义设置包后缀#setPackageSuffix(&quot;entity&quot;)##使用全局变量实现默认包导入$!autoImport<span class="hljs-keyword">import</span> java.io.Serializable; ##使用宏定义实现类注释信息#tableComment(&quot;实体类&quot;)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> $!</span>&#123;tableInfo.name&#125; implements Serializable &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = $!tool.serial();#foreach($column in $tableInfo.fullColumn)    #if($&#123;column.comment&#125;)    <span class="hljs-comment">/**</span><span class="hljs-comment">      *$&#123;column.comment&#125;</span><span class="hljs-comment">      */</span>    #end     <span class="hljs-keyword">private</span> $!&#123;tool.getClsNameByFullName($column.type)&#125; $!&#123;column.name&#125;;#end#foreach($column in $tableInfo.fullColumn)    ##使用宏定义实现get,set方法    #getSetMethod($column)#end &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>easyCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luna-commons-common</title>
    <link href="/2020/08/10/luna-commons-common/"/>
    <url>/2020/08/10/luna-commons-common/</url>
    
    <content type="html"><![CDATA[<h2 id="基础工具包Api"><a href="#基础工具包Api" class="headerlink" title="基础工具包Api"></a>基础工具包Api</h2><h3 id="http操作"><a href="#http操作" class="headerlink" title="http操作"></a>http操作</h3><h5 id="HttpUtils类"><a href="#HttpUtils类" class="headerlink" title="HttpUtils类"></a>HttpUtils类</h5><ol><li>普通get请求</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * get</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> host 主机</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> path 路径</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> headers 请求头</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> queries 请求参数</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HttpResponse <span class="hljs-title">doGet</span><span class="hljs-params">(String host, String path, Map&lt;String, String&gt; headers,Map&lt;String, String&gt; queries)</span> </span></code></pre></div><ol start="2"><li>参数/文件post请求</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Post File/form</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> host 主机</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> path 路径</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> headers 请求头</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> queries 请求参数</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> bodies &lt;p&gt;Map&lt;文件名或者参数key,文件地址或者参数value&gt;&lt;p/&gt;</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HttpResponse <span class="hljs-title">doPost</span><span class="hljs-params">(String host, String path, Map&lt;String, String&gt; headers,</span></span><span class="hljs-function"><span class="hljs-params">    Map&lt;String, String&gt; queries, Map&lt;String, String&gt; bodies)</span></span></code></pre></div><ol start="3"><li>流post请求</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Post stream</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> host 主机</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> path 路径</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> headers 请求头</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> queries 请求参数</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> body 字节流</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HttpResponse <span class="hljs-title">doPost</span><span class="hljs-params">(String host, String path, Map&lt;String, String&gt; headers,</span></span><span class="hljs-function"><span class="hljs-params">    Map&lt;String, String&gt; queries, <span class="hljs-keyword">byte</span>[] body)</span></span></code></pre></div><ol start="4"><li>字符串post请求</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Post String</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> host 主机</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> path 路径</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> headers 请求头</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> queries 请求参数</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> body 字符串</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HttpResponse <span class="hljs-title">doPost</span><span class="hljs-params">(String host, String path, Map&lt;String, String&gt; headers,</span></span><span class="hljs-function"><span class="hljs-params">    Map&lt;String, String&gt; queries, String body)</span> </span></code></pre></div><ol start="5"><li>返回结果解析及检查</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 检测响应体</span><span class="hljs-comment">     * </span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> httpResponse</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">checkResponseAndGetResult</span><span class="hljs-params">(HttpResponse httpResponse, <span class="hljs-keyword">boolean</span> isEnsure)</span></span></code></pre></div><ol start="6"><li>简单的检查是否为网络路径</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">    * 检查是不是网络路径</span><span class="hljs-comment">    * </span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> url</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isNetUrl</span><span class="hljs-params">(String url)</span> </span>&#123;</code></pre></div><h3 id="jsonfile"><a href="#jsonfile" class="headerlink" title="jsonfile"></a>jsonfile</h3><h5 id="InformationConverter类"><a href="#InformationConverter类" class="headerlink" title="InformationConverter类"></a>InformationConverter类</h5><ol><li>读取JSON文件操作</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 读取json文件并转换为JSONObject</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> path JSON文件路径</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> a fastjson JSONObject</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> JSONObject <span class="hljs-title">fileToJson</span><span class="hljs-params">(String path)</span></span></code></pre></div><ol start="2"><li>JSONObject写入JSON文件</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * write json String to a json file</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> text the json text needs to write</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> path the json file path needs to save</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stringToFile</span><span class="hljs-params">(String text, String path)</span></span></code></pre></div><ol start="3"><li>获取JSON文件中的指定值</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * get item from json text file</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> path the json file path</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item the item you want to get, can be para, header</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> a Map, key is String, value is Object</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;String, Object&gt; <span class="hljs-title">getItem</span><span class="hljs-params">(String path, String item)</span></span></code></pre></div><ol start="4"><li>将JSONObject的值转为HashMap</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Convert jsonobject to hashMap</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> object the jsonObject need to convert</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the hashMap(String, String)</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HashMap&lt;String, String&gt; <span class="hljs-title">jsonToHasMap</span><span class="hljs-params">(JSONObject object)</span></span></code></pre></div><h3 id="okHttp"><a href="#okHttp" class="headerlink" title="okHttp"></a>okHttp</h3><ol><li>Get请求</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * send a get to a site</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> url the website url</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> para the parameter hashMap, use put to add</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> header the header hasMap, use put to add</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> a response json object</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> JSONObject <span class="hljs-title">get</span><span class="hljs-params">(String url, HashMap&lt;String,String&gt; para, HashMap&lt;String,String&gt; header)</span></span></code></pre></div><ol start="2"><li>POST请求</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * send a post to a site</span><span class="hljs-comment">     * </span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> url the website url</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> para the parameter hashMap, use put to add</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> header the header hasMap, use put to add</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bodyFormat the body hashMap, if use none, put(&quot;none&quot;,&quot;&quot;), if form-data, put(key,value)</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> a response json object</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> JSONObject <span class="hljs-title">post</span><span class="hljs-params">(String url, HashMap&lt;String, String&gt; para, HashMap&lt;String, String&gt; header,</span></span><span class="hljs-function"><span class="hljs-params">        HashMap&lt;String, String&gt; bodyFormat)</span></span></code></pre></div><h3 id="utils"><a href="#utils" class="headerlink" title="utils"></a>utils</h3><h5 id="fileUtils"><a href="#fileUtils" class="headerlink" title="fileUtils"></a>fileUtils</h5><ol><li>获取文件夹内文件数</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 获取文件夹内文件数目</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> path</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">getFileLength</span><span class="hljs-params">(String path)</span> </span>&#123;</code></pre></div><ol start="2"><li>批量转换文件类型</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 批量转换文件类型</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> path 文件夹路径</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> oldExt 原本类型</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> newExt 转换后类型</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">renameFiles</span><span class="hljs-params">(String path, String oldExt, String newExt)</span></span></code></pre></div><ol start="3"><li>复制文件</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 复制文件</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> input 输入</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> output 输出</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IOException</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">copyFile</span><span class="hljs-params">(File input, File output)</span> </span></code></pre></div><ol start="4"><li>批量复制文件</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 批量复制文件</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> inputPath 输入目录</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> outputPath 输出目录</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> number 每个文件复制数量</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> inputPrefix 输入文件前缀</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> outputPrefix 输出文件前缀</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> inputType 输入文件类型</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> outputType 输出文件类型</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 文件操作数</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IOException</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">copyFile</span><span class="hljs-params">(String inputPath, String outputPath, Integer number, String inputPrefix,</span></span><span class="hljs-function"><span class="hljs-params">    String outputPrefix, String inputType, String outputType)</span></span></code></pre></div><h5 id="imageUtils"><a href="#imageUtils" class="headerlink" title="imageUtils"></a>imageUtils</h5><ol><li>图片/文件转为字节</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 图片转字节</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> imgFile 文件路径</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] getBytes(String imgFile)</code></pre></div><ol start="2"><li>字节转图片</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 字节转图片</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> data 数据</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> path 输出路径</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">byte2image</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] data, String path)</span></span></code></pre></div><h5 id="textUtils"><a href="#textUtils" class="headerlink" title="textUtils"></a>textUtils</h5><p>CharsetKit 字符串处理工具栏</p><p>Convert 类型转换器</p><p> DatePattern 日期格式匹配</p><p>IdWorker Id生成器</p><p>RandomValueUtil 随机姓名生成器</p><p>StrFormatter 字符串格式化,替换{}标识</p>]]></content>
    
    
    <categories>
      
      <category>project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>commons</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luna-commons</title>
    <link href="/2020/07/27/luna-commons/"/>
    <url>/2020/07/27/luna-commons/</url>
    
    <content type="html"><![CDATA[<h1 id="luna-commons"><a href="#luna-commons" class="headerlink" title="luna-commons"></a>luna-commons</h1><!-- PROJECT SHIELDS --><p><a href="https://github.com/czy1024/luna-commons/graphs/contributors"><img src="https://img.shields.io/github/contributors/czy1024/luna-commons.svg?style=flat-square" alt="Contributors"></a><br><a href="https://github.com/czy1024/luna-commons/network/members"><img src="https://img.shields.io/github/forks/czy1024/luna-commons.svg?style=flat-square" alt="Forks"></a><br><a href="https://github.com/czy1024/luna-commons/stargazers"><img src="https://img.shields.io/github/stars/czy1024/luna-commons.svg?style=flat-square" alt="Stargazers"></a><br><a href="https://img.shields.io/github/issues/czy1024/luna-commons.svg"><img src="https://img.shields.io/github/issues/czy1024/luna-commons.svg?style=flat-square" alt="Issues"></a><br><a href="https://github.com/czy1024/luna-commons/blob/master/LICENSE.txt"><img src="https://img.shields.io/github/license/czy1024/luna-commons.svg?style=flat-square" alt="MIT License"></a><br><a href="https://linkedin.com/in/luna-commons"><img src="https://img.shields.io/badge/-LinkedIn-black.svg?style=flat-square&logo=linkedin&colorB=555" alt="LinkedIn"></a></p><!-- PROJECT LOGO --><br /><p align="center">  <a href="https://github.com/czy1024/luna-commons/">    <img src="https://i.loli.net/2020/07/28/5MzIVArBZyp8NgX.png" alt="Logo" width="80" height="80">  </a>  <h3 align="center">"完美的"开发工具</h3>  <p align="center">    市场上许多界面和工具的集合,例如ftp,httpd等文件与工具操作，包括但不限于图像处理、人脸识别等的api。让你免去寻找工具的烦恼    <br />    <a href="https://github.com/czy1024/luna-commons"><strong>探索本项目的文档 »</strong></a>    <br />    <br />    <a href="">查看Demo</a>    ·    <a href="">报告Bug</a>    ·    <a href="https://github.com/czy1024/luna-commons/issues">提出新特性</a>  </p></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97">上手指南</a><ul><li><a href="#%E5%BC%80%E5%8F%91%E5%89%8D%E7%9A%84%E9%85%8D%E7%BD%AE%E8%A6%81%E6%B1%82">开发前的配置要求</a></li><li><a href="#%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4">安装步骤</a></li></ul></li><li><a href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E8%AF%B4%E6%98%8E">文件目录说明</a></li><li><a href="#%E9%83%A8%E7%BD%B2">部署</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E6%A1%86%E6%9E%B6">使用到的框架</a></li><li><a href="#%E8%B4%A1%E7%8C%AE%E8%80%85">贡献者</a><ul><li><a href="#%E5%A6%82%E4%BD%95%E5%8F%82%E4%B8%8E%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE">如何参与开源项目</a></li></ul></li><li><a href="#%E4%BD%9C%E8%80%85">作者</a></li><li><a href="#%E9%B8%A3%E8%B0%A2">鸣谢</a></li></ul><h3 id="上手指南"><a href="#上手指南" class="headerlink" title="上手指南"></a>上手指南</h3><h6 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a><strong>安装步骤</strong></h6><ol><li>Get a free API Key at <a href="https://ai.baidu.com/sdk#ocr">https://ai.baidu.com/sdk#ocr</a></li><li>Get a free API Key at <a href="https://cloud.tencent.com/">https://cloud.tencent.com</a></li><li>Get a free API Key at <a href="https://account.aliyun.com/">https://account.aliyun.com</a></li><li>找到config目录下的xxxConfigValue,application.properties</li><li>Clone the repo</li></ol><div class="hljs code-wrapper"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://github.com/czy1024/luna-commons.git</code></pre></div><h3 id="文件目录说明"><a href="#文件目录说明" class="headerlink" title="文件目录说明"></a>文件目录说明</h3><p>eg:</p><div class="hljs code-wrapper"><pre><code class="hljs gradle">luna-commons-loc├── ARCHITECTURE.md├── LICENSE.txt├── .gitignore├── README.md├── luna-commons-ali│  ├── pom.xml│  │  ├── <span class="hljs-regexp">/config/</span>│  │  └── <span class="hljs-regexp">/api/</span>│  └──── <span class="hljs-regexp">/resource/</span>├── luna-commons-api│  ├── pom.xml│  │  ├── <span class="hljs-regexp">/config/</span>│  │  └── <span class="hljs-regexp">/api/</span>│  └──── <span class="hljs-regexp">/resource/</span>├── luna-commons-baidu│  ├── pom.xml│  │  ├── <span class="hljs-regexp">/config/</span>│  │  └── <span class="hljs-regexp">/api/</span>│  └──── <span class="hljs-regexp">/resource/</span>├── luna-commons-common│  ├── pom.xml│  │  ├── <span class="hljs-regexp">/config/</span>│  │  └── <span class="hljs-regexp">/api/</span>│  └──── <span class="hljs-regexp">/resource/</span>├── luna-commons-<span class="hljs-keyword">file</span>│  ├── pom.xml│  │  ├── <span class="hljs-regexp">/config/</span>│  │  └── <span class="hljs-regexp">/api/</span>│  └──── <span class="hljs-regexp">/resource/</span>├── luna-commons-media│  ├── pom.xml│  │  ├── <span class="hljs-regexp">/config/</span>│  │  └── <span class="hljs-regexp">/api/</span>│  └──── <span class="hljs-regexp">/resource/</span>├── luna-commons-message│  ├── pom.xml│  │  ├── <span class="hljs-regexp">/config/</span>│  │  └── <span class="hljs-regexp">/api/</span>│  └──── <span class="hljs-regexp">/resource/</span>├── luna-commons-tencent│  ├── pom.xml│  │  ├── <span class="hljs-regexp">/config/</span>│  │  └── <span class="hljs-regexp">/api/</span>│  └──── <span class="hljs-regexp">/resource/</span>└── pom.xml</code></pre></div><h2 id="各-Module-介绍"><a href="#各-Module-介绍" class="headerlink" title="各 Module 介绍"></a>各 Module 介绍</h2><table><thead><tr><th>Module 名称</th><th>Module 介绍</th></tr></thead><tbody><tr><td><a href="./luna-commons-ali">luna-commons-ali</a></td><td>关于阿里oss和alpay支付宝的使用</td></tr><tr><td><a href="./luna-commons-common">luna-commons-common</a></td><td>基础工具包,加密字符等操作,http网络操作</td></tr><tr><td><a href="./luna-commons-api">luna-commons-api</a></td><td>api集合模块,现阶段为学小易查题目接口,<a href="https://github.com/czy1024/luna-commons/wiki/sm.ms-api-todo">sm.ms 图床api</a></td></tr><tr><td><a href="./luna-commons-baidu">luna-commons-baidu</a></td><td>百度Api集合,包含人脸识别,人证审核百度地图等api封装</td></tr><tr><td><a href="./luna-commons-file">luna-commons-file</a></td><td>文件处理工具集合,包括ftp,httpd,fastdfs等文件操作</td></tr><tr><td><a href="./luna-commons-media">luna-commons-media</a></td><td>媒体流处理工具,包含ffmpeg工具封装,JavaCv图像处理</td></tr></tbody></table><p>| <a href="./luna-commons-message">luna-commons-message</a>       |  消息发送,短信邮件消息发送,有html模板附赠 <a href="https://github.com/czy1024/luna-commons/blob/master/luna-commons-message/src/main/resources/static/luna-message.html">HTML邮件模板</a><br>| <a href="./luna-commons-tencent">luna-commons-tencent</a> | 腾讯Api集合,包含人脸识别,人证审核腾讯地图等api封装 |</p><h3 id="开发的架构"><a href="#开发的架构" class="headerlink" title="开发的架构"></a>开发的架构</h3><p>请阅读<a href="https://github.com/czy1024/luna-commons/blob/master/ARCHITECTURE.md">ARCHITECTURE.md</a> 查阅为该项目的架构。</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>请前往各个小项目查看</p><h3 id="使用到的框架"><a href="#使用到的框架" class="headerlink" title="使用到的框架"></a>使用到的框架</h3><ul><li><a href="https://spring.io/">springboot</a></li></ul><h3 id="贡献者"><a href="#贡献者" class="headerlink" title="贡献者"></a>贡献者</h3><p>请阅读<strong>CONTRIBUTING.md</strong> 查阅为该项目做出贡献的开发者。</p><h4 id="如何参与开源项目"><a href="#如何参与开源项目" class="headerlink" title="如何参与开源项目"></a>如何参与开源项目</h4><p>贡献使开源社区成为一个学习、激励和创造的绝佳场所。你所作的任何贡献都是<strong>非常感谢</strong>的。</p><ol><li>Fork the Project</li><li>Create your Feature Branch (<code>git checkout -b feature/AmazingFeature</code>)</li><li>Commit your Changes (<code>git commit -m &#39;Add some AmazingFeature&#39;</code>)</li><li>Push to the Branch (<code>git push origin feature/AmazingFeature</code>)</li><li>Open a Pull Request</li></ol><h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><p>该项目使用Git进行版本管理。您可以在repository参看当前可用版本。</p><h3 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h3><p>luna</p><p>email <a href="mailto:&#x4b;&#101;&#121;&#108;&#117;&#110;&#x61;&#64;&#49;&#50;&#54;&#x2e;&#99;&#x6f;&#109;">&#x4b;&#101;&#121;&#108;&#117;&#110;&#x61;&#64;&#49;&#50;&#54;&#x2e;&#99;&#x6f;&#109;</a>  &ensp; qq:1173288254</p><p> <em>您也可以在贡献者名单中参看所有参与该项目的开发者。</em></p><h3 id="版权说明"><a href="#版权说明" class="headerlink" title="版权说明"></a>版权说明</h3><p>该项目签署了MIT 授权许可，详情请参阅 <a href="https://github.com/czy1024/luna-commons/blob/master/LICENSE">LICENSE.txt</a></p><h3 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢<a href=""></a></h3><ul><li><a href="">ffmpeg</a></li><li><a href="">Javacv</a></li></ul><!-- links -->]]></content>
    
    
    <categories>
      
      <category>project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>commons</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>maven config start</title>
    <link href="/2020/07/27/maven-start/"/>
    <url>/2020/07/27/maven-start/</url>
    
    <content type="html"><![CDATA[<h1 id="Maven配置学习"><a href="#Maven配置学习" class="headerlink" title="Maven配置学习"></a>Maven配置学习</h1><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>pom.xml文件的节点大致可以分为以下几个部分：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0</span></span><span class="hljs-tag"><span class="hljs-string">            http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>     <span class="hljs-comment">&lt;!-- 基本配置 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span>     <span class="hljs-comment">&lt;!-- 依赖配置 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>     <span class="hljs-comment">&lt;!-- 构建配置 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">reporting</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">reporting</span>&gt;</span>     <span class="hljs-comment">&lt;!-- 项目信息 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">inceptionYear</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">inceptionYear</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">licenses</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">licenses</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">organization</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">organization</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">developers</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">developers</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">contributors</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">contributors</span>&gt;</span>     <span class="hljs-comment">&lt;!-- 环境设置 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">issueManagement</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">issueManagement</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ciManagement</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">ciManagement</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mailingLists</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">mailingLists</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scm</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">scm</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">prerequisites</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">prerequisites</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">pluginRepositories</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">pluginRepositories</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">distributionManagement</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">distributionManagement</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div><p>pom.xml文件中，最外层的标签是<code>project</code>标签，该标签定义了如下属性：</p><blockquote><ol><li><code>xmlns</code>属性：表明了该标签下元素的默认命名空间是：<a href="https://link.jianshu.com/?t=http://maven.apache.org/POM/4.0.0">http://maven.apache.org/POM/4.0.0</a>，xml文件中，定义命名空间的格式为：xmlns:namespace-prefix=”namespaceURI”，而定义默认命名空间的格式为：xmlns=”namespaceURI”；</li><li><code>xmlns:xsi</code>属性：定义了一个namespace-prefix，其代表的命名空间URI为：<a href="https://link.jianshu.com/?t=http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</a>，定义该命名空间主要是为了更方便的使用其所代表的命名空间中的schemaLocation属性；其中，使用xsi作为namespace-prefix，并不是硬性规定，只是一种通用的选择，当然也可以改成别的命名；</li><li><code>xsi:schemaLocation</code>属性：该属性的使用格式为：<code>xsi:schemaLocation=&quot;namespaceURI1 schemaURI1 namespaceURI2 schemaURI2 ...&quot;</code>，这里是说使用schemaURI1所对应的schema文件，校验命名空间namespaceURI1下的元素是否符合XML语法规范，后面的则是以此类推。</li></ol></blockquote><hr><p>再来看一下基础信息的几个节点：</p><table><thead><tr><th>节点</th><th>对应的解释</th></tr></thead><tbody><tr><td>modelVersion</td><td>pom模型版本，根据官方文档，Maven2和3只能为4.0.0</td></tr><tr><td>groupId</td><td>项目组id，表明该项目所属的组织或公司，命名规则通常为组织或公司域名反转，然后再加项目名称</td></tr><tr><td>artifactId</td><td>项目的id，有时候和项目名保持一致，有时候是<code>项目名 + 模块名</code>，该id是唯一的，一个goupId下面可能会有多个artifactId，就是通过artifactId区分。比如：<code>consumer-banking</code>。</td></tr><tr><td>version</td><td>当前项目的版本号，一般是：<code>大版本.小版本.增量版本-限定版本号</code>，<code>SHAPSHOT</code>意为快照，说明该项目还处于开发中</td></tr><tr><td>packaging</td><td>项目的打包方式，常用可选值：<code>pom, jar, ejb, maven-plugin, war, ear, rar, par</code>等，默认方式为jar</td></tr></tbody></table><h3 id="项目信息"><a href="#项目信息" class="headerlink" title="项目信息"></a>项目信息</h3><p>下面再来看下项目的一些信息：</p><table><thead><tr><th>节点</th><th>对应的解释</th></tr></thead><tbody><tr><td>name</td><td>声明了一个对于用户更加友好的项目名称，非必须项，一般用于Maven生成的文档</td></tr><tr><td>description</td><td>项目的详细描述信息，能使用HTML格式描述时不建议使用纯文本来描述， 一般用于Maven生成的文档</td></tr><tr><td>url</td><td>项目主页的url，一般用于Maven生成的文档</td></tr><tr><td>inceptionYear</td><td>项目开始的年份，一般是4位数字，涉及到介绍情况时用作提供版权信息</td></tr><tr><td>licenses</td><td>当前项目所有的许可文件，每一个许可文件用一个许可元素来描述，然后描述额外的元素。 通常只列出适用于这个项目的许可文件，无需列出依赖项目的 许可文件列表。如果列出多个license，那么用户可以选择其中所需的，而不是接受所有的许可文件。</td></tr><tr><td>organization</td><td>组织相关信息</td></tr><tr><td>developers</td><td>项目开发人员列表</td></tr><tr><td>contributors</td><td>项目其他贡献者列表，同developers</td></tr></tbody></table><h3 id="licenses列表："><a href="#licenses列表：" class="headerlink" title="licenses列表："></a>licenses列表：</h3><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">license</span>&gt;</span>        <span class="hljs-comment">&lt;!--license用于法律上的名称--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>         <span class="hljs-comment">&lt;!--官方的license正文页面的URL--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>....<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>    <span class="hljs-comment">&lt;!--项目分发的主要方式：repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">distribution</span>&gt;</span>repo<span class="hljs-tag">&lt;/<span class="hljs-name">distribution</span>&gt;</span>         <span class="hljs-comment">&lt;!--关于license的补充信息--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">comments</span>&gt;</span>....<span class="hljs-tag">&lt;/<span class="hljs-name">comments</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">license</span>&gt;</span></code></pre></div><h3 id="organization属性："><a href="#organization属性：" class="headerlink" title="organization属性："></a>organization属性：</h3><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">organization</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 组织的主页 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 组织名称 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">organization</span>&gt;</span></code></pre></div><h3 id="developers属性："><a href="#developers属性：" class="headerlink" title="developers属性："></a>developers属性：</h3><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">developers</span>&gt;</span>      <span class="hljs-comment">&lt;!--某个开发者信息--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">developer</span>&gt;</span>          <span class="hljs-comment">&lt;!--开发者的唯一标识符--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>....<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>          <span class="hljs-comment">&lt;!--开发者的全名--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>          <span class="hljs-comment">&lt;!--开发者的email--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">email</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">email</span>&gt;</span>          <span class="hljs-comment">&lt;!--开发者的主页--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>...<span class="hljs-tag">&lt;<span class="hljs-name">url</span>/&gt;</span>        <span class="hljs-comment">&lt;!--开发者在项目中的角色--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">roles</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">role</span>&gt;</span>Java Dev<span class="hljs-tag">&lt;/<span class="hljs-name">role</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">role</span>&gt;</span>Web UI<span class="hljs-tag">&lt;/<span class="hljs-name">role</span>&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">roles</span>&gt;</span>         <span class="hljs-comment">&lt;!--开发者所属组织--&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">organization</span>&gt;</span>sun<span class="hljs-tag">&lt;/<span class="hljs-name">organization</span>&gt;</span>          <span class="hljs-comment">&lt;!--开发者所属组织的URL--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">organizationUrl</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">organizationUrl</span>&gt;</span>          <span class="hljs-comment">&lt;!--开发者属性，如即时消息如何处理等--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 和主标签中的properties一样，可以随意定义子标签 --&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>         <span class="hljs-comment">&lt;!--开发者所在时区， -11到12范围内的整数。--&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">timezone</span>&gt;</span>-5<span class="hljs-tag">&lt;/<span class="hljs-name">timezone</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">developer</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">developers</span>&gt;</span></code></pre></div><h3 id="contributors属性："><a href="#contributors属性：" class="headerlink" title="contributors属性："></a>contributors属性：</h3><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">contributors</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">contributor</span>&gt;</span>        ...    <span class="hljs-tag">&lt;/<span class="hljs-name">contributor</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">contributors</span>&gt;</span></code></pre></div><h2 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h2><ol><li><code>dependencies</code>：项目相关依赖，如果父项目中的依赖，会被子项目引用，所以一般在父项目中定义子项目中共有的依赖。并且如果有需要，子项目可以修改所依赖包的版本：</li></ol><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div><ol><li><code>parent</code>：用于确定父项目的坐标位置。</li></ol><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.learnPro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>SIP-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">relativePath</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></code></pre></div><blockquote><ul><li>groupId： 父项目的组Id标识符</li><li>artifactId：父项目的唯一标识符</li><li>relativePath：Maven首先在当前项目中找父项目的pom，然后在文件系统的这个位置（relativePath）查找，然后在本地仓库查找，再在远程仓库找。</li><li>version：父项目的版本</li></ul></blockquote><ol><li><code>dependencyManagement</code>：用于帮助管理children的依赖。例如如果parent使用<code>dependencyManagement</code>定义了一个<code>junit:junit4.0</code>，那么它的children就可以只引用 groupId和artifactId，而version就可以直接使用父模块的，如果有需要，我们也可以设置version，这样的好处就是可以集中管理依赖的详情，并且也更灵活。<br>  不过<code>dependencyManagement</code>里只是声明依赖，并不实现引入，因此子项目需要显示的声明需要用的依赖。配置同<code>dependencies</code>类似；</li></ol><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 子项目先通过parent继承之后，就可以引入使用了 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="dependencies几个重要的属性介绍："><a href="#dependencies几个重要的属性介绍：" class="headerlink" title="dependencies几个重要的属性介绍："></a>dependencies几个重要的属性介绍：</h3><blockquote><ol><li>type属性，默认为jar，指定pom，可以定义整个pom文件；</li><li>scope属性，当前包的依赖范围，用于限制依赖项的传递性，通过控制依赖的范围，可以指定该依赖在什么阶段有效。该属性共有5个值，默认是<code>compile</code>，也就是依赖关系在包含编译，测试，运行的所有类路径中都是可用的。而比如<code>provided</code>，则是依赖关系在编译和测试阶段的类路径中是可用的。如需查看全部，可参考：<a href="https://link.jianshu.com/?t=http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html">Introduction to the Dependency Mechanism -Dependency Scope</a></li><li>optional属性，因为依赖是具有传递性的，例如 Project A 依赖于 Project B，B 依赖于 C，那么 B 对 C 的依赖关系也会传递给 A，如果我们不需要这种传递性依赖，就可以通过设置该属性的值。默认为false，即子项目默认都继承，true的话子项目必须显示的引入，与dependencyManagement里定义的依赖类似；</li><li>exclusions和exclusion属性，用于移除项目依赖相关，如果项目X需要A，而A包含B依赖，那么X可以声明不要B依赖，只要在exclusions中声明exclusion，将B从依赖树中删除即可。这一般用于解决jar包冲突的问题；</li></ol></blockquote><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.china.shared<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>alibaba.apollo.webx<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>org.slf4j.slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.external<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div><ol><li><code>modules</code>：Maven项目的一大特点就是以多模块著称，该标签就是用于指定当前项目所包含的模块，对该模块进行的Maven操作，会让所有子模块也进行相应的操作；</li></ol><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>com-a<span class="hljs-tag">&lt;/&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>com-b<span class="hljs-tag">&lt;/&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>com-c<span class="hljs-tag">&lt;/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>/&gt;</span></code></pre></div><ol><li><code>properties</code>：该标签用于定义pom文件中的常量，这样，在pom文件的任何地方，都可以通过<code>$&#123;java.version&#125;</code>来引用该值；</li></ol><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 定义常量 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">rocketmq.version</span>&gt;</span>3.2.6<span class="hljs-tag">&lt;/<span class="hljs-name">rocketmq.version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><span class="hljs-comment">&lt;!-- 使用 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.rocketmq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>rocketmq-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;rocketmq.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h2 id="构建配置"><a href="#构建配置" class="headerlink" title="构建配置"></a>构建配置</h2><blockquote><p>所谓的build，也就是项目构建。在构建配置的过程中，一般包含两个部分，一个是<build>，另一个是<reporting>；而在Maven的pom.xml中build又分为两种，一种被称为Project Build，也就是<project>下的直接子元素，另一种<build>被称为Profile Build，即是<profile>的直接子元素。Profile Build包含了基本的build元素，而Project Build还包含两个特殊的元素，即各种&lt;…Directory&gt;和<extensions>。</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-comment">&lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">sourceDirectory</span>/&gt;</span>    <span class="hljs-comment">&lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scriptSourceDirectory</span>/&gt;</span>    <span class="hljs-comment">&lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">testSourceDirectory</span>/&gt;</span>    <span class="hljs-comment">&lt;!--被编译过的应用程序class文件存放的目录。--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">outputDirectory</span>/&gt;</span>    <span class="hljs-comment">&lt;!--被编译过的测试class文件存放的目录。--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">testOutputDirectory</span>/&gt;</span>    <span class="hljs-comment">&lt;!--使用来自该项目的一系列构建扩展--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">extensions</span>&gt;</span>        <span class="hljs-comment">&lt;!--描述使用到的构建扩展。--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">extension</span>&gt;</span>            <span class="hljs-comment">&lt;!--构建扩展的groupId--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>/&gt;</span>            <span class="hljs-comment">&lt;!--构建扩展的artifactId--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>/&gt;</span>            <span class="hljs-comment">&lt;!--构建扩展的版本--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">extension</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">extensions</span>&gt;</span>    <span class="hljs-comment">&lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">defaultGoal</span>/&gt;</span>    <span class="hljs-comment">&lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>        <span class="hljs-comment">&lt;!--这个元素描述了项目相关或测试相关的所有资源路径--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>            <span class="hljs-comment">&lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。举个例 子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">targetPath</span>/&gt;</span>            <span class="hljs-comment">&lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>/&gt;</span>            <span class="hljs-comment">&lt;!--描述存放资源的目录，该路径相对POM路径--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>/&gt;</span>            <span class="hljs-comment">&lt;!--包含的模式列表，例如**/*.xml.--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>/&gt;</span>            <span class="hljs-comment">&lt;!--排除的模式列表，例如**/*.xml--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span>    <span class="hljs-comment">&lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">testResources</span>&gt;</span>        <span class="hljs-comment">&lt;!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">testResource</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">targetPath</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">testResource</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">testResources</span>&gt;</span>    <span class="hljs-comment">&lt;!--构建产生的所有文件存放的目录--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>/&gt;</span>    <span class="hljs-comment">&lt;!--产生的构件的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>/&gt;</span>    <span class="hljs-comment">&lt;!--当filtering开关打开时，使用到的过滤器属性文件列表--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filters</span>/&gt;</span>    <span class="hljs-comment">&lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">pluginManagement</span>&gt;</span>        <span class="hljs-comment">&lt;!--使用的插件列表 。--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>            <span class="hljs-comment">&lt;!--plugin元素包含描述插件所需要的信息。--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-comment">&lt;!--插件在仓库里的group ID--&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>/&gt;</span>                <span class="hljs-comment">&lt;!--插件在仓库里的artifact ID--&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>/&gt;</span>                <span class="hljs-comment">&lt;!--被使用的插件的版本（或版本范围）--&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>/&gt;</span>                <span class="hljs-comment">&lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。--&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">extensions</span>/&gt;</span>                <span class="hljs-comment">&lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。--&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>                    <span class="hljs-comment">&lt;!--execution元素包含了插件执行需要的信息--&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>                        <span class="hljs-comment">&lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标--&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>/&gt;</span>                        <span class="hljs-comment">&lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段--&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>/&gt;</span>                        <span class="hljs-comment">&lt;!--配置的执行目标--&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>/&gt;</span>                        <span class="hljs-comment">&lt;!--配置是否被传播到子POM--&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">inherited</span>/&gt;</span>                        <span class="hljs-comment">&lt;!--作为DOM对象的配置--&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>/&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>                <span class="hljs-comment">&lt;!--项目引入插件所需要的额外依赖--&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>                    <span class="hljs-comment">&lt;!--参见dependencies/dependency元素--&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>                        ......                    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>                <span class="hljs-comment">&lt;!--任何配置是否被传播到子项目--&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">inherited</span>/&gt;</span>                <span class="hljs-comment">&lt;!--作为DOM对象的配置--&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">pluginManagement</span>&gt;</span>    <span class="hljs-comment">&lt;!--使用的插件列表--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>        <span class="hljs-comment">&lt;!--参见build/pluginManagement/plugins/plugin元素--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">extensions</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>/&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>/&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>/&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">inherited</span>/&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>/&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>                <span class="hljs-comment">&lt;!--参见dependencies/dependency元素--&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>                    ......                <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">inherited</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></div><p>reporting，该元素描述使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">reporting</span>&gt;</span>    <span class="hljs-comment">&lt;!--true，则网站不包括默认的报表。这包括“项目信息”菜单中的报表。--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">excludeDefaults</span>/&gt;</span>    <span class="hljs-comment">&lt;!--所有产生的报表存放到哪里。默认值是$&#123;project.build.directory&#125;/site。--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">outputDirectory</span>/&gt;</span>    <span class="hljs-comment">&lt;!--使用的报表插件和他们的配置。--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>        <span class="hljs-comment">&lt;!--plugin元素包含描述报表插件需要的信息--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>            <span class="hljs-comment">&lt;!--报表插件在仓库里的group ID--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>/&gt;</span>            <span class="hljs-comment">&lt;!--报表插件在仓库里的artifact ID--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>/&gt;</span>            <span class="hljs-comment">&lt;!--被使用的报表插件的版本（或版本范围）--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>/&gt;</span>            <span class="hljs-comment">&lt;!--任何配置是否被传播到子项目--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">inherited</span>/&gt;</span>            <span class="hljs-comment">&lt;!--报表插件的配置--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>/&gt;</span>            <span class="hljs-comment">&lt;!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。</span><span class="hljs-comment">              例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。</span><span class="hljs-comment">              2，5，8构成B报表集，对应另一个执行目标--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">reportSets</span>&gt;</span>                <span class="hljs-comment">&lt;!--表示报表的一个集合，以及产生该集合的配置--&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">reportSet</span>&gt;</span>                    <span class="hljs-comment">&lt;!--报表集合的唯一标识符，POM继承时用到--&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>/&gt;</span>                    <span class="hljs-comment">&lt;!--产生报表集合时，被使用的报表的配置--&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>/&gt;</span>                    <span class="hljs-comment">&lt;!--配置是否被继承到子POMs--&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">inherited</span>/&gt;</span>                    <span class="hljs-comment">&lt;!--这个集合里使用到哪些报表--&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">reports</span>/&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">reportSet</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">reportSets</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">reporting</span>&gt;</span></code></pre></div><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><div class="hljs code-wrapper"><pre><code class="hljs xml">issueManagement：用于缺陷系统的跟踪与管理，比如Bugzilla, Jira等管理工具：<span class="hljs-tag">&lt;<span class="hljs-name">issueManagement</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">system</span>&gt;</span>Bugzilla<span class="hljs-tag">&lt;/<span class="hljs-name">system</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://127.0.0.1/bugzilla/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">issueManagement</span>&gt;</span></code></pre></div><ol><li><code>ciManagement</code>：项目的持续集成信息：</li></ol><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ciManagement</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">system</span>&gt;</span>continuum<span class="hljs-tag">&lt;/<span class="hljs-name">system</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://127.0.0.1:8080/continuum<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">notifiers</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">notifier</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>mail<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">sendOnError</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">sendOnError</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">sendOnFailure</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">sendOnFailure</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">sendOnSuccess</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">sendOnSuccess</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">sendOnWarning</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">sendOnWarning</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">address</span>&gt;</span>continuum@127.0.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">address</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">notifier</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">notifiers</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ciManagement</span>&gt;</span></code></pre></div><blockquote><ol><li>system：持续集成系统的名字</li><li>url：持续集成系统的URL</li><li>notifiers：构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告）</li></ol></blockquote><ul><li>type：通知方式</li><li>sendOnError：错误时是否通知</li><li>sendOnFailure：失败时是否通知</li><li>sendOnSuccess：成功时是否通知</li><li>sendOnWarning：警告时是否通知</li><li>address：通知发送到的地址</li><li>configuration：扩展项</li></ul><ol><li><code>mailingLists</code>：项目相关邮件列表：</li></ol><blockquote><ol><li>subscribe, unsubscribe: 订阅邮件（取消订阅）的地址或链接，如果是邮件地址，创建文档时，链接会被自动创建；</li><li>archive：浏览邮件信息的URL；    3. post：接收邮件的地址；</li></ol></blockquote><ol><li><code>SCM</code>：(Source Control Management)，该标签允许你配置你的代码库，供Maven Web站点和其他插件使用。</li></ol><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">scm</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">connection</span>&gt;</span>scm:svn:http://127.0.0.1/svn/my-project<span class="hljs-tag">&lt;/<span class="hljs-name">connection</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">developerConnection</span>&gt;</span>scm:svn:https://127.0.0.1/svn/my-project<span class="hljs-tag">&lt;/<span class="hljs-name">developerConnection</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tag</span>&gt;</span>HEAD<span class="hljs-tag">&lt;/<span class="hljs-name">tag</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://127.0.0.1/websvn/my-project<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">scm</span>&gt;</span></code></pre></div><ul><li>connection, developerConnection：这两个表示我们如何连接到maven的版本库。connection只提供读，developerConnection将提供写的请求；写法如：<code>scm:[provider]:[provider_specific]</code>，如果连接到CVS仓库，可以配置如下：<br><code>scm:cvs:pserver:127.0.0.1:/cvs/root:my-project</code></li><li>tag：项目标签，默认HEAD</li><li>url：共有仓库路径</li></ul><ol><li><code>prerequisites</code>：项目构建的前提。</li></ol><blockquote><ol><li>repositories，pluginRepositories，依赖和扩展的远程仓库列表；pom里面的仓库与setting.xml里的仓库功能是一样的。主要的区别在于，pom里的仓库是个性化的。比如一家大公司里的setting文件是公用 的，所有项目都用一个setting文件，但各个子项目却会引用不同的第三方库，所以就需要在pom里设置自己需要的仓库地址。而pluginRepositories，与Repositories具有类似的结构，只是Repositories是dependencies的home，而这个是plugins 的home。`</li></ol></blockquote><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">releases</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">updatePolicy</span>&gt;</span>always<span class="hljs-tag">&lt;/<span class="hljs-name">updatePolicy</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">checksumPolicy</span>&gt;</span>warn<span class="hljs-tag">&lt;/<span class="hljs-name">checksumPolicy</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">releases</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">snapshots</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">updatePolicy</span>&gt;</span>never<span class="hljs-tag">&lt;/<span class="hljs-name">updatePolicy</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">checksumPolicy</span>&gt;</span>fail<span class="hljs-tag">&lt;/<span class="hljs-name">checksumPolicy</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">snapshots</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>codehausSnapshots<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Codehaus Snapshots<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://snapshots.maven.codehaus.org/maven2<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">layout</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">pluginRepositories</span>&gt;</span>    ...  <span class="hljs-tag">&lt;/<span class="hljs-name">pluginRepositories</span>&gt;</span></code></pre></div><ul><li>releases，snapshots：这是各种构件的策略，release或者snapshot，这两个集合，POM就可以根据独立仓库任意类型的依赖改变策略。如：一个人可能只激活下载snapshot用来开发。</li><li>enable：true或者false，决定仓库是否对于各自的类型激活(release 或者 snapshot)。</li><li>updatePolicy: 这个元素决定更新频率。maven将比较本地pom的时间戳（存储在仓库的maven数据文件中）和远程的。有以下选择: always, daily (默认), interval:X (x是代表分钟的整型) ， never。</li><li>checksumPolicy：当Maven向仓库部署文件的时候，它也部署了相应的校验和文件。可选的为：ignore，fail，warn，或者不正确的校验和。</li><li>layout：在上面描述仓库的时候，提到他们有统一的布局。Maven 2有它仓库默认布局。然而，Maven 1.x有不同布局。使用这个元素来表明它是default还是legacy。</li></ul><ol><li><code>profiles</code>：POM 4.0的一个新特性是一个项目能够根据所构建的环境改变设置。通过profiles，我们可以指定构建的环境是开发，测试，UAT，生产等环境；</li><li>我们可以通过activation标签来激活相应的profile，也就是指定要构建的默认的环境，并且可以配置各种需要的环境，并且激活profile的方式也有多种，具体参数可查看官网文档。</li></ol><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><span class="hljs-tag">  <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">  <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0</span></span><span class="hljs-tag"><span class="hljs-string">                      https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>  ...  <span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">jdk</span>&gt;</span>1.5<span class="hljs-tag">&lt;/<span class="hljs-name">jdk</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">os</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Windows XP<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Windows<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">arch</span>&gt;</span>x86<span class="hljs-tag">&lt;/<span class="hljs-name">arch</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.2600<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">os</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>sparrow-type<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>African<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">exists</span>&gt;</span>$&#123;basedir&#125;/file2.properties<span class="hljs-tag">&lt;/<span class="hljs-name">exists</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span>$&#123;basedir&#125;/file1.properties<span class="hljs-tag">&lt;/<span class="hljs-name">missing</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span>      ...    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>maven</category>
      
    </categories>
    
    
    <tags>
      
      <tag>maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql 免安装配置学习</title>
    <link href="/2020/07/27/mysql-install/"/>
    <url>/2020/07/27/mysql-install/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL5-7绿色版（免装版）的初始化和修改密码"><a href="#MySQL5-7绿色版（免装版）的初始化和修改密码" class="headerlink" title="MySQL5.7绿色版（免装版）的初始化和修改密码"></a><a href="https://www.cnblogs.com/jyiqing/p/6924062.html">MySQL5.7绿色版（免装版）的初始化和修改密码</a></h2><p><strong>1、下载</strong></p><p>（1）下载地址：<a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a></p><p>（2）选择下载</p><p><img src="https://img2018.cnblogs.com/blog/1627739/201906/1627739-20190620001542784-897003254.png" alt="img"></p><p><strong>2、配置环境变量</strong></p><p>（1）解压目录：D:\mysql-8.0.16-winx64</p><p>（2）配置环境变量</p><p><img src="https://img2018.cnblogs.com/blog/1627739/201906/1627739-20190620002109235-1598560339.png" alt="img"></p><p><strong>3、添加配置文件</strong></p><p>（1）配置文件目录：D:\mysql-8.0.16-winx64</p><p>（2）配置文件名：my.ini</p><p>（3）文件内容：</p><div class="hljs code-wrapper"><pre><code class="hljs mel">[mysql]<span class="hljs-string">``</span># 设置mysql客户端默认字符集<span class="hljs-string">``</span><span class="hljs-keyword">default</span>-<span class="hljs-keyword">character</span>-<span class="hljs-string">``</span>set<span class="hljs-string">``</span>=utf8<span class="hljs-string">` `</span>[mysqld]<span class="hljs-string">``</span># 绑定IPv4<span class="hljs-string">``</span>bind-address=<span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-string">``</span># 设置端口号<span class="hljs-string">``</span>port=<span class="hljs-number">3306</span><span class="hljs-string">``</span># 设置mysql的安装目录，即解压目录<span class="hljs-string">``</span>basedir=D:\\mysql<span class="hljs-number">-8.0</span><span class="hljs-number">.16</span>-winx64<span class="hljs-string">``</span># 设置数据库的数据存放目录<span class="hljs-string">``</span>datadir=D:\\mysql<span class="hljs-number">-8.0</span><span class="hljs-number">.16</span>-winx64\\data<span class="hljs-string">``</span># 设置允许最大连接数<span class="hljs-string">``</span>max_connections=<span class="hljs-number">200</span><span class="hljs-string">``</span># 设置允许连接失败次数<span class="hljs-string">``</span>max_connect_errors=<span class="hljs-number">10</span><span class="hljs-string">``</span># 设置服务端的默认字符集<span class="hljs-string">``</span><span class="hljs-keyword">character</span>-<span class="hljs-string">``</span>set<span class="hljs-string">``</span>-server=utf8<span class="hljs-string">``</span># 创建表使用的默认存储引擎<span class="hljs-string">``</span><span class="hljs-keyword">default</span>-storage-engine=INNODB<span class="hljs-string">``</span># 使用“mysql_native_password”插件认证<span class="hljs-string">``</span>default_authentication_plugin=mysql_native_password</code></pre></div><p><strong>4、CMD命令窗口配置mysql</strong></p><p>（1）初始化mysql（记住随机密码）：<strong>mysqld –initialize –console</strong></p><p> <img src="https://img2018.cnblogs.com/blog/1627739/201906/1627739-20190620014312114-157191049.png" alt="img"></p><p>随机密码为：%tbmq)f&lt;;3jE</p><p>目录会多处data文件夹</p><p>（2）安装mysql服务：<strong>mysqld –install mysql –defaults-file=****”D:\mysql-8.0.16-winx64\my.ini”</strong></p><p><strong><img src="https://img2018.cnblogs.com/blog/1627739/201906/1627739-20190620014706448-303230754.png" alt="img"></strong></p><p>切换管理员身份运行</p><p><img src="https://img2018.cnblogs.com/blog/1627739/201906/1627739-20190620015148365-1323561363.png" alt="img"></p><p>（3）启动mysql服务：<strong>net start mysql</strong></p><p><strong><img src="https://img2018.cnblogs.com/blog/1627739/201906/1627739-20190620015241272-592406864.png" alt="img"></strong></p><p>（4）登录mysql：<strong>mysql -uroot -p</strong></p><p>密码为之前的随机密码：：%tbmq)f&lt;;3jE</p><p>（5）修改密码：<strong>ALTER USER ‘root’@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘新密码’;</strong></p><p><img src="https://img2018.cnblogs.com/blog/1627739/201906/1627739-20190620020223252-138085659.png" alt="img"></p><p>退出重新登录</p><p><img src="https://img2018.cnblogs.com/blog/1627739/201906/1627739-20190620021250850-1721675715.png" alt="img"></p><p><strong>5、其他命令</strong></p><p>（1）关闭服务：net stop mysql</p><p>（2）卸载服务：mysqld –remove</p>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql-install</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个简单的反向代理Nginx</title>
    <link href="/2020/07/27/nginx-install/"/>
    <url>/2020/07/27/nginx-install/</url>
    
    <content type="html"><![CDATA[<h1 id="Nginx安装配置"><a href="#Nginx安装配置" class="headerlink" title="Nginx安装配置"></a>Nginx安装配置</h1><p>NGINX联合创始人安德鲁·阿列克谢夫（Andrew Alexeev）曾说：NGINX是为对Apache性能不满意的人而构建的。随着Internet需求的变化，Web服务器的工作也在变化。NGINX的构建比以往任何时候都更有效率，更可扩展，更安全，更强大。</p><p>本文提供了Nginx的基本概念及知识。以开发者必备的Nginx基础知识为主，罗列了一些Nginx教程，希望对大家有所帮助。</p><p><strong>一.环境</strong></p><p>服务器版本：CentOS 7.2</p><p>为了保证学习阶段不遇到奇怪的事情，请保证以下四点：</p><ol><li>确认系统网络</li><li>确认yum可用</li><li>确认关闭iptables</li><li>确认停用selinux</li></ol><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#查看iptables状态</span>systemctl status firewalld.service<span class="hljs-comment">#关闭防火墙（临时关闭）</span>systemctl stop firewalld.service<span class="hljs-comment">#查看SELinux状态 </span>getenforce<span class="hljs-comment">#临时关闭SELinux </span>setenforce 0</code></pre></div><p>安装一些系统基本工具，正常情况系统都会自带</p><div class="hljs code-wrapper"><pre><code class="hljs angelscript">yum -y install gcc gcc-c++ <span class="hljs-built_in">auto</span>conf pcre pcre-devel make <span class="hljs-built_in">auto</span>makeyum -y install wget httpd-tools vim</code></pre></div><p><strong>二.基本概念</strong></p><p><strong>2.1Nginx是什么？</strong></p><p><code>Nginx</code>是一个高性能的<code>http</code>和反向代理服务器，其特点是占用内存小，并发能力强。<code>Nginx</code>专为性能优化而开发，性能是其最重要的考量，能经受高负载的考验，有报告表明能支持高达50000个并发连接数。</p><p><img src="/blog/img/nginx-1.jpg"></p><p><strong>2.2正向代理与反向代</strong></p><p>为了便于理解，首先先来了解一下一些基础知识，nginx是一个高性能的反向代理服务器那么什么是反向代理呢？</p><p>代理是在服务器和客户端之间假设的一层服务器，代理将接收客户端的请求并将它转发给服务器，然后将服务端的响应转发给客户端。</p><p>不管是正向代理还是反向代理，实现的都是上面的功能。如果你对OSI 七层模型与 TCP/IP 四层模型不是很熟悉可以再回顾下。</p><p><img src="/blog/img/nginx-2.jpg"></p><blockquote><p><strong>正向代理</strong></p></blockquote><p>正向代理（forward）意思是一个位于客户端和原始服务器 (origin server) 之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标 (原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。</p><p>正向代理是为我们服务的，即为客户端服务的，客户端可以根据正向代理访问到它本身无法访问到的服务器资源。</p><p>正向代理对我们是透明的，对服务端是非透明的，即服务端并不知道自己收到的是来自代理的访问还是来自真实客户端的访问。</p><blockquote><p><strong>反向代理</strong></p></blockquote><p>反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p><p>反向代理是为服务端服务的，反向代理可以帮助服务器接收来自客户端的请求，帮助服务器做请求转发，负载均衡等。</p><p>反向代理对服务端是透明的，对我们是非透明的，即我们并不知道自己访问的是代理服务器，而服务器知道反向代理在为他服务。</p><p><strong>2.3负载均衡</strong></p><p>如果请求数过大，单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器的情况改为请求分发到多个服务器上，就是负载均衡。</p><p>Upstream 指定后端服务器地址列表，在 server 中拦截响应请求，并将请求转发到 Upstream 中配置的服务器列表。</p><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-string">upstream</span> <span class="hljs-string">balanceServer</span> &#123; <span class="hljs-string">server</span> <span class="hljs-number">10.1</span><span class="hljs-number">.22</span><span class="hljs-number">.33</span><span class="hljs-string">:12345;</span>  <span class="hljs-string">server</span> <span class="hljs-number">10.1</span><span class="hljs-number">.22</span><span class="hljs-number">.34</span><span class="hljs-string">:12345;</span><span class="hljs-string">server</span> <span class="hljs-number">10.1</span><span class="hljs-number">.22</span><span class="hljs-number">.35</span><span class="hljs-string">:12345;</span>&#125;<span class="hljs-string">server</span> &#123;   <span class="hljs-string">server_name</span> <span class="hljs-string">fe.server.com;</span>  <span class="hljs-string">listen</span> <span class="hljs-number">80</span><span class="hljs-string">;</span>  <span class="hljs-string">location</span> <span class="hljs-string">/api</span> &#123;    <span class="hljs-string">proxy_pass</span> [<span class="hljs-string">http://balanceServer</span>]<span class="hljs-string">(http://balanceserver/);</span> &#125;&#125;</code></pre></div><p>上面的配置只是指定了 nginx 需要转发的服务端列表，并没有指定分配策略。</p><p>默认情况下采用的是轮询策略，将所有客户端请求轮询分配给服务端。这种策略是可以正常工作的，但是如果其中某一台服务器压力太大，出现延迟，会影响所有分配在这台服务器下的用户。</p><p><strong>Nginx支持的负载均衡调度算法方式如下：</strong></p><p>weight轮询(默认，常用)：接收到的请求按照权重分配到不同的后端服务器，即使在使用过程中，某一台后端服务器宕机，Nginx会自动将该服务器剔除出队列，请求受理情况不会受到任何影响。这种方式下，可以给不同的后端服务器设置一个权重值(weight)，用于调整不同的服务器上请求的分配率；权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的。ip_hash（常用）：每个请求按照发起客户端的ip的hash结果进行匹配，这样的算法下一个固定ip地址的客户端总会访问到同一个后端服务器，这也在一定程度上解决了集群部署环境下session共享的问题。</p><p>fair：智能调整调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配，响应时间短处理效率高的服务器分配到请求的概率高，响应时间长处理效率低的服务器分配到的请求少；结合了前两者的优点的一种调度算法。但是需要注意的是Nginx默认不支持fair算法，如果要使用这种调度算法，请安装upstream_fair模块。url_hash：按照访问的url的hash结果分配请求，每个请求的url会指向后端固定的某个服务器，可以在Nginx作为静态服务器的情况下提高缓存效率。同样要注意Nginx默认不支持这种调度算法，要使用的话需要安装Nginx的hash软件包。</p><p><strong>2.4动静分离</strong></p><p>为了加快服务器的解析速度，可以把动态页面和静态页面交给不同的服务器来解析，加快解析速度，降低原来单个服务器的压力。</p><p><strong>2.5Nginx常用命令</strong></p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 快速关闭Nginx，可能不保存相关信息，并迅速终止web服务</span>nginx -s stop<span class="hljs-comment"># 平稳关闭Nginx，保存相关信息，有安排的结束web服务</span>nginx -s quit<span class="hljs-comment"># 因改变了Nginx相关配置，需要重新加载配置而重载</span>nginx -s reload<span class="hljs-comment"># 重新打开日志文件</span>nginx -s reopen<span class="hljs-comment"># 为 Nginx 指定一个配置文件，来代替缺省的</span>nginx -c filename<span class="hljs-comment"># 不运行，而仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件</span>nginx -t<span class="hljs-comment">#  显示 nginx 的版本</span>nginx -v<span class="hljs-comment"># 显示 nginx 的版本，编译器版本和配置参数</span>nginx -V<span class="hljs-comment"># 格式换显示 nginx 配置参数</span>2&gt;&amp;1 nginx -V | xargs -n12&gt;&amp;1 nginx -V | xargs -n1 | grep lua</code></pre></div><p><strong>三.为什么选择****Nginx？</strong></p><p>Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为反向代理进行负载均衡的实现。在Nginx网站上，其功能包括：</p><ul><li>HTTP和HTTPS（TLS / SSL / SNI）</li><li>超快速的Web服务器用于静态内容</li><li>FastCGI，WSGI，SCGI用于动态内容</li><li>具有负载平衡和缓存功能的加速Web代理</li><li>不间断实时二进制升级和配置</li><li>压缩和内容过滤器</li><li>虚拟主机</li><li>FLV和MP4的媒体流</li><li>带宽和连接策略</li><li>全面的访问控制</li><li>自定义日志</li><li>嵌入式脚本</li><li>带有TLS的SMTP / IMAP / POP3的邮件代理</li><li>逻辑，灵活，可扩展的配置</li><li>在Linux，FreeBSD，Mac OS X，Solaris和Windows上运行</li></ul><p><strong>nginx有如下优势：</strong></p><p><strong>1. IO多路复用epoll（IO复用）</strong></p><p>如何理解呢？举个例子吧！<br>有A、B、C三个老师，他们都遇到一个难题，要帮助一个班级的学生解决课堂作业。<br>老师A采用从第一排开始一个学生一个学生轮流解答的方式去回答问题，老师A浪费了很多时间，并且有的学生作业还没有完成呢，老师就来了，反反复复效率极慢。<br>老师B是一个忍者，他发现老师A的方法行不通，于是他使用了影分身术，分身出好几个自己同一时间去帮好几个同学回答问题，最后还没回答完，老师B消耗光了能量累倒了。<br>老师C比较精明，他告诉学生，谁完成了作业举手，有举手的同学他才去指导问题，他让学生主动发声，分开了“并发”。<br>这个老师C就是Nginx。</p><p><strong>2.</strong> <strong>轻量级</strong></p><ul><li>功能模块少 - Nginx仅保留了HTTP需要的模块，其他都用插件的方式，后天添加</li><li>代码模块化 - 更适合二次开发，如阿里巴巴Tengine</li></ul><p><strong>3. CPU亲和</strong></p><p>把CPU核心和Nginx工作进程绑定，把每个worker进程固定在一个CPU上执行，减少切换CPU的cache miss，从而提高性能。</p><p><strong>四.Nginx的安装</strong></p><h4 id="1-本地安装"><a href="#1-本地安装" class="headerlink" title="1.本地安装"></a><strong>1.本地安装</strong></h4><ul><li>windows系统：</li></ul><blockquote><p>直接去官网：<a href="https://nginx.org/en/download">https://nginx.org/en/download</a>… 下载相应版本即可。</p></blockquote><ul><li>mac系统：</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash">$ brew install nginx</code></pre></div><h4 id="2-Linux安装："><a href="#2-Linux安装：" class="headerlink" title="2.Linux安装："></a><strong>2.Linux安装：</strong></h4><blockquote><p>以centOS系统为例，有下面两种安装方式(推荐1)</p></blockquote><p>1.) 通过rpm镜像源安装</p><div class="hljs code-wrapper"><pre><code class="hljs bash">$ rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm$ yum install -y nginx</code></pre></div><p>2.) 通过依赖包详细安装</p><blockquote><p>安装nginx依赖库pcre、zlib</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs bash">$ yum install pcre pcre-devel$ yum install zlib zlib-devel</code></pre></div><blockquote><p>如有必要，可以安装c++编译环境和openssl</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs bash">$ yum install gcc-c++$ yum install openssl openssl-devel</code></pre></div><blockquote><p>下载/编译nginx</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-string">$</span> <span class="hljs-string">wget</span> <span class="hljs-string">-c</span> <span class="hljs-string">https://nginx.org/download/nginx-1.16.0.tar.gz</span><span class="hljs-string">$</span> <span class="hljs-string">tar</span> <span class="hljs-string">-zxvf</span> <span class="hljs-string">nginx-1.16.0.tar.gz</span><span class="hljs-comment"># 编译安装</span><span class="hljs-string">$</span> <span class="hljs-string">cd</span> <span class="hljs-string">nginx-1.16.0</span><span class="hljs-string">$</span> <span class="hljs-string">./configure</span>  <span class="hljs-comment"># 默认安装在/usr/local/nginx</span><span class="hljs-string">$</span> <span class="hljs-string">make</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">make</span> <span class="hljs-string">install</span><span class="hljs-comment"># 创建软链</span><span class="hljs-string">$</span> <span class="hljs-string">ln</span> <span class="hljs-string">-s</span> <span class="hljs-string">/usr/local/nginx/sbin/nginx</span> <span class="hljs-string">/usr/local/sbin/nginx</span><span class="hljs-string">$</span> <span class="hljs-string">nginx</span> <span class="hljs-string">-v</span></code></pre></div><p><strong>五.Nginx配置</strong></p><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-comment">#打开主配置文件，若你是用lnmp环境安装</span><span class="hljs-string">vim</span> <span class="hljs-string">/usr/local/nginx/conf/nginx.conf</span><span class="hljs-string">----------------------------------------</span><span class="hljs-string">user</span>                    <span class="hljs-comment">#设置nginx服务的系统使用用户</span><span class="hljs-string">worker_processes</span>        <span class="hljs-comment">#工作进程数 一般情况与CPU核数保持一致</span><span class="hljs-string">error_log</span>               <span class="hljs-comment">#nginx的错误日志</span><span class="hljs-string">pid</span>                     <span class="hljs-comment">#nginx启动时的pid</span><span class="hljs-string">events</span> &#123;    <span class="hljs-string">worker_connections</span>    <span class="hljs-comment">#每个进程允许最大连接数</span>    <span class="hljs-string">use</span>                   <span class="hljs-comment">#nginx使用的内核模型</span>&#125;</code></pre></div><p>我们使用 nginx 的 http 服务，在配置文件 nginx.conf 中的 http 区域内，配置无数个 server ，每一个 server 对应这一个虚拟主机或者域名。</p><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-string">http</span> &#123;    <span class="hljs-string">...</span> <span class="hljs-string">...</span>        <span class="hljs-comment">#后面再详细介绍 http 配置项目</span>        <span class="hljs-string">server</span> &#123;        <span class="hljs-string">listen</span> <span class="hljs-number">80</span>                          <span class="hljs-comment">#监听端口;</span>        <span class="hljs-string">server_name</span> <span class="hljs-string">localhost</span>              <span class="hljs-comment">#地址</span>                <span class="hljs-string">location</span> <span class="hljs-string">/</span> &#123;                       <span class="hljs-comment">#访问首页路径</span>            <span class="hljs-string">root</span> <span class="hljs-string">/xxx/xxx/index.html</span>       <span class="hljs-comment">#默认目录</span>            <span class="hljs-string">index</span> <span class="hljs-string">index.html</span> <span class="hljs-string">index.htm</span>     <span class="hljs-comment">#默认文件</span>        &#125;                        <span class="hljs-string">error_page</span>  <span class="hljs-number">500</span> <span class="hljs-number">504</span>   <span class="hljs-string">/50x.html</span>    <span class="hljs-comment">#当出现以上状态码时从新定义到50x.html</span>        <span class="hljs-string">location</span> <span class="hljs-string">=</span> <span class="hljs-string">/50x.html</span> &#123;             <span class="hljs-comment">#当访问50x.html时</span>            <span class="hljs-string">root</span> <span class="hljs-string">/xxx/xxx/html</span>             <span class="hljs-comment">#50x.html 页面所在位置</span>        &#125;            &#125;        <span class="hljs-string">server</span> &#123;        <span class="hljs-string">...</span> <span class="hljs-string">...</span> &#125; &#125;</code></pre></div><p>一个 server 可以出现多个 location ，我们对不同的访问路径进行不同情况的配置<br>我们再来看看 http 的配置详情。</p><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-string">http</span> &#123;    <span class="hljs-string">sendfile</span>  <span class="hljs-string">on</span>                  <span class="hljs-comment">#高效传输文件的模式 一定要开启</span>    <span class="hljs-string">keepalive_timeout</span>   <span class="hljs-number">65</span>        <span class="hljs-comment">#客户端服务端请求超时时间</span>    <span class="hljs-string">log_format</span>  <span class="hljs-string">main</span>   <span class="hljs-string">XXX</span>        <span class="hljs-comment">#定义日志格式 代号为main</span>    <span class="hljs-string">access_log</span>  <span class="hljs-string">/usr/local/access.log</span>  <span class="hljs-string">main</span>     <span class="hljs-comment">#日志保存地址 格式代码 main</span>&#125;</code></pre></div><p>下面是 nginx 一些配置中常用的内置全局变量，你可以在配置的任何位置使用它们。</p><p><img src="/blog/img/nginx-3.jpg"></p><p><strong>六.Nginx实战</strong></p><p>各种开发工具的配置结合实战来讲述，会让人更易理解。</p><p>我们先实现一个小目标：不考虑复杂的配置，仅仅是完成一个 http 反向代理。</p><p>nginx.conf 配置文件如下：</p><blockquote><p><em>注：_</em><code>conf/nginx.conf</code> 是 nginx 的默认配置文件。你也可以使用 nginx -c 指定你的配置文件_</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-comment">#运行用户</span><span class="hljs-comment">#user somebody;</span><span class="hljs-comment">#启动进程,通常设置成和cpu的数量相等</span><span class="hljs-string">worker_processes</span>  <span class="hljs-number">1</span><span class="hljs-string">;</span><span class="hljs-comment">#全局错误日志</span><span class="hljs-string">error_log</span>  <span class="hljs-string">D:/Tools/nginx-1.10.1/logs/error.log;</span><span class="hljs-string">error_log</span>  <span class="hljs-string">D:/Tools/nginx-1.10.1/logs/notice.log</span>  <span class="hljs-string">notice;</span><span class="hljs-string">error_log</span>  <span class="hljs-string">D:/Tools/nginx-1.10.1/logs/info.log</span>  <span class="hljs-string">info;</span><span class="hljs-comment">#PID文件，记录当前启动的nginx的进程ID</span><span class="hljs-string">pid</span>        <span class="hljs-string">D:/Tools/nginx-1.10.1/logs/nginx.pid;</span><span class="hljs-comment">#工作模式及连接数上限</span><span class="hljs-string">events</span> &#123;    <span class="hljs-string">worker_connections</span> <span class="hljs-number">1024</span><span class="hljs-string">;</span>    <span class="hljs-comment">#单个后台worker process进程的最大并发链接数</span>&#125;<span class="hljs-comment">#设定http服务器，利用它的反向代理功能提供负载均衡支持</span><span class="hljs-string">http</span> &#123;    <span class="hljs-comment">#设定mime类型(邮件支持类型),类型由mime.types文件定义</span>    <span class="hljs-string">include</span>       <span class="hljs-string">D:/Tools/nginx-1.10.1/conf/mime.types;</span>    <span class="hljs-string">default_type</span>  <span class="hljs-string">application/octet-stream;</span>    <span class="hljs-comment">#设定日志</span>    <span class="hljs-string">log_format</span>  <span class="hljs-string">main</span>  <span class="hljs-string">&#x27;[$remote_addr] - [$remote_user] [$time_local] &quot;$request&quot; &#x27;</span>                      <span class="hljs-string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span>                      <span class="hljs-string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span><span class="hljs-string">;</span>    <span class="hljs-string">access_log</span>    <span class="hljs-string">D:/Tools/nginx-1.10.1/logs/access.log</span> <span class="hljs-string">main;</span>    <span class="hljs-string">rewrite_log</span>     <span class="hljs-string">on;</span>    <span class="hljs-comment">#sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，对于普通应用，</span>    <span class="hljs-comment">#必须设为 on,如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，以平衡磁盘与网络I/O处理速度，降低系统的uptime.</span>    <span class="hljs-string">sendfile</span>        <span class="hljs-string">on;</span>    <span class="hljs-comment">#tcp_nopush     on;</span>    <span class="hljs-comment">#连接超时时间</span>    <span class="hljs-string">keepalive_timeout</span>  <span class="hljs-number">120</span><span class="hljs-string">;</span>    <span class="hljs-string">tcp_nodelay</span>        <span class="hljs-string">on;</span>    <span class="hljs-comment">#gzip压缩开关</span>    <span class="hljs-comment">#gzip  on;</span>    <span class="hljs-comment">#设定实际的服务器列表</span>    <span class="hljs-string">upstream</span> <span class="hljs-string">zp_server1</span>&#123;        <span class="hljs-string">server</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8089;</span>    &#125;    <span class="hljs-comment">#HTTP服务器</span>    <span class="hljs-string">server</span> &#123;        <span class="hljs-comment">#监听80端口，80端口是知名端口号，用于HTTP协议</span>        <span class="hljs-string">listen</span>       <span class="hljs-number">80</span><span class="hljs-string">;</span>        <span class="hljs-comment">#定义使用www.xx.com访问</span>        <span class="hljs-string">server_name</span>  <span class="hljs-string">www.helloworld.com;</span>        <span class="hljs-comment">#首页</span>        <span class="hljs-string">index</span> <span class="hljs-string">index.html</span>        <span class="hljs-comment">#指向webapp的目录</span>        <span class="hljs-string">root</span> <span class="hljs-string">D:01_WorkspaceProjectgithubzpSpringNotesspring-securityspring-shirosrcmainwebapp;</span>        <span class="hljs-comment">#编码格式</span>        <span class="hljs-string">charset</span> <span class="hljs-string">utf-8;</span>        <span class="hljs-comment">#代理配置参数</span>        <span class="hljs-string">proxy_connect_timeout</span> <span class="hljs-number">180</span><span class="hljs-string">;</span>        <span class="hljs-string">proxy_send_timeout</span> <span class="hljs-number">180</span><span class="hljs-string">;</span>        <span class="hljs-string">proxy_read_timeout</span> <span class="hljs-number">180</span><span class="hljs-string">;</span>        <span class="hljs-string">proxy_set_header</span> <span class="hljs-string">Host</span> <span class="hljs-string">$host;</span>        <span class="hljs-string">proxy_set_header</span> <span class="hljs-string">X-Forwarder-For</span> <span class="hljs-string">$remote_addr;</span>        <span class="hljs-comment">#反向代理的路径（和upstream绑定），location 后面设置映射的路径</span>        <span class="hljs-string">location</span> <span class="hljs-string">/</span> &#123;            <span class="hljs-string">proxy_pass</span> <span class="hljs-string">http://zp_server1;</span>        &#125;        <span class="hljs-comment">#静态文件，nginx自己处理</span>        <span class="hljs-string">location</span> <span class="hljs-string">~</span> <span class="hljs-string">^/(images|javascript|js|css|flash|media|static)/</span> &#123;            <span class="hljs-string">root</span> <span class="hljs-string">D:01_WorkspaceProjectgithubzpSpringNotesspring-securityspring-shirosrcmainwebappviews;</span>            <span class="hljs-comment">#过期30天，静态文件不怎么更新，过期可以设大一点，如果频繁更新，则可以设置得小一点。</span>            <span class="hljs-string">expires</span> <span class="hljs-string">30d;</span>        &#125;        <span class="hljs-comment">#设定查看Nginx状态的地址</span>        <span class="hljs-string">location</span> <span class="hljs-string">/NginxStatus</span> &#123;            <span class="hljs-string">stub_status</span>           <span class="hljs-string">on;</span>            <span class="hljs-string">access_log</span>            <span class="hljs-string">on;</span>            <span class="hljs-string">auth_basic</span>            <span class="hljs-string">&quot;NginxStatus&quot;</span><span class="hljs-string">;</span>            <span class="hljs-string">auth_basic_user_file</span>  <span class="hljs-string">conf/htpasswd;</span>        &#125;        <span class="hljs-comment">#禁止访问 .htxxx 文件</span>        <span class="hljs-string">location</span> <span class="hljs-string">~</span> <span class="hljs-string">/.ht</span> &#123;            <span class="hljs-string">deny</span> <span class="hljs-string">all;</span>        &#125;        <span class="hljs-comment">#错误处理页面（可选择性配置）</span>        <span class="hljs-comment">#error_page   404              /404.html;</span>        <span class="hljs-comment">#error_page   500 502 503 504  /50x.html;</span>        <span class="hljs-comment">#location = /50x.html &#123;</span>        <span class="hljs-comment">#    root   html;</span>        <span class="hljs-comment">#&#125;</span>    &#125;&#125;</code></pre></div><p>好了，让我们来试试吧：</p><ol><li>启动 webapp，注意启动绑定的端口要和 nginx 中的 upstream 设置的端口保持一致。</li><li>更改 host：在 C:WindowsSystem32driversetc 目录下的 host 文件中添加一条 DNS 记录</li></ol><div class="hljs code-wrapper"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1</span> www.helloworld.com</code></pre></div><ol><li>启动前文中 startup.bat 的命令</li><li>在浏览器中访问 <a href="http://www.helloworld.com,不出意外,已经可以访问了./">www.helloworld.com，不出意外，已经可以访问了。</a></li></ol><h3 id="搭建文件服务器"><a href="#搭建文件服务器" class="headerlink" title="搭建文件服务器"></a><strong>搭建文件服务器</strong></h3><p>有时候，团队需要归档一些数据或资料，那么文件服务器必不可少。使用 Nginx 可以非常快速便捷的搭建一个简易的文件服务。</p><p>Nginx 中的配置要点：</p><ul><li>将 autoindex 开启可以显示目录，默认不开启。</li><li>将 autoindex_exact_size 开启可以显示文件的大小。</li><li>将 autoindex_localtime 开启可以显示文件的修改时间。</li><li>root 用来设置开放为文件服务的根路径。</li><li>charset 设置为 charset utf-8,gbk;，可以避免中文乱码问题</li></ul><p>一个最简化的配置如下：</p><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-string">autoindex</span> <span class="hljs-string">on;#</span> <span class="hljs-string">显示目录</span><span class="hljs-string">autoindex_exact_size</span> <span class="hljs-string">on;#</span> <span class="hljs-string">显示文件大小</span><span class="hljs-string">autoindex_localtime</span> <span class="hljs-string">on;#</span> <span class="hljs-string">显示文件时间</span><span class="hljs-string">server</span> &#123;    <span class="hljs-string">charset</span>      <span class="hljs-string">utf-8</span>,<span class="hljs-string">gbk;</span> <span class="hljs-comment"># windows 服务器下设置后，依然乱码，暂时无解</span>    <span class="hljs-string">listen</span>       <span class="hljs-number">9050 </span><span class="hljs-string">default_server;</span>    <span class="hljs-string">listen</span>       [<span class="hljs-string">::</span>]<span class="hljs-string">:9050</span> <span class="hljs-string">default_server;</span>    <span class="hljs-string">server_name</span>  <span class="hljs-string">_;</span>    <span class="hljs-string">root</span>         <span class="hljs-string">/share/fs;</span>&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql-DDL</title>
    <link href="/2020/07/04/mysql-DDL/"/>
    <url>/2020/07/04/mysql-DDL/</url>
    
    <content type="html"><![CDATA[<h2 id="Review-mysql"><a href="#Review-mysql" class="headerlink" title="Review mysql"></a>Review mysql</h2><h3 id="库管理"><a href="#库管理" class="headerlink" title="库管理"></a>库管理</h3><div class="hljs code-wrapper"><pre><code class="hljs sql">一、创建库<span class="hljs-keyword">create</span> database 【if <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span>】 库名【 <span class="hljs-type">character</span> <span class="hljs-keyword">set</span> 字符集名】;二、修改库<span class="hljs-keyword">alter</span> database 库名 <span class="hljs-type">character</span> <span class="hljs-keyword">set</span> 字符集名;三、删除库<span class="hljs-keyword">drop</span> database 【if <span class="hljs-keyword">exists</span>】 库名;</code></pre></div><h3 id="表管理"><a href="#表管理" class="headerlink" title="表管理"></a>表管理</h3><div class="hljs code-wrapper"><pre><code class="hljs sql">一、创建表 ★<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 【if <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span>】 表名(字段名 字段类型 【约束】,字段名 字段类型 【约束】,。。。字段名 字段类型 【约束】 )二、修改表<span class="hljs-number">1.</span>添加列<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">add</span> <span class="hljs-keyword">column</span> 列名 类型 【<span class="hljs-keyword">first</span><span class="hljs-operator">|</span>after 字段名】;<span class="hljs-number">2.</span>修改列的类型或约束<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 modify <span class="hljs-keyword">column</span> 列名 新类型 【新约束】;<span class="hljs-number">3.</span>修改列名<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 change <span class="hljs-keyword">column</span> 旧列名 新列名 类型;<span class="hljs-number">4</span> .删除列<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">drop</span> <span class="hljs-keyword">column</span> 列名;<span class="hljs-number">5.</span>修改表名<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 rename 【<span class="hljs-keyword">to</span>】 新表名;三、删除表<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span>【if <span class="hljs-keyword">exists</span>】 表名;四、复制表<span class="hljs-number">1</span>、复制表的结构<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">like</span> 旧表;<span class="hljs-number">2</span>、复制表的结构<span class="hljs-operator">+</span>数据<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">select</span> 查询列表 <span class="hljs-keyword">from</span> 旧表【<span class="hljs-keyword">where</span> 筛选】;</code></pre></div><h3 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h3><div class="hljs code-wrapper"><pre><code class="hljs sql">一、数值型<span class="hljs-number">1</span>、整型tinyint、<span class="hljs-type">smallint</span>、mediumint、<span class="hljs-type">int</span><span class="hljs-operator">/</span><span class="hljs-type">integer</span>、<span class="hljs-type">bigint</span><span class="hljs-number">1</span>         <span class="hljs-number">2</span>        <span class="hljs-number">3</span>          <span class="hljs-number">4</span>            <span class="hljs-number">8</span>特点：①都可以设置无符号和有符号，默认有符号，通过unsigned设置无符号②如果超出了范围，会报<span class="hljs-keyword">out</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">range</span>异常，插入临界值③长度可以不指定，默认会有一个长度长度代表显示的最大宽度，如果不够则左边用<span class="hljs-number">0</span>填充，但需要搭配zerofill，并且默认变为无符号整型<span class="hljs-number">2</span>、浮点型定点数：<span class="hljs-type">decimal</span>(M,D)浮点数:<span class="hljs-type">float</span>(M,D)   <span class="hljs-number">4</span><span class="hljs-keyword">double</span>(M,D)  <span class="hljs-number">8</span>特点：①M代表整数部位<span class="hljs-operator">+</span>小数部位的个数，D代表小数部位②如果超出范围，则报<span class="hljs-keyword">out</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">range</span>异常，并且插入临界值③M和D都可以省略，但对于定点数，M默认为<span class="hljs-number">10</span>，D默认为<span class="hljs-number">0</span>④如果精度要求较高，则优先考虑使用定点数二、字符型<span class="hljs-type">char</span>、<span class="hljs-type">varchar</span>、<span class="hljs-type">binary</span>、<span class="hljs-type">varbinary</span>、enum、<span class="hljs-keyword">set</span>、text、<span class="hljs-type">blob</span><span class="hljs-type">char</span>：固定长度的字符，写法为<span class="hljs-type">char</span>(M)，最大长度不能超过M，其中M可以省略，默认为<span class="hljs-number">1</span><span class="hljs-type">varchar</span>：可变长度的字符，写法为<span class="hljs-type">varchar</span>(M)，最大长度不能超过M，其中M不可以省略三、日期型<span class="hljs-keyword">year</span>年<span class="hljs-type">date</span>日期<span class="hljs-type">time</span>时间datetime 日期<span class="hljs-operator">+</span>时间          <span class="hljs-number">8</span>      <span class="hljs-type">timestamp</span> 日期<span class="hljs-operator">+</span>时间         <span class="hljs-number">4</span>   比较容易受时区、语法模式、版本的影响，更能反映当前时区的真实时间</code></pre></div><h3 id="常见约束"><a href="#常见约束" class="headerlink" title="常见约束"></a>常见约束</h3><div class="hljs code-wrapper"><pre><code class="hljs sql">一、常见的约束<span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>：非空，该字段的值必填<span class="hljs-keyword">UNIQUE</span>：唯一，该字段的值不可重复<span class="hljs-keyword">DEFAULT</span>：默认，该字段的值不用手动插入有默认值<span class="hljs-keyword">CHECK</span>：检查，mysql不支持<span class="hljs-keyword">PRIMARY</span> KEY：主键，该字段的值不可重复并且非空  <span class="hljs-keyword">unique</span><span class="hljs-operator">+</span><span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><span class="hljs-keyword">FOREIGN</span> KEY：外键，该字段的值引用了另外的表的字段主键和唯一<span class="hljs-number">1</span>、区别：①、一个表至多有一个主键，但可以有多个唯一②、主键不允许为空，唯一可以为空<span class="hljs-number">2</span>、相同点都具有唯一性都支持组合键，但不推荐外键：<span class="hljs-number">1</span>、用于限制两个表的关系，从表的字段值引用了主表的某字段值<span class="hljs-number">2</span>、外键列和主表的被引用列要求类型一致，意义一样，名称无要求<span class="hljs-number">3</span>、主表的被引用列要求是一个key（一般就是主键）<span class="hljs-number">4</span>、插入数据，先插入主表删除数据，先删除从表可以通过以下两种方式来删除主表的记录#方式一：级联删除<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stuinfo <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> fk_stu_major <span class="hljs-keyword">FOREIGN</span> KEY(majorid) <span class="hljs-keyword">REFERENCES</span> major(id) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> CASCADE;#方式二：级联置空<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stuinfo <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> fk_stu_major <span class="hljs-keyword">FOREIGN</span> KEY(majorid) <span class="hljs-keyword">REFERENCES</span> major(id) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">NULL</span>;二、创建表时添加约束<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名(字段名 字段类型 <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,#非空字段名 字段类型 <span class="hljs-keyword">primary</span> key,#主键字段名 字段类型 <span class="hljs-keyword">unique</span>,#唯一字段名 字段类型 <span class="hljs-keyword">default</span> 值,#默认<span class="hljs-keyword">constraint</span> 约束名 <span class="hljs-keyword">foreign</span> key(字段名) <span class="hljs-keyword">references</span> 主表（被引用列）)注意：支持类型可以起约束名列级约束除了外键不可以表级约束除了非空和默认可以，但对主键无效列级约束可以在一个字段上追加多个，中间用空格隔开，没有顺序要求三、修改表时添加或删除约束<span class="hljs-number">1</span>、非空添加非空<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 modify <span class="hljs-keyword">column</span> 字段名 字段类型 <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>;删除非空<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 modify <span class="hljs-keyword">column</span> 字段名 字段类型 ;<span class="hljs-number">2</span>、默认添加默认<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 modify <span class="hljs-keyword">column</span> 字段名 字段类型 <span class="hljs-keyword">default</span> 值;删除默认<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 modify <span class="hljs-keyword">column</span> 字段名 字段类型 ;<span class="hljs-number">3</span>、主键添加主键<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">add</span>【 <span class="hljs-keyword">constraint</span> 约束名】 <span class="hljs-keyword">primary</span> key(字段名);删除主键<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">drop</span> <span class="hljs-keyword">primary</span> key;<span class="hljs-number">4</span>、唯一添加唯一<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">add</span>【 <span class="hljs-keyword">constraint</span> 约束名】 <span class="hljs-keyword">unique</span>(字段名);删除唯一<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">drop</span> index 索引名;<span class="hljs-number">5</span>、外键添加外键<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">add</span>【 <span class="hljs-keyword">constraint</span> 约束名】 <span class="hljs-keyword">foreign</span> key(字段名) <span class="hljs-keyword">references</span> 主表（被引用列）;删除外键<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">drop</span> <span class="hljs-keyword">foreign</span> key 约束名;四、自增长列特点：<span class="hljs-number">1</span>、不用手动插入值，可以自动提供序列值，默认从<span class="hljs-number">1</span>开始，步长为<span class="hljs-number">1</span>auto_increment_increment如果要更改起始值：手动插入值如果要更改步长：更改系统变量<span class="hljs-keyword">set</span> auto_increment_increment<span class="hljs-operator">=</span>值;<span class="hljs-number">2</span>、一个表至多有一个自增长列<span class="hljs-number">3</span>、自增长列只能支持数值型<span class="hljs-number">4</span>、自增长列必须为一个key一、创建表时设置自增长列<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表(字段名 字段类型 约束 auto_increment)二、修改表时设置自增长列<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表 modify <span class="hljs-keyword">column</span> 字段名 字段类型 约束 auto_increment三、删除自增长列<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表 modify <span class="hljs-keyword">column</span> 字段名 字段类型 约束</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql-DML</title>
    <link href="/2020/07/04/mysql-DML/"/>
    <url>/2020/07/04/mysql-DML/</url>
    
    <content type="html"><![CDATA[<h2 id="Review-mysql"><a href="#Review-mysql" class="headerlink" title="Review mysql"></a>Review mysql</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><div class="hljs code-wrapper"><pre><code class="hljs sql">一、方式一语法：<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> 表名(字段名,...) <span class="hljs-keyword">values</span>(值,...);特点：<span class="hljs-number">1</span>、要求值的类型和字段的类型要一致或兼容<span class="hljs-number">2</span>、字段的个数和顺序不一定与原始表中的字段个数和顺序一致但必须保证值和字段一一对应<span class="hljs-number">3</span>、假如表中有可以为<span class="hljs-keyword">null</span>的字段，注意可以通过以下两种方式插入<span class="hljs-keyword">null</span>值①字段和值都省略②字段写上，值使用<span class="hljs-keyword">null</span><span class="hljs-number">4</span>、字段和值的个数必须一致<span class="hljs-number">5</span>、字段名可以省略，默认所有列二、方式二语法：<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> 表名 <span class="hljs-keyword">set</span> 字段<span class="hljs-operator">=</span>值,字段<span class="hljs-operator">=</span>值,...;两种方式 的区别：<span class="hljs-number">1.</span>方式一支持一次插入多行，语法如下：<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> 表名【(字段名,..)】 <span class="hljs-keyword">values</span>(值，..),(值，...),...;<span class="hljs-number">2.</span>方式一支持子查询，语法如下：<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> 表名查询语句;</code></pre></div><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><div class="hljs code-wrapper"><pre><code class="hljs sql">一、修改单表的记录 ★语法：update 表名 <span class="hljs-keyword">set</span> 字段<span class="hljs-operator">=</span>值,字段<span class="hljs-operator">=</span>值 【<span class="hljs-keyword">where</span> 筛选条件】;二、修改多表的记录【补充】语法：update 表<span class="hljs-number">1</span> 别名 <span class="hljs-keyword">left</span><span class="hljs-operator">|</span><span class="hljs-keyword">right</span><span class="hljs-operator">|</span><span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> 表<span class="hljs-number">2</span> 别名 <span class="hljs-keyword">on</span> 连接条件  <span class="hljs-keyword">set</span> 字段<span class="hljs-operator">=</span>值,字段<span class="hljs-operator">=</span>值 【<span class="hljs-keyword">where</span> 筛选条件】;</code></pre></div><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><div class="hljs code-wrapper"><pre><code class="hljs sql">方式一：使用<span class="hljs-keyword">delete</span>一、删除单表的记录★语法：<span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表名 【<span class="hljs-keyword">where</span> 筛选条件】【limit 条目数】二、级联删除[补充]语法：<span class="hljs-keyword">delete</span> 别名<span class="hljs-number">1</span>,别名<span class="hljs-number">2</span> <span class="hljs-keyword">from</span> 表<span class="hljs-number">1</span> 别名 <span class="hljs-keyword">inner</span><span class="hljs-operator">|</span><span class="hljs-keyword">left</span><span class="hljs-operator">|</span><span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> 表<span class="hljs-number">2</span> 别名 <span class="hljs-keyword">on</span> 连接条件 【<span class="hljs-keyword">where</span> 筛选条件】方式二：使用<span class="hljs-keyword">truncate</span>语法：<span class="hljs-keyword">truncate</span> <span class="hljs-keyword">table</span> 表名两种方式的区别【面试题】★<span class="hljs-number">1.</span><span class="hljs-keyword">truncate</span>删除后，如果再插入，标识列从<span class="hljs-number">1</span>开始  <span class="hljs-keyword">delete</span>删除后，如果再插入，标识列从断点开始<span class="hljs-number">2.</span><span class="hljs-keyword">delete</span>可以添加筛选条件 <span class="hljs-keyword">truncate</span>不可以添加筛选条件<span class="hljs-number">3.</span><span class="hljs-keyword">truncate</span>效率较高<span class="hljs-number">4.</span><span class="hljs-keyword">truncate</span>没有返回值<span class="hljs-keyword">delete</span>可以返回受影响的行数<span class="hljs-number">5.</span><span class="hljs-keyword">truncate</span>不可以回滚<span class="hljs-keyword">delete</span>可以回滚</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql-DQL</title>
    <link href="/2020/06/29/mysql-DQL/"/>
    <url>/2020/06/29/mysql-DQL/</url>
    
    <content type="html"><![CDATA[<h2 id="Review-mysql"><a href="#Review-mysql" class="headerlink" title="Review mysql"></a>Review mysql</h2><h4 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h4><div class="hljs code-wrapper"><pre><code class="hljs sql">一、语法<span class="hljs-keyword">select</span> 查询列表<span class="hljs-keyword">from</span> 表名;二、特点<span class="hljs-number">1</span>、查询列表可以是字段、常量、表达式、函数，也可以是多个<span class="hljs-number">2</span>、查询结果是一个虚拟表三、示例<span class="hljs-number">1</span>、查询单个字段<span class="hljs-keyword">select</span> 字段名 <span class="hljs-keyword">from</span> 表名;<span class="hljs-number">2</span>、查询多个字段<span class="hljs-keyword">select</span> 字段名，字段名 <span class="hljs-keyword">from</span> 表名;<span class="hljs-number">3</span>、查询所有字段<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> 表名<span class="hljs-number">4</span>、查询常量<span class="hljs-keyword">select</span> 常量值;注意：字符型和日期型的常量值必须用单引号引起来，数值型不需要<span class="hljs-number">5</span>、查询函数<span class="hljs-keyword">select</span> 函数名(实参列表);<span class="hljs-number">6</span>、查询表达式<span class="hljs-keyword">select</span> <span class="hljs-number">100</span><span class="hljs-operator">/</span><span class="hljs-number">1234</span>;<span class="hljs-number">7</span>、起别名①<span class="hljs-keyword">as</span>②空格<span class="hljs-number">8</span>、去重<span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> 字段名 <span class="hljs-keyword">from</span> 表名;<span class="hljs-number">9</span>、<span class="hljs-operator">+</span>作用：做加法运算<span class="hljs-keyword">select</span> 数值<span class="hljs-operator">+</span>数值; 直接运算<span class="hljs-keyword">select</span> 字符<span class="hljs-operator">+</span>数值;先试图将字符转换成数值，如果转换成功，则继续运算；否则转换成<span class="hljs-number">0</span>，再做运算<span class="hljs-keyword">select</span> <span class="hljs-keyword">null</span><span class="hljs-operator">+</span>值;结果都为<span class="hljs-keyword">null</span><span class="hljs-number">10</span>、【补充】concat函数功能：拼接字符<span class="hljs-keyword">select</span> concat(字符<span class="hljs-number">1</span>，字符<span class="hljs-number">2</span>，字符<span class="hljs-number">3</span>,...);<span class="hljs-number">11</span>、【补充】ifnull函数功能：判断某字段或表达式是否为<span class="hljs-keyword">null</span>，如果为<span class="hljs-keyword">null</span> 返回指定的值，否则返回原本的值<span class="hljs-keyword">select</span> ifnull(commission_pct,<span class="hljs-number">0</span>) <span class="hljs-keyword">from</span> employees;<span class="hljs-number">12</span>、【补充】isnull函数功能：判断某字段或表达式是否为<span class="hljs-keyword">null</span>，如果是，则返回<span class="hljs-number">1</span>，否则返回<span class="hljs-number">0</span></code></pre></div><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><div class="hljs code-wrapper"><pre><code class="hljs sql">一、语法<span class="hljs-keyword">select</span> 查询列表<span class="hljs-keyword">from</span> 表名<span class="hljs-keyword">where</span> 筛选条件二、筛选条件的分类<span class="hljs-number">1</span>、简单条件运算符<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span> <span class="hljs-operator">=</span> <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-operator">!=</span> <span class="hljs-operator">&gt;=</span> <span class="hljs-operator">&lt;=</span>  <span class="hljs-operator">&lt;=&gt;</span>安全等于<span class="hljs-number">2</span>、逻辑运算符<span class="hljs-operator">&amp;&amp;</span> <span class="hljs-keyword">and</span><span class="hljs-operator">||</span> <span class="hljs-keyword">or</span><span class="hljs-operator">!</span>  <span class="hljs-keyword">not</span><span class="hljs-number">3</span>、模糊查询<span class="hljs-keyword">like</span>:一般搭配通配符使用，可以判断字符型或数值型通配符：<span class="hljs-operator">%</span>任意多个字符，_任意单个字符<span class="hljs-keyword">between</span> <span class="hljs-keyword">and</span><span class="hljs-keyword">in</span><span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span> <span class="hljs-operator">/</span><span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>：用于判断<span class="hljs-keyword">null</span>值<span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span> PK <span class="hljs-operator">&lt;=&gt;</span>普通类型的数值<span class="hljs-keyword">null</span>值可读性<span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span>×√√<span class="hljs-operator">&lt;=&gt;</span>√√×</code></pre></div><h4 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h4><div class="hljs code-wrapper"><pre><code class="hljs sql">一、语法<span class="hljs-keyword">select</span> 查询列表<span class="hljs-keyword">from</span> 表<span class="hljs-keyword">where</span> 筛选条件order by 排序列表 【asc&#125;desc】二、特点<span class="hljs-number">1</span>、<span class="hljs-keyword">asc</span> ：升序，如果不写默认升序   <span class="hljs-keyword">desc</span>：降序<span class="hljs-number">2</span>、排序列表 支持 单个字段、多个字段、函数、表达式、别名<span class="hljs-number">3</span>、<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span>的位置一般放在查询语句的最后（除limit语句之外）</code></pre></div><h4 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h4><div class="hljs code-wrapper"><pre><code class="hljs sql">一、概述功能：类似于java中的方法好处：提高重用性和隐藏实现细节调用：<span class="hljs-keyword">select</span> 函数名(实参列表);二、单行函数<span class="hljs-number">1</span>、字符函数concat:连接substr:截取子串upper:变大写lower：变小写replace：替换length：获取字节长度trim:去前后空格lpad：左填充rpad：右填充instr:获取子串第一次出现的索引<span class="hljs-number">2</span>、数学函数ceil:向上取整round：四舍五入mod:取模floor：向下取整<span class="hljs-keyword">truncate</span>:截断rand:获取随机数，返回<span class="hljs-number">0</span><span class="hljs-number">-1</span>之间的小数<span class="hljs-number">3</span>、日期函数now：返回当前日期<span class="hljs-operator">+</span>时间<span class="hljs-keyword">year</span>:返回年<span class="hljs-keyword">month</span>：返回月<span class="hljs-keyword">day</span>:返回日date_format:将日期转换成字符curdate:返回当前日期str_to_date:将字符转换成日期curtime：返回当前时间<span class="hljs-keyword">hour</span>:小时<span class="hljs-keyword">minute</span>:分钟<span class="hljs-keyword">second</span>：秒datediff:返回两个日期相差的天数monthname:以英文形式返回月<span class="hljs-number">4</span>、其他函数version 当前数据库服务器的版本database 当前打开的数据库<span class="hljs-keyword">user</span>当前用户password(<span class="hljs-string">&#x27;字符&#x27;</span>)：返回该字符的密码形式md5(<span class="hljs-string">&#x27;字符&#x27;</span>):返回该字符的md5加密形式<span class="hljs-number">5</span>、流程控制函数①if(条件表达式，表达式<span class="hljs-number">1</span>，表达式<span class="hljs-number">2</span>)：如果条件表达式成立，返回表达式<span class="hljs-number">1</span>，否则返回表达式<span class="hljs-number">2</span>②<span class="hljs-keyword">case</span>情况<span class="hljs-number">1</span><span class="hljs-keyword">case</span> 变量或表达式或字段<span class="hljs-keyword">when</span> 常量<span class="hljs-number">1</span> <span class="hljs-keyword">then</span> 值<span class="hljs-number">1</span><span class="hljs-keyword">when</span> 常量<span class="hljs-number">2</span> <span class="hljs-keyword">then</span> 值<span class="hljs-number">2</span>...<span class="hljs-keyword">else</span> 值n<span class="hljs-keyword">end</span>③<span class="hljs-keyword">case</span>情况<span class="hljs-number">2</span><span class="hljs-keyword">case</span> <span class="hljs-keyword">when</span> 条件<span class="hljs-number">1</span> <span class="hljs-keyword">then</span> 值<span class="hljs-number">1</span><span class="hljs-keyword">when</span> 条件<span class="hljs-number">2</span> <span class="hljs-keyword">then</span> 值<span class="hljs-number">2</span>...<span class="hljs-keyword">else</span> 值n<span class="hljs-keyword">end</span>三、分组函数<span class="hljs-number">1</span>、分类max 最大值min 最小值sum 和avg 平均值count 计算个数<span class="hljs-number">2</span>、特点①语法<span class="hljs-keyword">select</span> <span class="hljs-built_in">max</span>(字段) <span class="hljs-keyword">from</span> 表名;②支持的类型sum和avg一般用于处理数值型max、min、count可以处理任何数据类型③以上分组函数都忽略<span class="hljs-keyword">null</span>④都可以搭配<span class="hljs-keyword">distinct</span>使用，实现去重的统计<span class="hljs-keyword">select</span> <span class="hljs-built_in">sum</span>(<span class="hljs-keyword">distinct</span> 字段) <span class="hljs-keyword">from</span> 表;⑤count函数<span class="hljs-built_in">count</span>(字段)：统计该字段非空值的个数<span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>):统计结果集的行数案例：查询每个部门的员工个数<span class="hljs-number">1</span> xx    <span class="hljs-number">10</span><span class="hljs-number">2</span> dd    <span class="hljs-number">20</span><span class="hljs-number">3</span> mm    <span class="hljs-number">20</span><span class="hljs-number">4</span> aa    <span class="hljs-number">40</span><span class="hljs-number">5</span> hh    <span class="hljs-number">40</span><span class="hljs-built_in">count</span>(<span class="hljs-number">1</span>):统计结果集的行数效率上：MyISAM存储引擎，<span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)最高InnoDB存储引擎，<span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)和<span class="hljs-built_in">count</span>(<span class="hljs-number">1</span>)效率<span class="hljs-operator">&gt;</span><span class="hljs-built_in">count</span>(字段)⑥ 和分组函数一同查询的字段，要求是<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>后出现的字段</code></pre></div><h4 id="分组函数"><a href="#分组函数" class="headerlink" title="分组函数"></a>分组函数</h4><div class="hljs code-wrapper"><pre><code class="hljs sql">一、语法<span class="hljs-keyword">select</span> 分组函数，分组后的字段<span class="hljs-keyword">from</span> 表【<span class="hljs-keyword">where</span> 筛选条件】<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 分组的字段【<span class="hljs-keyword">having</span> 分组后的筛选】【<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 排序列表】二、特点使用关键字筛选的表 位置分组前筛选<span class="hljs-keyword">where</span>原始表  <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>的前面分组后筛选<span class="hljs-keyword">having</span>分组后的结果<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 的后面</code></pre></div><h4 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h4><div class="hljs code-wrapper"><pre><code class="hljs sql">一、含义当查询中涉及到了多个表的字段，需要使用多表连接<span class="hljs-keyword">select</span> 字段<span class="hljs-number">1</span>，字段<span class="hljs-number">2</span><span class="hljs-keyword">from</span> 表<span class="hljs-number">1</span>，表<span class="hljs-number">2</span>,...;笛卡尔乘积：当查询多个表时，没有添加有效的连接条件，导致多个表所有行实现完全连接如何解决：添加有效的连接条件二、分类按年代分类：sql92：等值非等值自连接也支持一部分外连接（用于oracle、sqlserver，mysql不支持）sql99【推荐使用】内连接等值非等值自连接外连接左外右外全外（mysql不支持）交叉连接三、SQL92语法<span class="hljs-number">1</span>、等值连接语法：<span class="hljs-keyword">select</span> 查询列表<span class="hljs-keyword">from</span> 表<span class="hljs-number">1</span> 别名,表<span class="hljs-number">2</span> 别名<span class="hljs-keyword">where</span> 表<span class="hljs-number">1.</span>key<span class="hljs-operator">=</span>表<span class="hljs-number">2.</span>key【<span class="hljs-keyword">and</span> 筛选条件】【<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 分组字段】【<span class="hljs-keyword">having</span> 分组后的筛选】【<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 排序字段】特点：① 一般为表起别名②多表的顺序可以调换③n表连接至少需要n<span class="hljs-number">-1</span>个连接条件④等值连接的结果是多表的交集部分<span class="hljs-number">2</span>、非等值连接语法：<span class="hljs-keyword">select</span> 查询列表<span class="hljs-keyword">from</span> 表<span class="hljs-number">1</span> 别名,表<span class="hljs-number">2</span> 别名<span class="hljs-keyword">where</span> 非等值的连接条件【<span class="hljs-keyword">and</span> 筛选条件】【<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 分组字段】【<span class="hljs-keyword">having</span> 分组后的筛选】【<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 排序字段】<span class="hljs-number">3</span>、自连接语法：<span class="hljs-keyword">select</span> 查询列表<span class="hljs-keyword">from</span> 表 别名<span class="hljs-number">1</span>,表 别名<span class="hljs-number">2</span><span class="hljs-keyword">where</span> 等值的连接条件【<span class="hljs-keyword">and</span> 筛选条件】【<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 分组字段】【<span class="hljs-keyword">having</span> 分组后的筛选】【<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 排序字段】四、SQL99语法<span class="hljs-number">1</span>、内连接语法：<span class="hljs-keyword">select</span> 查询列表<span class="hljs-keyword">from</span> 表<span class="hljs-number">1</span> 别名【<span class="hljs-keyword">inner</span>】 <span class="hljs-keyword">join</span> 表<span class="hljs-number">2</span> 别名 <span class="hljs-keyword">on</span> 连接条件<span class="hljs-keyword">where</span> 筛选条件<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 分组列表<span class="hljs-keyword">having</span> 分组后的筛选<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 排序列表limit 子句;特点：①表的顺序可以调换②内连接的结果<span class="hljs-operator">=</span>多表的交集③n表连接至少需要n<span class="hljs-number">-1</span>个连接条件分类：等值连接非等值连接自连接<span class="hljs-number">2</span>、外连接语法：<span class="hljs-keyword">select</span> 查询列表<span class="hljs-keyword">from</span> 表<span class="hljs-number">1</span> 别名<span class="hljs-keyword">left</span><span class="hljs-operator">|</span><span class="hljs-keyword">right</span><span class="hljs-operator">|</span><span class="hljs-keyword">full</span>【<span class="hljs-keyword">outer</span>】 <span class="hljs-keyword">join</span> 表<span class="hljs-number">2</span> 别名 <span class="hljs-keyword">on</span> 连接条件<span class="hljs-keyword">where</span> 筛选条件<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 分组列表<span class="hljs-keyword">having</span> 分组后的筛选<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 排序列表limit 子句;特点：①查询的结果<span class="hljs-operator">=</span>主表中所有的行，如果从表和它匹配的将显示匹配行，如果从表没有匹配的则显示<span class="hljs-keyword">null</span>②<span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> 左边的就是主表，<span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> 右边的就是主表  <span class="hljs-keyword">full</span> <span class="hljs-keyword">join</span> 两边都是主表③一般用于查询除了交集部分的剩余的不匹配的行<span class="hljs-number">3</span>、交叉连接语法：<span class="hljs-keyword">select</span> 查询列表<span class="hljs-keyword">from</span> 表<span class="hljs-number">1</span> 别名<span class="hljs-keyword">cross</span> <span class="hljs-keyword">join</span> 表<span class="hljs-number">2</span> 别名;特点：类似于笛卡尔乘积</code></pre></div><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><div class="hljs code-wrapper"><pre><code class="hljs sql">一、含义嵌套在其他语句内部的<span class="hljs-keyword">select</span>语句称为子查询或内查询，外面的语句可以是<span class="hljs-keyword">insert</span>、update、<span class="hljs-keyword">delete</span>、<span class="hljs-keyword">select</span>等，一般<span class="hljs-keyword">select</span>作为外面语句较多外面如果为<span class="hljs-keyword">select</span>语句，则此语句称为外查询或主查询二、分类<span class="hljs-number">1</span>、按出现位置<span class="hljs-keyword">select</span>后面：仅仅支持标量子查询<span class="hljs-keyword">from</span>后面：表子查询<span class="hljs-keyword">where</span>或<span class="hljs-keyword">having</span>后面：标量子查询列子查询行子查询<span class="hljs-keyword">exists</span>后面：标量子查询列子查询行子查询表子查询<span class="hljs-number">2</span>、按结果集的行列标量子查询（单行子查询）：结果集为一行一列列子查询（多行子查询）：结果集为多行一列行子查询：结果集为多行多列表子查询：结果集为多行多列三、示例<span class="hljs-keyword">where</span>或<span class="hljs-keyword">having</span>后面<span class="hljs-number">1</span>、标量子查询案例：查询最低工资的员工姓名和工资①最低工资<span class="hljs-keyword">select</span> <span class="hljs-built_in">min</span>(salary) <span class="hljs-keyword">from</span> employees②查询员工的姓名和工资，要求工资<span class="hljs-operator">=</span>①<span class="hljs-keyword">select</span> last_name,salary<span class="hljs-keyword">from</span> employees<span class="hljs-keyword">where</span> salary<span class="hljs-operator">=</span>(<span class="hljs-keyword">select</span> <span class="hljs-built_in">min</span>(salary) <span class="hljs-keyword">from</span> employees);<span class="hljs-number">2</span>、列子查询案例：查询所有是领导的员工姓名①查询所有员工的 manager_id<span class="hljs-keyword">select</span> manager_id<span class="hljs-keyword">from</span> employees②查询姓名，employee_id属于①列表的一个<span class="hljs-keyword">select</span> last_name<span class="hljs-keyword">from</span> employees<span class="hljs-keyword">where</span> employee_id <span class="hljs-keyword">in</span>(<span class="hljs-keyword">select</span> manager_id<span class="hljs-keyword">from</span> employees);</code></pre></div><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><div class="hljs code-wrapper"><pre><code class="hljs sql">一、应用场景当要查询的条目数太多，一页显示不全二、语法<span class="hljs-keyword">select</span> 查询列表<span class="hljs-keyword">from</span> 表limit 【<span class="hljs-keyword">offset</span>，】size;注意：<span class="hljs-keyword">offset</span>代表的是起始的条目索引，默认从<span class="hljs-number">0</span>卡死size代表的是显示的条目数公式：假如要显示的页数为page，每一页条目数为size<span class="hljs-keyword">select</span> 查询列表<span class="hljs-keyword">from</span> 表limit (page<span class="hljs-number">-1</span>)<span class="hljs-operator">*</span>size,size;</code></pre></div><h4 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h4><div class="hljs code-wrapper"><pre><code class="hljs sql">一、含义<span class="hljs-keyword">union</span>：合并、联合，将多次查询结果合并成一个结果二、语法查询语句<span class="hljs-number">1</span><span class="hljs-keyword">union</span> 【<span class="hljs-keyword">all</span>】查询语句<span class="hljs-number">2</span><span class="hljs-keyword">union</span> 【<span class="hljs-keyword">all</span>】...三、意义<span class="hljs-number">1</span>、将一条比较复杂的查询语句拆分成多条语句<span class="hljs-number">2</span>、适用于查询多个表的时候，查询的列基本是一致四、特点<span class="hljs-number">1</span>、要求多条查询语句的查询列数必须一致<span class="hljs-number">2</span>、要求多条查询语句的查询的各列类型、顺序最好一致<span class="hljs-number">3</span>、<span class="hljs-keyword">union</span> 去重，<span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>包含重复项</code></pre></div><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><div class="hljs code-wrapper"><pre><code class="hljs sql">语法：<span class="hljs-keyword">select</span> 查询列表    ⑦<span class="hljs-keyword">from</span> 表<span class="hljs-number">1</span> 别名       ①连接类型 <span class="hljs-keyword">join</span> 表<span class="hljs-number">2</span>   ②<span class="hljs-keyword">on</span> 连接条件         ③<span class="hljs-keyword">where</span> 筛选          ④<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 分组列表   ⑤<span class="hljs-keyword">having</span> 筛选         ⑥<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span>排序列表    ⑧limit 起始条目索引，条目数;  ⑨</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue-demo</title>
    <link href="/2020/06/15/vue-demo/"/>
    <url>/2020/06/15/vue-demo/</url>
    
    <content type="html"><![CDATA[<h2 id="1-vue脚手架"><a href="#1-vue脚手架" class="headerlink" title="1. vue脚手架"></a>1. vue脚手架</h2><div class="hljs code-wrapper"><pre><code>用来创建vue项目的工具包创建项目:    npm install -g vue-cli    vue init webpack VueDemo开发环境运行:    cd VueDemo    npm install    npm run dev生产环境打包发布    npm run build    npm install -g serve    serve dist    http://localhost:5000</code></pre></div><h2 id="2-eslint"><a href="#2-eslint" class="headerlink" title="2. eslint"></a>2. eslint</h2><div class="hljs code-wrapper"><pre><code>用来做项目编码规范检查的工具基本原理: 定义了很多规则, 检查项目的代码一旦发现违背了某个规则就输出相应的提示信息有相应的配置, 可定制检查</code></pre></div><h2 id="3-组件化编程"><a href="#3-组件化编程" class="headerlink" title="3. 组件化编程"></a>3. 组件化编程</h2><div class="hljs code-wrapper"><pre><code>vue文件包含3个部分    &lt;template&gt;      &lt;div&gt;&lt;/div&gt;    &lt;/template&gt;    &lt;script&gt;        export default &#123;          props: []/&#123;&#125;          data()&#123;&#125;,          computed: &#123;&#125;          methods: &#123;&#125;,                    watch: &#123;&#125;          filters: &#123;&#125;          directives: &#123;&#125;          components: &#123;&#125;        &#125;    &lt;/script&gt;    &lt;style&gt;    &lt;/style&gt;组件化编码的基本流程    1). 拆分界面, 抽取组件    2). 编写静态组件    3). 编写动态组件        初始化数据, 动态显示初始化界面        实现与用户交互功能组件通信的5种方式    props    vue的自定义事件    pubsub第三方库    slot    vuex(后面单独讲)props:    父子组件间通信的基本方式    属性值的2大类型:         一般: 父组件--&gt;子组件        函数: 子组件--&gt;父组件    隔层组件间传递: 必须逐层传递(麻烦)    兄弟组件间: 必须借助父组件(麻烦)vue自定义事件    子组件与父组件的通信方式    用来取代function props    不适合隔层组件和兄弟组件间的通信pubsub第三方库(消息订阅与发布)    适合于任何关系的组件间通信slot    通信是带数据的标签    注意: 标签是在父组件中解析vuex    多组件共享状态(数据的管理)    组件间的关系也没有限制    功能比pubsub强大, 更适用于vue项目</code></pre></div><h2 id="4-ajax"><a href="#4-ajax" class="headerlink" title="4. ajax"></a>4. ajax</h2><div class="hljs code-wrapper"><pre><code class="hljs js">相关库:    vue-resource: vue插件, 多用于vue1.x    axios: 第三方库, 多用于vue2.xvue-resource使用    <span class="hljs-comment">// 引入模块</span>    <span class="hljs-keyword">import</span> VueResource <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-resource&#x27;</span>    <span class="hljs-comment">// 使用插件</span>    Vue.use(VueResource)        <span class="hljs-comment">// 通过vue/组件对象发送ajax请求</span>    <span class="hljs-built_in">this</span>.$http.get(<span class="hljs-string">&#x27;/someUrl&#x27;</span>).then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;      <span class="hljs-comment">// success callback</span>      <span class="hljs-built_in">console</span>.log(response.data) <span class="hljs-comment">//返回结果数据</span>    &#125;, <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;      <span class="hljs-comment">// error callback</span>      <span class="hljs-built_in">console</span>.log(response.statusText) <span class="hljs-comment">//错误信息</span>    &#125;)axios使用    <span class="hljs-comment">// 引入模块</span>    <span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>        <span class="hljs-comment">// 发送ajax请求</span>    axios.get(url)      .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;        <span class="hljs-built_in">console</span>.log(response.data) <span class="hljs-comment">// 得到返回结果数据</span>      &#125;)      .catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(error.message)      &#125;)</code></pre></div><h2 id="5-vue-router"><a href="#5-vue-router" class="headerlink" title="5. vue-router"></a>5. vue-router</h2><div class="hljs code-wrapper"><pre><code class="hljs html">vue用来实现SPA的插件使用vue-router    1. 创建路由器: router/index.js      new VueRouter(&#123;        routes: [          &#123; // 一般路由            path: &#x27;/about&#x27;,            component: about          &#125;,          &#123; // 自动跳转路由            path: &#x27;/&#x27;,             redirect: &#x27;/about&#x27;          &#125;        ]      &#125;)    2. 注册路由器: main.js       import router from &#x27;./router&#x27;       new Vue(&#123;       router       &#125;)    3. 使用路由组件标签:       <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/xxx&quot;</span>&gt;</span>Go to XXX<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span>编写路由的3步    1. 定义路由组件        2. 映射路由    3. 编写路由2个标签嵌套路由    children: [        &#123;          path: &#x27;/home/news&#x27;,          component: news        &#125;,        &#123;          path: &#x27;message&#x27;,          component: message        &#125;     ]向路由组件传递数据    params: <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/home/news/abc/123&quot;</span>&gt;</span>    props: <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">msg</span>=<span class="hljs-string">&#x27;abc&#x27;</span>&gt;</span>缓存路由组件    <span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span>路由的编程式导航this.$router.push(path): 相当于点击路由链接(可以返回到当前路由界面)this.$router.replace(path): 用新路由替换当前路由(不可以返回到当前路由界面)this.$router.back(): 请求(返回)上一个记录路由</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue-start</title>
    <link href="/2020/06/12/vue-start/"/>
    <url>/2020/06/12/vue-start/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Vue-js是什么"><a href="#1-Vue-js是什么" class="headerlink" title="1. Vue.js是什么?"></a>1. Vue.js是什么?</h1><div class="hljs code-wrapper"><pre><code class="hljs tex">1). 一位华裔前Google工程师(尤雨溪)开发的前端js库2). 作用: 动态构建用户界面3). 特点:* 遵循MVVM模式* 编码简洁, 体积小, 运行效率高, 移动/PC端开发* 它本身只关注UI, 可以轻松引入vue插件和其它第三库开发项目4). 与其它框架的关联:* 借鉴angular的模板和数据绑定技术* 借鉴react的组件化和虚拟DOM技术5). vue包含一系列的扩展插件(库):* vue-cli: vue脚手架* vue-resource(axios): ajax请求* vue-router: 路由* vuex: 状态管理* vue-lazyload: 图片懒加载* vue-scroller: 页面滑动相关* mint-ui: 基于vue的组件库(移动端)* element-ui: 基于vue的组件库(PC端)</code></pre></div><h1 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2. 基本使用"></a>2. 基本使用</h1><div class="hljs code-wrapper"><pre><code>1). 引入vue.js2). 创建Vue实例对象(vm), 指定选项(配置)对象    el : 指定dom标签容器的选择器    data : 指定初始化状态数据的对象/函数(返回一个对象)3). 在页面模板中使用&#123;&#123;&#125;&#125;或vue指令# 3. Vue对象的选项## 1). el指定dom标签容器的选择器Vue就会管理对应的标签及其子标签## 2). data对象或函数类型指定初始化状态属性数据的对象vm也会自动拥有data中所有属性页面中可以直接访问使用数据代理: 由vm对象来代理对data中所有属性的操作(读/写)## 3). methods包含多个方法的对象供页面中的事件指令来绑定回调回调函数默认有event参数, 但也可以指定自己的参数所有的方法由vue对象来调用, 访问data中的属性直接使用this.xxx## 4). computed包含多个方法的对象对状态属性进行计算返回一个新的数据, 供页面获取显示一般情况下是相当于是一个只读的属性利用set/get方法来实现属性数据的计算读取, 同时监视属性数据的变化如何给对象定义get/set属性在创建对象时指定: get name () &#123;return xxx&#125; / set name (value) &#123;&#125;  对象创建之后指定: Object.defineProperty(obj, age, &#123;get()&#123;&#125;, set(value)&#123;&#125;&#125;)</code></pre></div><h2 id="5-watch"><a href="#5-watch" class="headerlink" title="5). watch"></a>5). watch</h2><div class="hljs code-wrapper"><pre><code>包含多个属性监视的对象分为一般监视和深度监视    xxx: function(value)&#123;&#125;    xxx : &#123;        deep : true,        handler : fun(value)    &#125;另一种添加监视方式: vm.$watch(&#39;xxx&#39;, function(value)&#123;&#125;)</code></pre></div><h1 id="4-过渡动画"><a href="#4-过渡动画" class="headerlink" title="4. 过渡动画"></a>4. 过渡动画</h1><div class="hljs code-wrapper"><pre><code class="hljs html">利用vue去操控css的transition/animation动画模板: 使用<span class="hljs-tag">&lt;<span class="hljs-name">transition</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;xxx&#x27;</span>&gt;</span>包含带动画的标签css样式.fade-enter-active: 进入过程, 指定进入的transition.fade-leave-active: 离开过程, 指定离开的transition.xxx-enter, .xxx-leave-to: 指定隐藏的样式编码例子    .xxx-enter-active, .xxx-leave-active &#123;      transition: opacity .5s    &#125;    .xxx-enter, .xxx-leave-to &#123;      opacity: 0    &#125;        <span class="hljs-tag">&lt;<span class="hljs-name">transition</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;xxx&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;show&quot;</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span></code></pre></div><h1 id="5-生命周期"><a href="#5-生命周期" class="headerlink" title="5. 生命周期"></a>5. 生命周期</h1><div class="hljs code-wrapper"><pre><code>vm/组件对象生命周期图主要的生命周期函数(钩子)    created() / mounted(): 启动异步任务(启动定时器,发送ajax请求, 绑定监听)    beforeDestroy(): 做一些收尾的工作</code></pre></div><h1 id="6-自定义过滤器"><a href="#6-自定义过滤器" class="headerlink" title="6. 自定义过滤器"></a>6. 自定义过滤器</h1><h2 id="1-理解"><a href="#1-理解" class="headerlink" title="1). 理解"></a>1). 理解</h2><div class="hljs code-wrapper"><pre><code>对需要显示的数据进行格式化后再显示</code></pre></div><h2 id="2-编码"><a href="#2-编码" class="headerlink" title="2). 编码"></a>2). 编码</h2><div class="hljs code-wrapper"><pre><code>1). 定义过滤器    Vue.filter(filterName, function(value[,arg1,arg2,...])&#123;      // 进行一定的数据处理      return newValue    &#125;)2). 使用过滤器    &lt;div&gt;&#123;&#123;myData | filterName&#125;&#125;&lt;/div&gt;    &lt;div&gt;&#123;&#123;myData | filterName(arg)&#125;&#125;&lt;/div&gt;</code></pre></div><h1 id="7-vue内置指令"><a href="#7-vue内置指令" class="headerlink" title="7. vue内置指令"></a>7. vue内置指令</h1><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">v-text/v-html:</span> <span class="hljs-string">指定标签体</span><span class="hljs-string">*</span> <span class="hljs-attr">v-text :</span> <span class="hljs-string">当作纯文本</span><span class="hljs-string">*</span> <span class="hljs-attr">v-html :</span> <span class="hljs-string">将value作为html标签来解析</span><span class="hljs-attr">v-if v-else v-show:</span> <span class="hljs-string">显示/隐藏元素</span><span class="hljs-string">*</span> <span class="hljs-attr">v-if :</span> <span class="hljs-string">如果vlaue为true,</span> <span class="hljs-string">当前标签会输出在页面中</span><span class="hljs-string">*</span> <span class="hljs-attr">v-else :</span> <span class="hljs-string">与v-if一起使用,</span> <span class="hljs-string">如果value为false,</span> <span class="hljs-string">将当前标签输出到页面中</span><span class="hljs-string">*</span> <span class="hljs-attr">v-show:</span> <span class="hljs-string">就会在标签中添加display样式,</span> <span class="hljs-string">如果vlaue为true,</span> <span class="hljs-string">display=block,</span> <span class="hljs-string">否则是none</span><span class="hljs-attr">v-for :</span> <span class="hljs-string">遍历</span><span class="hljs-string">*</span> <span class="hljs-string">遍历数组</span> <span class="hljs-string">:</span> <span class="hljs-string">v-for=&quot;(person,</span> <span class="hljs-string">index)</span> <span class="hljs-string">in</span> <span class="hljs-string">persons&quot;</span>   <span class="hljs-string">*</span> <span class="hljs-string">遍历对象</span> <span class="hljs-string">:</span> <span class="hljs-string">v-for=&quot;value</span> <span class="hljs-string">in</span> <span class="hljs-string">person&quot;</span>   <span class="hljs-string">$key</span><span class="hljs-attr">v-on :</span> <span class="hljs-string">绑定事件监听</span><span class="hljs-string">*</span> <span class="hljs-string">v-on:事件名,</span> <span class="hljs-string">可以缩写为:</span> <span class="hljs-string">@事件名</span><span class="hljs-string">*</span> <span class="hljs-string">监视具体的按键:</span> <span class="hljs-string">@keyup.keyCode</span>   <span class="hljs-string">@keyup.enter</span><span class="hljs-string">*</span> <span class="hljs-string">停止事件的冒泡和阻止事件默认行为:</span> <span class="hljs-string">@click.stop</span>   <span class="hljs-string">@click.prevent</span><span class="hljs-string">*</span> <span class="hljs-string">隐含对象:</span> <span class="hljs-string">$event</span><span class="hljs-attr">v-bind :</span> <span class="hljs-string">强制绑定解析表达式</span>  <span class="hljs-string">*</span> <span class="hljs-string">html标签属性是不支持表达式的,</span> <span class="hljs-string">就可以使用v-bind</span><span class="hljs-string">*</span> <span class="hljs-string">可以缩写为:</span>  <span class="hljs-string">:id=&#x27;name&#x27;</span><span class="hljs-string">*</span> <span class="hljs-string">:class</span>  <span class="hljs-string">*</span> <span class="hljs-string">:class=&quot;a&quot;</span><span class="hljs-string">*</span> <span class="hljs-string">:class=&quot;&#123;classA</span> <span class="hljs-string">:</span> <span class="hljs-string">isA,</span> <span class="hljs-attr">classB :</span> <span class="hljs-string">isB&#125;&quot;</span><span class="hljs-string">*</span> <span class="hljs-string">:class=&quot;[classA,</span> <span class="hljs-string">classB]&quot;</span><span class="hljs-string">*</span> <span class="hljs-string">:style</span><span class="hljs-string">:style=&quot;&#123;color</span> <span class="hljs-string">:</span> <span class="hljs-string">color&#125;&quot;</span><span class="hljs-string">v-model</span><span class="hljs-string">*</span> <span class="hljs-string">双向数据绑定</span><span class="hljs-string">*</span> <span class="hljs-string">自动收集用户输入数据</span><span class="hljs-attr">ref :</span> <span class="hljs-string">标识某个标签</span><span class="hljs-string">*</span> <span class="hljs-string">ref=&#x27;xxx&#x27;</span><span class="hljs-string">*</span> <span class="hljs-string">读取得到标签对象:</span> <span class="hljs-string">this.$refs.xxx</span></code></pre></div><h1 id="8-自定义指令"><a href="#8-自定义指令" class="headerlink" title="8. 自定义指令"></a>8. 自定义指令</h1><h2 id="1-注册全局指令"><a href="#1-注册全局指令" class="headerlink" title="1). 注册全局指令"></a>1). 注册全局指令</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript">Vue.directive(<span class="hljs-string">&#x27;my-directive&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">el, binding</span>)</span>&#123;  el.innerHTML = binding.value.toUpperCase()&#125;)</code></pre></div><h2 id="2-注册局部指令"><a href="#2-注册局部指令" class="headerlink" title="2). 注册局部指令"></a>2). 注册局部指令</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript">directives : &#123;  <span class="hljs-string">&#x27;my-directive&#x27;</span> : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">el, binding</span>) </span>&#123;      el.innerHTML = binding.value.toUpperCase()  &#125;&#125;</code></pre></div><h2 id="3-使用指令"><a href="#3-使用指令" class="headerlink" title="3). 使用指令"></a>3). 使用指令</h2><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-my-directive</span>=<span class="hljs-string">&#x27;xxx&#x27;</span>&gt;</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot 统一异常处理</title>
    <link href="/2020/06/07/spring-exception/"/>
    <url>/2020/06/07/spring-exception/</url>
    
    <content type="html"><![CDATA[<h2 id="springBoot-统一异常处理"><a href="#springBoot-统一异常处理" class="headerlink" title="springBoot 统一异常处理"></a>springBoot 统一异常处理</h2><h3 id="异常处理反例"><a href="#异常处理反例" class="headerlink" title="异常处理反例"></a>异常处理反例</h3><ul><li><h4 id="捕获异常后只输出到控制台"><a href="#捕获异常后只输出到控制台" class="headerlink" title="捕获异常后只输出到控制台"></a>捕获异常后只输出到控制台</h4></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript">前端$.ajax(&#123;    type: <span class="hljs-string">&quot;GET&quot;</span>,    url: <span class="hljs-string">&quot;/user/add&quot;</span>,    dataType: <span class="hljs-string">&quot;json&quot;</span>,    success: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;        alert(<span class="hljs-string">&quot;添加成功&quot;</span>);    &#125;&#125;);后端<span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// do something</span>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;    e.printStackTrace();&#125;</code></pre></div><p> 这是见过最多的异常处理方式了, 如果这是一个添加商品的方法, 前台通过 ajax 发送请求到后端, 期望返回 json 信息表示添加结果. 但如果这段代码出现了异常:</p><ul><li>那么用户看到的场景就是点击了添加按钮, 但没有任何反应(其实是返回了 500 错误页面, 但这里前端没有监听 error 事件, 只监听了 success 事件. 但即使加上了<code>error: function(data) &#123;alert(&quot;添加失败&quot;);&#125;</code>) 又如何呢? 到底因为啥失败了呢, 用户也不得而知.</li><li>后台 <code>e.printStackTrace()</code> 打印在控制台的日志也会在漫漫的日志中被埋没, 很可能会看不到输出的异常. 但这并不是最糟的情况, 更糟糕的事情是连 <code>e.printStackTrace()</code> 都没有, <code>catch</code> 块中是空的, 这样后端的控制台中更是什么都看不到了, 这段代码会像一个隐形的炸弹一样一直埋伏在系统中.</li></ul><h4 id="混乱的返回方式"><a href="#混乱的返回方式" class="headerlink" title="混乱的返回方式"></a>混乱的返回方式</h4><div class="hljs code-wrapper"><pre><code class="hljs javascript">$.ajax(&#123;    type: <span class="hljs-string">&quot;GET&quot;</span>,    url: <span class="hljs-string">&quot;/goods/add&quot;</span>,    dataType: <span class="hljs-string">&quot;json&quot;</span>,    success: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;        <span class="hljs-keyword">if</span> (data.flag) &#123;            alert(<span class="hljs-string">&quot;添加成功&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            alert(data.message);        &#125;    &#125;,    error: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;        alert(<span class="hljs-string">&quot;添加失败&quot;</span>);    &#125;&#125;);后端@RequestMapping(<span class="hljs-string">&quot;/goods/add&quot;</span>)@ResponseBodypublic <span class="hljs-built_in">Map</span> <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params">Goods goods</span>)</span> &#123;    <span class="hljs-built_in">Map</span> map = <span class="hljs-keyword">new</span> HashMap();    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// do something</span>        map.put(flag, <span class="hljs-literal">true</span>);    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();        map.put(<span class="hljs-string">&quot;flag&quot;</span>, <span class="hljs-literal">false</span>);        map.put(<span class="hljs-string">&quot;message&quot;</span>, e.getMessage());    &#125;    reutrn map;&#125;</code></pre></div><ul><li><p>这种方式捕获异常后, 返回了错误信息, 且前台做了一定的处理, 看起来很完善? 但用 <code>HashMap</code> 中的 <code>flag</code> 和 <code>message</code> 这种字符串来当键很容易处理, 例如你这里叫 <code>message</code>, 别人起名叫 <code>msg</code>, 甚至有时手抖打错了, 怎么办? 前台再改成 <code>msg</code> 或其他的字符?, 前端后端这样一直来回改?</p><p>更有甚者在情况 A 的情况下, 返回 json, 在情况 B 的情况下, 重定向到某个页面, 这就更乱了. 对于这种不统一的结构处理起来非常麻烦.</p></li></ul><h3 id="异常处理规范"><a href="#异常处理规范" class="headerlink" title="异常处理规范"></a>异常处理规范</h3><ul><li><h4 id="不要捕获任何异常"><a href="#不要捕获任何异常" class="headerlink" title="不要捕获任何异常"></a>不要捕获任何异常</h4><p>对的, 不要在<strong>业务代码中</strong>进行捕获异常, 即 dao、service、controller 层的所以异常都全部抛出到上层. 这样不会导致业务代码中的一堆 <code>try-catch</code> 会混乱业务代码.</p></li><li><h4 id="统一返回结果集"><a href="#统一返回结果集" class="headerlink" title="统一返回结果集"></a>统一返回结果集</h4><p>不要使用 Map 来返回结果, Map 不易控制且容易犯错, 应该定义一个 Java 实体类. 来表示统一结果来返回, 如定义实体类:</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xkcoding.exception.handler.model;<span class="hljs-keyword">import</span> com.xkcoding.exception.handler.constant.Status;<span class="hljs-keyword">import</span> com.xkcoding.exception.handler.exception.BaseException;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiResponse</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 状态码</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> Integer code;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 返回内容</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> String message;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 返回数据</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> Object data;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 无参构造函数</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ApiResponse</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 全参构造函数</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> code    状态码</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> message 返回内容</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> data    返回数据</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ApiResponse</span><span class="hljs-params">(Integer code, String message, Object data)</span> </span>&#123;<span class="hljs-keyword">this</span>.code = code;<span class="hljs-keyword">this</span>.message = message;<span class="hljs-keyword">this</span>.data = data;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 构造一个自定义的API返回</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> code    状态码</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> message 返回内容</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> data    返回数据</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> ApiResponse</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ApiResponse <span class="hljs-title">of</span><span class="hljs-params">(Integer code, String message, Object data)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApiResponse(code, message, data);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 构造一个成功且带数据的API返回</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> data 返回数据</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> ApiResponse</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ApiResponse <span class="hljs-title">ofSuccess</span><span class="hljs-params">(Object data)</span> </span>&#123;<span class="hljs-keyword">return</span> ofStatus(Status.OK, data);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 构造一个成功且自定义消息的API返回</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> message 返回内容</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> ApiResponse</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ApiResponse <span class="hljs-title">ofMessage</span><span class="hljs-params">(String message)</span> </span>&#123;<span class="hljs-keyword">return</span> of(Status.OK.getCode(), message, <span class="hljs-keyword">null</span>);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 构造一个有状态的API返回</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> status 状态 &#123;<span class="hljs-doctag">@link</span> Status&#125;</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> ApiResponse</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ApiResponse <span class="hljs-title">ofStatus</span><span class="hljs-params">(Status status)</span> </span>&#123;<span class="hljs-keyword">return</span> ofStatus(status, <span class="hljs-keyword">null</span>);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 构造一个有状态且带数据的API返回</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> status 状态 &#123;<span class="hljs-doctag">@link</span> Status&#125;</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> data   返回数据</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> ApiResponse</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ApiResponse <span class="hljs-title">ofStatus</span><span class="hljs-params">(Status status, Object data)</span> </span>&#123;<span class="hljs-keyword">return</span> of(status.getCode(), status.getMessage(), data);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 构造一个异常且带数据的API返回</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> t    异常</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> data 返回数据</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt;  &#123;<span class="hljs-doctag">@link</span> BaseException&#125; 的子类</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> ApiResponse</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T extends BaseException&gt; <span class="hljs-function">ApiResponse <span class="hljs-title">ofException</span><span class="hljs-params">(T t, Object data)</span> </span>&#123;<span class="hljs-keyword">return</span> of(t.getCode(), t.getMessage(), data);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 构造一个异常且带数据的API返回</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> t   异常</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt; &#123;<span class="hljs-doctag">@link</span> BaseException&#125; 的子类</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> ApiResponse</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T extends BaseException&gt; <span class="hljs-function">ApiResponse <span class="hljs-title">ofException</span><span class="hljs-params">(T t)</span> </span>&#123;<span class="hljs-keyword">return</span> ofException(t, <span class="hljs-keyword">null</span>);&#125;&#125;</code></pre></div><h3 id="异常处理类"><a href="#异常处理类" class="headerlink" title="异常处理类"></a>异常处理类</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoExceptionHandler</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_ERROR_VIEW = <span class="hljs-string">&quot;error&quot;</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 统一 json 异常处理</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> exception JsonException</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 统一返回 json 格式</span><span class="hljs-comment"> */</span><span class="hljs-meta">@ExceptionHandler(value = JsonException.class)</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> ApiResponse <span class="hljs-title">jsonErrorHandler</span><span class="hljs-params">(JsonException exception)</span> </span>&#123;log.error(<span class="hljs-string">&quot;【JsonException】:&#123;&#125;&quot;</span>, exception.getMessage());<span class="hljs-keyword">return</span> ApiResponse.ofException(exception);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 统一 页面 异常处理</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> exception PageException</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 统一跳转到异常页面</span><span class="hljs-comment"> */</span><span class="hljs-meta">@ExceptionHandler(value = PageException.class)</span><span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">pageErrorHandler</span><span class="hljs-params">(PageException exception)</span> </span>&#123;log.error(<span class="hljs-string">&quot;【DemoPageException】:&#123;&#125;&quot;</span>, exception.getMessage());ModelAndView view = <span class="hljs-keyword">new</span> ModelAndView();view.addObject(<span class="hljs-string">&quot;message&quot;</span>, exception.getMessage());view.setViewName(DEFAULT_ERROR_VIEW);<span class="hljs-keyword">return</span> view;&#125;&#125;</code></pre></div><p>意思由代码进入Controller层之后由@ControllerAdvice进行AOP包围处理,可自定义接受异常后跳转页面或者返回API调用信息。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>exception</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker Principal</title>
    <link href="/2020/06/03/docker-%20design-architecture/"/>
    <url>/2020/06/03/docker-%20design-architecture/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-架构"><a href="#Docker-架构" class="headerlink" title="Docker 架构"></a>Docker 架构</h1><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>docker架构设计参考文章进行整理：地址为<a href="https://www.huweihuang.com/article/docker/docker-architecture/">https://www.huweihuang.com/article/docker/docker-architecture/</a></p><p>这一篇文章源于2015年出版的《docker源码分析》，书中以docker1.2.0版本进行分析。但是在docker1.11以后，docker的架构就在不断的优化和拆分。下面整理出了docker框架的变迁史，可以稍作参考。</p><h3 id="2-架构设计"><a href="#2-架构设计" class="headerlink" title="2. 架构设计"></a>2. 架构设计</h3><p><img src="/img/docker/docker-principal.png"></p>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker container</title>
    <link href="/2020/06/03/docker-container-use/"/>
    <url>/2020/06/03/docker-container-use/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-容器操作"><a href="#Docker-容器操作" class="headerlink" title="Docker 容器操作"></a>Docker 容器操作</h1><p>​        镜像包含了容器运行所需要的文件系统结构和内容，是静态的只读文件，而容器则是在镜像的只读层上创建了可写层，并且容器中的进程属于运行状态，容器是真正的应用载体。接下来讲讲Docker 核心：容器，重点讲解一下容器的基本操作。</p><h3 id="1-容器（Container）"><a href="#1-容器（Container）" class="headerlink" title="1. 容器（Container）"></a>1. 容器（Container）</h3><p>容器是基于镜像创建的可运行实例，并且单独存在，一个镜像可以创建出多个容器。</p><p><img src="/img/docker/docker-container-layer.png"></p><h5 id="1-1-容器的生命周期"><a href="#1-1-容器的生命周期" class="headerlink" title="1.1 容器的生命周期"></a>1.1 容器的生命周期</h5><p>容器的生命周期是容器可能处于的状态，容器的生命周期分为 5 种。</p><ul><li><p>created：初建状态</p></li><li><p>running：运行状态</p></li><li><p>stopped：停止状态</p></li><li><p>paused： 暂停状态</p></li><li><p>deleted：删除状态</p></li></ul><p>各生命周期之前的转换关系如图所示：</p><p><img src="/img/docker/docker-container-status.png"></p><p>docker create命令: 生成的容器状态为初建状态，初建状态通过</p><p>docker start命令：可以将初建状态转化为运行状态</p><p>docker stop命令：运行状态的容器转化为停止状态</p><p>docker start命令：可以将处于停止状态的容器转化为运行状态</p><p>docker pause命令：运行状态的容器转化为暂停状态</p><p>docker unpause命令：将处于暂停状态的容器转化为运行状态 。</p><p><strong>重点：处于初建状态、运行状态、停止状态、暂停状态的容器都可以直接删除。</strong></p><h3 id="2-容器命令"><a href="#2-容器命令" class="headerlink" title="2. 容器命令"></a>2. 容器命令</h3><p>容器的操作可以分为五个步骤：创建并启动容器、终止容器、进入容器、删除容器、导入和导出容器。</p><h5 id="2-1-创建并启动容器"><a href="#2-1-创建并启动容器" class="headerlink" title="2.1 创建并启动容器"></a>2.1 创建并启动容器</h5><p>容器启动有两种方式：</p><ol><li><p>docker create命令用于创建容器，创建后的容器处于停止状态，然后可以使用docker start命令来启动它。</p><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver"><span class="hljs-comment"># --name 指定容器的名称  </span><span class="hljs-comment"># 最后面的busybox为镜像</span>docker <span class="hljs-built_in">create</span> -<span class="hljs-keyword">it</span> <span class="hljs-comment">--name=new_busybox busybox</span><span class="hljs-comment"># 启动刚create创建的容器</span>docker <span class="hljs-built_in">start</span> new_busybox</code></pre></div></li><li><p>使用docker run命令直接基于镜像新建一个容器并启动，相当于先执行docker create命令从镜像创建容器，然后再执行docker start命令启动容器。</p><div class="hljs code-wrapper"><pre><code class="hljs routeros">docker <span class="hljs-builtin-name">run</span> -it <span class="hljs-attribute">--name</span>=new_busybox busybox</code></pre></div></li></ol><p>当使用<code>docker run</code>创建并启动容器时，Docker 后台执行的流程为：</p><ul><li>Docker 会检查本地是否存在 busybox 镜像，如果镜像不存在则从 Docker Hub 拉取 busybox 镜像</li><li>使用 busybox 镜像创建并启动一个容器, 容器名为new_busybox</li><li>分配文件系统，并且在镜像只读层外创建一个读写层</li><li>从 Docker IP 池中分配一个 IP 给容器（在下面会讲解原理）</li><li>执行用户的启动命令运行镜像</li></ul><h5 id="2-2-终止容器"><a href="#2-2-终止容器" class="headerlink" title="2.2 终止容器"></a>2.2 终止容器</h5><p><code>docker stop</code>命令：停止运行中的容器。命令格式为 docker stop [-t|–time[=10]]。</p><p>该命令首先会向运行中的容器发送 SIGTERM 信号，如果容器内 1 号进程接受并能够处理 SIGTERM，则等待 1 号进程处理完毕后退出，如果等待一段时间后，容器仍然没有退出，则会发送 SIGKILL 强制终止容器。</p><div class="hljs code-wrapper"><pre><code class="hljs arduino">docker stop new_busybox</code></pre></div><p>如果你想查看停止状态的容器信息，你可以使用 docker ps -a 命令。</p><div class="hljs code-wrapper"><pre><code class="hljs css">docker ps -<span class="hljs-selector-tag">a</span></code></pre></div><p>处于终止状态的容器也可以通过<code>docker start</code>命令和<code>docker restart</code>命令来重新启动。</p><div class="hljs code-wrapper"><pre><code class="hljs haxe">docker start <span class="hljs-keyword">new</span><span class="hljs-type">_busybox</span><span class="hljs-type">docker</span> restart <span class="hljs-keyword">new</span><span class="hljs-type">_busybox</span></code></pre></div><h5 id="2-3-进入容器"><a href="#2-3-进入容器" class="headerlink" title="2.3 进入容器"></a>2.3 进入容器</h5><p>处于运行状态的容器可以通过<code>docker attach</code>、<code>docker exec</code>、<code>nsenter</code>等多种方式进入容器。</p><ul><li><strong>使用</strong><code>docker attach</code>命令<strong>进入容器</strong></li></ul><p>使用 docker attach ，进入我们上一步创建好的容器，如下所示。</p><div class="hljs code-wrapper"><pre><code class="hljs arduino">docker attach new_busybox</code></pre></div><p><strong>注意：</strong>当我们同时使用<code>docker attach</code>命令同时在多个终端运行时，所有的终端窗口将同步显示相同内容，当某个命令行窗口的命令阻塞时，其他命令行窗口同样也无法操作。<br>由于<code>docker attach</code>命令不够灵活，因此我们一般不会使用<code>docker attach</code>进入容器</p><ul><li><strong>使用 docker exec 命令进入容器</strong></li></ul><p>通过<code>docker exec -it CONTAINER /bin/bash</code>的方式进入到一个已经运行中的容器</p><div class="hljs code-wrapper"><pre><code class="hljs python">docker <span class="hljs-built_in">exec</span> -it 容器<span class="hljs-built_in">id</span> /<span class="hljs-built_in">bin</span>/bash</code></pre></div><h5 id="2-4-删除容器"><a href="#2-4-删除容器" class="headerlink" title="2.4 删除容器"></a>2.4 删除容器</h5><p>删除容器命令的使用方式如下：<code>docker rm [OPTIONS] CONTAINER [CONTAINER...]</code></p><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-comment"># 删除已经暂停的容器</span>docker <span class="hljs-built_in">rm</span> 容器名或者容器id<span class="hljs-comment"># 删除还在运行中的容器</span>docker <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> 容器名或者容器id</code></pre></div><h5 id="2-5-导出容器"><a href="#2-5-导出容器" class="headerlink" title="2.5 导出容器"></a>2.5 导出容器</h5><ul><li><strong>导出容器</strong></li></ul><p>使用<code>docker export CONTAINER</code>命令导出一个容器到文件，不管此时该容器是否处于运行中的状态。</p><p>执行导出命令：</p><div class="hljs code-wrapper"><pre><code class="hljs haxe">docker export <span class="hljs-keyword">new</span><span class="hljs-type">_busybox</span> &gt; <span class="hljs-keyword">new</span><span class="hljs-type">_busybox</span>.tar</code></pre></div><p>执行以上命令后会在当前文件夹下生成 new_busybox.tar 文件，我们可以将该文件拷贝到其他机器上，通过导入命令实现容器的迁移。</p><ul><li><strong>导入容器</strong></li></ul><p>通过<code>docker export</code>命令导出的文件，可以使用<code>docker import</code>命令导入，执行完<code>docker import</code>后会变为本地镜像，最后再使用<code>docker run</code>命令启动该镜像，这样我们就实现了容器的迁移。</p><p>导入容器的命令格式为 docker import [OPTIONS] file|URL [REPOSITORY[:TAG]]。接下来将上一步导出的镜像文件导入到其他机器的 Docker 中并启动它。</p><p>使用<code>docker import</code>命令导入上一步导出的容器</p><div class="hljs code-wrapper"><pre><code class="hljs haxe">docker <span class="hljs-keyword">import</span> <span class="hljs-keyword">new</span><span class="hljs-type">_busybox</span>.tar <span class="hljs-keyword">new</span><span class="hljs-type">_busybox</span>:test</code></pre></div><p>此时，new_busybox.tar 被导入成为新的镜像，镜像名称为 new_busybox:test 。下面，我们使用<code>docker run</code>命令启动并进入容器，查看上一步创建的临时文件</p><div class="hljs code-wrapper"><pre><code class="hljs stata">docker <span class="hljs-keyword">run</span> -it busybox:<span class="hljs-keyword">test</span> <span class="hljs-keyword">sh</span></code></pre></div><p><strong>重点：</strong>通过<code>docker export</code>和<code>docker import</code>命令配合实现了容器的迁移</p><h3 id="3-网络动态IP分配"><a href="#3-网络动态IP分配" class="headerlink" title="3. 网络动态IP分配"></a>3. 网络动态IP分配</h3><p>刚讲到docker run命令的执行时需要从Docker IP 池中分配一个 IP 给容器，接下来重点讲解下该内容。</p><h5 id="一、Docker的四种网络模式"><a href="#一、Docker的四种网络模式" class="headerlink" title="一、Docker的四种网络模式"></a>一、Docker的四种网络模式</h5><p>Docker在创建容器时有四种网络模式，bridge为默认不需要用–net去指定，其他三种模式需要在创建容器时使用–net去指定。</p><ol><li>bridge模式，使用–net=bridge指定，默认设置。</li><li>none模式，使用–net=none指定。</li><li>host模式，使用–net=host指定。</li><li>container模式，使用–net=container:容器名称或ID指定。（如：–net=container:30b668ccb630）</li></ol><p><strong>bridge模式：</strong>docker网络隔离基于网络命名空间<Network Namespace>，在物理机上创建docker容器时会为每一个docker容器分配网络命名空间，并且把容器IP桥接到物理机的虚拟网桥上。</p><p><strong>none模式：</strong>此模式下创建容器是不会为容器配置任何网络参数的，如：容器网卡、IP、通信路由等，全部需要自己去配置。</p><p><strong>host模式：</strong>此模式创建的容器没有自己独立的网络命名空间，是和物理机共享一个Network Namespace，并且共享物理机的所有端口与IP，并且这个模式认为是不安全的。</p><p><strong>container模式：</strong>此模式和host模式很类似，只是此模式创建容器共享的是其他容器的IP和端口而不是物理机，此模式容器自身是不会配置网络和端口，创建此模式容器进去后，你会发现里边的IP是你所指定的那个容器IP并且端口也是共享的，而且其它还是互相隔离的，如进程等。</p>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker File</title>
    <link href="/2020/06/03/docker-file/"/>
    <url>/2020/06/03/docker-file/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-file"><a href="#Docker-file" class="headerlink" title="Docker file"></a>Docker file</h1><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​    生产实践中一定优先使用 Dockerfile 的方式构建镜像。 因为使用 Dockerfile 构建镜像可以带来很多好处：</p><ul><li><p>易于版本化管理，Dockerfile 本身是一个文本文件，方便存放在代码仓库做版本管理，可以很方便地找到各个版本之间的变更历史；</p></li><li><p>过程可追溯，Dockerfile 的每一行指令代表一个镜像层，根据 Dockerfile 的内容即可很明确地查看镜像的完整构建过程；</p></li><li><p>屏蔽构建环境异构，使用 Dockerfile 构建镜像无须考虑构建环境，基于相同 Dockerfile 无论在哪里运行，构建结果都一致；</p></li><li><p>虽然有这么多好处，但是如果你 Dockerfile 使用不当也会引发很多问题。比如镜像构建时间过长，甚至镜像构建失败；镜像层数过多，导致镜像文件过大。所以，这一课时我就教你如何在生产环境中编写最优的 Dockerfile；</p></li></ul><h3 id="2-Dockerfile编写遵循的原则"><a href="#2-Dockerfile编写遵循的原则" class="headerlink" title="2. Dockerfile编写遵循的原则"></a>2. Dockerfile编写遵循的原则</h3><p>​    遵循以下 Dockerfile 书写原则，不仅可以使得我们的 Dockerfile 简洁明了，让协作者清楚地了解镜像的完整构建流程，还可以帮助我们减少镜像的体积，加快镜像构建的速度和分发速度。</p><p><strong>（1）单一职责</strong><br>​    由于容器的本质是进程，一个容器代表一个进程，因此不同功能的应用应该尽量拆分为不同的容器，每个容器只负责单一业务进程。</p><p><strong>（2）提供注释信息</strong><br>​    Dockerfile 也是一种代码，我们应该保持良好的代码编写习惯，晦涩难懂的代码尽量添加注释，让协作者可以一目了然地知道每一行代码的作用，并且方便扩展和使用。</p><p><strong>（3）保持容器最小化</strong><br>​    应该避免安装无用的软件包，比如在一个 nginx 镜像中，我并不需要安装 vim 、gcc 等开发编译工具。这样不仅可以加快容器构建速度，而且可以避免镜像体积过大。</p><p><strong>（4）合理选择基础镜像</strong><br>​    容器的核心是应用，因此只要基础镜像能够满足应用的运行环境即可。例如一个Java类型的应用运行时只需要JRE，并不需要JDK，因此我们的基础镜像只需要安装JRE环境即可。</p><p><strong>（5）使用 .dockerignore 文件</strong><br>​    在使用git时，我们可以使用.gitignore文件忽略一些不需要做版本管理的文件。同理，使用.dockerignore文件允许我们在构建时，忽略一些不需要参与构建的文件，从而提升构建效率。.dockerignore的定义类似于.gitignore。</p><p>.dockerignore的本质是文本文件，Docker 构建时可以使用换行符来解析文件定义，每一行可以忽略一些文件或者文件夹。具体使用方式如下：</p><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">规则   含义<span class="hljs-comment"># 开头的表示注释，# 后面所有内容将会被忽略</span><span class="hljs-string">/tmp</span>匹配当前目录下任何以 tmp 开头的文件或者文件夹*<span class="hljs-string">.md</span>匹配以 <span class="hljs-string">.md</span> 为后缀的任意文件tem?匹配以 tem 开头并且以任意字符结尾的文件，？代表任意一个字符!README.md  ! 表示排除忽略。</code></pre></div><p><strong>（6）尽量使用构建缓存</strong><br>​    Docker 构建过程中，每一条 Dockerfile 指令都会提交为一个镜像层，下一条指令都是基于上一条指令构建的。如果构建时发现要构建的镜像层的父镜像层已经存在，并且下一条命令使用了相同的指令，即可命中构建缓存。</p><p>Docker 构建时判断是否需要使用缓存的规则如下：</p><ul><li><p>从当前构建层开始，比较所有的子镜像，检查所有的构建指令是否与当前完全一致，如果不一致，则不使用缓存；</p></li><li><p>一般情况下，只需要比较构建指令即可判断是否需要使用缓存，但是有些指令除外（例如ADD和COPY）；</p></li><li><p>对于ADD和COPY指令不仅要校验命令是否一致，还要为即将拷贝到容器的文件计算校验和（根据文件内容计算出的一个数值，如果两个文件计算的数值一致，表示两个文件内容一致 ），命令和校验和完全一致，才认为命中缓存。</p></li><li><p>因此，基于 Docker 构建时的缓存特性，我们可以把不轻易改变的指令放到 Dockerfile 前面（例如安装软件包），而可能经常发生改变的指令放在 Dockerfile 末尾（例如编译应用程序）。</p></li><li><p>例如，我们想要定义一些环境变量并且安装一些软件包，可以按照如下顺序编写 Dockerfile：</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs routeros"><span class="hljs-keyword">FROM</span> centos:7<span class="hljs-comment"># 设置环境变量指令放前面</span>ENV PATH /usr/local/bin:<span class="hljs-variable">$PATH</span><span class="hljs-comment"># 安装软件指令放前面</span><span class="hljs-builtin-name">RUN</span> yum install -y make<span class="hljs-comment"># 把业务软件的配置,版本等经常变动的步骤放最后</span></code></pre></div><p>按照上面原则编写的 Dockerfile 在构建镜像时，前面步骤命中缓存的概率会增加，可以大大缩短镜像构建时间。</p><p><strong>（7）正确设置时区</strong><br>​    我们从 Docker Hub 拉取的官方操作系统镜像大多数都是 UTC 时间（世界标准时间）。如果你想要在容器中使用中国区标准时间（东八区），请根据使用的操作系统修改相应的时区信息，下面我介绍几种常用操作系统的修改方式：</p><p><strong>Ubuntu 和Debian 系统</strong></p><p>Ubuntu 和Debian 系统可以向 Dockerfile 中添加以下指令：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">RUN ln -sf <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/zoneinfo/</span>Asia<span class="hljs-regexp">/Shanghai /</span>etc/localtimeRUN echo <span class="hljs-string">&quot;Asia/Shanghai&quot;</span> &gt;&gt; <span class="hljs-regexp">/etc/</span>timezone</code></pre></div><p><strong>CentOS系统</strong></p><p>CentOS 系统则向 Dockerfile 中添加以下指令：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">RUN ln -sf <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/zoneinfo/</span>Asia<span class="hljs-regexp">/Shanghai /</span>etc/localtime</code></pre></div><p><strong>（8）使用国内软件源加快镜像构建速度</strong><br>​    由于我们常用的官方操作系统镜像基本都是国外的，软件服务器大部分也在国外，所以我们构建镜像的时候想要安装一些软件包可能会非常慢。</p><p><strong>（9）最小化镜像层数</strong><br>在构建镜像时尽可能地减少 Dockerfile 指令行数。例如我们要在 CentOS 系统中安装make和net-tools两个软件包，应该在 Dockerfile 中使用以下指令：</p><div class="hljs code-wrapper"><pre><code class="hljs gauss"><span class="hljs-keyword">RUN</span> yum install -y <span class="hljs-built_in">make</span> net-tools</code></pre></div><p>而不应该写成这样：</p><div class="hljs code-wrapper"><pre><code class="hljs gauss"><span class="hljs-keyword">RUN</span> yum install -y <span class="hljs-built_in">make</span><span class="hljs-keyword">RUN</span> yum install -y <span class="hljs-built_in">make</span></code></pre></div><p>了解完 Dockerfile 的书写原则后，我们再来具体了解下这些原则落实到具体的 Dockerfile 指令应该如何书写。</p><h3 id="3-Dockerfile-指令书写建议"><a href="#3-Dockerfile-指令书写建议" class="headerlink" title="3. Dockerfile 指令书写建议"></a>3. Dockerfile 指令书写建议</h3><p>下面是我们常用的一些指令:</p><p><strong>（1）RUN</strong><br>RUN指令在构建时<strong>将会生成一个新的镜像层</strong>并且执行RUN指令后面的内容。</p><p>使用RUN指令时应该尽量遵循以下原则：</p><ul><li><p>当RUN指令后面跟的内容比较复杂时，建议使用反斜杠（\） 结尾并且换行；</p></li><li><p>RUN指令后面的内容尽量按照字母顺序排序，提高可读性。</p></li></ul><p>例如，在官方的 CentOS 镜像下安装一些软件，一个建议的 Dockerfile 指令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs livescript">FROM centos:<span class="hljs-number">7</span>RUN yum install -y automake <span class="hljs-string">\</span>                   curl <span class="hljs-string">\</span>                   python <span class="hljs-string">\</span>                   vim</code></pre></div><p><strong>（2）CMD 和 ENTRYPOINT</strong></p><p>​    <strong>CMD和ENTRYPOINT指令都是容器运行的命令入口</strong>。</p><p>这两个指令的相同之处，CMD和ENTRYPOINT的基本使用格式分为两种。</p><ul><li><p>第一种为CMD/ENTRYPOINT[“command” , “param”]。这种格式是使用 <strong>Linux 的exec</strong>实现的， 一般称为exec模式，这种书写格式为CMD/ENTRYPOINT后面跟 json 数组，也是Docker 推荐的使用格式。</p></li><li><p>另外一种格式为CMD/ENTRYPOINTcommand param ，这种格式是<strong>基于 shell 实现</strong>的， 通常称为shell模式。当使用shell模式时，Docker 会以 /bin/sh -c command 的方式执行命令。</p></li></ul><p>区别：</p><ul><li>Dockerfile 中如果使用了ENTRYPOINT指令，启动 Docker 容器时需要使用 –entrypoint 参数才能覆盖 Dockerfile 中的ENTRYPOINT指令 </li><li>使用CMD设置的命令则可以被docker run后面的参数直接覆盖。</li><li>ENTRYPOINT指令可以结合CMD指令使用，也可以单独使用，而CMD指令只能单独使用。</li></ul><p>例如：dockerfiler如下定义</p><div class="hljs code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3</span><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;python3&quot;</span>, <span class="hljs-string">&quot;hello.py&quot;</span>]</span></code></pre></div><p>执行启动命令为：docker run python3 xxx.py -itd xxxx，表示下拉python:3镜像，并执行python3 xxx.py命令，如果用docker run -itd xxxx，表示下拉python:3镜像，并执行Dockerfile中定义的python3 hello.py命令。</p><h4 id="疑问🤔️："><a href="#疑问🤔️：" class="headerlink" title="疑问🤔️："></a><strong>疑问🤔️：</strong></h4><p>什么时候应该使用ENTRYPOINT,什么时候使用CMD呢？</p><p>如果你希望你的镜像足够灵活，推荐使用CMD指令。如果你的镜像只执行单一的具体程序，并且不希望用户在执行docker run时覆盖默认程序，建议使用ENTRYPOINT。</p><p>最后再强调一下，无论使用CMD还是ENTRYPOINT，都<strong>尽量使用exec模式</strong>。</p><p>如果<strong>在Dockerfile中有多条CMD指令，那么永远只会执行最后一条CMD指令，最好将执行的命令通过&amp;&amp;进行连接。</strong></p><p><strong>（3）ADD 和 COPY</strong><br>​    ADD和COPY指令功能类似，都是从外部往容器内添加文件。</p><ul><li>COPY指令只支持<strong>基本的文件和文件夹</strong>拷贝功能</li><li>ADD则支持更多<strong>文件来源类型</strong>，比如自动提取 tar 包，并且可以支持源文件为 URL 格式。</li></ul><p>那么在日常应用中，我们应该使用哪个命令向容器里添加文件呢？既然ADD指令支持的功能更多，当然应该使用ADD指令了。然而事实恰恰相反，其实更推荐使用COPY指令，因为COPY指令更加透明，仅支持本地文件向容器拷贝，而且使用COPY指令可以更好地利用构建缓存，有效减小镜像体积。</p><p>如果使用ADD向容器中添加 URL 文件时，请尽量考虑使用其他方式替代。例如你想要在容器中安装 memtester（一种内存压测工具），你应该避免使用以下格式：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">ADD http:<span class="hljs-regexp">//</span>pyropus.ca<span class="hljs-regexp">/software/m</span>emtester<span class="hljs-regexp">/old-versions/m</span>emtester-<span class="hljs-number">4.3</span>.<span class="hljs-number">0</span>.tar.gz <span class="hljs-regexp">/tmp/</span>RUN tar -xvf <span class="hljs-regexp">/tmp/m</span>emtester-<span class="hljs-number">4.3</span>.<span class="hljs-number">0</span>.tar.gz -C /tmpRUN make -C <span class="hljs-regexp">/tmp/m</span>emtester-<span class="hljs-number">4.3</span>.<span class="hljs-number">0</span> &amp;&amp; make -C <span class="hljs-regexp">/tmp/m</span>emtester-<span class="hljs-number">4.3</span>.<span class="hljs-number">0</span> install</code></pre></div><p>下面是推荐写法：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">RUN wget -O <span class="hljs-regexp">/tmp/m</span>emtester-<span class="hljs-number">4.3</span>.<span class="hljs-number">0</span>.tar.gz http:<span class="hljs-regexp">//</span>pyropus.ca<span class="hljs-regexp">/software/m</span>emtester<span class="hljs-regexp">/old-versions/m</span>emtester-<span class="hljs-number">4.3</span>.<span class="hljs-number">0</span>.tar.gz \&amp;&amp; tar -xvf <span class="hljs-regexp">/tmp/m</span>emtester-<span class="hljs-number">4.3</span>.<span class="hljs-number">0</span>.tar.gz -C /tmp \&amp;&amp; make -C <span class="hljs-regexp">/tmp/m</span>emtester-<span class="hljs-number">4.3</span>.<span class="hljs-number">0</span> &amp;&amp; make -C <span class="hljs-regexp">/tmp/m</span>emtester-<span class="hljs-number">4.3</span>.<span class="hljs-number">0</span> install</code></pre></div><p><strong>（4）WORKDIR</strong><br>​    WORKDIR： 指定容器的工作路径，应该尽量避免使用 RUN cd /work/path &amp;&amp; do some work 这样的指令。</p>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker mirro warehouse</title>
    <link href="/2020/06/03/docker-mirro-warehouse/"/>
    <url>/2020/06/03/docker-mirro-warehouse/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-镜像仓库"><a href="#Docker-镜像仓库" class="headerlink" title="Docker 镜像仓库"></a>Docker 镜像仓库</h1><p>Docker 的操作围绕镜像、容器、仓库三大核心概念。在学架构设计之前，我们需要先了解 Docker 的三个核心概念。</p><h3 id="1-Docker-核心概念"><a href="#1-Docker-核心概念" class="headerlink" title="1. Docker 核心概念"></a>1. Docker 核心概念</h3><h4 id="1-1-镜像"><a href="#1-1-镜像" class="headerlink" title="1.1 镜像"></a>1.1 镜像</h4><p>镜像是什么呢？通俗地讲，它是一个只读的文件和文件夹组合。它包含了容器运行时所需要的所有基础文件和配置信息，是容器启动的基础。所以你想启动一个容器，那首先必须要有一个镜像。<strong>镜像是 Docker 容器启动的先决条件。</strong></p><p>如果你想要使用一个镜像，你可以用这两种方式：</p><ol><li>自己创建镜像。通常情况下，一个镜像是基于一个基础镜像构建的，你可以在基础镜像上添加一些用户自定义的内容。例如你可以基于<code>centos</code>镜像制作你自己的业务镜像，首先安装<code>nginx</code>服务，然后部署你的应用程序，最后做一些自定义配置，这样一个业务镜像就做好了。</li><li>从功能镜像仓库拉取别人制作好的镜像。一些常用的软件或者系统都会有官方已经制作好的镜像，例如<code>nginx</code>、<code>ubuntu</code>、<code>centos</code>、<code>mysql</code>等，你可以到 <a href="https://hub.docker.com/">Docker Hub</a> 搜索并下载它们。</li></ol><h4 id="1-2-容器"><a href="#1-2-容器" class="headerlink" title="1.2 容器"></a>1.2 容器</h4><p>容器是什么呢？容器是 Docker 的另一个核心概念。通俗地讲，容器是镜像的运行实体。镜像是静态的只读文件，而容器带有运行时需要的可写文件层，并且容器中的进程属于运行状态。即<strong>容器运行着真正的应用进程。容器有初建、运行、停止、暂停和删除五种状态。</strong></p><p>虽然容器的本质是主机上运行的一个进程，但是容器有自己独立的命名空间隔离和资源限制。也就是说，在容器内部，无法看到主机上的进程、环境变量、网络等信息，这是容器与直接运行在主机上进程的本质区别。</p><h4 id="1-3-仓库"><a href="#1-3-仓库" class="headerlink" title="1.3 仓库"></a>1.3 仓库</h4><p>Docker 的镜像仓库类似于代码仓库，用来存储和分发 Docker 镜像。镜像仓库分为公共镜像仓库和私有镜像仓库。</p><p>目前，<a href="https://hub.docker.com/">Docker Hub</a> 是 Docker 官方的公开镜像仓库，它不仅有很多应用或者操作系统的官方镜像，还有很多组织或者个人开发的镜像供我们免费存放、下载、研究和使用。除了公开镜像仓库，你也可以构建自己的私有镜像仓库，在第 5 课时，我会带你搭建一个私有的镜像仓库。</p><h4 id="1-4-镜像、容器、仓库，三者之间的联系"><a href="#1-4-镜像、容器、仓库，三者之间的联系" class="headerlink" title="1.4 镜像、容器、仓库，三者之间的联系"></a>1.4 镜像、容器、仓库，三者之间的联系</h4><p><img src="/img/docker/docker-container-relation.png" alt="Drawing 1.png"></p><p>可以看到，镜像是容器的基石，容器是由镜像创建的。一个镜像可以创建多个容器，容器是镜像运行的实体。仓库就非常好理解了，就是用来存放和分发镜像的。</p><p>了解了 Docker 的三大核心概念，接下来认识下 Docker 的核心架构和一些重要的组件。</p><h1 id="2-Docker-架构"><a href="#2-Docker-架构" class="headerlink" title="2. Docker 架构"></a>2. Docker 架构</h1><p>在了解 Docker 架构前，我先说下相关的背景知识——容器的发展史。</p><p>容器技术随着 Docker 的出现变得炙手可热，所有公司都在积极拥抱容器技术。此时市场上除了有 Docker 容器，还有很多其他的容器技术，比如 CoreOS 的 rkt、lxc 等。容器技术百花齐放是好事，但也出现了很多问题。比如容器技术的标准到底是什么？容器标准应该由谁来制定？</p><p>也许你可能会说， Docker 已经成为了事实标准，把 Docker 作为容器技术的标准不就好了？事实并没有想象的那么简单。因为那时候不仅有容器标准之争，编排技术之争也十分激烈。当时的编排技术有三大主力，<strong>分别是 Docker Swarm、Kubernetes 和 Mesos</strong> 。Swarm 毋庸置疑，肯定愿意把 Docker 作为唯一的容器运行时，但是 Kubernetes 和 Mesos 就不同意了，因为它们不希望调度的形式过度单一。</p><p>在这样的背景下，最终爆发了容器大战，<code>OCI</code>也正是在这样的背景下应运而生。</p><p><strong><code>OCI</code>全称为开放容器标准（Open Container Initiative）</strong>，它是一个轻量级，开放的治理结构。<code>OCI</code>组织在 Linux 基金会的大力支持下，于 2015 年 6 月份正式注册成立。基金会旨在为用户围绕工业化容器的格式和镜像运行时，制定一个开放的容器标准。目前主要有两个标准文档：<strong>容器运行时标准 （runtime spec）和容器镜像标准（image spec）</strong>。</p><p>正是由于容器的战争，才导致 Docker 不得不在战争中改变一些技术架构。最终形成了下图所示的技术架构。</p><p><img src="/img/docker/docker-architecture.png"></p><p>​    我们可以看到，Docker 整体架构采用 <strong>C/S（客户端 / 服务器）模式</strong>，主要由客户端和服务端两大部分组成。客户端负责发送操作指令，服务端负责接收和处理指令。客户端和服务端通信有多种方式，即可以在同一台机器上通过<code>UNIX</code>套接字通信，也可以通过网络连接远程通信。</p><p>下面我逐一介绍客户端和服务端。</p><h4 id="2-1-Docker-客户端"><a href="#2-1-Docker-客户端" class="headerlink" title="2.1 Docker 客户端"></a>2.1 Docker 客户端</h4><p>​    Docker 客户端其实是一种泛称。其中 <strong>docker 命令是 Docker 用户与 Docker 服务端交互的主要方式</strong>。除了使用 docker 命令的方式，还可以使用<strong>直接请求 REST API 的方式与 Docker 服务端交互</strong>，甚至还可以使用各种语言的 SDK 与 Docker 服务端交互。目前社区维护着 Go、Java、Python、PHP 等数十种语言的 SDK，足以满足你的日常需求。如<strong>Python中的docker-py库</strong>。</p><h4 id="2-2-Docker-服务端"><a href="#2-2-Docker-服务端" class="headerlink" title="2.2 Docker 服务端"></a>2.2 Docker 服务端</h4><p>​    Docker 服务端是 Docker 所有后台服务的统称。其中 <strong>dockerd 是一个非常重要的后台管理进程</strong>，默认的配置文件为/etc/docker/daemon.json。它负责响应和处理来自 Docker 客户端的请求，然后<strong>将客户端的请求转化为 Docker 的具体操作</strong>。例如镜像、容器、网络和挂载卷等具体对象的操作和管理。</p><p>​    Docker 从诞生到现在，服务端经历了多次架构重构。起初，服务端的组件是全部集成在 docker 二进制里。但是从 1.11 版本开始， dockerd 已经成了独立的二进制，此时的容器也不是直接由 dockerd 来启动了，而是集成了 containerd、runC 等多个组件。</p><p>​    虽然 Docker 的架构在不停重构，但是各个模块的基本功能和定位并没有变化。它和一般的 C/S 架构系统一样，Docker 服务端模块负责和 Docker 客户端交互，并管理 Docker 的容器、镜像、网络等资源。</p><h4 id="2-3-Docker-重要组件"><a href="#2-3-Docker-重要组件" class="headerlink" title="2.3 Docker 重要组件"></a>2.3 Docker 重要组件</h4><p>看下 Docker 都有哪些工具和组件。在 Docker 安装路径下**/usr/bin** 中执行 ls 命令可以看到以下与 docker 有关的二进制文件。（containerd、containerd-shim、ctr、docker、docker-init、docker-proxy、dockerd、runc）</p><p><img src="/img/docker/docker-component.png"></p><p>先简单介绍一下 Docker 的两个至关重要的组件：<code>runc</code>和<code>containerd</code>。</p><ul><li><code>runc</code>是 Docker 官方按照 OCI 容器运行时标准的一个实现。通俗地讲，runc是一个用来运行容器的轻量级工具，是真正用来运行容器的。</li><li><code>containerd</code>是 Docker 服务端的一个核心组件，它是从<code>dockerd</code>中剥离出来的 ，它的诞生完全遵循 OCI 标准，是容器标准化后的产物。<code>containerd</code>通过 containerd-shim 启动并管理 runc，<strong>可以说<code>containerd</code>真正管理了容器的生命周期。</strong></li></ul><h5 id="首先谈谈dockerd-containerd-docker-shim-runc，每个组件是用来干嘛的"><a href="#首先谈谈dockerd-containerd-docker-shim-runc，每个组件是用来干嘛的" class="headerlink" title="首先谈谈dockerd,containerd,docker-shim,runc，每个组件是用来干嘛的"></a><strong>首先谈谈dockerd,containerd,docker-shim,runc，每个组件是用来干嘛的</strong></h5><p><strong>2.3.1）dockerd</strong><br>​    dockerd本身实属是对容器相关操作的api的最上层封装，直接面向操作用户。</p><p><strong>2.3.2）containerd</strong><br>​    dockerd实际真实调用的还是containerd的api接口（rpc方式实现），containerd是dockerd和runc之间的一个中间交流组件。</p><p><strong>2.3.3）containerd-shim</strong><br>​    containerd-shim是一个真实<strong>运行的容器的真实垫片载体</strong>，每启动一个容器都会起一个新的containerd-shim的一个进程，他直接通过指定的三个参数：容器id，boundle目录（containerd的对应某个容器生成的目录，一般位于：/var/run/docker/libcontainerd/containerID），运行是二进制（默认为runc）来调用runc的api创建一个容器（比如创建容器：最后拼装的命令如下：runc create）</p><p><strong>2.3.4）runc</strong><br>​    runc是一个命令行工具端，他根据<code>OCI</code>（开放容器组织）的标准来创建和运行容器。</p><h3 id="3-Docker-各组件之间的关系"><a href="#3-Docker-各组件之间的关系" class="headerlink" title="3. Docker 各组件之间的关系"></a>3. Docker 各组件之间的关系</h3><p>首先通过以下命令来启动一个 busybox 容器：</p><div class="hljs code-wrapper"><pre><code class="hljs autoit">docker <span class="hljs-built_in">run</span> -d busybox <span class="hljs-built_in">sleep</span> <span class="hljs-number">3600</span></code></pre></div><p>为了验证Docker 各组件之间的调用关系，下面使用 pstree 命令查看一下进程父子关系：</p><div class="hljs code-wrapper"><pre><code class="hljs scss">systemd(<span class="hljs-number">1</span>)─┬─Xvfb(<span class="hljs-number">17214</span>)─┬─&#123;llvmpipe-0&#125;(<span class="hljs-number">18510</span>)           │             ├─&#123;llvmpipe-1&#125;(<span class="hljs-number">18511</span>)           │             ├─&#123;llvmpipe-2&#125;(<span class="hljs-number">18512</span>)           │             └─&#123;llvmpipe-3&#125;(<span class="hljs-number">18513</span>)           ├─accounts-daemon(<span class="hljs-number">1327</span>)─┬─&#123;gdbus&#125;(<span class="hljs-number">1495</span>)           │                       └─&#123;gmain&#125;(<span class="hljs-number">1492</span>)           ├─acpid(<span class="hljs-number">1203</span>)           ├─agetty(<span class="hljs-number">23750</span>)           ├─atd(<span class="hljs-number">1223</span>,daemon)           ├─containerd(<span class="hljs-number">22211</span>)─┬─containerd-shim(<span class="hljs-number">8473</span>)─┬─sleep(<span class="hljs-number">8491</span>)           │                   │                       ├─&#123;containerd-shim&#125;(<span class="hljs-number">8474</span>)           │                   │                       ├─&#123;containerd-shim&#125;(<span class="hljs-number">8475</span>)           │                   │                       ├─&#123;containerd-shim&#125;(<span class="hljs-number">8476</span>)           │                   │                       ├─&#123;containerd-shim&#125;(<span class="hljs-number">8477</span>)           │                   │                       ├─&#123;containerd-shim&#125;(<span class="hljs-number">8478</span>)           │                   │                       ├─&#123;containerd-shim&#125;(<span class="hljs-number">8479</span>)           │                   │                       ├─&#123;containerd-shim&#125;(<span class="hljs-number">8480</span>)           │                   │                       └─&#123;containerd-shim&#125;(<span class="hljs-number">8482</span>)           │                   ├─&#123;containerd&#125;(<span class="hljs-number">22216</span>)           │                   ├─&#123;containerd&#125;(<span class="hljs-number">22217</span>)           │                   ├─&#123;containerd&#125;(<span class="hljs-number">22218</span>)           │                   ├─&#123;containerd&#125;(<span class="hljs-number">22219</span>)           │                   ├─&#123;containerd&#125;(<span class="hljs-number">22220</span>)           │                   ├─&#123;containerd&#125;(<span class="hljs-number">22227</span>)           │                   ├─&#123;containerd&#125;(<span class="hljs-number">22228</span>)           │                   ├─&#123;containerd&#125;(<span class="hljs-number">22229</span>)           │                   ├─&#123;containerd&#125;(<span class="hljs-number">22231</span>)           │                   ├─&#123;containerd&#125;(<span class="hljs-number">22232</span>)           │                   ├─&#123;containerd&#125;(<span class="hljs-number">22233</span>)           │                   ├─&#123;containerd&#125;(<span class="hljs-number">22234</span>)           │                   ├─&#123;containerd&#125;(<span class="hljs-number">22369</span>)           │                   ├─&#123;containerd&#125;(<span class="hljs-number">22375</span>)           │                   ├─&#123;containerd&#125;(<span class="hljs-number">23023</span>)           │                   ├─&#123;containerd&#125;(<span class="hljs-number">24119</span>)           │                   ├─&#123;containerd&#125;(<span class="hljs-number">31016</span>)           │                   ├─&#123;containerd&#125;(<span class="hljs-number">32704</span>)           │                   ├─&#123;containerd&#125;(<span class="hljs-number">7339</span>)           │                   ├─&#123;containerd&#125;(<span class="hljs-number">23491</span>)           │                   ├─&#123;containerd&#125;(<span class="hljs-number">23596</span>)           │                   ├─&#123;containerd&#125;(<span class="hljs-number">23889</span>)           │                   ├─&#123;containerd&#125;(<span class="hljs-number">23894</span>)           │                   ├─&#123;containerd&#125;(<span class="hljs-number">24535</span>)           │                   ├─&#123;containerd&#125;(<span class="hljs-number">31378</span>)           │                   ├─&#123;containerd&#125;(<span class="hljs-number">32403</span>)           │                   ├─&#123;containerd&#125;(<span class="hljs-number">32404</span>)           │                   ├─&#123;containerd&#125;(<span class="hljs-number">15398</span>)           │                   ├─&#123;containerd&#125;(<span class="hljs-number">15399</span>)           │                   ├─&#123;containerd&#125;(<span class="hljs-number">15805</span>)           │                   └─&#123;containerd&#125;(<span class="hljs-number">16319</span>)           ├─cron(<span class="hljs-number">20629</span>)           ├─dbus-daemon(<span class="hljs-number">1227</span>,messagebus)           ├─dhclient(<span class="hljs-number">1023</span>)           ├─dockerd(<span class="hljs-number">6901</span>)─┬─&#123;dockerd&#125;(<span class="hljs-number">6903</span>)           │               ├─&#123;dockerd&#125;(<span class="hljs-number">6904</span>)           │               ├─&#123;dockerd&#125;(<span class="hljs-number">6905</span>)           │               ├─&#123;dockerd&#125;(<span class="hljs-number">6906</span>)           │               ├─&#123;dockerd&#125;(<span class="hljs-number">6907</span>)           │               ├─&#123;dockerd&#125;(<span class="hljs-number">6908</span>)           │               ├─&#123;dockerd&#125;(<span class="hljs-number">6909</span>)           │               ├─&#123;dockerd&#125;(<span class="hljs-number">6910</span>)           │               ├─&#123;dockerd&#125;(<span class="hljs-number">6912</span>)           │               ├─&#123;dockerd&#125;(<span class="hljs-number">6913</span>)           │               ├─&#123;dockerd&#125;(<span class="hljs-number">6914</span>)           │               └─&#123;dockerd&#125;(<span class="hljs-number">6915</span>)           ├─irqbalance(<span class="hljs-number">1468</span>)           ├─iscsid(<span class="hljs-number">1140</span>)           ├─iscsid(<span class="hljs-number">1141</span>)           ├─lvmetad(<span class="hljs-number">479</span>)           ├─lxcfs(<span class="hljs-number">1215</span>)─┬─&#123;lxcfs&#125;(<span class="hljs-number">1337</span>)           │             ├─&#123;lxcfs&#125;(<span class="hljs-number">1340</span>)           │             ├─&#123;lxcfs&#125;(<span class="hljs-number">9044</span>)           │             ├─&#123;lxcfs&#125;(<span class="hljs-number">23720</span>)           │             └─&#123;lxcfs&#125;(<span class="hljs-number">9313</span>)           ├─mdadm(<span class="hljs-number">1453</span>)           ├─mysqld(<span class="hljs-number">31859</span>,mysql)─┬─&#123;mysqld&#125;(<span class="hljs-number">31871</span>)           │                     ├─&#123;mysqld&#125;(<span class="hljs-number">31872</span>)           │                     ├─&#123;mysqld&#125;(<span class="hljs-number">31873</span>)           │                     ├─&#123;mysqld&#125;(<span class="hljs-number">31874</span>)           │                     ├─&#123;mysqld&#125;(<span class="hljs-number">31875</span>)           │                     ├─&#123;mysqld&#125;(<span class="hljs-number">31876</span>)           │                     ├─&#123;mysqld&#125;(<span class="hljs-number">31877</span>)           │                     ├─&#123;mysqld&#125;(<span class="hljs-number">31878</span>)           │                     ├─&#123;mysqld&#125;(<span class="hljs-number">31879</span>)           │                     ├─&#123;mysqld&#125;(<span class="hljs-number">31880</span>)           │                     ├─&#123;mysqld&#125;(<span class="hljs-number">31881</span>)           │                     ├─&#123;mysqld&#125;(<span class="hljs-number">31882</span>)           │                     ├─&#123;mysqld&#125;(<span class="hljs-number">31884</span>)           │                     ├─&#123;mysqld&#125;(<span class="hljs-number">31885</span>)           │                     ├─&#123;mysqld&#125;(<span class="hljs-number">31886</span>)           │                     ├─&#123;mysqld&#125;(<span class="hljs-number">31887</span>)           │                     ├─&#123;mysqld&#125;(<span class="hljs-number">31888</span>)           │                     ├─&#123;mysqld&#125;(<span class="hljs-number">31889</span>)           │                     ├─&#123;mysqld&#125;(<span class="hljs-number">31890</span>)           │                     ├─&#123;mysqld&#125;(<span class="hljs-number">31891</span>)           │                     ├─&#123;mysqld&#125;(<span class="hljs-number">31892</span>)           │                     ├─&#123;mysqld&#125;(<span class="hljs-number">31893</span>)           │                     ├─&#123;mysqld&#125;(<span class="hljs-number">31894</span>)           │                     ├─&#123;mysqld&#125;(<span class="hljs-number">31895</span>)           │                     ├─&#123;mysqld&#125;(<span class="hljs-number">31896</span>)           │                     ├─&#123;mysqld&#125;(<span class="hljs-number">31897</span>)           │                     ├─&#123;mysqld&#125;(<span class="hljs-number">30641</span>)           │                     ├─&#123;mysqld&#125;(<span class="hljs-number">15274</span>)           │                     ├─&#123;mysqld&#125;(<span class="hljs-number">10442</span>)           │                     ├─&#123;mysqld&#125;(<span class="hljs-number">26016</span>)           │                     ├─&#123;mysqld&#125;(<span class="hljs-number">10137</span>)           │                     ├─&#123;mysqld&#125;(<span class="hljs-number">1973</span>)           │                     ├─&#123;mysqld&#125;(<span class="hljs-number">23981</span>)           │                     └─&#123;mysqld&#125;(<span class="hljs-number">18314</span>)           ├─nginx(<span class="hljs-number">10152</span>)─┬─nginx(<span class="hljs-number">10153</span>,www-data)           │              ├─nginx(<span class="hljs-number">10154</span>,www-data)           │              ├─nginx(<span class="hljs-number">10155</span>,www-data)           │              └─nginx(<span class="hljs-number">10156</span>,www-data)           ├─polkitd(<span class="hljs-number">1512</span>)─┬─&#123;gdbus&#125;(<span class="hljs-number">1516</span>)           │               └─&#123;gmain&#125;(<span class="hljs-number">1514</span>)           ├─python(<span class="hljs-number">1190</span>)           ├─rsyslogd(<span class="hljs-number">1212</span>,syslog)─┬─&#123;in:imklog&#125;(<span class="hljs-number">1440</span>)           │                       ├─&#123;in:imuxsock&#125;(<span class="hljs-number">1439</span>)           │                       └─&#123;rs:main Q:Reg&#125;(<span class="hljs-number">1441</span>)           ├─sshd(<span class="hljs-number">1499</span>)───sshd(<span class="hljs-number">4622</span>)─┬─bash(<span class="hljs-number">4678</span>)─┬─pstree(<span class="hljs-number">8779</span>)           │                         │            └─systemctl(<span class="hljs-number">7769</span>)───pager(<span class="hljs-number">7774</span>)           │                         ├─bash(<span class="hljs-number">8773</span>)───sleep(<span class="hljs-number">8778</span>)           │                         └─sftp-server(<span class="hljs-number">4693</span>)           ├─supervisord(<span class="hljs-number">29467</span>)           ├─supervisord(<span class="hljs-number">29644</span>)           ├─systemd(<span class="hljs-number">1700</span>)───(sd-pam)(<span class="hljs-number">1704</span>)           ├─systemd-journal(<span class="hljs-number">424</span>)           ├─systemd-logind(<span class="hljs-number">1193</span>)           ├─systemd-timesyn(<span class="hljs-number">544</span>,systemd-timesync)───&#123;sd-resolve&#125;(<span class="hljs-number">559</span>)           ├─systemd-udevd(<span class="hljs-number">501</span>)           ├─top(<span class="hljs-number">19260</span>)           ├─top(<span class="hljs-number">19447</span>)           ├─uwsgi(<span class="hljs-number">10063</span>)───uwsgi(<span class="hljs-number">10077</span>)           └─wrapper(<span class="hljs-number">1490</span>)─┬─java(<span class="hljs-number">1559</span>)─┬─&#123;java&#125;(<span class="hljs-number">1567</span>)                           │            ├─&#123;java&#125;(<span class="hljs-number">1570</span>)                           │            ├─&#123;java&#125;(<span class="hljs-number">1572</span>)                           │            ├─&#123;java&#125;(<span class="hljs-number">1574</span>)                           │            ├─&#123;java&#125;(<span class="hljs-number">1576</span>)                           │            ├─&#123;java&#125;(<span class="hljs-number">1584</span>)                           │            ├─&#123;java&#125;(<span class="hljs-number">1586</span>)                           │            ├─&#123;java&#125;(<span class="hljs-number">1589</span>)                           │            ├─&#123;java&#125;(<span class="hljs-number">1603</span>)                           │            ├─&#123;java&#125;(<span class="hljs-number">1605</span>)                           │            ├─&#123;java&#125;(<span class="hljs-number">1607</span>)                           │            ├─&#123;java&#125;(<span class="hljs-number">1610</span>)                           │            ├─&#123;java&#125;(<span class="hljs-number">1612</span>)                           │            ├─&#123;java&#125;(<span class="hljs-number">1614</span>)                           │            ├─&#123;java&#125;(<span class="hljs-number">1628</span>)                           │            ├─&#123;java&#125;(<span class="hljs-number">1651</span>)                           │            └─&#123;java&#125;(<span class="hljs-number">1655</span>)                           └─&#123;wrapper&#125;(<span class="hljs-number">1493</span>)</code></pre></div><p>可以分别发现有两个进行，分别是：<code>dockerd</code>与<code>containerd</code>。而<code>dockerd</code>通过 gRPC 与<code>containerd</code>通信。当执行 <strong>docker run 命令</strong>（通过 busybox 镜像创建并启动容器）时，containerd 会创建 containerd-shim 充当 “垫片” 进程（进程PID为8473），然后启动容器的真正进程 sleep 3600 。这个过程和架构图是完全一致的。</p><p>再次创建一个容器，再来观察containerd进程的情况，下面先执行容器的创建：</p><div class="hljs code-wrapper"><pre><code class="hljs autoit">docker <span class="hljs-built_in">run</span> -d busybox <span class="hljs-built_in">sleep</span> <span class="hljs-number">3600</span></code></pre></div><p>下面使用 pstree 命令查看一下进程父子关系：</p><div class="hljs code-wrapper"><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">systemd</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>─┬─X<span class="hljs-title">vfb</span><span class="hljs-params">(<span class="hljs-number">17214</span>)</span>─┬─&#123;<span class="hljs-title">llvmpipe</span>-0&#125;<span class="hljs-params">(<span class="hljs-number">18510</span>)</span></span><span class="hljs-function">           │             ├─&#123;<span class="hljs-title">llvmpipe</span>-1&#125;<span class="hljs-params">(<span class="hljs-number">18511</span>)</span></span><span class="hljs-function">           │             ├─&#123;<span class="hljs-title">llvmpipe</span>-2&#125;<span class="hljs-params">(<span class="hljs-number">18512</span>)</span></span><span class="hljs-function">           │             └─&#123;<span class="hljs-title">llvmpipe</span>-3&#125;<span class="hljs-params">(<span class="hljs-number">18513</span>)</span></span><span class="hljs-function">           ├─<span class="hljs-title">accounts</span>-<span class="hljs-title">daemon</span><span class="hljs-params">(<span class="hljs-number">1327</span>)</span>─┬─&#123;<span class="hljs-title">gdbus</span>&#125;<span class="hljs-params">(<span class="hljs-number">1495</span>)</span></span><span class="hljs-function">           │                       └─&#123;<span class="hljs-title">gmain</span>&#125;<span class="hljs-params">(<span class="hljs-number">1492</span>)</span></span><span class="hljs-function">           ├─<span class="hljs-title">acpid</span><span class="hljs-params">(<span class="hljs-number">1203</span>)</span></span><span class="hljs-function">           ├─<span class="hljs-title">agetty</span><span class="hljs-params">(<span class="hljs-number">23750</span>)</span></span><span class="hljs-function">           ├─<span class="hljs-title">atd</span><span class="hljs-params">(<span class="hljs-number">1223</span>,daemon)</span></span><span class="hljs-function">           ├─<span class="hljs-title">containerd</span><span class="hljs-params">(<span class="hljs-number">22211</span>)</span>─┬─<span class="hljs-title">containerd</span>-<span class="hljs-title">shim</span><span class="hljs-params">(<span class="hljs-number">8473</span>)</span>─┬─<span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">8491</span>)</span></span><span class="hljs-function">           │                   │                       ├─&#123;<span class="hljs-title">containerd</span>-<span class="hljs-title">shim</span>&#125;<span class="hljs-params">(<span class="hljs-number">8474</span>)</span></span><span class="hljs-function">           │                   │                       ├─&#123;<span class="hljs-title">containerd</span>-<span class="hljs-title">shim</span>&#125;<span class="hljs-params">(<span class="hljs-number">8475</span>)</span></span><span class="hljs-function">           │                   │                       ├─&#123;<span class="hljs-title">containerd</span>-<span class="hljs-title">shim</span>&#125;<span class="hljs-params">(<span class="hljs-number">8476</span>)</span></span><span class="hljs-function">           │                   │                       ├─&#123;<span class="hljs-title">containerd</span>-<span class="hljs-title">shim</span>&#125;<span class="hljs-params">(<span class="hljs-number">8477</span>)</span></span><span class="hljs-function">           │                   │                       ├─&#123;<span class="hljs-title">containerd</span>-<span class="hljs-title">shim</span>&#125;<span class="hljs-params">(<span class="hljs-number">8478</span>)</span></span><span class="hljs-function">           │                   │                       ├─&#123;<span class="hljs-title">containerd</span>-<span class="hljs-title">shim</span>&#125;<span class="hljs-params">(<span class="hljs-number">8479</span>)</span></span><span class="hljs-function">           │                   │                       ├─&#123;<span class="hljs-title">containerd</span>-<span class="hljs-title">shim</span>&#125;<span class="hljs-params">(<span class="hljs-number">8480</span>)</span></span><span class="hljs-function">           │                   │                       ├─&#123;<span class="hljs-title">containerd</span>-<span class="hljs-title">shim</span>&#125;<span class="hljs-params">(<span class="hljs-number">8482</span>)</span></span><span class="hljs-function">           │                   │                       └─&#123;<span class="hljs-title">containerd</span>-<span class="hljs-title">shim</span>&#125;<span class="hljs-params">(<span class="hljs-number">8820</span>)</span></span><span class="hljs-function">           │                   ├─<span class="hljs-title">containerd</span>-<span class="hljs-title">shim</span><span class="hljs-params">(<span class="hljs-number">9297</span>)</span>─┬─<span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">9316</span>)</span></span><span class="hljs-function">           │                   │                       ├─&#123;<span class="hljs-title">containerd</span>-<span class="hljs-title">shim</span>&#125;<span class="hljs-params">(<span class="hljs-number">9298</span>)</span></span><span class="hljs-function">           │                   │                       ├─&#123;<span class="hljs-title">containerd</span>-<span class="hljs-title">shim</span>&#125;<span class="hljs-params">(<span class="hljs-number">9299</span>)</span></span><span class="hljs-function">           │                   │                       ├─&#123;<span class="hljs-title">containerd</span>-<span class="hljs-title">shim</span>&#125;<span class="hljs-params">(<span class="hljs-number">9300</span>)</span></span><span class="hljs-function">           │                   │                       ├─&#123;<span class="hljs-title">containerd</span>-<span class="hljs-title">shim</span>&#125;<span class="hljs-params">(<span class="hljs-number">9301</span>)</span></span><span class="hljs-function">           │                   │                       ├─&#123;<span class="hljs-title">containerd</span>-<span class="hljs-title">shim</span>&#125;<span class="hljs-params">(<span class="hljs-number">9302</span>)</span></span><span class="hljs-function">           │                   │                       ├─&#123;<span class="hljs-title">containerd</span>-<span class="hljs-title">shim</span>&#125;<span class="hljs-params">(<span class="hljs-number">9303</span>)</span></span><span class="hljs-function">           │                   │                       ├─&#123;<span class="hljs-title">containerd</span>-<span class="hljs-title">shim</span>&#125;<span class="hljs-params">(<span class="hljs-number">9304</span>)</span></span><span class="hljs-function">           │                   │                       ├─&#123;<span class="hljs-title">containerd</span>-<span class="hljs-title">shim</span>&#125;<span class="hljs-params">(<span class="hljs-number">9306</span>)</span></span><span class="hljs-function">           │                   │                       └─&#123;<span class="hljs-title">containerd</span>-<span class="hljs-title">shim</span>&#125;<span class="hljs-params">(<span class="hljs-number">9343</span>)</span></span><span class="hljs-function">           │                   ├─&#123;<span class="hljs-title">containerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">22216</span>)</span></span><span class="hljs-function">           │                   ├─&#123;<span class="hljs-title">containerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">22217</span>)</span></span><span class="hljs-function">           │                   ├─&#123;<span class="hljs-title">containerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">22218</span>)</span></span><span class="hljs-function">           │                   ├─&#123;<span class="hljs-title">containerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">22219</span>)</span></span><span class="hljs-function">           │                   ├─&#123;<span class="hljs-title">containerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">22220</span>)</span></span><span class="hljs-function">           │                   ├─&#123;<span class="hljs-title">containerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">22227</span>)</span></span><span class="hljs-function">           │                   ├─&#123;<span class="hljs-title">containerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">22228</span>)</span></span><span class="hljs-function">           │                   ├─&#123;<span class="hljs-title">containerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">22229</span>)</span></span><span class="hljs-function">           │                   ├─&#123;<span class="hljs-title">containerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">22231</span>)</span></span><span class="hljs-function">           │                   ├─&#123;<span class="hljs-title">containerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">22232</span>)</span></span><span class="hljs-function">           │                   ├─&#123;<span class="hljs-title">containerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">22233</span>)</span></span><span class="hljs-function">           │                   ├─&#123;<span class="hljs-title">containerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">22234</span>)</span></span><span class="hljs-function">           │                   ├─&#123;<span class="hljs-title">containerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">22369</span>)</span></span><span class="hljs-function">           │                   ├─&#123;<span class="hljs-title">containerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">22375</span>)</span></span><span class="hljs-function">           │                   ├─&#123;<span class="hljs-title">containerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">23023</span>)</span></span><span class="hljs-function">           │                   ├─&#123;<span class="hljs-title">containerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">24119</span>)</span></span><span class="hljs-function">           │                   ├─&#123;<span class="hljs-title">containerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">31016</span>)</span></span><span class="hljs-function">           │                   ├─&#123;<span class="hljs-title">containerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">32704</span>)</span></span><span class="hljs-function">           │                   ├─&#123;<span class="hljs-title">containerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">7339</span>)</span></span><span class="hljs-function">           │                   ├─&#123;<span class="hljs-title">containerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">23491</span>)</span></span><span class="hljs-function">           │                   ├─&#123;<span class="hljs-title">containerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">23596</span>)</span></span><span class="hljs-function">           │                   ├─&#123;<span class="hljs-title">containerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">23889</span>)</span></span><span class="hljs-function">           │                   ├─&#123;<span class="hljs-title">containerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">23894</span>)</span></span><span class="hljs-function">           │                   ├─&#123;<span class="hljs-title">containerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">24535</span>)</span></span><span class="hljs-function">           │                   ├─&#123;<span class="hljs-title">containerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">31378</span>)</span></span><span class="hljs-function">           │                   ├─&#123;<span class="hljs-title">containerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">32403</span>)</span></span><span class="hljs-function">           │                   ├─&#123;<span class="hljs-title">containerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">32404</span>)</span></span><span class="hljs-function">           │                   ├─&#123;<span class="hljs-title">containerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">15398</span>)</span></span><span class="hljs-function">           │                   ├─&#123;<span class="hljs-title">containerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">15399</span>)</span></span><span class="hljs-function">           │                   ├─&#123;<span class="hljs-title">containerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">15805</span>)</span></span><span class="hljs-function">           │                   └─&#123;<span class="hljs-title">containerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">16319</span>)</span></span><span class="hljs-function">           ├─<span class="hljs-title">cron</span><span class="hljs-params">(<span class="hljs-number">20629</span>)</span></span><span class="hljs-function">           ├─<span class="hljs-title">dbus</span>-<span class="hljs-title">daemon</span><span class="hljs-params">(<span class="hljs-number">1227</span>,messagebus)</span></span><span class="hljs-function">           ├─<span class="hljs-title">dhclient</span><span class="hljs-params">(<span class="hljs-number">1023</span>)</span></span><span class="hljs-function">           ├─<span class="hljs-title">dockerd</span><span class="hljs-params">(<span class="hljs-number">6901</span>)</span>─┬─&#123;<span class="hljs-title">dockerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">6903</span>)</span></span><span class="hljs-function">           │               ├─&#123;<span class="hljs-title">dockerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">6904</span>)</span></span><span class="hljs-function">           │               ├─&#123;<span class="hljs-title">dockerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">6905</span>)</span></span><span class="hljs-function">           │               ├─&#123;<span class="hljs-title">dockerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">6906</span>)</span></span><span class="hljs-function">           │               ├─&#123;<span class="hljs-title">dockerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">6907</span>)</span></span><span class="hljs-function">           │               ├─&#123;<span class="hljs-title">dockerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">6908</span>)</span></span><span class="hljs-function">           │               ├─&#123;<span class="hljs-title">dockerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">6909</span>)</span></span><span class="hljs-function">           │               ├─&#123;<span class="hljs-title">dockerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">6910</span>)</span></span><span class="hljs-function">           │               ├─&#123;<span class="hljs-title">dockerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">6912</span>)</span></span><span class="hljs-function">           │               ├─&#123;<span class="hljs-title">dockerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">6913</span>)</span></span><span class="hljs-function">           │               ├─&#123;<span class="hljs-title">dockerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">6914</span>)</span></span><span class="hljs-function">           │               └─&#123;<span class="hljs-title">dockerd</span>&#125;<span class="hljs-params">(<span class="hljs-number">6915</span>)</span></span><span class="hljs-function">           ├─<span class="hljs-title">irqbalance</span><span class="hljs-params">(<span class="hljs-number">1468</span>)</span></span><span class="hljs-function">           ├─<span class="hljs-title">iscsid</span><span class="hljs-params">(<span class="hljs-number">1140</span>)</span></span><span class="hljs-function">           ├─<span class="hljs-title">iscsid</span><span class="hljs-params">(<span class="hljs-number">1141</span>)</span></span><span class="hljs-function">           ├─<span class="hljs-title">lvmetad</span><span class="hljs-params">(<span class="hljs-number">479</span>)</span></span><span class="hljs-function">           ├─<span class="hljs-title">lxcfs</span><span class="hljs-params">(<span class="hljs-number">1215</span>)</span>─┬─&#123;<span class="hljs-title">lxcfs</span>&#125;<span class="hljs-params">(<span class="hljs-number">1337</span>)</span></span><span class="hljs-function">           │             ├─&#123;<span class="hljs-title">lxcfs</span>&#125;<span class="hljs-params">(<span class="hljs-number">1340</span>)</span></span><span class="hljs-function">           │             ├─&#123;<span class="hljs-title">lxcfs</span>&#125;<span class="hljs-params">(<span class="hljs-number">9044</span>)</span></span><span class="hljs-function">           │             ├─&#123;<span class="hljs-title">lxcfs</span>&#125;<span class="hljs-params">(<span class="hljs-number">23720</span>)</span></span><span class="hljs-function">           │             └─&#123;<span class="hljs-title">lxcfs</span>&#125;<span class="hljs-params">(<span class="hljs-number">9313</span>)</span></span><span class="hljs-function">           ├─<span class="hljs-title">mdadm</span><span class="hljs-params">(<span class="hljs-number">1453</span>)</span></span><span class="hljs-function">           ├─<span class="hljs-title">mysqld</span><span class="hljs-params">(<span class="hljs-number">31859</span>,mysql)</span>─┬─&#123;<span class="hljs-title">mysqld</span>&#125;<span class="hljs-params">(<span class="hljs-number">31871</span>)</span></span><span class="hljs-function">           │                     ├─&#123;<span class="hljs-title">mysqld</span>&#125;<span class="hljs-params">(<span class="hljs-number">31872</span>)</span></span><span class="hljs-function">           │                     ├─&#123;<span class="hljs-title">mysqld</span>&#125;<span class="hljs-params">(<span class="hljs-number">31873</span>)</span></span><span class="hljs-function">           │                     ├─&#123;<span class="hljs-title">mysqld</span>&#125;<span class="hljs-params">(<span class="hljs-number">31874</span>)</span></span><span class="hljs-function">           │                     ├─&#123;<span class="hljs-title">mysqld</span>&#125;<span class="hljs-params">(<span class="hljs-number">31875</span>)</span></span><span class="hljs-function">           │                     ├─&#123;<span class="hljs-title">mysqld</span>&#125;<span class="hljs-params">(<span class="hljs-number">31876</span>)</span></span><span class="hljs-function">           │                     ├─&#123;<span class="hljs-title">mysqld</span>&#125;<span class="hljs-params">(<span class="hljs-number">31877</span>)</span></span><span class="hljs-function">           │                     ├─&#123;<span class="hljs-title">mysqld</span>&#125;<span class="hljs-params">(<span class="hljs-number">31878</span>)</span></span><span class="hljs-function">           │                     ├─&#123;<span class="hljs-title">mysqld</span>&#125;<span class="hljs-params">(<span class="hljs-number">31879</span>)</span></span><span class="hljs-function">           │                     ├─&#123;<span class="hljs-title">mysqld</span>&#125;<span class="hljs-params">(<span class="hljs-number">31880</span>)</span></span><span class="hljs-function">           │                     ├─&#123;<span class="hljs-title">mysqld</span>&#125;<span class="hljs-params">(<span class="hljs-number">31881</span>)</span></span><span class="hljs-function">           │                     ├─&#123;<span class="hljs-title">mysqld</span>&#125;<span class="hljs-params">(<span class="hljs-number">31882</span>)</span></span><span class="hljs-function">           │                     ├─&#123;<span class="hljs-title">mysqld</span>&#125;<span class="hljs-params">(<span class="hljs-number">31884</span>)</span></span><span class="hljs-function">           │                     ├─&#123;<span class="hljs-title">mysqld</span>&#125;<span class="hljs-params">(<span class="hljs-number">31885</span>)</span></span><span class="hljs-function">           │                     ├─&#123;<span class="hljs-title">mysqld</span>&#125;<span class="hljs-params">(<span class="hljs-number">31886</span>)</span></span><span class="hljs-function">           │                     ├─&#123;<span class="hljs-title">mysqld</span>&#125;<span class="hljs-params">(<span class="hljs-number">31887</span>)</span></span><span class="hljs-function">           │                     ├─&#123;<span class="hljs-title">mysqld</span>&#125;<span class="hljs-params">(<span class="hljs-number">31888</span>)</span></span><span class="hljs-function">           │                     ├─&#123;<span class="hljs-title">mysqld</span>&#125;<span class="hljs-params">(<span class="hljs-number">31889</span>)</span></span><span class="hljs-function">           │                     ├─&#123;<span class="hljs-title">mysqld</span>&#125;<span class="hljs-params">(<span class="hljs-number">31890</span>)</span></span><span class="hljs-function">           │                     ├─&#123;<span class="hljs-title">mysqld</span>&#125;<span class="hljs-params">(<span class="hljs-number">31891</span>)</span></span><span class="hljs-function">           │                     ├─&#123;<span class="hljs-title">mysqld</span>&#125;<span class="hljs-params">(<span class="hljs-number">31892</span>)</span></span><span class="hljs-function">           │                     ├─&#123;<span class="hljs-title">mysqld</span>&#125;<span class="hljs-params">(<span class="hljs-number">31893</span>)</span></span><span class="hljs-function">           │                     ├─&#123;<span class="hljs-title">mysqld</span>&#125;<span class="hljs-params">(<span class="hljs-number">31894</span>)</span></span><span class="hljs-function">           │                     ├─&#123;<span class="hljs-title">mysqld</span>&#125;<span class="hljs-params">(<span class="hljs-number">31895</span>)</span></span><span class="hljs-function">           │                     ├─&#123;<span class="hljs-title">mysqld</span>&#125;<span class="hljs-params">(<span class="hljs-number">31896</span>)</span></span><span class="hljs-function">           │                     ├─&#123;<span class="hljs-title">mysqld</span>&#125;<span class="hljs-params">(<span class="hljs-number">31897</span>)</span></span><span class="hljs-function">           │                     ├─&#123;<span class="hljs-title">mysqld</span>&#125;<span class="hljs-params">(<span class="hljs-number">30641</span>)</span></span><span class="hljs-function">           │                     ├─&#123;<span class="hljs-title">mysqld</span>&#125;<span class="hljs-params">(<span class="hljs-number">15274</span>)</span></span><span class="hljs-function">           │                     ├─&#123;<span class="hljs-title">mysqld</span>&#125;<span class="hljs-params">(<span class="hljs-number">10442</span>)</span></span><span class="hljs-function">           │                     ├─&#123;<span class="hljs-title">mysqld</span>&#125;<span class="hljs-params">(<span class="hljs-number">26016</span>)</span></span><span class="hljs-function">           │                     ├─&#123;<span class="hljs-title">mysqld</span>&#125;<span class="hljs-params">(<span class="hljs-number">10137</span>)</span></span><span class="hljs-function">           │                     ├─&#123;<span class="hljs-title">mysqld</span>&#125;<span class="hljs-params">(<span class="hljs-number">1973</span>)</span></span><span class="hljs-function">           │                     ├─&#123;<span class="hljs-title">mysqld</span>&#125;<span class="hljs-params">(<span class="hljs-number">23981</span>)</span></span><span class="hljs-function">           │                     └─&#123;<span class="hljs-title">mysqld</span>&#125;<span class="hljs-params">(<span class="hljs-number">18314</span>)</span></span><span class="hljs-function">           ├─<span class="hljs-title">nginx</span><span class="hljs-params">(<span class="hljs-number">10152</span>)</span>─┬─<span class="hljs-title">nginx</span><span class="hljs-params">(<span class="hljs-number">10153</span>,www-data)</span></span><span class="hljs-function">           │              ├─<span class="hljs-title">nginx</span><span class="hljs-params">(<span class="hljs-number">10154</span>,www-data)</span></span><span class="hljs-function">           │              ├─<span class="hljs-title">nginx</span><span class="hljs-params">(<span class="hljs-number">10155</span>,www-data)</span></span><span class="hljs-function"> </span></code></pre></div><p>不难发现，当执行 <strong>docker run 命令</strong>时，containerd 会创建 containerd-shim 充当 “垫片” 进程（进程PID为9297），然后启动容器的真正进程 sleep 3600 。</p><p>在当前的宿主机器上，可能就存在由上述的不同进程构成的进程树，如下图所示：</p><p><img src="/img/docker/docker-process-size.png"></p>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker security</title>
    <link href="/2020/06/03/docker-security-1/"/>
    <url>/2020/06/03/docker-security-1/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-安全性能"><a href="#Docker-安全性能" class="headerlink" title="Docker 安全性能"></a>Docker 安全性能</h1><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​    Docker 是基于 Linux 内核的 <strong>Namespace</strong> 技术实现资源隔离的，<strong>所有的容器都共享主机的内核</strong>。其实这与以虚拟机为代表的云计算时代还是有很多区别的，比如虚拟机有着更好的隔离性和安全性，而容器的隔离性和安全性则相对较弱。</p><p>​    在讨论容器的安全性之前，我们先了解下容器与虚拟机的区别，这样可以帮助我们更好地了解容器的安全隐患以及如何加固容器安全。</p><h3 id="2-docker与虚拟机的区别"><a href="#2-docker与虚拟机的区别" class="headerlink" title="2. docker与虚拟机的区别"></a>2. docker与虚拟机的区别</h3><p>​    虚拟机是通过<strong>管理系统(Hypervisor)<strong>模拟出 CPU、内存、网络等硬件，然后在这些模拟的硬件上创建客户内核和操作系统。这样做的好处</strong>就是虚拟机有自己的内核和操作系统，并且硬件都是通过虚拟机管理系统模拟出来的，用户程序无法直接使用到主机的操作系统和硬件资源，</strong>因此虚拟机也对隔离性和安全性有着更好的保证。</p><p>​    而 Docker 容器则是通过 Linux 内核(<strong>kernel</strong>)的 <strong>Namespace 技术实现了文件系统、进程、设备以及网络的隔离</strong>，然后再通过 <strong>Cgroups 对 CPU、 内存等资源进行限制</strong>，最终实现了容器之间相互不受影响，由于容器的隔离性仅仅依靠内核来提供，因此容器的隔离性也远弱于虚拟机。</p><p><img src="/img/docker/docker-with-virtual.png"></p><p>​    容器与虚拟机相比，<strong>容器的性能损耗非常小，并且镜像也非常小</strong>，而且在业务快速开发和迭代的今天，容器秒级的启动等特性也非常匹配业务快速迭代的业务场景。</p><p>​    既然我们要利用容器的优点，那就需要尽量弥补<strong>容器弱隔离的安全性缺点</strong>呢？要了解如何解决容器的安全问题，我们首先需要了解下容器目前存在的安全问题。</p><h3 id="3-docker的安全性问题"><a href="#3-docker的安全性问题" class="headerlink" title="3. docker的安全性问题"></a><strong>3. docker的安全性问题</strong></h3><h5 id="1）docker自身安全"><a href="#1）docker自身安全" class="headerlink" title="1）docker自身安全"></a>1）docker自身安全</h5><p>​    Docker 作为一款容器引擎，本身也会存在一些安全漏洞。安全漏洞可以通过CVE（Common Vulnerabilities and Exposures）又称常见漏洞与披露，是一个与信息安全有关的数据库，收集各种信息安全弱点及漏洞并给予编号以便于公众查阅。</p><p><strong>2）镜像安全</strong><br>​    由于 Docker 容器是基于镜像创建并启动，因此镜像的安全直接影响到容器的安全。具体影响镜像安全的总结如下。</p><ul><li><p>镜像软件存在安全漏洞：由于容器需要安装基础的软件包，如果软件包存在漏洞，则可能会被不法分子利用并且侵入容器，影响其他容器或主机安全。</p></li><li><p>仓库漏洞：无论是 Docker 官方的镜像仓库还是我们私有的镜像仓库，都有可能被攻击，然后篡改镜像，当我们使用镜像时，就可能成为攻击者的目标对象。</p></li><li><p>用户程序漏洞：用户自己构建的软件包可能存在漏洞或者被植入恶意脚本，这样会导致运行时提权影响其他容器或主机安全。</p></li></ul><p><strong>3）Linux 内核隔离性不够</strong></p><p>​    尽管目前 <strong>Namespace</strong> 已经提供了非常多的资源隔离类型，但是仍有部分关键内容没有被完全隔离，其中包括一些系统的关键性目录（如 /sys、/proc 等），这些关键性的目录可能会泄露主机上一些关键性的信息，让攻击者利用这些信息对整个主机甚至云计算中心发起攻击。</p><p>​    而且仅仅依靠 Namespace 的隔离是远远不够的，因为一旦内核的 Namespace 被突破，使用者就有可能直接提权获取到主机的超级权限，从而影响主机安全。</p><p><strong>4) 所有容器共享主机内核</strong></p><p>​    由于<strong>同一宿主机上所有容器共享主机内核</strong>，所以攻击者可以利用一些特殊手段导致内核崩溃，进而导致主机宕机影响主机上其他服务。</p><h3 id="4-Docker安全问题解决"><a href="#4-Docker安全问题解决" class="headerlink" title="4. Docker安全问题解决"></a>4. Docker安全问题解决</h3><p><strong>1) Docker 自身安全性改进</strong><br>​    事实上，Docker 从 2013 年诞生到现在，在安全性上面已经做了非常多的努力。目前 Docker 在默认配置和默认行为下是足够安全的。</p><p>​    Docker 自身是基于 Linux 的多种 Namespace 实现的，其中有一个<strong>很重要的 Namespace 叫作 User Namespace</strong>，User Namespace 主要是用来做容器内用户和主机的用户隔离的。在过去容器里的 root 用户就是主机上的 root 用户，如果容器受到攻击，或者容器本身含有恶意程序，在容器内就可以直接获取到主机 root 权限。Docker 从 1.10 版本开始，使用 <strong>User Namespace 做用户隔离，实现了容器中的 root 用户映射到主机上的非 root 用户，从而大大减轻了容器被突破的风险。</strong></p><p>因此，我们尽可能地使用 Docker 最新版本就可以得到更好的安全保障。</p><p><strong>2) 保障镜像安全</strong></p><p>​    为保障镜像安全，我们可以在<strong>私有镜像仓库安装镜像安全扫描组件</strong>，对上传的镜像进行检查，通过与 CVE 数据库对比，一旦发现有漏洞的镜像及时通知用户或阻止非安全镜像继续构建和分发。同时为了确保我们使用的镜像足够安全，在拉取镜像时，要确保只从受信任的镜像仓库拉取，并且与镜像仓库通信一定要使用 HTTPS 协议。</p><p><strong>3) 加强内核安全和管理</strong></p><p>​    由于仅仅依赖内核的隔离可能会引发安全问题，因此我们对于内核的安全应该更加重视。可以从以下几个方面进行加强。</p><ul><li><p>宿主机及时升级内核漏洞</p></li><li><p>宿主机内核应该尽量安装最新补丁，因为更新的内核补丁往往有着更好的安全性和稳定性。</p></li><li><p>使用 Capabilities 划分权限</p></li></ul><p>Capabilities 是 Linux 内核的概念，Linux 将系统权限分为了多个 Capabilities，它们都可以单独地开启或关闭，Capabilities 实现了系统更细粒度的访问控制。在执行docker run命令启动容器时，如非特殊可控情况，–privileged 参数不允许设置为 true，其他特殊权限可以使用 –cap-add 参数，根据使用场景适当添加相应的权限。</p><p><strong>4) 使用安全加固组件</strong></p><p>​    Linux 的 <strong>SELinux、AppArmor、GRSecurity组件都是 Docker 官方推荐的安全加固组件</strong>。</p><ul><li><p>SELinux (Secure Enhanced Linux): 是 Linux 的一个内核安全模块，提供了安全访问的策略机制，通过设置 SELinux 策略可以实现某些进程允许访问某些文件。</p></li><li><p>AppArmor: 类似于 SELinux，也是一个 Linux 的内核安全模块，普通的访问控制仅能控制到用户的访问权限，而 AppArmor 可以控制到用户程序的访问权限。</p></li><li><p>GRSecurity: 是一个对内核的安全扩展，可通过智能访问控制，提供内存破坏防御，文件系统增强等多种防御形式。</p></li></ul><p>这三个组件可以限制一个容器对主机的内核或其他资源的访问控制。目前，容器报告的一些安全漏洞中，很多都是通过对内核进行加强访问和隔离来实现的。</p><p><strong>5) 资源限制</strong></p><p>​    在生产环境中，建议每个容器都添加相应的资源限制。下面给出一些执行docker run命令启动容器时可以传递的资源限制参数：</p><div class="hljs code-wrapper"><pre><code class="hljs ada"><span class="hljs-comment">--cpus                          限制 CPU 配额</span>-m, <span class="hljs-comment">--memory                    限制内存配额</span><span class="hljs-comment">--pids-limit                    限制容器的 PID 个数</span></code></pre></div><p>例如我想要启动一个 1 核 2G 的容器，并且限制在容器内最多只能创建 1000 个 PID，启动命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs routeros">$ docker <span class="hljs-builtin-name">run</span> -it <span class="hljs-attribute">--cpus</span>=1 <span class="hljs-attribute">-m</span>=2048m <span class="hljs-attribute">--pids-limit</span>=1000 busybox /bin/bash</code></pre></div><p>推荐在生产环境中限制 CPU、内存、PID 等资源，这样即便应用程序有漏洞，也不会导致主机的资源完全耗尽，最大限度降低安全风险。</p><p><strong>6) 使用安全容器</strong></p><p>​    容器有着轻便快速启动的优点，虚拟机有着安全隔离的优点，有没有一种技术可以兼顾两者的优点，做到既轻量又安全呢？</p><p>​    答案是有，那就是<strong>安全容器。安全容器是相较于普通容器的，安全容器与普通容器的主要区别在于，安全容器中的每个容器都运行在一个单独的微型虚拟机中，拥有独立的操作系统和内核，并且有虚拟化层的安全隔离。</strong></p><p>安全容器目前推荐的技术方案是 : <strong>Kata Containers</strong></p>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker mirror principal</title>
    <link href="/2020/06/03/docker-mirror-principal/"/>
    <url>/2020/06/03/docker-mirror-principal/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-镜像原理"><a href="#Docker-镜像原理" class="headerlink" title="Docker 镜像原理"></a>Docker 镜像原理</h1><p>Docker 核心：镜像，首先重点讲解一下镜像的基本操作，然后介绍一下镜像的实现原理。</p><h3 id="1-镜像"><a href="#1-镜像" class="headerlink" title="1. 镜像"></a>1. 镜像</h3><p>​    镜像是一个只读的 Docker 容器模板，包含启动容器所需要的所有文件系统结构和内容。简单来讲，<strong>镜像是一个特殊的文件系统</strong>，它提供了容器运行时所需的程序、软件库、资源、配置等静态数据。即镜像不包含任何动态数据，镜像内容在构建后不会被改变。</p><p>如何操作镜像：</p><p><img src="/img/docker/docker-mirror-todo.png"></p><p>从图中可知，镜像的操作可分为：</p><p>​    拉取镜像，使用docker pull命令拉取远程仓库的镜像到本地 ；</p><p>​    重命名镜像，使用docker tag命令“重命名”镜像 ；</p><p>​    查看镜像，使用docker image ls或docker images命令查看本地已经存在的镜像 ；</p><p>​    删除镜像，使用docker rmi命令删除无用镜像 ；</p><p>​    构建镜像，构建镜像有两种方式。第一种方式是使用docker build命令基于 Dockerfile 构建镜像，也是我比较推荐的镜像构建方式；第二种方式是使用docker commit命令基于已经运行的容器提交为镜像。</p><h4 id="1-1-拉取镜像"><a href="#1-1-拉取镜像" class="headerlink" title="1.1 拉取镜像"></a><strong>1.1 拉取镜像</strong></h4><p>Docker 镜像的拉取使用<strong>docker pull命令</strong>， 命令格式一般为 **docker pull [Registry]/[Repository]/[Image]:[Tag]**。</p><ul><li><p>Registry 为注册服务器，Docker 默认会从 docker.io 拉取镜像，如果你有自己的镜像仓库，可以把 Registry 替换为自己的注册服务器。</p></li><li><p>Repository 为镜像仓库，通常把一组相关联的镜像归为一个镜像仓库，library为 Docker 默认的镜像仓库。</p></li><li><p>Image 为镜像名称。</p></li><li><p>Tag 为镜像的标签，如果你不指定拉取镜像的标签，默认为latest。</p></li></ul><p>例如，我们需要获取一个 busybox 镜像，可以执行以下命令：</p><p>busybox 是一个集成了数百个 Linux 命令（例如 curl、grep、mount、telnet 等）的精简工具箱，只有几兆大小，被誉为 Linux 系统的瑞士军刀。我经常会使用 busybox 做调试来查找生产环境中遇到的问题。</p><div class="hljs code-wrapper"><pre><code class="hljs vim">$ docker pull busyboxUsing default <span class="hljs-keyword">ta</span><span class="hljs-variable">g:</span> latestlates<span class="hljs-variable">t:</span> Pulling from library/busybox<span class="hljs-number">61</span>c5ed1cbdf8: Pull <span class="hljs-built_in">complete</span>Diges<span class="hljs-variable">t:</span> <span class="hljs-built_in">sha256</span>:<span class="hljs-number">4</span>f47c01fa91355af2865ac10fef5bf6ec9c7f42ad2321377c21e844427972977Statu<span class="hljs-variable">s:</span> Downloaded newer image <span class="hljs-keyword">for</span> busybox:latestdocker.io/library/busybox:latest</code></pre></div><p>​    实际上执行docker pull busybox命令，都是先从本地搜索，如果本地搜索不到busybox镜像则从 Docker Hub 下载镜像。</p><h4 id="1-2-操作镜像"><a href="#1-2-操作镜像" class="headerlink" title="1.2 操作镜像"></a>1.2 操作镜像</h4><h5 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h5><p>Docker 镜像查看使用<strong>docker images或者docker image ls</strong>命令。</p><p>下面我们使用docker images命令列出本地所有的镜像。</p><div class="hljs code-wrapper"><pre><code class="hljs crmsh">$ docker imagesREPOSITORY          <span class="hljs-keyword">TAG</span>                 <span class="hljs-title">IMAGE</span> ID            CREATED             SIZEnginx               latest              <span class="hljs-number">4</span>bb46517cac3        <span class="hljs-number">9</span> days ago          <span class="hljs-number">133M</span>Bnginx               <span class="hljs-number">1.15</span>                <span class="hljs-number">53</span>f3fd8007f7        <span class="hljs-number">15</span> months ago       <span class="hljs-number">109M</span>Bbusybox             latest              <span class="hljs-number">018</span>c9d7b792b        <span class="hljs-number">3</span> weeks ago         <span class="hljs-number">1.22M</span>B</code></pre></div><p>如果我们想要查询指定的镜像，可以使用docker image ls命令来查询。</p><div class="hljs code-wrapper"><pre><code class="hljs crmsh">$ docker image ls busyboxREPOSITORY          <span class="hljs-keyword">TAG</span>                 <span class="hljs-title">IMAGE</span> ID            CREATED             SIZEbusybox             latest              <span class="hljs-number">018</span>c9d7b792b        <span class="hljs-number">3</span> weeks ago         <span class="hljs-number">1.22M</span>B</code></pre></div><p>当然你也可以使用docker images命令列出所有镜像，然后使用grep命令进行过滤。使用方法如下：</p><div class="hljs code-wrapper"><pre><code class="hljs 1c">$ docker images <span class="hljs-string">|grep busybox</span>busybox             latest              <span class="hljs-number">018</span>c9d7b792b        <span class="hljs-number">3</span> weeks ago         <span class="hljs-number">1.22</span>MB</code></pre></div><p><strong>“重命名”镜像</strong></p><p>如果你想要自定义镜像名称或者推送镜像到其他镜像仓库，你可以使用docker tag命令将镜像重命名。docker tag的命令格式为 docker tag [SOURCE_IMAGE][:TAG] [TARGET_IMAGE][:TAG]。</p><div class="hljs code-wrapper"><pre><code class="hljs crmsh">$ docker <span class="hljs-keyword">tag</span> <span class="hljs-title">busybox</span>:latest mybusybox:latest</code></pre></div><p>执行完docker tag命令后，可以使用查询镜像命令查看一下镜像列表：</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> images<span class="hljs-attribute">REPOSITORY</span>          TAG                 IMAGE ID            CREATED             SIZE<span class="hljs-attribute">busybox</span>             latest              <span class="hljs-number">018</span>c<span class="hljs-number">9</span>d<span class="hljs-number">7</span>b<span class="hljs-number">792</span>b        <span class="hljs-number">3</span> weeks ago         <span class="hljs-number">1</span>.<span class="hljs-number">22</span>MB<span class="hljs-attribute">mybusybox</span>           latest              <span class="hljs-number">018</span>c<span class="hljs-number">9</span>d<span class="hljs-number">7</span>b<span class="hljs-number">792</span>b        <span class="hljs-number">3</span> weeks ago         <span class="hljs-number">1</span>.<span class="hljs-number">22</span>MB</code></pre></div><p>可以看到，镜像列表中多了一个mybusybox的镜像。busybox和mybusybox这两个镜像的 IMAGE ID 是完全一样的。为什么呢？实际上它们指向了同一个镜像文件，只是别名不同而已。</p><h5 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h5><p>你可以使用<strong>docker rmi或者docker image rm</strong>命令删除镜像。</p><p>例：删除mybusybox镜像</p><div class="hljs code-wrapper"><pre><code class="hljs crmsh">$ docker rmi mybusybox此时，再次使用docker images命令查看一下我们机器上的镜像列表。$ docker imagesREPOSITORY          <span class="hljs-keyword">TAG</span>                 <span class="hljs-title">IMAGE</span> ID            CREATED             SIZEbusybox             latest              <span class="hljs-number">018</span>c9d7b792b        <span class="hljs-number">3</span> weeks ago         <span class="hljs-number">1.22M</span>B通过上面的输出，我们可以看到，mybusybox镜像已经被删除。</code></pre></div><h5 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a><strong>构建镜像</strong></h5><p>构建镜像主要有两种方式：</p><ul><li><strong>docker commit</strong>命令从运行中的容器提交为镜像；</li><li><strong>docker build</strong>命令从 Dockerfile 构建镜像。</li></ul><p><strong>Docker commit命令</strong></p><p>首先介绍下如何从运行中的容器提交为镜像。我依旧使用 busybox 镜像举例，使用以下命令创建一个名为 busybox 的容器并进入 busybox 容器。</p><div class="hljs code-wrapper"><pre><code class="hljs applescript"><span class="hljs-comment"># 创建容器</span>$ docker <span class="hljs-built_in">run</span> -itd busybox<span class="hljs-comment"># 进入容器</span>$ docker exec -<span class="hljs-keyword">it</span> 容器<span class="hljs-built_in">id</span> /binn/bash</code></pre></div><p>执行完上面的命令后，当前窗口会启动一个 busybox 容器并且进入容器中。在容器中，执行以下命令创建一个文件并写入内容：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">touch hello.txt &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;I love Docker. &quot;</span> &gt; hello.txt</code></pre></div><p>此时在容器的根目录下，已经创建了一个 hello.txt 文件，并写入了 “I love Docker. “。下面，我们新打开另一个命令行窗口，运行以下命令提交镜像：</p><div class="hljs code-wrapper"><pre><code class="hljs llvm">$ docker commit busybox busybox:hellosha<span class="hljs-number">256</span>:cbc<span class="hljs-number">6406</span>aaef<span class="hljs-number">080</span>d<span class="hljs-number">1</span>dd<span class="hljs-number">3087</span>d<span class="hljs-number">4</span>ea<span class="hljs-number">1e6</span><span class="hljs-keyword">c</span><span class="hljs-number">6</span><span class="hljs-keyword">c</span><span class="hljs-number">9915</span>ee<span class="hljs-number">0</span>ee<span class="hljs-number">0</span>f<span class="hljs-number">5</span>dd<span class="hljs-number">9e0</span>a<span class="hljs-number">90</span>b<span class="hljs-number">03e2215</span>e<span class="hljs-number">81</span><span class="hljs-keyword">c</span></code></pre></div><p>然后使用上面讲到的docker image ls命令查看镜像：</p><div class="hljs code-wrapper"><pre><code class="hljs crmsh">$ docker image ls busyboxREPOSITORY          <span class="hljs-keyword">TAG</span>                 <span class="hljs-title">IMAGE</span> ID            CREATED             SIZEbusybox             hello               cbc6406aaef0        <span class="hljs-number">2</span> minutes ago       <span class="hljs-number">1.22M</span>Bbusybox             latest              <span class="hljs-number">018</span>c9d7b792b        <span class="hljs-number">4</span> weeks ago         <span class="hljs-number">1.22M</span>B</code></pre></div><p>此时我们可以看到主机上新生成了 busybox:hello 这个镜像。</p><p><strong>Docker build命令</strong></p><p>最常用的镜像构建方式：Dockerfile。Dockerfile 是一个包含了用户所有构建命令的文本。<strong>通过docker build命令可以从 Dockerfile 生成镜像。</strong></p><p>使用 Dockerfile 构建镜像具有以下特性：</p><ul><li><p>Dockerfile 的每一行命令都会生成一个独立的镜像层，并且拥有唯一的 ID；</p></li><li><p>Dockerfile 的命令是完全透明的，通过查看 Dockerfile 的内容，就可以知道镜像是如何一步步构建的；</p></li><li><p>Dockerfile 是纯文本的，方便跟随代码一起存放在代码仓库并做版本管理。</p></li></ul><p>先学习下 Dockerfile 常用的指令。</p><p>Dockerfile 指令    指令简介</p><ul><li>FROM    Dockerfile 除了注释第一行必须是 FROM ，FROM 后面跟镜像名称，代表我们要基于哪个基础镜像构建我们的容器。（ <strong>默认会先从本地去查找镜像</strong>）</li><li>RUN    RUN 后面跟一个具体的命令，类似于 Linux 命令行执行命令。</li><li>ADD    拷贝本机文件或者远程文件到镜像内</li><li>COPY    拷贝本机文件到镜像内</li><li>USER    指定容器启动的用户</li><li>ENTRYPOINT    容器的启动命令</li><li>CMD    CMD 为 ENTRYPOINT 指令提供默认参数，也可以单独使用 CMD 指定容器启动参数</li><li>ENV    指定容器运行时的环境变量，格式为 key=value</li><li>ARG    定义外部变量，构建镜像时可以使用 build-arg = 的格式传递参数用于构建</li><li>EXPOSE    指定容器监听的端口，格式为 [port]/tcp 或者 [port]/udp</li><li>WORKDIR    为 Dockerfile 中跟在其后的所有 RUN、CMD、ENTRYPOINT、COPY 和 ADD 命令设置工作目录。</li></ul><p>先分析下如下Dockerfile文件中的含义：</p><div class="hljs code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> centos:<span class="hljs-number">7</span><span class="hljs-keyword">COPY</span><span class="bash"> nginx.repo /etc/yum.repos.d/nginx.repo</span><span class="hljs-keyword">RUN</span><span class="bash"> yum install -y nginx</span><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span><span class="hljs-keyword">ENV</span> HOST=mynginx<span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;nginx&quot;</span>,<span class="hljs-string">&quot;-g&quot;</span>,<span class="hljs-string">&quot;daemon off;&quot;</span>]</span></code></pre></div><ul><li><p>第一行表示我要基于 centos:7 这个镜像来构建自定义镜像。这里需要注意，每个 Dockerfile 的第一行除了注释都必须以 FROM 开头。</p></li><li><p>第二行表示拷贝本地文件 nginx.repo 文件到容器内的 /etc/yum.repos.d 目录下。这里拷贝 nginx.repo 文件是为了添加 nginx 的安装源。</p></li><li><p>第三行表示在容器内运行yum install -y nginx命令，安装 nginx 服务到容器内，执行完第三行命令，容器内的 nginx 已经安装完成。</p></li><li><p>第四行声明容器内业务（nginx）使用 80 端口对外提供服务。</p></li><li><p>第五行定义容器启动时的环境变量 HOST=mynginx，容器启动后可以获取到环境变量 HOST 的值为 mynginx。</p></li><li><p>第六行定义容器的启动命令，命令格式为 json 数组。这里设置了容器的启动命令为 nginx ，并且添加了 nginx 的启动参数 -g ‘daemon off;’ ，使得 nginx 以前台的方式启动。</p></li></ul><p>上面这个 Dockerfile 的例子基本涵盖了常用的镜像构建指令。</p><h3 id="2-镜像的实现原理"><a href="#2-镜像的实现原理" class="headerlink" title="2. 镜像的实现原理"></a>2. 镜像的实现原理</h3><h4 id="2-1-Bootfs和Rootfs"><a href="#2-1-Bootfs和Rootfs" class="headerlink" title="2.1 Bootfs和Rootfs"></a>2.1 Bootfs和Rootfs</h4><p>先下拉ubuntu镜像和python:3镜像：</p><div class="hljs code-wrapper"><pre><code class="hljs python">root@iZ2ze1lioikou185atzucgZ:~<span class="hljs-comment"># docker pull ubuntu</span>Using default tag: latestlatest: Pulling <span class="hljs-keyword">from</span> library/ubuntu54ee1f796a1e: Pull complete f7bfea53ad12: Pull complete 46d371e02073: Pull complete b66c17bbf772: Pull complete Digest: sha256:31dfb10d52ce76c5ca0aa19d10b3e6424b830729e32a89a7c6eee2cda2be67a5Status: Downloaded newer image <span class="hljs-keyword">for</span> ubuntu:latestdocker.io/library/ubuntu:latestroot@iZ2ze1lioikou185atzucgZ:~<span class="hljs-comment"># docker images</span>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZEpython              <span class="hljs-number">3</span>                   28a4c88cdbbf        <span class="hljs-number">15</span> hours ago        882MBubuntu              latest              4e2eef94cd6b        <span class="hljs-number">3</span> weeks ago         <span class="hljs-number">73.9</span>MB</code></pre></div><p>大家可能注意到上面命令输出的最后一列， 它显示 ubuntu 这个镜像才 73.9MB ！但是大家应该都知道，安装一个 ubuntu 系统怎么也不可能就几十兆，那么 Docker 是怎么做到的呢？</p><p>这是因为典型的 Linux 运行需要两个 FS: <strong>bootfs 和 rootfs</strong>，Linux 刚启动时会加载 bootfs 文件系统，之后 bootfs 会被卸载掉。对于不同的 Linux 发行版, bootfs 基本是一致的, 但 rootfs 会有差别，其包含我们熟悉的 /dev, /proc, /bin 等目录。对于 ubuntu 镜像来说，其底层直接使用 Host 的 <strong>kernel内核</strong>，自己只需要提供 rootfs 就行了。如下图所示：</p><p><img src="/img/docker/docker-bootfs-rootfs.png"></p><p>为了确定 ubuntu 镜像使用的是 Host 的Kernel内核，我们可以使用<strong>uname -a命令查看内核版本</strong>：</p><p><img src="/img/docker/docker-kernel.png"></p><p>说明如下：</p><div class="hljs code-wrapper"><pre><code class="hljs pgsql">第一个组数字：<span class="hljs-number">4</span>, 主版本号第二个组数字：<span class="hljs-number">15</span>, 次版本号，当前为稳定版本第三个组数字：<span class="hljs-number">0</span>, 修订版本号第四个组数字：<span class="hljs-number">111</span>，当前内核版本（<span class="hljs-number">4.15</span><span class="hljs-number">.0</span>）的第<span class="hljs-number">111</span>次微调patchgeneric：当前内核版本为通用版本，另有表示不同含义的<span class="hljs-keyword">server</span>（针对服务器）、i386（针对老式英特尔处理器）pae（Physical Address <span class="hljs-keyword">Extension</span>）：物理地址扩展，为了弥补<span class="hljs-number">32</span>位地址在PC服务器应用上的不足而推出，表示此<span class="hljs-number">32</span>位系统可以支持超过<span class="hljs-number">4</span>G的内存x86_64：采用的是<span class="hljs-number">64</span>位的CPUSMP：对称多处理机，表示内核支持多核、多处理器Tue Jul <span class="hljs-number">15</span> <span class="hljs-number">17</span>:<span class="hljs-number">46</span>:<span class="hljs-number">11</span> UTC <span class="hljs-number">2014</span>：内核的编译时间（build <span class="hljs-type">date</span>）为 <span class="hljs-number">2014</span>/<span class="hljs-number">07</span>/<span class="hljs-number">15</span> <span class="hljs-number">17</span>:<span class="hljs-number">46</span>:<span class="hljs-number">11</span></code></pre></div><p><strong>重点：</strong>如果我们在同一个 host 上下载不同 Linux 发行版镜像，如python:3和Ubuntu，可以从上图中发现其都是使用的公用 host 的 bootfs。抽象一下，如下图所示：</p><p><img src="/img/docker/docker-bootfs.png"></p><p>理解到bootfs和rootfs后，就可以解释什么是镜像分层了。</p><h4 id="2-1-镜像分层"><a href="#2-1-镜像分层" class="headerlink" title="2.1 镜像分层"></a>2.1 镜像分层</h4><p>​    每个镜像都是通过 DockerFile 文本文件定义的，Dockerfile 中的每条指令最终都会成为镜像中的 Layer。Layer 是按顺序构成的，<strong>最底层的 Layer 是基础镜像（base image），最上层是最终镜像（final image）</strong>。当一个镜像被更新或重新构建时，只有更新的层需要修改，其他没有更新的层可以直接复用本地缓存。这就是 Docker 镜像如此快速和轻量级的部分原因，每一层的大小加起来等于最终镜像的大小。</p><p>​    理解上面的设计之后，我们现在来解释最上面关于 Layer 这个概念。假设我们的 Dockerfile 定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs routeros"><span class="hljs-keyword">FROM</span> debian<span class="hljs-builtin-name">RUN</span> apt-<span class="hljs-builtin-name">get</span> update &amp;&amp; apt-<span class="hljs-builtin-name">get</span> -y -f install emacs<span class="hljs-builtin-name">RUN</span> apt-<span class="hljs-builtin-name">get</span> update &amp;&amp; apt-<span class="hljs-builtin-name">get</span> -y -f install apache2</code></pre></div><p>上面一共有三条指令，如果编译这个 Dockerfile，其会生成三个镜像：</p><div class="hljs code-wrapper"><pre><code class="hljs routeros">[root@iteblog.com ~]$ docker build -t iteblog-docker ./Sending build context <span class="hljs-keyword">to</span> Docker daemon  2.048kB<span class="hljs-keyword">Step</span> 1/3: <span class="hljs-keyword">FROM</span> debian---&gt; a8797652cfd9<span class="hljs-keyword">Step</span> 2/3: <span class="hljs-builtin-name">RUN</span> apt-<span class="hljs-builtin-name">get</span> update &amp;&amp; apt-<span class="hljs-builtin-name">get</span> -y -f install emacs---&gt; Using cache---&gt; 4b2cc711d0f1<span class="hljs-keyword">Step</span> 3/3: <span class="hljs-builtin-name">RUN</span> apt-<span class="hljs-builtin-name">get</span> update &amp;&amp; apt-<span class="hljs-builtin-name">get</span> -y -f installapache2---&gt; Using cache---&gt; 48ec647c89a1Successfully built 48ec647c89a1Successfully tagged iteblog-docker:latest</code></pre></div><p>如果用图片表示的话，这个过程如下：</p><p><img src="/img/docjer/docker-container-layer"></p><h3 id="3-容器层"><a href="#3-容器层" class="headerlink" title="3. 容器层"></a>3. 容器层</h3><p>​    如果多个镜像共用一个基础镜像，内存中也只需加载一份基础镜像，就可以为所有容器服务了。那么问题来了，如果我们需要修改基础镜像里面的东西咋办呢？Docker 很好的处理了这个问题，<strong>当容器启动时，一个新的可写层被加载到镜像的顶部，这一层通常被称作容器层（container layer），容器层之下的都叫镜像层（image layer）</strong>，所有的修改（比如删除文件、添加文件）都是在容器层进行的，如下图所示：</p><p><img src="/img/docker/docker-container-one.png"></p><p>​    可以从图中看出Container layer容器可读层和Image layers镜像层。用户对容器中的添加、修改等数据都存放在container layer层，当容器被删除时，也只是container layer层被删除。底层的image layers镜像层是不动的。因此<strong>不同容器都有自己独有的容器层，所有的修改只会存在自己的容器层，也就是说不同容器之间的修改都互不影响，这也就使得不同容器可以共享一个镜像层</strong>，具体图解如下：</p><p><img src="/img/docker/docker-container-one.png"></p><p><strong>重点：不同容器之间的修改是互不影响的，但是如果不同容器之间需要做数据传递，可以使用network进行网络通信。</strong></p>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker security 2</title>
    <link href="/2020/06/03/docker-security-2/"/>
    <url>/2020/06/03/docker-security-2/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-安全性能2"><a href="#Docker-安全性能2" class="headerlink" title="Docker 安全性能2"></a>Docker 安全性能2</h1><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​    Docker容器安全目前推荐的技术方案是 : <strong>Kata Containers</strong>，那先来认识一下什么是kata containers。</p><p>​    Kata Containers是一个开源项目和社区，致力于<strong>构建轻量级虚拟机（VM）的标准实现——这些虚拟机的感知和执行类似容器</strong>，但提供VM的工作负载隔离和安全优势，内核级别的隔离宿主机的内核！Kata Containers 项目最初是基于 <strong>QEMU</strong> 的，但它的设计从一开始就以支持多种管理程序解决方案为出发点。</p><h3 id="2-kata-containers"><a href="#2-kata-containers" class="headerlink" title="2. kata-containers"></a>2. kata-containers</h3><p>　　kata containers是由OpenStack基金会管理，但独立于OpenStack项目之外的容器项目。它是一个<strong>可以使用容器镜像以超轻量级虚机的形式创建容器的运行时工具</strong>。 kata containers整合了Intel的 Clear Containers 和 Hyper.sh 的 runV，能够支持不同平台的硬件 （x86-64，arm等），并符合**OCI(Open Container Initiative)**规范，同时还可以兼容k8s的 <strong>CRI（Container Runtime Interface）</strong>接口规范。目前项目包含几个配套组件，即Runtime，Agent， Proxy，Shim，Kernel等</p><p>　　真正启动Docker容器的命令工具是RunC，它是OCI运行时规范 (runtime-spec)的默认实现。Kata containers其实跟RunC类似，也是一个符合OCI运行时规范的一种 实现（即<strong>Clear Container和runV 都符OCI规范</strong>），不同之处是，它给每个容器（在Docker容器的 角度）或每个Pod（k8s的角度）增加了一个独立的linux内核（不共享宿主机的内核），使容器有更好 的隔离性，安全性。</p><p><strong>2.1）docker的runtime模式架构图：</strong></p><p><img src="/img/docker/docker-runtime-architecture-1.png"></p><p>​    可以看到runC处于docker组件图的最底端，runC下面就是容器。目前docker已经不是一个专一的容器 管理组件，而真正的容器管理组件是containerd，而containerd本身也不会直接跟操作系统交互，去创建、删除容器，而是借助runC来对容器生命周期进行管理，因此runC作为必须遵循OCI规范。</p><p><strong>2.2）kata containers定义位置：</strong></p><p>kata containers在容器的什么位置，应该就显而易见了。它符合OCI运行时规 范，因此，可以作为runC的替代组件，如红色虚线框内所示：</p><p><img src="/img/docker/docker-runtime-architecture-1.png"></p><p><strong>2.3）kata container原理</strong></p><p>​    kata container实质上是在虚拟机内部使用container（基于runc的实现）。 kata-container使用虚拟化软件(qemu-lite优化过的qemu)， 通过已经将kata-agent 安装的kernel &amp; intrd image，启动过一个轻量级的虚拟机， 使用nvdimm将initrd image映射到guest vm中。然后由kata-agent为container创建对应的namespace和资源。 Guest VM作为实质上的sandbox可以完全与host kernel进行隔离。</p><p><img src="/img/images/8.kata-container%E5%8E%9F%E7%90%86png.png"></p><p><strong>组件拆分介绍</strong></p><ul><li><strong>kata-runtime</strong>：实现OCI接口，可以通过CRI-O 与kubelet对接作为k8s runtime server， containerd对接docker engine，创建运行container/pod的VM</li><li><strong>kata-proxy</strong>: 每一个container都会由一个kata-proxy进程，kata-proxy负责与kata-agent通讯，当guest vm启动后，kata-agent会随之启动并使用qemu virtio serial console 进行通讯</li><li><strong>kata-agent</strong>： 运行在guest vm中的进程， 主要依赖于<strong>libcontainer</strong>项目，重用了大部分的runc代码，为container创建namespace(NS, UTS, IPC and PID)</li><li><strong>kata-shim</strong>: 作为guest vm标准输入输出的接口，exec命令就是同kata-shim实现的。（其实相当于是container-shim的一个适配）</li></ul><p><strong>2.4）classic Docker与Docker with Kata的架构</strong></p><p><img src="/img/docker/docker-with-kata.png"></p>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker underly isolation</title>
    <link href="/2020/06/03/docker-underly-isolation/"/>
    <url>/2020/06/03/docker-underly-isolation/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker资源隔离"><a href="#Docker资源隔离" class="headerlink" title="Docker资源隔离"></a>Docker资源隔离</h1><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​    在上一章Docker安全性能中已有讲解Namespace的功能作用。</p><p>​    概念回顾：Docker 是基于 Linux 内核的 <strong>Namespace</strong> 技术实现资源隔离的，<strong>所有的容器都共享主机的内核</strong>。其实这与以虚拟机为代表的云计算时代还是有很多区别的，比如虚拟机有着更好的隔离性和安全性，而容器的隔离性和安全性则相对较弱。</p><p>​    虽然Namespace的技术的隔离和安全性相对较弱，那么究竟什么是 Namespace，各种 Namespace 都有什么作用，为什么 Docker 需要 Namespace呢？</p><h3 id="2-什么是Namespace"><a href="#2-什么是Namespace" class="headerlink" title="2.什么是Namespace"></a>2.什么是Namespace</h3><p>​    <strong>维基百科定义</strong>：Namespace 是 Linux 内核的一项功能，该功能对内核资源进行分区，以使一组进程看到一组资源，而另一组进程看到另一组资源。Namespace 的工作方式通过为一组资源和进程设置相同的 Namespace 而起作用，但是这些 Namespace 引用了不同的资源。资源可能存在于多个 Namespace 中。这些资源可以是进程 ID、主机名、用户 ID、文件名、与网络访问相关的名称和进程间通信。</p><p>​    <strong>简单来说，</strong>Namespace 是 Linux 内核的一个特性，该<strong>特性可以实现在同一主机系统中，对进程 ID、主机名、用户 ID、文件名、网络和进程间通信等资源的隔离</strong>。Docker 利用 Linux 内核的 Namespace 特性，<strong>实现了每个容器的资源相互隔离，从而保证容器内部只能访问到自己 Namespace 的资源</strong>。</p><p><img src="/img/images/9.Namespaces%E7%B1%BB%E5%9E%8B.png"></p><h3 id="3-Namespace的作用"><a href="#3-Namespace的作用" class="headerlink" title="3.Namespace的作用"></a>3.Namespace的作用</h3><p>下面分别讲解六种Namespace的运用：<br><strong>1）Mount Namespace</strong><br>​    <strong>Mount Namespace 是 Linux 内核实现的第一个 Namespace，</strong>从内核的 2.4.19 版本开始加入。它可以用来隔离不同的进程或进程组看到的挂载点。通俗地说，就是可以实现在不同的进程中看到不同的挂载目录。使用 Mount Namespace 可以实现容器内只能看到自己的挂载信息，在容器内的挂载操作不会影响主机的挂载目录。</p><p>​    <strong>unshare</strong> 是 util-linux 工具包中的一个工具，CentOS 7 系统默认已经集成了该工具，使用 unshare 命令可以实现创建并访问不同类型的 Namespace。</p><p>首先我们使用以下命令创建一个 bash 进程并且新建一个 Mount Namespace：</p><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">$ sudo unshare <span class="hljs-params">--mount</span> <span class="hljs-params">--fork</span> <span class="hljs-string">/bin/bash</span></code></pre></div><p>执行完上述命令后，这时我们已经在主机上创建了一个新的 Mount Namespace，并且当前命令行窗口加入了新创建的 Mount Namespace。下面我通过一个例子来验证下，<strong>在独立的 Mount Namespace 内创建挂载目录是不影响主机的挂载目录的。</strong></p><p>首先在 /tmp 目录下创建一个目录。</p><div class="hljs code-wrapper"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@centos7</span> centos]<span class="hljs-meta"># mkdir /tmp/tmpfs</span></code></pre></div><p>创建好目录后使用 mount 命令挂载一个 tmpfs 类型的目录。命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs gradle">[root@centos7 centos]# mount -t tmpfs -o <span class="hljs-keyword">size</span>=<span class="hljs-number">20</span>m tmpfs <span class="hljs-regexp">/tmp/</span>tmpfs</code></pre></div><p>然后使用 df 命令查看一下已经挂载的目录信息：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">[root@centos7 centos]<span class="hljs-comment"># df -h</span>Filesystem      Size  Used Avail Use% Mounted on<span class="hljs-regexp">/dev/</span>vda1       <span class="hljs-number">500</span>G  <span class="hljs-number">1.4</span>G  <span class="hljs-number">499</span>G   <span class="hljs-number">1</span>% /devtmpfs         <span class="hljs-number">16</span>G     <span class="hljs-number">0</span>   <span class="hljs-number">16</span>G   <span class="hljs-number">0</span>% /devtmpfs            <span class="hljs-number">16</span>G     <span class="hljs-number">0</span>   <span class="hljs-number">16</span>G   <span class="hljs-number">0</span>% <span class="hljs-regexp">/dev/</span>shmtmpfs            <span class="hljs-number">16</span>G     <span class="hljs-number">0</span>   <span class="hljs-number">16</span>G   <span class="hljs-number">0</span>% <span class="hljs-regexp">/sys/</span>fs/cgrouptmpfs            <span class="hljs-number">16</span>G   <span class="hljs-number">57</span>M   <span class="hljs-number">16</span>G   <span class="hljs-number">1</span>% /runtmpfs           <span class="hljs-number">3.2</span>G     <span class="hljs-number">0</span>  <span class="hljs-number">3.2</span>G   <span class="hljs-number">0</span>% <span class="hljs-regexp">/run/u</span>ser/<span class="hljs-number">1000</span>tmpfs            <span class="hljs-number">20</span>M     <span class="hljs-number">0</span>   <span class="hljs-number">20</span>M   <span class="hljs-number">0</span>% <span class="hljs-regexp">/tmp/</span>tmpfs</code></pre></div><p>可以看到 /tmp/tmpfs 目录已经被正确挂载。为了验证主机上并没有挂载此目录，我们新打开一个命令行窗口，同样执行 df 命令查看主机的挂载信息：</p><div class="hljs code-wrapper"><pre><code class="hljs gradle">[centos@centos7 ~]$ df -hFilesystem      <span class="hljs-keyword">Size</span>  Used Avail Use% Mounted ondevtmpfs         <span class="hljs-number">16</span>G     <span class="hljs-number">0</span>   <span class="hljs-number">16</span>G   <span class="hljs-number">0</span>% /devtmpfs            <span class="hljs-number">16</span>G     <span class="hljs-number">0</span>   <span class="hljs-number">16</span>G   <span class="hljs-number">0</span>% <span class="hljs-regexp">/dev/</span>shmtmpfs            <span class="hljs-number">16</span>G   <span class="hljs-number">57</span>M   <span class="hljs-number">16</span>G   <span class="hljs-number">1</span>% /runtmpfs            <span class="hljs-number">16</span>G     <span class="hljs-number">0</span>   <span class="hljs-number">16</span>G   <span class="hljs-number">0</span>% <span class="hljs-regexp">/sys/</span>fs/cgroup<span class="hljs-regexp">/dev/</span>vda1       <span class="hljs-number">500</span>G  <span class="hljs-number">1.4</span>G  <span class="hljs-number">499</span>G   <span class="hljs-number">1</span>% /tmpfs           <span class="hljs-number">3.2</span>G     <span class="hljs-number">0</span>  <span class="hljs-number">3.2</span>G   <span class="hljs-number">0</span>% <span class="hljs-regexp">/run/u</span>ser/<span class="hljs-number">1000</span></code></pre></div><p>通过上面输出可以看到主机上并没有挂载 /tmp/tmpfs，可见我们独立的 Mount Namespace 中执行 mount 操作并不会影响主机。</p><p>为了进一步验证我们的想法，我们继续在当前命令行窗口查看一下当前进程的 Namespace 信息，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs tcl">[root@centos7 centos]# ls -l /<span class="hljs-keyword">proc</span>/self/ns/total 0lrwxrwxrwx. 1<span class="hljs-title"> root</span> root 0<span class="hljs-title"> Sep</span>  4 08:20<span class="hljs-title"> ipc</span> -&gt;<span class="hljs-title"> ipc:[4026531839]</span><span class="hljs-title">lrwxrwxrwx.</span> 1<span class="hljs-title"> root</span> root 0<span class="hljs-title"> Sep</span>  4 08:20<span class="hljs-title"> mnt</span> -&gt;<span class="hljs-title"> mnt:[4026532239]</span><span class="hljs-title">lrwxrwxrwx.</span> 1<span class="hljs-title"> root</span> root 0<span class="hljs-title"> Sep</span>  4 08:20<span class="hljs-title"> net</span> -&gt;<span class="hljs-title"> net:[4026531956]</span><span class="hljs-title">lrwxrwxrwx.</span> 1<span class="hljs-title"> root</span> root 0<span class="hljs-title"> Sep</span>  4 08:20<span class="hljs-title"> pid</span> -&gt;<span class="hljs-title"> pid:[4026531836]</span><span class="hljs-title">lrwxrwxrwx.</span> 1<span class="hljs-title"> root</span> root 0<span class="hljs-title"> Sep</span>  4 08:20<span class="hljs-title"> user</span> -&gt;<span class="hljs-title"> user:[4026531837]</span><span class="hljs-title">lrwxrwxrwx.</span> 1<span class="hljs-title"> root</span> root 0<span class="hljs-title"> Sep</span>  4 08:20<span class="hljs-title"> uts</span> -&gt;<span class="hljs-title"> uts:[4026531838]</span></code></pre></div><p>然后新打开一个命令行窗口，使用相同的命令查看一下主机上的 Namespace 信息：</p><div class="hljs code-wrapper"><pre><code class="hljs tcl">[centos@centos7 ~]$ ls -l /<span class="hljs-keyword">proc</span>/self/ns/total 0lrwxrwxrwx. 1<span class="hljs-title"> centos</span> centos 0<span class="hljs-title"> Sep</span>  4 08:20<span class="hljs-title"> ipc</span> -&gt;<span class="hljs-title"> ipc:[4026531839]</span><span class="hljs-title">lrwxrwxrwx.</span> 1<span class="hljs-title"> centos</span> centos 0<span class="hljs-title"> Sep</span>  4 08:20<span class="hljs-title"> mnt</span> -&gt;<span class="hljs-title"> mnt:[4026531840]</span><span class="hljs-title">lrwxrwxrwx.</span> 1<span class="hljs-title"> centos</span> centos 0<span class="hljs-title"> Sep</span>  4 08:20<span class="hljs-title"> net</span> -&gt;<span class="hljs-title"> net:[4026531956]</span><span class="hljs-title">lrwxrwxrwx.</span> 1<span class="hljs-title"> centos</span> centos 0<span class="hljs-title"> Sep</span>  4 08:20<span class="hljs-title"> pid</span> -&gt;<span class="hljs-title"> pid:[4026531836]</span><span class="hljs-title">lrwxrwxrwx.</span> 1<span class="hljs-title"> centos</span> centos 0<span class="hljs-title"> Sep</span>  4 08:20<span class="hljs-title"> user</span> -&gt;<span class="hljs-title"> user:[4026531837]</span><span class="hljs-title">lrwxrwxrwx.</span> 1<span class="hljs-title"> centos</span> centos 0<span class="hljs-title"> Sep</span>  4 08:20<span class="hljs-title"> uts</span> -&gt;<span class="hljs-title"> uts:[4026531838]</span></code></pre></div><p>通过对比两次命令的输出结果，我们可以看到，除了 Mount Namespace 的 ID 值不一样外，其他Namespace 的 ID 值均一致。</p><p>通过以上结果我们可以得出结论，使用 unshare 命令可以新建 Mount Namespace，并且在新建的 Mount Namespace 内 mount 是和外部完全隔离的。</p><p><strong>2）PID Namespace</strong><br>​    <strong>PID Namespace 的作用是用来隔离进程</strong>。在不同的 PID Namespace 中，进程可以拥有相同的 PID 号，利用 PID Namespace 可以实现每个容器的主进程为 1 号进程，而容器内的进程在主机上却拥有不同的PID。例如一个进程在主机上 PID 为 122，使用 PID Namespace 可以实现该进程在容器内看到的 PID 为 1。</p><p>下面演示PID Namespace的作用。创建一个 bash 进程，并且新建一个 PID Namespace：</p><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">$ sudo unshare <span class="hljs-params">--pid</span> <span class="hljs-params">--fork</span> <span class="hljs-params">--mount-proc</span> <span class="hljs-string">/bin/bash</span></code></pre></div><p>执行完上述命令后，我们在主机上创建了一个新的 PID Namespace，并且当前命令行窗口加入了新创建的 PID Namespace。在当前的命令行窗口使用 ps aux 命令查看一下进程信息：</p><div class="hljs code-wrapper"><pre><code class="hljs tap">[root@centos7 centos]<span class="hljs-comment"># ps aux</span>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDroot        <span class="hljs-number"> 1 </span> 0.0  0.0<span class="hljs-number"> 115544 </span><span class="hljs-number"> 2004 </span>pts/0    S    10:57   0:00 bashroot       <span class="hljs-number"> 10 </span> 0.0  0.0<span class="hljs-number"> 155444 </span><span class="hljs-number"> 1764 </span>pts/0    R+   10:59   0:00 ps aux</code></pre></div><p>通过上述命令输出结果可以看到当前 Namespace 下 bash 为 1 号进程，而且我们也看不到主机上的其他进程信息。</p><p><strong>3）UTS Namespace</strong><br>​    <strong>UTS Namespace 主要是用来隔离主机名的</strong>，它允许每个 UTS Namespace 拥有一个独立的主机名。例如我们的主机名称为 docker，使用 UTS Namespace 可以实现在容器内的主机名称为 utsdocker 或者其他任意自定义主机名。</p><p>同样我们通过一个实例来验证下 UTS Namespace 的作用，首先我们使用 unshare 命令来创建一个 UTS Namespace：</p><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">$ sudo unshare <span class="hljs-params">--uts</span> <span class="hljs-params">--fork</span> <span class="hljs-string">/bin/bash</span></code></pre></div><p>创建好 UTS Namespace 后，当前命令行窗口已经处于一个独立的 UTS Namespace 中，下面我们使用 hostname 命令（hostname 可以用来查看主机名称）设置一下主机名：</p><div class="hljs code-wrapper"><pre><code class="hljs autoit">root<span class="hljs-symbol">@centos7</span> centos]<span class="hljs-meta"># hostname -b utsdocker</span></code></pre></div><p>然后再查看一下主机名：</p><div class="hljs code-wrapper"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@centos7</span> centos]<span class="hljs-meta"># hostname</span>utsdocker</code></pre></div><p>通过上面命令的输出，我们可以看到当前UTS Namespace 内的主机名已经被修改为 utsdocker。然后我们新打开一个命令行窗口，使用相同的命令查看一下主机的 hostname：</p><div class="hljs code-wrapper"><pre><code class="hljs elixir">[centos<span class="hljs-variable">@centos7</span> ~]<span class="hljs-variable">$ </span>hostnamecentos7</code></pre></div><p>可以看到主机的名称仍然为 centos7，并没有被修改。由此，可以验证 UTS Namespace 可以用来隔离主机名。</p><p><strong>4）IPC Namespace</strong><br>​    <strong>IPC Namespace 主要是用来隔离进程间通信的</strong>。<strong>PID Namespace 和 IPC Namespace 一起使用可以实现同一 IPC Namespace 内的进程彼此可以通信</strong>，不同 IPC Namespace 的进程却不能通信。</p><p>使用 unshare 命令来创建一个 IPC Namespace：</p><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">$ sudo unshare <span class="hljs-params">--ipc</span> <span class="hljs-params">--fork</span> <span class="hljs-string">/bin/bash</span></code></pre></div><p>下面我们需要借助两个命令来实现对 IPC Namespace 的验证。</p><ul><li><p>ipcs -q 命令：用来查看系统间通信队列列表。</p></li><li><p>ipcmk -Q 命令：用来创建系统间通信队列。</p></li></ul><p>我们首先使用 ipcs -q 命令查看一下当前 IPC Namespace 下的系统通信队列列表：</p><div class="hljs code-wrapper"><pre><code class="hljs brainfuck"><span class="hljs-title">[</span><span class="hljs-comment">centos@centos7</span> <span class="hljs-comment">~</span><span class="hljs-title">]</span><span class="hljs-comment">$</span> <span class="hljs-comment">ipcs</span> <span class="hljs-literal">-</span><span class="hljs-comment">q</span><span class="hljs-comment"></span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span> <span class="hljs-comment">Message</span> <span class="hljs-comment">Queues</span> --<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">key</span>        <span class="hljs-comment">msqid</span>      <span class="hljs-comment">owner</span>      <span class="hljs-comment">perms</span>      <span class="hljs-comment">used</span><span class="hljs-literal">-</span><span class="hljs-comment">bytes</span>   <span class="hljs-comment">messages</span></code></pre></div><p>由上可以看到当前无任何系统通信队列，然后我们使用 ipcmk -Q 命令创建一个系统通信队列：</p><div class="hljs code-wrapper"><pre><code class="hljs applescript">[root@centos7 centos]<span class="hljs-comment"># ipcmk -Q</span>Message queue <span class="hljs-built_in">id</span>: <span class="hljs-number">0</span></code></pre></div><p>再次使用 ipcs -q 命令查看当前 IPC Namespace 下的系统通信队列列表：</p><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">[root@centos7 centos]<span class="hljs-comment"># ipcs -q</span><span class="hljs-params">------</span> Message Queues <span class="hljs-params">--------</span>key        msqid      owner      perms      used-bytes   messages0x73682a32 0          root       644        0            0</code></pre></div><p>可以看到我们已经成功创建了一个系统通信队列。然后我们新打开一个命令行窗口，使用ipcs -q 命令查看一下主机的系统通信队列：</p><div class="hljs code-wrapper"><pre><code class="hljs brainfuck"><span class="hljs-title">[</span><span class="hljs-comment">centos@centos7</span> <span class="hljs-comment">~</span><span class="hljs-title">]</span><span class="hljs-comment">$</span> <span class="hljs-comment">ipcs</span> <span class="hljs-literal">-</span><span class="hljs-comment">q</span><span class="hljs-comment"></span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span> <span class="hljs-comment">Message</span> <span class="hljs-comment">Queues</span> --<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">key</span>        <span class="hljs-comment">msqid</span>      <span class="hljs-comment">owner</span>      <span class="hljs-comment">perms</span>      <span class="hljs-comment">used</span><span class="hljs-literal">-</span><span class="hljs-comment">bytes</span>   <span class="hljs-comment">messages</span></code></pre></div><p>通过上面的实验，可以发现，在单独的 IPC Namespace 内创建的系统通信队列在主机上无法看到。即 IPC Namespace 实现了系统通信队列的隔离。</p><p><strong>5）User Namespace</strong><br>​    <strong>User Namespace 主要是用来隔离用户和用户组的</strong>。一个比较典型的应用场景就是在主机上以非 root 用户运行的进程可以在一个单独的 User Namespace 中映射成 root 用户。使用 User Namespace 可以实现进程在容器内拥有 root 权限，而在主机上却只是普通用户。</p><p>User Namesapce 的创建是可以不使用 root 权限的。下面我们以普通用户的身份创建一个 User Namespace，命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs crmsh">[centos@centos7 ~]$ unshare --<span class="hljs-keyword">user</span> <span class="hljs-title">-r</span> /bin/bash</code></pre></div><p>CentOS7 默认允许创建的 User Namespace 为 0，如果执行上述命令失败（ unshare 命令返回的错误为 unshare: unshare failed: Invalid argument ），需要使用以下命令修改系统允许创建的 User Namespace 数量，命令为：echo 65535 &gt; /proc/sys/user/max_user_namespaces，然后再次尝试创建 User Namespace。</p><p>然后执行 id 命令查看一下当前的用户信息：</p><div class="hljs code-wrapper"><pre><code class="hljs routeros">[root@centos7 ~]# id<span class="hljs-attribute">uid</span>=0(root) <span class="hljs-attribute">gid</span>=0(root) <span class="hljs-attribute">groups</span>=0(root),65534(nfsnobody) <span class="hljs-attribute">context</span>=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</code></pre></div><p>通过上面的输出可以看到我们在新的 User Namespace 内已经是 root 用户了。下面我们使用只有主机 root 用户才可以执行的 reboot 命令来验证一下，在当前命令行窗口执行 reboot 命令：</p><div class="hljs code-wrapper"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@centos7</span> ~]<span class="hljs-meta"># reboot</span>Failed <span class="hljs-keyword">to</span> open /dev/initctl: Permission deniedFailed <span class="hljs-keyword">to</span> talk <span class="hljs-keyword">to</span> init daemon.</code></pre></div><p>可以看到，我们在新创建的 User Namespace 内虽然是 root 用户，但是并没有权限执行 reboot 命令。这说明在隔离的 User Namespace 中，并不能获取到主机的 root 权限，也就是说 User Namespace 实现了用户和用户组的隔离。</p><p><strong>6）Net Namespace</strong><br>​    <strong>Net Namespace 是用来隔离网络设备、IP 地址和端口等信息的</strong>。Net Namespace 可以让每个进程拥有自己独立    的 IP 地址，端口和网卡信息。例如主机 IP 地址为 172.16.4.1 ，容器内可以设置独立的 IP 地址为 192.168.1.1。</p><p>同样用实例验证，我们首先使用 ip a 命令查看一下主机上的网络信息：</p><div class="hljs code-wrapper"><pre><code class="hljs pf">$ ip a<span class="hljs-number">1</span>: lo: <span class="hljs-variable">&lt;LOOPBACK,UP,LOWER_UP&gt;</span> mtu <span class="hljs-number">65536</span> qdisc noqueue <span class="hljs-keyword">state</span> UNKNOWN <span class="hljs-keyword">group</span> <span class="hljs-keyword">default</span> qlen <span class="hljs-number">1000</span>    link/loopback <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> brd <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>    <span class="hljs-keyword">inet</span> <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>/<span class="hljs-number">8</span> scope host lo       valid_lft forever preferred_lft forever    <span class="hljs-keyword">inet6</span> ::<span class="hljs-number">1</span>/<span class="hljs-number">128</span> scope host       valid_lft forever preferred_lft forever<span class="hljs-number">2</span>: eth0: <span class="hljs-variable">&lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;</span> mtu <span class="hljs-number">1500</span> qdisc pfifo_fast <span class="hljs-keyword">state</span> UP <span class="hljs-keyword">group</span> <span class="hljs-keyword">default</span> qlen <span class="hljs-number">1000</span>    link/ether <span class="hljs-number">02</span>:<span class="hljs-number">11</span>:b0:<span class="hljs-number">14</span>:<span class="hljs-number">01</span>:<span class="hljs-number">0</span>c brd ff:ff:ff:ff:ff:ff    <span class="hljs-keyword">inet</span> <span class="hljs-number">172.20</span>.<span class="hljs-number">1.11</span>/<span class="hljs-number">24</span> brd <span class="hljs-number">172.20</span>.<span class="hljs-number">1.255</span> scope <span class="hljs-keyword">global</span> dynamic eth0       valid_lft <span class="hljs-number">86063337</span>sec preferred_lft <span class="hljs-number">86063337</span>sec    <span class="hljs-keyword">inet6</span> fe80::<span class="hljs-number">11</span>:b0ff:fe14:<span class="hljs-number">10</span>c/<span class="hljs-number">64</span> scope link       valid_lft forever preferred_lft forever<span class="hljs-number">3</span>: docker0: <span class="hljs-variable">&lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt;</span> mtu <span class="hljs-number">1500</span> qdisc noqueue <span class="hljs-keyword">state</span> DOWN <span class="hljs-keyword">group</span> <span class="hljs-keyword">default</span>    link/ether <span class="hljs-number">02</span>:<span class="hljs-number">42</span>:<span class="hljs-number">82</span>:<span class="hljs-number">8</span>d:a0:df brd ff:ff:ff:ff:ff:ff    <span class="hljs-keyword">inet</span> <span class="hljs-number">172.17</span>.<span class="hljs-number">0.1</span>/<span class="hljs-number">16</span> scope <span class="hljs-keyword">global</span> docker0       valid_lft forever preferred_lft forever    <span class="hljs-keyword">inet6</span> fe80::<span class="hljs-number">42</span>:<span class="hljs-number">82</span>ff:fe8d:a0df/<span class="hljs-number">64</span> scope link       valid_lft forever preferred_lft forever</code></pre></div><p>然后我们使用以下命令创建一个 Net Namespace：</p><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">$ sudo unshare <span class="hljs-params">--net</span> <span class="hljs-params">--fork</span> <span class="hljs-string">/bin/bash</span></code></pre></div><p>同样的我们使用 ip a 命令查看一下网络信息：</p><div class="hljs code-wrapper"><pre><code class="hljs pf">[root@centos7 centos]<span class="hljs-comment"># ip a</span><span class="hljs-number">1</span>: lo: <span class="hljs-variable">&lt;LOOPBACK&gt;</span> mtu <span class="hljs-number">65536</span> qdisc noop <span class="hljs-keyword">state</span> DOWN <span class="hljs-keyword">group</span> <span class="hljs-keyword">default</span> qlen <span class="hljs-number">1000</span>    link/loopback <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> brd <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span></code></pre></div><p>可以看到，宿主机上有 lo、eth0、docker0 等网络设备，而我们新建的 Net Namespace 内则与主机上的网络设备不同。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>​    Linux 内核从 2002 年 2.4.19 版本开始加入了 Mount Namespace，而直到内核 3.8 版本加入了 User Namespace 才为容器提供了足够的支持功能。</p><p>​    当 Docker 新建一个容器时， 它会创建这六种 Namespace，然后将容器中的进程加入这些 Namespace 之中，使得 Docker 容器中的进程只能看到当前 Namespace 中的系统资源。</p><p>​    正是由于 Docker 使用了 Linux 的这些 Namespace 技术，才实现了 Docker 容器的隔离，可以说没有 Namespace，就没有 Docker 容器。</p>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker 技术原理</title>
    <link href="/2020/06/03/docker-technology-%20principal/"/>
    <url>/2020/06/03/docker-technology-%20principal/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-principal"><a href="#Docker-principal" class="headerlink" title="Docker principal"></a>Docker principal</h1><h4 id="先聊聊Docker-的基础内容：Docker-能做什么，怎么安装-Docker，以及容器技术的原理。"><a href="#先聊聊Docker-的基础内容：Docker-能做什么，怎么安装-Docker，以及容器技术的原理。" class="headerlink" title="先聊聊Docker 的基础内容：Docker 能做什么，怎么安装 Docker，以及容器技术的原理。"></a><strong>先聊聊Docker 的基础内容：Docker 能做什么，怎么安装 Docker，以及容器技术的原理。</strong></h4><h3 id="1-Docker-能做什么？"><a href="#1-Docker-能做什么？" class="headerlink" title="1. Docker 能做什么？"></a>1. Docker 能做什么？</h3><p>​    众所周知，Docker 是一个用于开发，发布和运行应用程序的开放平台。通俗地讲，Docker 类似于集装箱。在一艘大船上，各种货物要想被整齐摆放并且相互不受到影响，我们就需要把各种货物进行集装箱标准化。有了集装箱，我们就不需要专门运输水果或者化学用品的船了。我们可以把各种货品通过集装箱打包，然后统一放到一艘船上运输。Docker 要做的就是把各种软件打包成一个集装箱（镜像），然后分发，且在运行的时候可以相互隔离。</p><p>到此，相信你已经迫不及待想要体验下了，下面就让我们来安装一个 Docker。</p><p><img src="//img/images/docker1.png"></p><h4 id="2-CentOS-下安装-Docker"><a href="#2-CentOS-下安装-Docker" class="headerlink" title="2. CentOS 下安装 Docker"></a><strong>2. CentOS 下安装 Docker</strong></h4><p>​    Docker 是跨平台的解决方案，它支持在当前主流的各大平台安装，包括 Ubuntu、RHEL、CentOS、Debian 等 Linux 发行版，同时也可以在 OSX 、Microsoft Windows 等非 Linux 平台下安装使用。</p><p>​    因为 Linux 是 Docker 的原生支持平台，所以推荐你在 Linux 上使用 Docker。由于生产环境中我们使用 CentOS 较多，下面主要针对在 CentOS 平台下安装和使用 Docker 展开介绍。</p><h5 id="2-1-操作系统要求"><a href="#2-1-操作系统要求" class="headerlink" title="2.1 操作系统要求"></a>2.1 操作系统要求</h5><p>要安装 Docker，我们需要 CentOS 7 及以上的发行版本。</p><h5 id="2-2-卸载已有-Docker"><a href="#2-2-卸载已有-Docker" class="headerlink" title="2.2 卸载已有 Docker"></a>2.2 卸载已有 Docker</h5><p>如果你已经安装过旧版的 Docker，可以先执行以下命令卸载旧版 Docker。</p><div class="hljs code-wrapper"><pre><code class="hljs livescript">$ sudo yum remove docker <span class="hljs-string">\</span>docker-client <span class="hljs-string">\</span>                docker-client-latest <span class="hljs-string">\</span>                docker-common <span class="hljs-string">\</span>                docker-latest <span class="hljs-string">\</span>                docker-latest-logrotate <span class="hljs-string">\</span>                docker-logrotate <span class="hljs-string">\</span>                docker-engine</code></pre></div><h5 id="2-3-安装-Docker"><a href="#2-3-安装-Docker" class="headerlink" title="2.3 安装 Docker"></a>2.3 安装 Docker</h5><p>首次安装 Docker 之前，需要添加 Docker 安装源。添加之后，我们就可以从已经配置好的源，安装和更新 Docker。添加 Docker 安装源的命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">$ yum -y install yum-utils$ sudo yum-config-manager \    --add-repo \    https:<span class="hljs-regexp">//</span>download.docker.com<span class="hljs-regexp">/linux/</span>centos/docker-ce.repo</code></pre></div><p>正常情况下，直接安装最新版本的 Docker 即可，因为最新版本的 Docker 有着更好的稳定性和安全性。你可以使用以下命令安装最新版本的 Docker。</p><div class="hljs code-wrapper"><pre><code class="hljs vim">$ sudo yum install docker-<span class="hljs-keyword">ce</span> docker-<span class="hljs-keyword">ce</span>-cli containerd.io</code></pre></div><p>安装完成后，使用以下命令启动 Docker。</p><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> sudo systemctl <span class="hljs-built_in">start</span> docker</code></pre></div><h5 id="2-4-启动一个-hello-world-的容器"><a href="#2-4-启动一个-hello-world-的容器" class="headerlink" title="2.4 启动一个 hello world 的容器"></a>2.4 启动一个 hello world 的容器</h5><div class="hljs code-wrapper"><pre><code class="hljs routeros">$ sudo docker <span class="hljs-builtin-name">run</span> hello-worldUnable <span class="hljs-keyword">to</span> <span class="hljs-builtin-name">find</span> image <span class="hljs-string">&#x27;hello-world:latest&#x27;</span> locallylatest: Pulling <span class="hljs-keyword">from</span> library/hello-world0e03bdcc26d7: Pull completeDigest: sha256:7f0a9f93b4aa3022c3a4c147a449bf11e0941a1fd0bf4a8e6c9408b2600777c5Status: Downloaded newer image <span class="hljs-keyword">for</span> hello-world:latestHello <span class="hljs-keyword">from</span> Docker!</code></pre></div><p>运行上述命令，Docker 首先会检查本地是否有<code>hello-world</code>这个镜像，如果发现本地没有这个镜像，Docker 就会去 <strong>Docker Hub</strong> 官方仓库下载此镜像，然后运行它。最后我们看到该镜像输出 “Hello from Docker!” 并退出。</p><blockquote><p>安装完成后默认 docker 命令只能以 root 用户执行，如果想允许普通用户执行 docker 命令，需要执行以下命令 sudo groupadd docker &amp;&amp; sudo gpasswd -a ${USER} docker &amp;&amp; sudo systemctl restart docker ，执行完命令后，退出当前命令行窗口并打开新的窗口即可。</p></blockquote><p>安装完 Docker，先不着急使用，先来了解下容器的技术原理，这样才能知其所以然。</p><h3 id="3-容器技术原理"><a href="#3-容器技术原理" class="headerlink" title="3. 容器技术原理"></a>3. 容器技术原理</h3><p>必须先提一提chroot，因为 chroot 是最早的容器雏形。chroot 意味着切换根目录，有了 chroot 就意味着我们可以把任何目录更改为当前进程的根目录，这与容器非常相似，下面我们通过一个实例了解下 chroot。</p><h4 id="3-1-chroot-即-change-root-directory-（更改-root-目录）"><a href="#3-1-chroot-即-change-root-directory-（更改-root-目录）" class="headerlink" title="3.1 chroot 即 change root directory （更改 root 目录）"></a>3.1 chroot 即 change root directory （更改 root 目录）</h4><p>​    什么是 chroot 呢？下面是 chroot 维基百科定义：</p><blockquote><p>chroot 是在 Unix 和 Linux 系统的一个操作，针对正在运作的软件行程和它的子进程，改变它外显的根目录。一个运行在这个环境下，经由 chroot 设置根目录的程序，它不能够对这个指定根目录之外的文件进行访问动作，不能读取，也不能更改它的内容。</p></blockquote><p>​    通俗地说 ，chroot 就是可以改变某进程的根目录，使这个程序不能访问目录之外的其他目录，这个跟我们在一个容器中是很相似的。</p><p>​    在经过 chroot 之后，系统读取到的目录和文件将不在是旧系统根下的而是新根下(即被指定的新的位置)的目录结构和文件，因此它带来的好处大致有以下3个：</p><ol><li><p>增加了系统的安全性，限制了用户的权力；</p><p>在经过 chroot 之后，在新根下将访问不到旧系统的根目录结构和文件，这样就增强了系统的安全性。这个一般是在登录 (login) 前使用 chroot，以此达到用户不能访问一些特定的文件。</p></li><li><p>建立一个与原系统隔离的系统目录结构，方便用户的开发；</p><p>使用 chroot 后，系统读取的是新根下的目录和文件，这是一个与原系统根下文件不相关的目录结构。在这个新的环境中，可以用来测试软件的静态编译以及一些与系统不相关的独立开发。</p></li><li><p>切换系统的根目录位置，引导 Linux 系统启动以及急救系统等。</p><p>chroot 的作用就是切换系统的根位置，而这个作用最为明显的是在系统初始引导磁盘的处理过程中使用，从初始 RAM 磁盘 (initrd) 切换系统的根位置并执行真正的 init。另外，当系统出现一些问题时，我们也可以使用 chroot 来切换到一个临时的系统。</p></li></ol><p>下面我们<strong>通过一个实例来演示下 chroot。</strong></p><p>首先我们在当前/home目录下创建一个 rootfs 目录：</p><div class="hljs code-wrapper"><pre><code class="hljs arduino">$ mkdir rootfs</code></pre></div><p>这里为了方便演示，我使用现成的 busybox 镜像来创建一个系统，镜像的概念和组成后面我会详细讲解，如果你没有 Docker 基础可以把下面的操作命令理解成在 rootfs 下创建了一些目录和放置了一些二进制文件。</p><p>复制</p><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> rootfs <span class="hljs-variable">$</span> docker export <span class="hljs-variable">$</span>(docker create busybox) <span class="hljs-literal">-o</span> busybox.tar<span class="hljs-variable">$</span> tar <span class="hljs-literal">-xf</span> busybox.tar</code></pre></div><p>执行完上面的命令后，在 rootfs 目录下，我们会得到一些目录和文件。下面我们使用 ls 命令查看一下 rootfs 目录下的内容。</p><p>复制</p><div class="hljs code-wrapper"><pre><code class="hljs tcl">$ lsbin  busybox.tar  dev  etc  home  <span class="hljs-keyword">proc</span><span class="hljs-title">  root</span> <span class="hljs-title"> sys</span> <span class="hljs-title"> tmp</span> <span class="hljs-title"> usr</span> <span class="hljs-title"> var</span></code></pre></div><p>可以看到我们在 rootfs 目录下初始化了一些目录，下面让我们通过一条命令来见证 chroot 的神奇之处。使用以下命令，可以启动一个 sh 进程，并且把 /home/centos/rootfs 作为 sh 进程的根目录。</p><p>复制</p><div class="hljs code-wrapper"><pre><code class="hljs awk">$ chroot <span class="hljs-regexp">/home/</span>rootfs <span class="hljs-regexp">/bin/</span>sh</code></pre></div><p>此时，我们的命令行窗口已经处于上述命令启动的 sh 进程中。在当前 sh 命令行窗口下，我们使用 ls 命令查看一下当前进程，看是否真的与主机上的其他目录隔离开了</p><div class="hljs code-wrapper"><pre><code class="hljs tcl">/ # ls /bin  busybox.tar  dev  etc  home  <span class="hljs-keyword">proc</span><span class="hljs-title">  root</span> <span class="hljs-title"> sys</span> <span class="hljs-title"> tmp</span> <span class="hljs-title"> usr</span> <span class="hljs-title"> var</span></code></pre></div><p>这里可以看到当前进程的根目录已经变成了主机上的 /home/rootfs 目录。这样就实现了当前进程与主机的隔离。到此为止，一个目录隔离的容器就完成了。操作图解如下图所示：</p><p><img src="/img/images/chroot1.png"></p><p>但是，此时还不能称之为一个容器，为什么呢？你可以在上一步（使用 chroot 启动命令行窗口）执行以下命令，查看如下路由信息：</p><div class="hljs code-wrapper"><pre><code class="hljs accesslog">/etc # ip routedefault via <span class="hljs-number">172</span>.<span class="hljs-number">20</span>.<span class="hljs-number">1</span>.<span class="hljs-number">1</span> dev eth0<span class="hljs-number">172.17.0.0</span>/<span class="hljs-number">16</span> dev docker0 scope link  src <span class="hljs-number">172</span>.<span class="hljs-number">17</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span><span class="hljs-number">172.20.1.0</span>/<span class="hljs-number">24</span> dev eth0 scope link  src <span class="hljs-number">172</span>.<span class="hljs-number">20</span>.<span class="hljs-number">1</span>.<span class="hljs-number">3</span></code></pre></div><p>执行 ip route 命令后，你可以看到网络信息并没有隔离，实际上进程等信息此时也并未隔离。要想实现一个完整的容器，我们还需要 Linux 的其他三项技术： Namespace、Cgroups 和联合文件系统。</p><p>Docker 是利用 Linux 的 Namespace 、Cgroups 和联合文件系统三大机制来保证实现的， 所以它的原理是使用 Namespace 做主机名、网络、PID 等资源的隔离，使用 Cgroups 对进程或者进程组做资源（例如：CPU、内存等）的限制，联合文件系统用于镜像构建和容器运行环境。</p><p>下面简单解释下它们的作用</p><h4 id="3-2-Namespace"><a href="#3-2-Namespace" class="headerlink" title="3.2 Namespace"></a><strong>3.2 Namespace</strong></h4><p>​    Namespace 是 Linux 内核的一项功能，该功能对内核资源进行隔离，使得容器中的进程都可以在单独的命名空间中运行，并且只可以访问当前容器命名空间的资源。Namespace 可以隔离进程 ID、主机名、用户 ID、文件名、网络访问和进程间通信等相关资源。</p><p>Docker 主要用到以下五种命名空间。</p><ul><li>pid namespace：用于隔离进程 ID。</li><li>net namespace：隔离网络接口，在虚拟的 net namespace 内用户可以拥有自己独立的 IP、路由、端口等。</li><li>mnt namespace：文件系统挂载点隔离。</li><li>ipc namespace：信号量,消息队列和共享内存的隔离。</li><li>uts namespace：主机名和域名的隔离。</li></ul><h4 id="3-3-Cgroups-即：Linux-Control-Group"><a href="#3-3-Cgroups-即：Linux-Control-Group" class="headerlink" title="3.3 Cgroups 即：Linux Control Group"></a>3.3 Cgroups 即：Linux Control Group</h4><p>​    Cgroups 是一种 Linux 内核功能，可以限制和隔离进程的资源使用情况（CPU、内存、磁盘 I/O、网络等）。在容器的实现中，Cgroups 通常用来限制容器的 CPU 和内存等资源的使用。</p><p>参考地址：<a href="https://coolshell.cn/articles/17049.html">https://coolshell.cn/articles/17049.html</a></p><p>首先，Linux把CGroup这个事实现成了一个file system，你可以mount。在我的Ubuntu 14.04下，你输入以下命令你就可以看到cgroup已为你mount好了。如下图所示：</p><p><img src="/img/images/cgroups1.png"></p><p>在**/sys/fs**下有一个cgroup的目录，这个目录下还有很多子目录，比如： cpu，cpuset，memory，blkio……这些，这些都是cgroup的子系统。分别用于干不同的事的。</p><h4 id="CPU限制"><a href="#CPU限制" class="headerlink" title="CPU限制"></a>CPU限制</h4><p><strong>1)  先创建一个test.py文件</strong></p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>    i = <span class="hljs-number">0</span>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:        i += <span class="hljs-number">1</span><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    main()</code></pre></div><p><strong>2）执行test.py文件，并查询内存使用情况</strong></p><p><img src="/img/images/cgroups2.png"></p><p><strong>3) 限制cpu使用效率</strong></p><p><img src="/img/images/cgroups-cpu-quota-us.png"></p><p>在/sys/fs/cgroup/cpu下创建了一个coco，而且你会发现，一旦你创建了一个子目录，这个子目录里又有很多文件了。其中<strong>cpu.cfs_quota_us</strong>表示该control group限制占用的时间（微秒），默认为-1，表示不限制。如果设为50000，表示占用50000/10000=50%的CPU。</p><p>这里，我们设置占用20%的CPU，即把cpu.cfs_quota_us设置为20000。执行命令就是：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">echo <span class="hljs-number">20000</span> &gt; <span class="hljs-regexp">/sys/</span>fs<span class="hljs-regexp">/cgroup/</span>cpu<span class="hljs-regexp">/coco/</span>cpu.cfs_quota_us</code></pre></div><p>然后执行死循环test.py文件，瞬间cpu就会跑到100%。如下图所示：</p><p><img src="/img/images/cgroups-cpu-full-top.png"></p><p>我们看到，这个进程的PID是4897，我们把这个进程加到这个cgroup中：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">echo <span class="hljs-number">4897</span> &gt;&gt; <span class="hljs-regexp">/sys/</span>fs<span class="hljs-regexp">/cgroup/</span>cpu<span class="hljs-regexp">/coco/</span>tasks</code></pre></div><p>然后，就会在top中看到CPU的利用立马下降成20%了。（前面我们设置的20000就是20%的意思）</p><p><strong>4) 查看内存使用情况</strong></p><p><img src="/img/images/cgroups-cpu-top.png"></p><h4 id="内存限制"><a href="#内存限制" class="headerlink" title="内存限制"></a>内存限制</h4><h5 id="1）创建test1-py文件"><a href="#1）创建test1-py文件" class="headerlink" title="1）创建test1.py文件"></a>1）创建test1.py文件</h5><div class="hljs code-wrapper"><pre><code class="hljs gradle"><span class="hljs-keyword">def</span> main():    i = []    <span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:        i.<span class="hljs-keyword">append</span>(<span class="hljs-number">1</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    main()</code></pre></div><p>想要的效果为：i变量一直新增元素，导致i的内存空间会一直增大。</p><p><strong>2） 执行test1.py文件，并通过top观察执行消耗内存情况</strong></p><p>执行test1.py文件，获取到进程PID</p><div class="hljs code-wrapper"><pre><code class="hljs Python">python test1.py &amp;</code></pre></div><p>然后可以通过top查看到对应进程的内存使用情况。</p><p><strong>3）限制内存使用情况</strong></p><p><img src="/img/images/cgroups-memory.png"></p><p>在/sys/fs/cgroup/memory下创建了一个coco，而且你会发现，一旦你创建了一个子目录，这个子目录里又有很多文件了。其中<strong>memory.limit_in_bytes</strong> 或 <strong>memory.memsw.limit_in_bytes</strong> 限制进程内存占用的大小，避免在进程异常时耗尽系统资源</p><p>这里，我们设置占用300k的内存使用量，即把memory.limit_in_bytes设置为300k。执行命令就是：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">echo <span class="hljs-number">300</span>k &gt; <span class="hljs-regexp">/sys/</span>fs<span class="hljs-regexp">/cgroup/m</span>emory<span class="hljs-regexp">/coco/m</span>emory.limit_in_bytes</code></pre></div><p>然后再把需要限制内存大小的进程加到这个cgroup中：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">echo <span class="hljs-number">23541</span> &gt;&gt; <span class="hljs-regexp">/sys/</span>fs<span class="hljs-regexp">/cgroup/m</span>emory<span class="hljs-regexp">/coco/</span>tasks</code></pre></div><p>最后你会看到，一会上面PID为 23541的进程将会被kill掉。</p><p><strong>4）查看进程</strong></p><p>从上图中可以看出，当执行kill -9 23541时，提示无法找到PID为23541的进程。那就说明当PID为23541的进程消耗的内存超过了300k时，将主动被kill掉了。</p><h4 id="3-4-联合文件系统"><a href="#3-4-联合文件系统" class="headerlink" title="3.4 联合文件系统"></a>3.4 联合文件系统</h4><p>​    联合文件系统，又叫 UnionFS，是一种通过创建文件层进程操作的文件系统，因此，联合文件系统非常轻快。Docker 使用联合文件系统为容器提供构建层，使得容器可以实现写时复制以及镜像的分层构建和存储。常用的联合文件系统有 AUFS、Overlay 和 Devicemapper 等。</p>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot的异步方法async调用与线程池配置</title>
    <link href="/2020/06/03/spring-async/"/>
    <url>/2020/06/03/spring-async/</url>
    
    <content type="html"><![CDATA[<h2 id="Springboot的异步方法调用与线程池配置"><a href="#Springboot的异步方法调用与线程池配置" class="headerlink" title="Springboot的异步方法调用与线程池配置"></a>Springboot的异步方法调用与线程池配置</h2><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><ol><li>springboot 自带了scheduling 包里已经设置了异步方法,我们只需要在方法或者类上加入@Async 注解即可</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xkcoding.async.task;<span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<span class="hljs-keyword">import</span> org.springframework.scheduling.annotation.Async;<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 将一个类声明为异步类，那么这个类对外暴露的方法全部成为异步方法。</span><span class="hljs-comment"> * 与异步方法的区别是这里的注解是加到类上，异步方法的注解是加到方法上。仅此而已</span><span class="hljs-comment"> * <span class="hljs-doctag">@DESC</span> </span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guchuang</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Async</span><span class="hljs-meta">@Service</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncClass</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AsyncClass</span><span class="hljs-params">()</span> </span>&#123;        log.info(<span class="hljs-string">&quot;-------------------------init AsyncClass--------------------&quot;</span>);    &#125;    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;        log.info(<span class="hljs-string">&quot;asyncclass foo, index:&quot;</span> + index);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;        <span class="hljs-keyword">this</span>.index = i;        log.info(<span class="hljs-string">&quot;asyncclass foo, index:&quot;</span> + i);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;        <span class="hljs-keyword">this</span>.index = i;        log.info(<span class="hljs-string">&quot;asyncclass bar, index:&quot;</span> + i);    &#125;&#125;</code></pre></div><ol start="2"><li>yml配置</li></ol><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">task:</span>    <span class="hljs-attr">execution:</span>      <span class="hljs-attr">pool:</span>        <span class="hljs-comment"># 最大线程数</span>        <span class="hljs-attr">max-size:</span> <span class="hljs-number">16</span>        <span class="hljs-comment"># 核心线程数</span>        <span class="hljs-attr">core-size:</span> <span class="hljs-number">16</span>        <span class="hljs-comment"># 存活时间</span>        <span class="hljs-attr">keep-alive:</span> <span class="hljs-string">10s</span>        <span class="hljs-comment"># 队列大小</span>        <span class="hljs-attr">queue-capacity:</span> <span class="hljs-number">100</span>        <span class="hljs-comment"># 是否允许核心线程超时</span>        <span class="hljs-attr">allow-core-thread-timeout:</span> <span class="hljs-literal">true</span>      <span class="hljs-comment"># 线程名称前缀</span>      <span class="hljs-attr">thread-name-prefix:</span> <span class="hljs-string">async-task-</span></code></pre></div><ol start="3"><li>然后直接调用即可产生异步效果</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;       asyncClass.foo();       asyncClass.foo(<span class="hljs-number">10</span>);       Thread.sleep(<span class="hljs-number">100</span>);       asyncClass.foo();   &#125;</code></pre></div><h3 id="ThreadFactory自定义配置"><a href="#ThreadFactory自定义配置" class="headerlink" title="ThreadFactory自定义配置"></a>ThreadFactory自定义配置</h3><ol><li>首先需创建一个类继承ThreadFactory,书写构造器</li><li>覆写他newThread 方法</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ThreadFactory</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> AtomicInteger poolNumber   = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadGroup          group;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger        threadNumber = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String               namePrefix;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThreadFactory</span><span class="hljs-params">(String name)</span> </span>&#123;        SecurityManager s = System.getSecurityManager();        group = (s != <span class="hljs-keyword">null</span>) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();        namePrefix = name + <span class="hljs-string">&quot;-pool-&quot;</span> +            poolNumber.getAndIncrement() +            <span class="hljs-string">&quot;-thread-&quot;</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 覆写了newThread方法</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> r</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;        Thread t = <span class="hljs-keyword">new</span> Thread(group, r,            namePrefix + threadNumber.getAndIncrement(),            <span class="hljs-number">0</span>);        <span class="hljs-keyword">if</span> (t.isDaemon()) &#123;            t.setDaemon(<span class="hljs-keyword">false</span>);        &#125;        <span class="hljs-keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY) &#123;            t.setPriority(Thread.NORM_PRIORITY);        &#125;        <span class="hljs-keyword">return</span> t;    &#125;&#125;</code></pre></div><h3 id="线程池异步配置"><a href="#线程池异步配置" class="headerlink" title="线程池异步配置"></a>线程池异步配置</h3><ol><li>添加注解@EnableAsync和@Configuration</li><li>实现AsyncConfigurer接口,如果不覆写AsyncConfigurer的话，这个方法暴露bean会被当做@Async的默认线程池。</li><li>ExecutorService配置</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ExecutorService threadPool               = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>,        <span class="hljs-number">60L</span>, TimeUnit.MILLISECONDS,        <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="hljs-number">3</span>), <span class="hljs-keyword">new</span> MyThreadFactory(<span class="hljs-string">&quot;common1&quot;</span>));</code></pre></div><ul><li>定义默认调用线程执行器和异常处理机制</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 这个实例声明的TaskExecutor会成为<span class="hljs-doctag">@Async</span>方法运行的默认线程执行器</span><span class="hljs-comment">     * </span><span class="hljs-comment">     * <span class="hljs-doctag">@Bean</span> 使这个实例完全被spring接管</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> TaskExecutor <span class="hljs-title">getAsyncExecutor</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcurrentTaskExecutor(Executors.newFixedThreadPool(<span class="hljs-number">5</span>, <span class="hljs-keyword">new</span> MyThreadFactory(<span class="hljs-string">&quot;async&quot;</span>)));    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 定义<span class="hljs-doctag">@Async</span>方法默认的异常处理机制（只对void型异步返回方法有效，Future返回值类型的异常会抛给调用者）</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AsyncUncaughtExceptionHandler <span class="hljs-title">getAsyncUncaughtExceptionHandler</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> (e, method, objects) -&gt; log.error(<span class="hljs-string">&quot;Method:&quot;</span> + method + <span class="hljs-string">&quot;, exception:&quot;</span> + e.getMessage());    &#125;</code></pre></div><ul><li>自定义线程执行器配置</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 如果不覆写AsyncConfigurer的话，这个方法暴露bean会被当做<span class="hljs-doctag">@Async</span>的默认线程池。</span><span class="hljs-comment">     * 注意必须是这个方法名（也就是bean name， 或者显示指定bean name <span class="hljs-doctag">@Qualifier</span>(&quot;taskExecutor&quot;)），返回类型可以是Executor或者TaskExecutor</span><span class="hljs-comment">     * 如果没有配置的Executor，则默认使用SimpleAsyncTaskExecutor</span><span class="hljs-comment">     * 备注： 这种方式声明的bean，方法名就是bean name</span><span class="hljs-comment">     * </span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Executor <span class="hljs-title">taskExecutor</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcurrentTaskExecutor(Executors.newFixedThreadPool(<span class="hljs-number">5</span>, <span class="hljs-keyword">new</span> MyThreadFactory(<span class="hljs-string">&quot;async0&quot;</span>)));    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 定义其它的TaskExecutor，声明<span class="hljs-doctag">@Async</span>方法的时候可以指定TaskExecutor，达到切换底层的目的</span><span class="hljs-comment">     * </span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> TaskExecutor <span class="hljs-title">async1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 线程数,线程名</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcurrentTaskExecutor(Executors.newFixedThreadPool(<span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> MyThreadFactory(<span class="hljs-string">&quot;async1&quot;</span>)));    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 没有设置拒绝策略</span><span class="hljs-comment">     * </span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@Qualifier(&quot;async2&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> TaskExecutor <span class="hljs-title">myAsyncExecutor2</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcurrentTaskExecutor(threadPool);    &#125;</code></pre></div><h3 id="异常配置"><a href="#异常配置" class="headerlink" title="异常配置"></a>异常配置</h3><ul><li>线程满载后处理类</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xkcoding.async.task;<span class="hljs-keyword">import</span> com.xkcoding.async.MyLog;<span class="hljs-keyword">import</span> lombok.extern.log4j.Log4j;<span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<span class="hljs-keyword">import</span> java.util.concurrent.RejectedExecutionHandler;<span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 线程池满之后的处理策略类</span><span class="hljs-comment"> * <span class="hljs-doctag">@DESC</span> </span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guchuang</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RejectedPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RejectedPolicy</span><span class="hljs-params">()</span> </span>&#123; &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 向线程池中添加线程被拒绝时会调用这个方法。一般拒绝是因为线程池满了</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> r 被拒绝的任务</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e 拒绝这个任务的线程池</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;        log.info(<span class="hljs-string">&quot;one thread is rejected, i will deal it&quot;</span>);        <span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;            r.run();        &#125;    &#125;&#125;</code></pre></div><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ol><li>获取返回值</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFuture</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException </span>&#123;        log.info(<span class="hljs-string">&quot;\n-----------------start-----------------------&quot;</span>);        Future&lt;String&gt; result1 = asyncMethod.futureTask1();        CompletableFuture&lt;String&gt; result2 = asyncMethod.futureTask2();        <span class="hljs-comment">// 获取返回值</span>        log.info(<span class="hljs-string">&quot;result1:&quot;</span> + result1.get());        log.info(<span class="hljs-string">&quot;result2:&quot;</span> + result2.get());    &#125;</code></pre></div><ol start="2"><li>无返回值方法可直接抛出异常,有返回值方法方法需要通过get方法获取异常</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testE</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">try</span> &#123;          Future&lt;String&gt; result = asyncMethod.futureE();          <span class="hljs-comment">//这里调用get才会获得异常</span>          log.info(result.get());      &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;          <span class="hljs-comment">//e.printStackTrace();</span>          log.info(<span class="hljs-string">&quot;this is excepted Exception:&quot;</span> + e.getMessage());      &#125;      <span class="hljs-comment">// 直接抛出异常</span>      asyncMethod.fooE();      log.info(<span class="hljs-string">&quot;end call e&quot;</span>);      <span class="hljs-comment">//log.sleep(1000);</span>  &#125;</code></pre></div><ol start="3"><li>当超过线程词最大容量的时候，会抛出TaskRejectedException</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testRejectWithDeal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;       log.info(<span class="hljs-string">&quot;\n-----------------start testRejectWithDeal-----------------------&quot;</span>);       log.info(<span class="hljs-string">&quot;start add task&quot;</span>);       <span class="hljs-keyword">try</span> &#123;           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;               asyncMethod.asyncSleep3(i, <span class="hljs-number">1</span>);           &#125;       &#125; <span class="hljs-keyword">catch</span>(RejectedExecutionException e) &#123;           log.info(<span class="hljs-string">&quot;excepted exception:&quot;</span> + e.getMessage());       &#125;       log.info(<span class="hljs-string">&quot;finished add task&quot;</span>);       Thread.sleep(<span class="hljs-number">100</span> * <span class="hljs-number">1000</span>);   &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>async</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis与springboot整合</title>
    <link href="/2020/06/02/redis-spring/"/>
    <url>/2020/06/02/redis-spring/</url>
    
    <content type="html"><![CDATA[<h1 id="redis与springboot整合"><a href="#redis与springboot整合" class="headerlink" title="redis与springboot整合"></a>redis与springboot整合</h1><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- 对象池，使用redis时必须引入 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="yml-配置"><a href="#yml-配置" class="headerlink" title="yml 配置"></a>yml 配置</h3><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">redis:</span>    <span class="hljs-attr">host:</span> <span class="hljs-string">xxx</span>    <span class="hljs-comment"># 连接超时时间（记得添加单位，Duration）</span>    <span class="hljs-attr">timeout:</span> <span class="hljs-string">10000ms</span>    <span class="hljs-comment"># Redis默认情况下有16个分片，这里配置具体使用的分片</span>    <span class="hljs-comment"># database: 0</span>    <span class="hljs-attr">lettuce:</span>      <span class="hljs-attr">pool:</span>        <span class="hljs-comment"># 连接池最大连接数（使用负值表示没有限制） 默认 8</span>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">8</span>        <span class="hljs-comment"># 连接池最大阻塞等待时间（使用负值表示没有限制） 默认 -1</span>        <span class="hljs-attr">max-wait:</span> <span class="hljs-string">-1ms</span>        <span class="hljs-comment"># 连接池中的最大空闲连接 默认 8</span>        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">8</span>        <span class="hljs-comment"># 连接池中的最小空闲连接 默认 0</span>        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span>  <span class="hljs-attr">cache:</span>    <span class="hljs-comment"># 一般来说是不用配置的，Spring Cache 会根据依赖的包自行装配</span>    <span class="hljs-attr">type:</span> <span class="hljs-string">redis</span><span class="hljs-attr">logging:</span>  <span class="hljs-attr">level:</span>    <span class="hljs-attr">com.xkcoding:</span> <span class="hljs-string">debug</span></code></pre></div><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@AutoConfigureAfter(RedisAutoConfiguration.class)</span><span class="hljs-meta">@EnableCaching</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 默认情况下的模板只能支持RedisTemplate&lt;String, String&gt;，也就是只能存入字符串，因此支持序列化</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;String, Serializable&gt; <span class="hljs-title">redisCacheTemplate</span><span class="hljs-params">(LettuceConnectionFactory redisConnectionFactory)</span> </span>&#123;        RedisTemplate&lt;String, Serializable&gt; template = <span class="hljs-keyword">new</span> RedisTemplate&lt;&gt;();        template.setKeySerializer(<span class="hljs-keyword">new</span> StringRedisSerializer());        template.setValueSerializer(<span class="hljs-keyword">new</span> GenericJackson2JsonRedisSerializer());        template.setConnectionFactory(redisConnectionFactory);        <span class="hljs-keyword">return</span> template;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Strig ,Object</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> redisConnectionFactory</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title">redisCacheTemplate2</span><span class="hljs-params">(LettuceConnectionFactory redisConnectionFactory)</span> </span>&#123;        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate&lt;&gt;();        template.setKeySerializer(<span class="hljs-keyword">new</span> StringRedisSerializer());        template.setValueSerializer(<span class="hljs-keyword">new</span> GenericJackson2JsonRedisSerializer());        template.setConnectionFactory(redisConnectionFactory);        <span class="hljs-keyword">return</span> template;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 配置使用注解的时候缓存配置，默认是序列化反序列化的形式，加上此配置则为 json 形式</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CacheManager <span class="hljs-title">cacheManager</span><span class="hljs-params">(RedisConnectionFactory factory)</span> </span>&#123;        <span class="hljs-comment">// 配置序列化</span>        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig();        RedisCacheConfiguration redisCacheConfiguration = config.serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="hljs-keyword">new</span> StringRedisSerializer())).serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="hljs-keyword">new</span> GenericJackson2JsonRedisSerializer()));        <span class="hljs-keyword">return</span> RedisCacheManager.builder(factory).cacheDefaults(redisCacheConfiguration).build();    &#125;&#125;</code></pre></div><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>使用Spring 自动注入</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 默认模板</span><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<span class="hljs-comment">// 自定义模板</span><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> RedisTemplate&lt;String, Serializable&gt; redisCacheTemplate;<span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</code></pre></div><h2 id="Api使用"><a href="#Api使用" class="headerlink" title="Api使用"></a>Api使用</h2><h3 id="通用操作工具"><a href="#通用操作工具" class="headerlink" title="通用操作工具"></a>通用操作工具</h3><ol><li>常用的分布式锁加强版</li></ol><div class="hljs code-wrapper"><pre><code class="hljs Java">    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 最终加强分布式锁</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key key值</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 是否获取到</span><span class="hljs-comment">     */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lock</span><span class="hljs-params">(String key)</span> </span>&#123;        String lock = LOCK_PREFIX + key;        <span class="hljs-comment">// 利用lambda表达式</span>        <span class="hljs-keyword">return</span> (Boolean) redisTemplate.execute(<span class="hljs-keyword">new</span> RedisCallback&lt;Object&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">doInRedis</span><span class="hljs-params">(RedisConnection redisConnection)</span> <span class="hljs-keyword">throws</span> DataAccessException </span>&#123;                <span class="hljs-keyword">long</span> expireAt = System.currentTimeMillis() + LOCK_EXPIRE + <span class="hljs-number">1</span>;                Boolean acquire = redisConnection.setNX(lock.getBytes(), String.valueOf(expireAt).getBytes());                <span class="hljs-keyword">if</span> (acquire) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">byte</span>[] value = redisConnection.get(lock.getBytes());                    <span class="hljs-keyword">if</span> (Objects.nonNull(value) &amp;&amp; value.length &gt; <span class="hljs-number">0</span>) &#123;                        <span class="hljs-keyword">long</span> expireTime = Long.parseLong(<span class="hljs-keyword">new</span> String(value));                        <span class="hljs-keyword">if</span> (expireTime &lt; System.currentTimeMillis()) &#123;                            <span class="hljs-comment">// 如果锁已经过期</span>                            <span class="hljs-keyword">byte</span>[] oldValue = redisConnection.getSet(lock.getBytes(), String.valueOf(System.currentTimeMillis() + LOCK_EXPIRE + <span class="hljs-number">1</span>).getBytes());                            <span class="hljs-comment">// 防止死锁</span>                            <span class="hljs-keyword">return</span> Long.parseLong(<span class="hljs-keyword">new</span> String(oldValue)) &lt; System.currentTimeMillis();                        &#125;                    &#125;                &#125;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;);    &#125;</code></pre></div><ol start="2"><li> 删除锁</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 删除锁</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(String key)</span> </span>&#123;    redisTemplate.delete(key);&#125;</code></pre></div><ol start="3"><li>指定缓存失效时间</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 指定缓存失效时间</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> key 键</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> time 时间(秒)</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">expire</span><span class="hljs-params">(String key,<span class="hljs-keyword">long</span> time)</span></span>&#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">if</span>(time&gt;<span class="hljs-number">0</span>)&#123;            redisTemplate.expire(key, time, TimeUnit.SECONDS);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><ol start="4"><li>根据key 获取过期时间</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 根据key 获取过期时间</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> key 键 不能为null</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 时间(秒) 返回0代表为永久有效</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getExpire</span><span class="hljs-params">(String key)</span></span>&#123;    <span class="hljs-keyword">return</span> redisTemplate.getExpire(key,TimeUnit.SECONDS);&#125;</code></pre></div><ol start="5"><li>判断key是否存在</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 判断key是否存在</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> key 键</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> true 存在 false不存在</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasKey</span><span class="hljs-params">(String key)</span></span>&#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">return</span> redisTemplate.hasKey(key);    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><ol start="6"><li>删除缓存</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 删除缓存</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> key 可以传一个值 或多个</span><span class="hljs-comment"> */</span><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">del</span><span class="hljs-params">(String ... key)</span></span>&#123;    <span class="hljs-keyword">if</span>(key!=<span class="hljs-keyword">null</span>&amp;&amp;key.length&gt;<span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">if</span>(key.length==<span class="hljs-number">1</span>)&#123;            redisTemplate.delete(key[<span class="hljs-number">0</span>]);        &#125;<span class="hljs-keyword">else</span>&#123;            redisTemplate.delete(CollectionUtils.arrayToList(key));        &#125;    &#125;&#125;</code></pre></div><h3 id="String类型相关操作"><a href="#String类型相关操作" class="headerlink" title="String类型相关操作"></a>String类型相关操作</h3><ol><li>获取缓存</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 获取缓存</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> key 键</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 值</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">get</span><span class="hljs-params">(String key)</span></span>&#123;    <span class="hljs-keyword">return</span> key==<span class="hljs-keyword">null</span>?<span class="hljs-keyword">null</span>:redisTemplate.opsForValue().get(key);&#125;</code></pre></div><ol start="2"><li>获取缓存</li></ol><div class="hljs code-wrapper"><pre><code class="hljs dart"><span class="hljs-comment"><span class="markdown">/<span class="hljs-strong">**</span></span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> 获取缓存</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param key 键</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @return 值</span></span><span class="hljs-comment"><span class="markdown"> <span class="hljs-emphasis">*/</span></span></span>public <span class="hljs-built_in">Object</span> <span class="hljs-keyword">get</span>(<span class="hljs-built_in">String</span> key)&#123;    <span class="hljs-keyword">return</span> key==null?<span class="hljs-keyword">null</span>:redisTemplate.opsForValue().<span class="hljs-keyword">get</span>(key);&#125;</code></pre></div><ol start="3"><li>添加缓存</li></ol><div class="hljs code-wrapper"><pre><code class="hljs dart"><span class="hljs-comment"><span class="markdown">/<span class="hljs-strong">**</span></span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> 添加缓存</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param key 键</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param value 值</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @return true成功 false失败</span></span><span class="hljs-comment"><span class="markdown"> <span class="hljs-emphasis">*/</span></span></span>public boolean <span class="hljs-keyword">set</span>(<span class="hljs-built_in">String</span> key,<span class="hljs-built_in">Object</span> value) &#123;    <span class="hljs-keyword">try</span> &#123;        redisTemplate.opsForValue().<span class="hljs-keyword">set</span>(key, value);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><ol start="4"><li>添加缓存并设置过期时间</li></ol><div class="hljs code-wrapper"><pre><code class="hljs dart"><span class="hljs-comment"><span class="markdown">/<span class="hljs-strong">**</span></span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> 添加缓存并设置过期时间</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param key 键</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param value 值</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param time 时间(秒) time要大于0 如果time小于等于0 将设置无限期</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @return true成功 false 失败</span></span><span class="hljs-comment"><span class="markdown"> <span class="hljs-emphasis">*/</span></span></span>public boolean <span class="hljs-keyword">set</span>(<span class="hljs-built_in">String</span> key,<span class="hljs-built_in">Object</span> value,long time)&#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">if</span>(time&gt;<span class="hljs-number">0</span>)&#123;            redisTemplate.opsForValue().<span class="hljs-keyword">set</span>(key, value, time, TimeUnit.SECONDS);        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">set</span>(key, value);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><ol start="5"><li>递增操作</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 递增</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> key 键</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">incr</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> delta)</span></span>&#123;    <span class="hljs-keyword">if</span>(delta&lt;<span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;递增因子必须大于0&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> redisTemplate.opsForValue().increment(key, delta);&#125;</code></pre></div><ol start="6"><li>递减操作</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 递减</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> key 键</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">decr</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> delta)</span></span>&#123;    <span class="hljs-keyword">if</span>(delta&lt;<span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;递减因子必须大于0&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> redisTemplate.opsForValue().increment(key, -delta);&#125;</code></pre></div><h3 id="哈希类型相关操作"><a href="#哈希类型相关操作" class="headerlink" title="哈希类型相关操作"></a>哈希类型相关操作</h3><ol><li>设置一组Map的键值对</li></ol><div class="hljs code-wrapper"><pre><code class="hljs dart"><span class="hljs-comment"><span class="markdown">/<span class="hljs-strong">**</span></span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> HashGet</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param key 键 不能为null</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param item 项 不能为null</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @return 值</span></span><span class="hljs-comment"><span class="markdown"> <span class="hljs-emphasis">*/</span></span></span>public <span class="hljs-built_in">Object</span> hget(<span class="hljs-built_in">String</span> key,<span class="hljs-built_in">String</span> item)&#123;    <span class="hljs-keyword">return</span> redisTemplate.opsForHash().<span class="hljs-keyword">get</span>(key, item);&#125;</code></pre></div><ol start="2"><li>获取指定Map的所有键值对</li></ol><div class="hljs code-wrapper"><pre><code class="hljs dart"><span class="hljs-comment"><span class="markdown">/<span class="hljs-strong">**</span></span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> 获取hashKey对应的所有键值</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param key 键</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @return 对应的多个键值</span></span><span class="hljs-comment"><span class="markdown"> <span class="hljs-emphasis">*/</span></span></span>public <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">Object</span>,<span class="hljs-built_in">Object</span>&gt; hmget(<span class="hljs-built_in">String</span> key)&#123;    <span class="hljs-keyword">return</span> redisTemplate.opsForHash().entries(key);&#125;</code></pre></div><ol start="3"><li>添加一个Map类型值</li></ol><div class="hljs code-wrapper"><pre><code class="hljs dart"><span class="hljs-comment"><span class="markdown">/<span class="hljs-strong">**</span></span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> HashSet</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param key 键</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param map 对应多个键值</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @return true 成功 false 失败</span></span><span class="hljs-comment"><span class="markdown"> <span class="hljs-emphasis">*/</span></span></span>public boolean hmset(<span class="hljs-built_in">String</span> key, <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">Object</span>&gt; map)&#123;    <span class="hljs-keyword">try</span> &#123;        redisTemplate.opsForHash().putAll(key, map);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><ol start="4"><li>添加一个Map类型值并设置过期时间</li></ol><div class="hljs code-wrapper"><pre><code class="hljs dart"><span class="hljs-comment"><span class="markdown">/<span class="hljs-strong">**</span></span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> HashSet 并设置时间</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param key 键</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param map 对应多个键值</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param time 时间(秒)</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @return true成功 false失败</span></span><span class="hljs-comment"><span class="markdown"> <span class="hljs-emphasis">*/</span></span></span>public boolean hmset(<span class="hljs-built_in">String</span> key, <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">Object</span>&gt; map, long time)&#123;    <span class="hljs-keyword">try</span> &#123;        redisTemplate.opsForHash().putAll(key, map);        <span class="hljs-keyword">if</span>(time&gt;<span class="hljs-number">0</span>)&#123;            expire(key, time);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><ol start="5"><li>向一张hash表中放入数据,如果不存在将创建</li></ol><div class="hljs code-wrapper"><pre><code class="hljs dart"><span class="hljs-comment"><span class="markdown">/<span class="hljs-strong">**</span></span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> 向一张hash表中放入数据,如果不存在将创建</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param key 键</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param item 项</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param value 值</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @return true 成功 false失败</span></span><span class="hljs-comment"><span class="markdown"> <span class="hljs-emphasis">*/</span></span></span>public boolean hset(<span class="hljs-built_in">String</span> key,<span class="hljs-built_in">String</span> item,<span class="hljs-built_in">Object</span> value) &#123;    <span class="hljs-keyword">try</span> &#123;        redisTemplate.opsForHash().put(key, item, value);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><ol start="6"><li>向一张hash表中放入数据,如果不存在将创建并设置过期时间</li></ol><div class="hljs code-wrapper"><pre><code class="hljs dart"><span class="hljs-comment"><span class="markdown">/<span class="hljs-strong">**</span></span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> 向一张hash表中放入数据,如果不存在将创建</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param key 键</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param item 项</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param value 值</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param time 时间(秒)  注意:如果已存在的hash表有时间,这里将会替换原有的时间</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @return true 成功 false失败</span></span><span class="hljs-comment"><span class="markdown"> <span class="hljs-emphasis">*/</span></span></span>public boolean hset(<span class="hljs-built_in">String</span> key,<span class="hljs-built_in">String</span> item,<span class="hljs-built_in">Object</span> value,long time) &#123;    <span class="hljs-keyword">try</span> &#123;        redisTemplate.opsForHash().put(key, item, value);        <span class="hljs-keyword">if</span>(time&gt;<span class="hljs-number">0</span>)&#123;            expire(key, time);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><ol start="7"><li>删除hash表中的值</li></ol><div class="hljs code-wrapper"><pre><code class="hljs dart"><span class="hljs-comment"><span class="markdown">/<span class="hljs-strong">**</span></span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> 删除hash表中的值</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param key 键 不能为null</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param item 项 可以使多个 不能为null</span></span><span class="hljs-comment"><span class="markdown"> <span class="hljs-emphasis">*/</span></span></span>public <span class="hljs-keyword">void</span> hdel(<span class="hljs-built_in">String</span> key, <span class="hljs-built_in">Object</span>... item)&#123;    redisTemplate.opsForHash().delete(key,item);&#125;</code></pre></div><ol start="8"><li>判断hash表中是否有该项的值</li></ol><div class="hljs code-wrapper"><pre><code class="hljs dart"><span class="hljs-comment"><span class="markdown">/<span class="hljs-strong">**</span></span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> 判断hash表中是否有该项的值</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param key 键 不能为null</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param item 项 不能为null</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @return true 存在 false不存在</span></span><span class="hljs-comment"><span class="markdown"> <span class="hljs-emphasis">*/</span></span></span>public boolean hHasKey(<span class="hljs-built_in">String</span> key, <span class="hljs-built_in">String</span> item)&#123;    <span class="hljs-keyword">return</span> redisTemplate.opsForHash().hasKey(key, item);&#125;</code></pre></div><ol start="9"><li>递增，如果不存在,就会创建一个 并把新增后的值返回</li></ol><div class="hljs code-wrapper"><pre><code class="hljs dart"><span class="hljs-comment"><span class="markdown">/<span class="hljs-strong">**</span></span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> hash递增 如果不存在,就会创建一个 并把新增后的值返回</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param key 键</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param item 项</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param by 要增加几(大于0)</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @return</span></span><span class="hljs-comment"><span class="markdown"> <span class="hljs-emphasis">*/</span></span></span>public <span class="hljs-built_in">double</span> hincr(<span class="hljs-built_in">String</span> key, <span class="hljs-built_in">String</span> item,<span class="hljs-built_in">double</span> by)&#123;    <span class="hljs-keyword">return</span> redisTemplate.opsForHash().increment(key, item, by);&#125;</code></pre></div><ol start="10"><li>递减</li></ol><div class="hljs code-wrapper"><pre><code class="hljs dart"><span class="hljs-comment"><span class="markdown">/<span class="hljs-strong">**</span></span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> hash递减</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param key 键</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param item 项</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param by 要减少记(小于0)</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @return</span></span><span class="hljs-comment"><span class="markdown"> <span class="hljs-emphasis">*/</span></span></span>public <span class="hljs-built_in">double</span> hdecr(<span class="hljs-built_in">String</span> key, <span class="hljs-built_in">String</span> item,<span class="hljs-built_in">double</span> by)&#123;    <span class="hljs-keyword">return</span> redisTemplate.opsForHash().increment(key, item,-by);&#125;</code></pre></div><h3 id="SET类型相关操作"><a href="#SET类型相关操作" class="headerlink" title="SET类型相关操作"></a>SET类型相关操作</h3><ol><li>根据key获取Set中的所有值</li></ol><div class="hljs code-wrapper"><pre><code class="hljs dart"><span class="hljs-comment"><span class="markdown">/<span class="hljs-strong">**</span></span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> 根据key获取Set中的所有值</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param key 键</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @return</span></span><span class="hljs-comment"><span class="markdown"> <span class="hljs-emphasis">*/</span></span></span>public <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">Object</span>&gt; sGet(<span class="hljs-built_in">String</span> key)&#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">return</span> redisTemplate.opsForSet().members(key);    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre></div><ol start="2"><li>根据value从一个set中查询,是否存在</li></ol><div class="hljs code-wrapper"><pre><code class="hljs dart"><span class="hljs-comment"><span class="markdown">/<span class="hljs-strong">**</span></span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> 根据value从一个set中查询,是否存在</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param key 键</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param value 值</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @return true 存在 false不存在</span></span><span class="hljs-comment"><span class="markdown"> <span class="hljs-emphasis">*/</span></span></span>public boolean sHasKey(<span class="hljs-built_in">String</span> key,<span class="hljs-built_in">Object</span> value)&#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">return</span> redisTemplate.opsForSet().isMember(key, value);    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><ol start="3"><li>添加一个SET缓存</li></ol><div class="hljs code-wrapper"><pre><code class="hljs dart"><span class="hljs-comment"><span class="markdown">/<span class="hljs-strong">**</span></span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> 将数据放入set缓存</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param key 键</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param values 值 可以是多个</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @return 成功个数</span></span><span class="hljs-comment"><span class="markdown"> <span class="hljs-emphasis">*/</span></span></span>public long sSet(<span class="hljs-built_in">String</span> key, <span class="hljs-built_in">Object</span>...values) &#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">return</span> redisTemplate.opsForSet().add(key, values);    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;&#125;</code></pre></div><ol start="4"><li> 添加一个SET缓存并设置过期时间</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 将set数据放入缓存</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> key 键</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> time 时间(秒)</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> values 值 可以是多个</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 成功个数</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sSetAndTime</span><span class="hljs-params">(String key,<span class="hljs-keyword">long</span> time,Object...values)</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        Long count = redisTemplate.opsForSet().add(key, values);        <span class="hljs-keyword">if</span>(time&gt;<span class="hljs-number">0</span>) expire(key, time);        <span class="hljs-keyword">return</span> count;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;&#125;</code></pre></div><ol start="5"><li> 获取SET缓存的长度</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 获取set缓存的长度</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> key 键</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sGetSetSize</span><span class="hljs-params">(String key)</span></span>&#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">return</span> redisTemplate.opsForSet().size(key);    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;&#125;</code></pre></div><ol start="6"><li> 移除指定key的缓存</li></ol><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 移除值为value的</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> key 键</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> values 值 可以是多个</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 移除的个数</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> long setRemove(String key, Object ...values) &#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-built_in">Long</span> count = redisTemplate.opsForSet().remove(key, values);        <span class="hljs-keyword">return</span> count;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;&#125;</code></pre></div><h3 id="LIST类型相关操作"><a href="#LIST类型相关操作" class="headerlink" title="LIST类型相关操作"></a>LIST类型相关操作</h3><ol><li> 获取list缓存的内容</li></ol><div class="hljs code-wrapper"><pre><code class="hljs dart"><span class="hljs-comment"><span class="markdown">/<span class="hljs-strong">**</span></span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> 获取list缓存的内容</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param key 键</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param start 开始</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param end 结束  0 到 -1代表所有值</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @return</span></span><span class="hljs-comment"><span class="markdown"> <span class="hljs-emphasis">*/</span></span></span>public <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Object</span>&gt; lGet(<span class="hljs-built_in">String</span> key,long start, long end)&#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">return</span> redisTemplate.opsForList().range(key, start, end);    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre></div><ol start="2"><li>  获取list缓存的长度</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 获取list缓存的长度</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> key 键</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">lGetListSize</span><span class="hljs-params">(String key)</span></span>&#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">return</span> redisTemplate.opsForList().size(key);    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;&#125;</code></pre></div><ol start="3"><li>通过索引 获取list中的值</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 通过索引 获取list中的值</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> key 键</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> index 索引  index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">lGetIndex</span><span class="hljs-params">(String key,<span class="hljs-keyword">long</span> index)</span></span>&#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">return</span> redisTemplate.opsForList().index(key, index);    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre></div><ol start="4"><li>  将list放入缓存</li></ol><div class="hljs code-wrapper"><pre><code class="hljs dart"><span class="hljs-comment"><span class="markdown">/<span class="hljs-strong">**</span></span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> 将list放入缓存</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param key 键</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param value 值</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @return</span></span><span class="hljs-comment"><span class="markdown"> <span class="hljs-emphasis">*/</span></span></span>public boolean lSet(<span class="hljs-built_in">String</span> key, <span class="hljs-built_in">Object</span> value) &#123;    <span class="hljs-keyword">try</span> &#123;        redisTemplate.opsForList().rightPush(key, value);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><ol start="5"><li>将list放入缓存并设置过期时间</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 将list放入缓存</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> key 键</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> value 值</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> time 时间(秒)</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lSet</span><span class="hljs-params">(String key, Object value, <span class="hljs-keyword">long</span> time)</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        redisTemplate.opsForList().rightPush(key, value);        <span class="hljs-keyword">if</span> (time &gt; <span class="hljs-number">0</span>) expire(key, time);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><ol start="6"><li> 将list放入缓存</li></ol><div class="hljs code-wrapper"><pre><code class="hljs dart"><span class="hljs-comment"><span class="markdown">/<span class="hljs-strong">**</span></span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> 将list放入缓存</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param key 键</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param value 值</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @return</span></span><span class="hljs-comment"><span class="markdown"> <span class="hljs-emphasis">*/</span></span></span>public boolean lSet(<span class="hljs-built_in">String</span> key, <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Object</span>&gt; value) &#123;    <span class="hljs-keyword">try</span> &#123;        redisTemplate.opsForList().rightPushAll(key, value);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><ol start="7"><li> 将list放入缓存并设置过期时间</li></ol><div class="hljs code-wrapper"><pre><code class="hljs dart"><span class="hljs-comment"><span class="markdown">/<span class="hljs-strong">**</span></span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> 将list放入缓存</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param key 键</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param value 值</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param time 时间(秒)</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @return</span></span><span class="hljs-comment"><span class="markdown"> <span class="hljs-emphasis">*/</span></span></span>public boolean lSet(<span class="hljs-built_in">String</span> key, <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Object</span>&gt; value, long time) &#123;    <span class="hljs-keyword">try</span> &#123;        redisTemplate.opsForList().rightPushAll(key, value);        <span class="hljs-keyword">if</span> (time &gt; <span class="hljs-number">0</span>) expire(key, time);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><ol start="8"><li> 根据索引修改list中的某条数据</li></ol><div class="hljs code-wrapper"><pre><code class="hljs dart"><span class="hljs-comment"><span class="markdown">/<span class="hljs-strong">**</span></span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> 根据索引修改list中的某条数据</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param key 键</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param index 索引</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param value 值</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @return</span></span><span class="hljs-comment"><span class="markdown"> <span class="hljs-emphasis">*/</span></span></span>public boolean lUpdateIndex(<span class="hljs-built_in">String</span> key, long index,<span class="hljs-built_in">Object</span> value) &#123;    <span class="hljs-keyword">try</span> &#123;        redisTemplate.opsForList().<span class="hljs-keyword">set</span>(key, index, value);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><ol start="9"><li> 移除N个值为value</li></ol><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 移除N个值为value</span><span class="hljs-comment"> * @param key 键</span><span class="hljs-comment"> * @param count 移除多少个</span><span class="hljs-comment"> * @param value 值</span><span class="hljs-comment"> * @return 移除的个数</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> <span class="hljs-title">lRemove</span>(<span class="hljs-params">String key,<span class="hljs-built_in">long</span> count,Object <span class="hljs-keyword">value</span></span>)</span> &#123;    <span class="hljs-keyword">try</span> &#123;        Long <span class="hljs-keyword">remove</span> = redisTemplate.opsForList().<span class="hljs-keyword">remove</span>(key, count, <span class="hljs-keyword">value</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">remove</span>;    &#125; catch (Exception e) &#123;        e.printStackTrace();        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>middle-component</category>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>智慧教学辅助系统-作品简介</title>
    <link href="/2020/06/01/project-genesis-1/"/>
    <url>/2020/06/01/project-genesis-1/</url>
    
    <content type="html"><![CDATA[<h3 id="作品简介"><a href="#作品简介" class="headerlink" title="作品简介"></a>作品简介</h3><p>现阶段，智慧教育课堂教学仍是学校教育的主阵地，传统课堂教学过程中，教师讲授课程知识以知识点为基本元素，更多偏向将过于细琐和庞杂的知识点填鸭式的、照本宣科的讲授给大学生。</p><p>我们开发的智慧教学辅助系统，利用知识图谱的构建与调整功能帮助教师了解学生在教学过程中对某一知识点的掌握情况，及时调整教学内容和教学方法，合理分配，重新组合知识点教学，利用知识点识别学生状态检测功能优化学生与老师的学习与授课体验。整体的教务管理系统能提供一个高效且安全的学生数据采集处理平台，为学校及时了解学生近况和相关措施的有效实施作为有力保障。更能引导和推动教育内容和模式的变革。</p><p>不仅如此，本系统能合理的测评学生上课效果与教师授课评价，本系统更能帮助落实教育改革，利用人工智能改善教学方式，引导和推动教育内容和模式的变革。</p><p>现阶段，智慧教育课堂教学仍是学校教育的主阵地，传统课堂教学过程中，教师讲授课程知识以知识点为基本元素，更多偏向将过于细琐和庞杂的知识点填鸭式的、照本宣科的讲授给大学生，然而，搜索引擎的功能迅速发展，已能非常快捷方便地为大学生提供知识点的解读，教师教学时，应强调课程相关知识点的发现逻辑、关联机理和思维导引。学科知识图谱的构建，能有效的寻找关联逻辑，从而引导学生更加快速进入学习状态，引导思维发散，提高学习效率，达到预期教学质量和效果。学生的学习效果是反映教学质量的最直接表现，如何合理的进行教学效果测评，则成了更加重要的一环。利用人工智能识别分析反馈学生学习状态，更是推进人了工智能与教育的真融合。</p>]]></content>
    
    
    <categories>
      
      <category>genesis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>智慧教学辅助系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>智慧教学辅助系统-作品思路</title>
    <link href="/2020/06/01/project-genesis-2/"/>
    <url>/2020/06/01/project-genesis-2/</url>
    
    <content type="html"><![CDATA[<h4 id="1-目标与思路"><a href="#1-目标与思路" class="headerlink" title="\1. 目标与思路"></a>\1. 目标与思路</h4><p>   人工智能，知识图谱等前沿信息技术在教育中的应用，推动信息化教育进入高校，学科知识图谱将不断为智慧的教学提供知识功能，人工智能为智慧教育的发展提供了强有力的技术支持，推动人工智能与教育都应刻不容缓。</p><h4 id="2-传统教育"><a href="#2-传统教育" class="headerlink" title="\2. 传统教育"></a>\2. 传统教育</h4><p>   现阶段，智慧教育课堂教学仍是学校教育的主阵地，传统课堂教学过程中，教师讲授课程知识以知识点为基本元素，更多偏向将过于细琐和庞杂的知识点填鸭式的、照本宣科的讲授给大学生，</p><p><img src="/blog/img/genesis/%E7%8E%B0%E9%98%B6%E6%AE%B5.jpg"></p><p>然而，搜索引擎的功能迅速发展，已能非常快捷方便地为大学生提供知识点的解读，教师教学时，应强调课程相关知识点的发现逻辑、关联机理和思维导引。学科知识图谱的构建，能有效的寻找关联逻辑，从而引导学生更加快速进入学习状态，引导思维发散，提高学习效率，达到预期教学质量和效果。学生的学习效果是反映教学质量的最直接表现，如何合理的进行教学效果测评，则成了更加重要的一环。利用人工智能识别分析反馈学生学习状态，更是推进人了工智能与教育的真融合。</p><p> <img src="/blog/img/genesis/%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.jpg"></p><h4 id="3-系统构想"><a href="#3-系统构想" class="headerlink" title="\3. 系统构想"></a>\3. 系统构想</h4><p>   为此，我们开发了本系统，帮助教师了解学生在教学过程中对某一知识点的掌握情况，及时调整教学内容和教学方法，合理分配，重新组合知识点教学，构建和调整课程知识图谱，优化学生与老师的学习与授课体验。其次能提供一个高效且安全的学生数据采集处理平台，为学校及时了解学生近况和相关措施的有效实施作为有力保障。更能帮助落实教育改革，利用人工智能改善教学方式，引导和推动教育内容和模式的变革。</p><h4 id="4-系统实现"><a href="#4-系统实现" class="headerlink" title="\4. 系统实现"></a>\4. 系统实现</h4><p>   为实现这一目的，系统包含以下几个核心功能：分别是知识点设置、知识点识别、与定时学习效果可视化反馈和知识图谱构建与调整。</p><p><img src="/blog/img/genesis/%E7%8E%B0%E9%98%B6%E6%AE%B5.jpg"> </p><p>具体功能实现流程如下：首先，教师课前通过系统预先设置某课时的知识点，上课过程中有一台球机始终对准教师所用PPT屏幕，用于获取整堂课PPT播放情况视频；一台对准学生，用于获取学生的课堂全景信息。接着，课后系统将对拍摄视频处理后进行知识点关键字的识别，与教师预设的知识点进行比对，获取知识点对应的时间段。然后，对知识点出现的时间段进行学生状态检测，统计对应知识点学生的掌握情况并可视化展示。最后，在课程结束后，由系统根据知识点识别的时间线以及此时学生的听课状态构建调整知识图谱呈现。</p><p> <img src="/blog/img/genesis/%E5%8A%9F%E8%83%BD%E6%B5%81%E7%A8%8B.jpg"></p><p>\5. 技术架构</p><p>   为实现以上功能，本系统采用SSM架构。可分为数据层，服务层，应用层，和视图层。利用springboot+mybtis框架搭建基础应用后，引入自定义状态监测接口和Ocr文字识别，Face++人脸检测，ffmpeg图像处理，第三方服务接口完善系统架构，引入shiro权限管理框架帮助系统完善安全性与可靠性。</p><p> <img src="/blog/img/genesis/%E6%9E%84%E6%80%9D%E5%9B%BE.jpg"></p><p>\6. 系统成果</p><p>   最后我们实现包括教学系统以外，还完善了包括学生信息管理，角色管理，人员权限分配等一系列基本教务功能。操作日志和数据监控等安全性功能也一并所完善。在此过程中，我们解决了帮助教师知识点把控难易程度，更加理性的知识点组合，课程结束后的学习效果和授课评价数据可视化。构建和调整知识图谱，以帮助教师寻找知识点关联逻辑，从而引导学生更加快速进入学习状态，引导思维发散，提高学习效率，达到预期教学质量和效果。完成教学目标。</p><p>  <img src="/blog/img/genesis/%E5%8A%9F%E8%83%BD%E5%AE%8C%E6%88%90.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>genesis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>智慧教学辅助系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>reply</title>
    <link href="/2020/06/01/project-genesis-reply/"/>
    <url>/2020/06/01/project-genesis-reply/</url>
    
    <content type="html"><![CDATA[<h3 id="1-如何将教务系统信息导入系统？怎么保证这些信息的安全？"><a href="#1-如何将教务系统信息导入系统？怎么保证这些信息的安全？" class="headerlink" title="1.如何将教务系统信息导入系统？怎么保证这些信息的安全？"></a>1.如何将教务系统信息导入系统？怎么保证这些信息的安全？</h3><p>我们采用Excel模板解析导入, 并使用apache的poi解析工具, 解析上传的数据并存入数据库</p><ul><li>数据库存储密码等信息采用sha256加密，保证信息安全。</li><li>项目部署的服务器位于校大数据中心，使用内网访问，安全性高。外部人员需要使用内部人员提供的vpn账号才能使用。</li><li>云数据库符合企业级安全标准，高效防御 SQL 注入、暴力破解等数据库攻击行为，极大减少用户因数据库攻击带来的业务中断和损失。</li><li>每日自动备份数据，确保数据存储安全。</li></ul><h3 id="2-使用人脸识别技术实现人脸点名，进行人脸检测，那么你们使用的人脸检测技术是什么？"><a href="#2-使用人脸识别技术实现人脸点名，进行人脸检测，那么你们使用的人脸检测技术是什么？" class="headerlink" title="2. 使用人脸识别技术实现人脸点名，进行人脸检测，那么你们使用的人脸检测技术是什么？"></a>2. 使用人脸识别技术实现人脸点名，进行人脸检测，那么你们使用的人脸检测技术是什么？</h3><ul><li>我们使用的是Face++的开放平台</li><li>它是一个免费的开放平台,开发者可利用试用的appkey调用所有服务,例如人脸识别服务</li><li>传入参数是base64编码后的图片，返回是一串json，接收后解析为java的实体，获取人脸信息</li></ul><h3 id="3-Face-流程，怎么调用的？"><a href="#3-Face-流程，怎么调用的？" class="headerlink" title="3. Face++流程，怎么调用的？"></a>3. Face++流程，怎么调用的？</h3><ul><li>face++对用户透明，通过官网提供的HttpUtils类，利用post方法，直接调用。返回json数据，经解析为java对象。</li></ul><h3 id="4-视频-数据来源？过程"><a href="#4-视频-数据来源？过程" class="headerlink" title="4. 视频/数据来源？过程"></a>4. 视频/数据来源？过程</h3><ul><li>从摄像头拍摄后的视频流（tcp流）处理后去掉配置信息，留下视频数据，拼接后成为多少秒的视频，然后保存到服务器的文件夹里。然后前端通过url接收到视频，是一个有延时的实时。更好的处理是视频传到前端进行处理，然后在网页上显示。保存到话就是前端的视频流保存到本地。</li><li>预期的实时显示，是把程序写到摄像头里。或者做一个中间的硬件设备，由他专门处理，就是<strong>边缘计算</strong>。</li></ul><h3 id="5-如何评定学生的听课质量？数据可视化是用什么实现的？"><a href="#5-如何评定学生的听课质量？数据可视化是用什么实现的？" class="headerlink" title="5. 如何评定学生的听课质量？数据可视化是用什么实现的？"></a>5. 如何评定学生的听课质量？数据可视化是用什么实现的？</h3><ul><li>课程开始后，每隔五分钟拍摄学生当前时刻的照片，利用Face++中人体抠图的功能将图片中的所有学生分割开来，依次调用状态检测模型，返回学生们当前时刻的状态，并将数据存入数据库中。</li><li>数据可视化为前端从后端得到数据库中的数据，利用百度的Echars数据图表可视化工具多方面展示,比如学生上课状态,教师知识点范围等。</li></ul><h3 id="6-是怎么使用权限管理模块实现增删角色并赋权的？"><a href="#6-是怎么使用权限管理模块实现增删角色并赋权的？" class="headerlink" title="6.是怎么使用权限管理模块实现增删角色并赋权的？"></a>6.是怎么使用权限管理模块实现增删角色并赋权的？</h3><ul><li>用户在登录系统时，会将用户的账号和密码传递给shiro框架自带的subject类的实例对象并将该对象以参数的形式传递给shiro。</li><li>shiro将其与数据库中的用户表中信息进行比对验证该用户身份，验证成功后从数据库中获得该用户的权限信息。为了减少系统开销，对齐进行权限缓存。通过shiro与thymeleaf整合的依赖对前端菜单进行动态渲染展示该用户对应权限的功能。</li></ul><h3 id="7-模型是如何调用的"><a href="#7-模型是如何调用的" class="headerlink" title="7. 模型是如何调用的"></a>7. 模型是如何调用的</h3><ol><li>python模型保存成Py文件</li><li>在Tensorflow官网下载对应的java jar包(libtensorflow-1.12.0.jar)和在运行目录下添加tensorflow_ini.dll文件</li><li>python在定义输入张量(输入数据，即图片)时，指定参数</li><li>在java中传入参数</li><li>将模型返回的数据结果</li><li>得到输出张量把输出张量转化为java的float数组得到的数组里，一共有四个值（分别代表四种状态的概率）取其中概率最大的一个，当作学生的状态</li></ol><h3 id="8-摄像头无法远程控制的原因"><a href="#8-摄像头无法远程控制的原因" class="headerlink" title="8.摄像头无法远程控制的原因"></a>8.摄像头无法远程控制的原因</h3><ul><li>我们部署的项目在服务部在学校的云计算中心的(8G， 4核， 100G)的虚拟机</li><li>摄像头部在107实验室，同在校园网内，所以程序可以控制摄像头</li><li>但是现在外网不能访问到校园网的虚拟机，需要网络中心进行公网的地址映射。指导老师跟网络中心联系时候才知道要走审批流程，到目前为止还没审批下来。</li><li>这也是无法现场展示的原因</li></ul><h3 id="9-摄像头控制程序如何实现？"><a href="#9-摄像头控制程序如何实现？" class="headerlink" title="9.摄像头控制程序如何实现？"></a>9.摄像头控制程序如何实现？</h3><ol><li>通过ip地址和端口号连接摄像头</li><li>根据命令行输入的字符串，调用对应的程序接口</li><li>断开连接，释放资源</li></ol><h3 id="10-为何无法显示摄像头实况？"><a href="#10-为何无法显示摄像头实况？" class="headerlink" title="10.为何无法显示摄像头实况？"></a>10.为何无法显示摄像头实况？</h3><ul><li>摄像头厂商提供的接口都是windows平台的接口，项目是通过java调用exe文件，但是服务器是Linux的，无法运行exe文件。</li><li>后期可以利用opencv 获取摄像推流的方式展示实时数据</li></ul><h3 id="11-ocr识别原理"><a href="#11-ocr识别原理" class="headerlink" title="11.ocr识别原理"></a>11.ocr识别原理</h3><ol><li><p>版面分析：把一整张图像拆分为行；便于后面行处理。在图像没有明显倾斜扭曲时，可以先使用**笔画等宽算法(swt算法)**把非笔迹的像素过滤掉，再使用投影直方图进行分行。</p></li><li><p>使用<strong>连通域分析或者直方图投影</strong>进行行拆分为字符</p></li><li><p>识别字符： 识别字符就在于生成样本+选择识别算法，由于时间因素，我们采用了百度已经训练好是文字识别算法</p></li><li><p>识别后的人工矫正</p></li></ol><h3 id="12-状态检测模型训练"><a href="#12-状态检测模型训练" class="headerlink" title="12. 状态检测模型训练"></a>12. 状态检测模型训练</h3><ul><li>制作数据集。实验视频是使用1920（水平）×1080（垂直）的球机采集的。拍摄对象共60名，让学生在座位上分别做出认真听课、打瞌睡、玩手机、发呆的动作，每个动作持续4-6秒，在动作间切换3次，获取18s-24s的视频。将所有视频每秒抽取20帧，将得到的图片在进行人工标注状态，得到符合条件的2500张图片。</li><li>选取模型训练方法。考虑到VGG16的拓展性强，容易迁移到其他数据图片上，同时由于<strong>其使用小卷积核和更深的网络进行的正则化</strong>，使用与训练得到的数据进行参数的初始化，VGG16网络较其他网络有更高的准确性和更快的速度，因此，选用VGG16对学生状态检测模型进行训练，是一个明智的选择。</li><li>将数据集放入VGG16网络进行训练，最终训练出学生状态检测模型，经测试，正确率能够达到89.34%。训练出的模型只需将某个学生的状态图输入，即可获取该学生此时刻对应的上课状态。</li><li>但是，由于我们现在是单人单图的训练，并且在人体抠图的过程中还是存在着遮挡的现象等问题，所以在实际应用中正确率往往达不到这么高，但我们也会积极的进行改进。</li></ul><h3 id="13-知识图谱构建"><a href="#13-知识图谱构建" class="headerlink" title="13. 知识图谱构建"></a>13. 知识图谱构建</h3><ol><li>首先需信息抽来有教师预设的知识点自动化信息地从半结构化和无结构数据中抽取实体、关系以及实体属性等结构化信息。 </li><li>然后这些繁杂的信息中在获取实体、关系与属性等知识要素后，经过知识融合，消除实体<strong>指称项</strong>与<strong>实体对象之间</strong>的歧义，得到一系列基本的事实表达。然而事实本身并不等于知识。要想最终获得结构化，网络化的知识体系，还需要进一步的人工优化去重。</li><li>然后将各个父子节点及同级节点之间的联系导入xml数据，Echars关系图利用xml的数据关系生成可视化展示，最终达到演示视频所展示的可视化效果</li><li>我们之后还会有需教师的个人理解和相关资料后的进一步改善,也会根据重新生成的知识图谱,进一步的引导教师挖掘知识点之间的联系.</li></ol><h3 id="14-可视化展示那些方面"><a href="#14-可视化展示那些方面" class="headerlink" title="14. 可视化展示那些方面"></a>14. 可视化展示那些方面</h3><ul><li>学生最近一次课程学生状态统计</li><li>不同班级对不同知识点组合所产生学生学习状态的影响</li><li>最近一周的知识点分布</li><li>最近一周知识点难易程度分配</li></ul><h3 id="15-是否已经投入使用"><a href="#15-是否已经投入使用" class="headerlink" title="15. 是否已经投入使用"></a>15. 是否已经投入使用</h3><ul><li>我们在项目完成后经学生同意后，对参与的志愿者进行了一系列的实验</li><li>在学校的监管下有部分班级已经开始用</li><li>并产生了一系列的结果数据集用于展示 </li><li>但由于现阶段我们服务器负载较小只能小范围进行测试使用</li><li>待后期系统更加完善后会进行响应的服务器扩容,来进行更大范围的测试</li></ul><h3 id="16-运行过程中出现的问题"><a href="#16-运行过程中出现的问题" class="headerlink" title="16.运行过程中出现的问题"></a>16.运行过程中出现的问题</h3><ul><li><strong>Ocr识别中对于视频知识点出现误差</strong>,我们使用ocr对同一段时间进行比对两次, 如果相差10秒以内,则进行第三次比对.对第三次识别的结果取平均值</li></ul><h3 id="17-对于学生隐私的问题-是否考虑过学生的感受"><a href="#17-对于学生隐私的问题-是否考虑过学生的感受" class="headerlink" title="17. 对于学生隐私的问题,是否考虑过学生的感受"></a>17. 对于学生隐私的问题,是否考虑过学生的感受</h3><ul><li>我们再使用本系统是已争取学生同意</li><li>我们使用权限控制模块,已保证教师只能查看数据的识别结果集,而不能针对单个学生的结果展示,对于学生的学习状态由短信单独通知.</li><li>我们拍摄所产生的数据在运算完成后进行实时的删除</li><li>系统部署于学校内网中,识别产生数据结果集保存在腾讯云数据库中</li><li>云数据库符合企业级安全标准，高效防御 SQL 注入、暴力破解等数据库攻击行为，极大减少用户因数据库攻击带来的业务中断和损失。</li><li>每日自动备份数据，确保数据存储安全。</li></ul><h3 id="18-项目优势"><a href="#18-项目优势" class="headerlink" title="18. 项目优势"></a>18. 项目优势</h3><ul><li>本系统能够帮助教师了解学生在教学过程中对某一知识点的掌握情况，及时调整教学内容和教学方法，合理分配，重新组合知识点教学，构建和调整课程知识图谱，优化学生与老师的学习与授课体验。其次能提供一个高效且安全的学生数据采集处理平台，为学校及时了解学生近况和相关措施的有效实施作为有力保障。更能帮助落实教育改革，利用人工智能改善教学方式，引导和推动教育内容和模式的变革</li></ul><h3 id="19-人脸识别过程"><a href="#19-人脸识别过程" class="headerlink" title="19. 人脸识别过程"></a>19. 人脸识别过程</h3><ul><li><p>(1)首先建立人脸的面像档案。即用摄像机采集单位人员的人脸的面像文件或取他们的照片形成面像文件，并将这些面像文件生成面纹(Faceprint)编码贮存起来。</p></li><li><p>(2)获取当前的人体面像。即用摄像机捕捉的当前出入人员的面像，或取照片输入，并将当前的面像文件生成面纹编码。</p></li><li><p>(3)用当前的面纹编码与档案库存的比对。即将当前的面像的面纹编码与档案库存中的面纹编码进行检索比对。上述的“面纹编码”方式是根据人脸脸部的本质特征和开头来工作的。这种面纹编码可以抵抗光线、皮肤色调、面部毛发、发型、眼镜、表情和姿态的变化，具有强大的可靠性，从而使它可以从百万人中精确地辨认出某个人。人脸的识别过程，利用普通的图像处理设备就能自动、连续、实时地完成。</p></li></ul><h3 id="20-用到很多第三方接口-为什么不自己创建接口"><a href="#20-用到很多第三方接口-为什么不自己创建接口" class="headerlink" title="20. 用到很多第三方接口,为什么不自己创建接口"></a>20. 用到很多第三方接口,为什么不自己创建接口</h3><ul><li>因为我们再设计项目之初想快速构建系统架构,从而选择了较多的第三方服务完善系统架构</li><li>在选择接口的同时,我们也对相关接口进行了一个同等级测试,包括性能,速度等方面,最终选择了现阶段的相关接口</li><li>再后期构建完善后,会引入openCV等开源框架,自定义相关人脸识别接口,从而降低相关成本</li></ul><h3 id="21-项目涉及范围太大"><a href="#21-项目涉及范围太大" class="headerlink" title="21. 项目涉及范围太大"></a>21. 项目涉及范围太大</h3><ul><li>我们在设计项目之初,只是为了想通过教师讲授的知识点构建知识图谱,从而帮助老师更好的教学,但在逐步的项目开发中,我们发现要实现这一功能需要更多的数据前提,包括知识点识别,学生状态采集等多方面内容,由此我们的项目范围也是逐步扩大,最终形成了一个相对完善的项目.来达到我们的需求</li><li>我们的项目是一个循序渐进的过程，学生状态检测功能能够有效提取困难知识点分布数据，有助于完成知识点检测，而知识点检测功能是知识图谱功能的前提，通过知识点检测功能得到的信息以及教师预设的知识点自动化信息来知识融合并加工，最终实现知识图谱功能</li></ul>]]></content>
    
    
    <categories>
      
      <category>genesis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>reply</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Aop切面编程</title>
    <link href="/2020/06/01/spring-aop/"/>
    <url>/2020/06/01/spring-aop/</url>
    
    <content type="html"><![CDATA[<h3 id="spring的aop与springboot整合-动态代理"><a href="#spring的aop与springboot整合-动态代理" class="headerlink" title="spring的aop与springboot整合   动态代理"></a>spring的aop与springboot整合   <a href="">动态代理</a></h3><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="设置切点"><a href="#设置切点" class="headerlink" title="设置切点"></a>设置切点</h3><ul><li>在类上注解@Aspect</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 切入点</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Pointcut(&quot;execution(public * com.xkcoding.log.aop.controller.*Controller.*(..))&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">()</span> </span>&#123;&#125;</code></pre></div><h3 id="通知方法"><a href="#通知方法" class="headerlink" title="通知方法"></a>通知方法</h3><ol><li>前置通知</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 前置操作</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> point 切入点</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Before(&quot;log()&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeLog</span><span class="hljs-params">(JoinPoint point)</span> </span>&#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         *  String toString();         //连接点所在位置的相关信息</span><span class="hljs-comment">         *    String toShortString();     //连接点所在位置的简短相关信息</span><span class="hljs-comment">         *    String toLongString();     //连接点所在位置的全部相关信息</span><span class="hljs-comment">         *    Object getThis();         //返回AOP代理对象，也就是com.sun.proxy.$Proxy18</span><span class="hljs-comment">         *    Object getTarget();       //返回目标对象，一般我们都需要它或者（也就是定义方法的接口或类，为什么会是接口呢？这主要是在目标对象本身是动态代理的情况下，例如Mapper。所以返回的是定义方法的对象如aoptest.daoimpl.GoodDaoImpl或com.b.base.BaseMapper&lt;T, E, PK&gt;）</span><span class="hljs-comment">         *    Object[] getArgs();       //返回被通知方法参数列表</span><span class="hljs-comment">         *    Signature getSignature();  //返回当前连接点签名  其getName()方法返回方法的FQN，如void aoptest.dao.GoodDao.delete()或com.b.base.BaseMapper.insert(T)(需要注意的是，很多时候我们定义了子类继承父类的时候，我们希望拿到基于子类的FQN，这直接可拿不到，要依赖于AopUtils.getTargetClass(point.getTarget())获取原始代理对象，下面会详细讲解)</span><span class="hljs-comment">         *    SourceLocation getSourceLocation();//返回连接点方法所在类文件中的位置</span><span class="hljs-comment">         *    String getKind();        //连接点类型</span><span class="hljs-comment">         *    StaticPart getStaticPart(); //返回连接点静态部分</span><span class="hljs-comment">         */</span>        JoinPoint.StaticPart staticPart = point.getStaticPart();        <span class="hljs-comment">/**</span><span class="hljs-comment">         *  Signature getSignature();    //返回当前连接点签名</span><span class="hljs-comment">         *    String getKind();          //连接点类型</span><span class="hljs-comment">         *    int getId();               //唯一标识</span><span class="hljs-comment">         *    String toString();         //连接点所在位置的相关信息</span><span class="hljs-comment">         *    String toShortString();     //连接点所在位置的简短相关信息</span><span class="hljs-comment">         *    String toLongString();     //连接点所在位置的全部相关信息</span><span class="hljs-comment">         */</span>        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();HttpServletRequest request = Objects.requireNonNull(attributes).getRequest();log.info(<span class="hljs-string">&quot;【请求 URL】：&#123;&#125;&quot;</span>, request.getRequestURL());log.info(<span class="hljs-string">&quot;【请求 IP】：&#123;&#125;&quot;</span>, request.getRemoteAddr());log.info(<span class="hljs-string">&quot;【请求类名】：&#123;&#125;，【请求方法名】：&#123;&#125;&quot;</span>, point.getSignature().getDeclaringTypeName(), point.getSignature().getName());Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();log.info(<span class="hljs-string">&quot;【请求参数】：&#123;&#125;，&quot;</span>, JSONUtil.toJsonStr(parameterMap));Long start = System.currentTimeMillis();request.setAttribute(START_TIME, start);&#125;</code></pre></div><ol start="2"><li>环绕通知</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 环绕操作</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> point 切入点</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 原方法返回值</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> Throwable 异常信息</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Around(&quot;log()&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">aroundLog</span><span class="hljs-params">(ProceedingJoinPoint point)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        String s = point.toLongString();        log.info(<span class="hljs-string">&quot;【参数值】：&#123;&#125;&quot;</span>, JSONUtil.toJsonStr(s));Object result = point.proceed();log.info(<span class="hljs-string">&quot;【返回值】：&#123;&#125;&quot;</span>, JSONUtil.toJsonStr(result));<span class="hljs-keyword">return</span> result;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs tex">/** * 环绕通知 ProceedingJoinPoint 执行proceed方法的作用是让目标方法执行，这也是环绕通知和前置、后置通知方法的一个最大区别。 *  Proceedingjoinpoint 继承了 JoinPoint 。是在JoinPoint的基础上暴露出 proceed 这个方法。proceed很重要，这个是aop代理链执行的方法。 */</code></pre></div><ol start="3"><li>后置通知</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 后置操作</span><span class="hljs-comment"> */</span><span class="hljs-meta">@AfterReturning(&quot;log()&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterReturning</span><span class="hljs-params">()</span> </span>&#123;ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();HttpServletRequest request = Objects.requireNonNull(attributes).getRequest();        HttpServletResponse response = Objects.requireNonNull(attributes).getResponse();        Long start = (Long) request.getAttribute(START_TIME);Long end = System.currentTimeMillis();log.info(<span class="hljs-string">&quot;【请求耗时】：&#123;&#125;毫秒&quot;</span>, end - start);String header = request.getHeader(<span class="hljs-string">&quot;User-Agent&quot;</span>);UserAgent userAgent = UserAgent.parseUserAgentString(header);log.info(<span class="hljs-string">&quot;【浏览器类型】：&#123;&#125;，【操作系统】：&#123;&#125;，【原始User-Agent】：&#123;&#125;&quot;</span>, userAgent.getBrowser().toString(), userAgent.getOperatingSystem().toString(), header);&#125;</code></pre></div><h3 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//返回客户端在此次请求中发送的所有Cookie对象。</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Cookie[] getCookies();    <span class="hljs-comment">//返回名字为name的请求报头的值。如果请求中没有包含指定名字的报头，这个方法返回null。</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getHeader</span><span class="hljs-params">(String paramString)</span></span>;    <span class="hljs-comment">//返回名字为name的请求报头所有的值的枚举集合。</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Enumeration&lt;String&gt; <span class="hljs-title">getHeaders</span><span class="hljs-params">(String paramString)</span></span>;    <span class="hljs-comment">//返回此次请求中包含的所有报头名字的枚举集合。</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Enumeration&lt;String&gt; <span class="hljs-title">getHeaderNames</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//返回此次请求所使用的HTTP方法的名字，例如，GET、POST或PUT。</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getMethod</span><span class="hljs-params">()</span></span>;        <span class="hljs-comment">//返回与客户端发送的请求URL相联系的额外的路径信息。额外的路径信息是跟在Servlet的路径之后、查询字符串之前的路径，并以斜杠（/）字符开始。</span>    <span class="hljs-comment">//例如，假定在web.xml文件中MyServlet类映射的URL是：/myservlet/*，用户请求的URL是：http://localhost:8080/ ch02/myservlet/test，</span>    <span class="hljs-comment">//当我们在HttpServletRequest对象上调用getPathInfo()时，该方法将返回/test。如果没有额外的路径信息，getPathInfo()方法将返回null。</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getPathInfo</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//将额外的路径信息转换为真实的路径。例如，在上面的例子中假定ch02 Web应用程序位于D:\OpenSource\apache-tomcat-6.0.16\webapps\ch02目录，</span>    <span class="hljs-comment">//当用户请求http://localhost: 8080/ch02/myservlet/test时，在请求对象上调用getPathTranslated()方法将返回</span>    <span class="hljs-comment">//D:\OpenSource\apache-tomcat-6.0.16\webapps\ch02\test。</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getPathTranslated</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//返回请求URI中表示请求上下文的部分，上下文路径是请求URI的开始部分。上下文路径总是以斜杠（/）开头，但结束没有斜杠（/）。在默认（根）上下文中，这个方法返回空字符串&quot;&quot;。</span>    <span class="hljs-comment">//例如，请求URI为“/sample/test”，调用该方法返回路径为“/sample”。</span>    <span class="hljs-comment">//示例： http://192.168.10.145:8888/ServletDemo/hello——&gt;ServletDemo</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getContextPath</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//返回请求URL中在路径后的查询字符串。如果在URL中没有查询字符串，该方法返回null。例如，有如下的请求URL：</span>    <span class="hljs-comment">//http://localhost:8080/ch02/logon.jsp?action=logon调用getQueryString()方法将返回action=logon。</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getQueryString</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//返回请求URL中从主机名到查询字符串之间的部分。例如：</span>    <span class="hljs-comment">//POST:     /some/path.html HTTP/1.1   /some/path.html</span>    <span class="hljs-comment">//GET:     http://foo.bar/a.html HTTP/1.0  /a.html</span>    <span class="hljs-comment">//HEAD:     /xyz?a=b HTTP/1.1    /xyz</span>    <span class="hljs-comment">//示例： http://192.168.10.145:8888/ServletDemo/hello——&gt;ServletDemo/hello</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getRequestURI</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//重新构造客户端用于发起请求的URL。返回的URL包括了协议、服务器的名字、端口号和服务器的路径，但是不包括查询字符串参数。</span>    <span class="hljs-comment">//要注意的是，如果请求使用RequestDispatcher.forward(ServletRequest, ServletResponse)方法被转发到另一个Servlet中，</span>    <span class="hljs-comment">//那么你在这个Servlet中调用getRequestURL()，得到的将是获取RequestDispatcher对象时使用的URL，而不是原始的请求URL。</span>    <span class="hljs-comment">//示例： http://192.168.10.145:8888/ServletDemo/hello——&gt;http://192.168.10.145:8888/ServletDemo/hello</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> StringBuffer <span class="hljs-title">getRequestURL</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//返回请求URI中调用Servlet的部分。这部分的路径以斜杠（/）开始，包括了Servlet的名字或者路径，但是不包括额外的路径信息和查询字符串。</span>    <span class="hljs-comment">//例如，假定在web.xml文件中MyServlet类映射的URL是：/myservlet/*，用户请求的URL是：http://localhost:8080/ ch02/myservlet/test，</span>    <span class="hljs-comment">//当我们在HttpServletRequest对象上调用getServletPath ()时，该方法将返回/myservlet。如果用于处理请求的Servlet与URL样式“/*”相匹配，那么这个方法将返回空字符串（&quot;&quot;）。</span>    <span class="hljs-comment">//示例： http://192.168.10.145:8888/ServletDemo/hello——&gt;hello</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getServletPath</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//返回和此次请求相关联的Session，如果没有给客户端分配Session，而create参数为true，</span>    <span class="hljs-comment">//则创建一个新的Session。如果create参数为false，而此次请求没有一个有效的HttpSession，则返回null。</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> HttpSession <span class="hljs-title">getSession</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> create)</span></span>;    <span class="hljs-comment">//返回和此次请求相关联的Session，如果没有给客户端分配Session，则创建一个新的Session。</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> HttpSession <span class="hljs-title">getSession</span><span class="hljs-params">()</span></span>;</code></pre></div><h3 id="HttpServletResponse"><a href="#HttpServletResponse" class="headerlink" title="HttpServletResponse"></a>HttpServletResponse</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//增加一个Cookie到响应中。这个方法可以被多次调用，用于设置多个Cookie。</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCookie</span><span class="hljs-params">(Cookie paramCookie)</span></span>;<span class="hljs-comment">//判断以name为名字的响应报头是否已经设置。</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsHeader</span><span class="hljs-params">(String name)</span></span>;<span class="hljs-comment">//使用Session ID对指定的url进行编码。如果该url不需要编码，则返回未改变的url。</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">encodeURL</span><span class="hljs-params">(String paramString)</span></span>;<span class="hljs-comment">//使用Session ID对用于重定向的url进行编码，以便用于sendRedirect()方法中。如果该url不需要编码，则返回未改变的url。</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">encodeRedirectURL</span><span class="hljs-params">(String paramString)</span></span>;<span class="hljs-comment">//使用指定的状态代码发送一个错误响应到客户端。服务器默认会创建一个包含了指定消息的服务器端错误页面作为响应，</span><span class="hljs-comment">//设置内容类型为“text/html”。如果Web应用程序已经声明了对应于指定状态代码的错误页面，则服务器会将这个页面发送给客户端，而不理会参数msg指定的错误消息。</span><span class="hljs-comment">//如果响应已经被提交，这个方法将抛出IllegalStateException异常。</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendError</span><span class="hljs-params">(<span class="hljs-keyword">int</span> paramInt, String msg)</span> <span class="hljs-keyword">throws</span> IOException</span>;<span class="hljs-comment">//使用参数sc表示的状态代码发送一个错误响应到客户端，同时清除缓存。如果响应已经被提交，这个方法将抛出IllegalStateException异常。</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendError</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sc)</span> <span class="hljs-keyword">throws</span> IOException</span>;<span class="hljs-comment">//发送一个临时的重定向响应到客户端，让客户端访问新的URL。如果指定的位置是相对URL，Servlet容器在发送响应到客户端之前，必须将相对URL转换为绝对URL。</span><span class="hljs-comment">//如果响应已经被提交，这个方法将抛出IllegalStateException异常。</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendRedirect</span><span class="hljs-params">(String paramString)</span> <span class="hljs-keyword">throws</span> IOException</span>;<span class="hljs-comment">//用给出的name和value，设置一个响应报头。如果这个报头已经被设置，新的值将覆盖先前的值。</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeader</span><span class="hljs-params">(String paramString1, String paramString2)</span></span>;<span class="hljs-comment">//用给出的name和value，增加一个响应报头到响应中。</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addHeader</span><span class="hljs-params">(String name, String value)</span></span>;<span class="hljs-comment">//为响应设置状态代码。</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStatus</span><span class="hljs-params">(<span class="hljs-keyword">int</span> paramInt)</span></span>;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>aop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot + LogBack 配置</title>
    <link href="/2020/05/31/spring-logback/"/>
    <url>/2020/05/31/spring-logback/</url>
    
    <content type="html"><![CDATA[<h3 id="SpringBoot-LogBack-配置"><a href="#SpringBoot-LogBack-配置" class="headerlink" title="SpringBoot + LogBack 配置"></a>SpringBoot + LogBack 配置</h3><ol><li>首先可使用Spring 默认依赖,其他maven项目可引入</li></ol><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/ch.qos.logback/logback-classic --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.0-alpha5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><ol start="2"><li>使用</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringBootDemoLogbackApplication</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(SpringBootDemoLogbackApplication.class);<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;ConfigurableApplicationContext context = SpringApplication.run(SpringBootDemoLogbackApplication.class, args);<span class="hljs-keyword">int</span> length = context.getBeanDefinitionNames().length;log.trace(<span class="hljs-string">&quot;Spring boot启动初始化了 &#123;&#125; 个 Bean&quot;</span>, length);log.debug(<span class="hljs-string">&quot;Spring boot启动初始化了 &#123;&#125; 个 Bean&quot;</span>, length);log.info(<span class="hljs-string">&quot;Spring boot启动初始化了 &#123;&#125; 个 Bean&quot;</span>, length);log.warn(<span class="hljs-string">&quot;Spring boot启动初始化了 &#123;&#125; 个 Bean&quot;</span>, length);log.error(<span class="hljs-string">&quot;Spring boot启动初始化了 &#123;&#125; 个 Bean&quot;</span>, length);<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span> / i;&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;log.error(<span class="hljs-string">&quot;【SpringBootDemoLogbackApplication】启动异常：&quot;</span>, e);&#125;&#125;&#125;</code></pre></div><ol start="3"><li>也可使用lombok 配合IDEA插件 使用@Sel4j 注解 无需LoggerFactory创建log</li></ol><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li><p><a href="(https://juejin.im/post/5b51f85c5188251af91a7525#heading-6)">参照这个文件介绍</a></p></li><li><p>这里贴出自定义完整配置</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-comment">&lt;!--  &quot;$&#123;FILE_LOG_PATTERN:-%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS&#125;&#125; $&#123;LOG_LEVEL_PATTERN:-%5p&#125; $&#123;PID:- &#125; - - - [%t]  %-40.40logger&#123;39&#125;  %file:%line: %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;&quot;--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE_ERROR_PATTERN_LUNA&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;FILE_ERROR_PATTERN_LUNA:-%d&#123;$&#123;FILE_ERROR_PATTERN_LUNA:-yyyy-MM-dd HH:mm:ss.SSS&#125;&#125; $&#123;LOG_LEVEL_PATTERN:-%5p&#125; $&#123;PID:- &#125; --- [%t] %file:%line: -  %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;&quot;</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;org/springframework/boot/logging/logback/defaults.xml&quot;</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">conversionRule</span> <span class="hljs-attr">conversionWord</span>=<span class="hljs-string">&quot;clr&quot;</span> <span class="hljs-attr">converterClass</span>=<span class="hljs-string">&quot;org.springframework.boot.logging.logback.ColorConverter&quot;</span> /&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">conversionRule</span> <span class="hljs-attr">conversionWord</span>=<span class="hljs-string">&quot;wex&quot;</span> <span class="hljs-attr">converterClass</span>=<span class="hljs-string">&quot;org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter&quot;</span> /&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">conversionRule</span> <span class="hljs-attr">conversionWord</span>=<span class="hljs-string">&quot;wEx&quot;</span></span><span class="hljs-tag">                  <span class="hljs-attr">converterClass</span>=<span class="hljs-string">&quot;org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter&quot;</span> /&gt;</span>  <span class="hljs-comment">&lt;!-- 彩色日志格式 --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;CONSOLE_LOG_PATTERN_LUNA&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;CONSOLE_LOG_PATTERN_LUNA:-%clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%t])&#123;faint&#125; %clr(%40.40file:%line:)&#123;cyan&#125; %clr( -)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>INFO<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;CONSOLE_LOG_PATTERN_LUNA&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE_INFO&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--如果只是想要 Info 级别的日志，只是过滤 info 还是会输出 Error 日志，因为 Error 的级别高， 所以我们使用下面的策略，可以避免输出 Error 的日志--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--过滤 Error--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>ERROR<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span><span class="hljs-comment">&lt;!--匹配到就禁止--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span><span class="hljs-comment">&lt;!--没有匹配到就允许--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><span class="hljs-comment">&lt;!--日志名称，如果没有File 属性，那么只会使用FileNamePattern的文件路径规则如果同时有&lt;File&gt;和&lt;FileNamePattern&gt;，那么当天日志是&lt;File&gt;，明天会自动把今天的日志改名为今天的日期。即，&lt;File&gt; 的日志都是当天的。--&gt;</span><span class="hljs-comment">&lt;!--&lt;File&gt;logs/info.spring-boot-demo-logback.log&lt;/File&gt;--&gt;</span><span class="hljs-comment">&lt;!--滚动策略，按照时间滚动 TimeBasedRollingPolicy--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--文件路径,定义了日志的切分方式——把每一天的日志归档到一个文件中,以防止日志填满整个磁盘空间--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">FileNamePattern</span>&gt;</span>logs/spring-boot-demo-logback/info.created_on_%d&#123;yyyy-MM-dd&#125;.part_%i.log<span class="hljs-tag">&lt;/<span class="hljs-name">FileNamePattern</span>&gt;</span><span class="hljs-comment">&lt;!--只保留最近90天的日志--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>90<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span><span class="hljs-comment">&lt;!--用来指定日志文件的上限大小，那么到了这个值，就会删除旧的日志--&gt;</span><span class="hljs-comment">&lt;!--&lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt;--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- maxFileSize:这是活动文件的大小，默认值是10MB,本篇设置为1KB，只是为了演示 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>2MB<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><span class="hljs-comment">&lt;!--&lt;triggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;&gt;--&gt;</span><span class="hljs-comment">&lt;!--&lt;maxFileSize&gt;1KB&lt;/maxFileSize&gt;--&gt;</span><span class="hljs-comment">&lt;!--&lt;/triggeringPolicy&gt;--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;FILE_ERROR_PATTERN_LUNA&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span> <span class="hljs-comment">&lt;!-- 此处设置字符集 --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE_ERROR&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--如果只是想要 Error 级别的日志，那么需要过滤一下，默认是 info 级别的，ThresholdFilter--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>Error<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><span class="hljs-comment">&lt;!--日志名称，如果没有File 属性，那么只会使用FileNamePattern的文件路径规则如果同时有&lt;File&gt;和&lt;FileNamePattern&gt;，那么当天日志是&lt;File&gt;，明天会自动把今天的日志改名为今天的日期。即，&lt;File&gt; 的日志都是当天的。--&gt;</span><span class="hljs-comment">&lt;!--&lt;File&gt;logs/error.spring-boot-demo-logback.log&lt;/File&gt;--&gt;</span><span class="hljs-comment">&lt;!--滚动策略，按照时间滚动 TimeBasedRollingPolicy--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--文件路径,定义了日志的切分方式——把每一天的日志归档到一个文件中,以防止日志填满整个磁盘空间--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">FileNamePattern</span>&gt;</span>logs/spring-boot-demo-logback/error.created_on_%d&#123;yyyy-MM-dd&#125;.part_%i.log<span class="hljs-tag">&lt;/<span class="hljs-name">FileNamePattern</span>&gt;</span><span class="hljs-comment">&lt;!--只保留最近90天的日志--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>90<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- maxFileSize:这是活动文件的大小，默认值是10MB,本篇设置为1KB，只是为了演示 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>2MB<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;FILE_ERROR_PATTERN_LUNA&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span> <span class="hljs-comment">&lt;!-- 此处设置字符集 --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE_INFO&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE_ERROR&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre></div><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>logback和logback-spring.xml都可以用来配置logback，但是2者的加载顺序是不一样的。</p><p>logback.xml—&gt;application.properties—&gt;logback-spring.xml.</p><h2 id="logback-xml加载早于application-properties，所以如果你在logback-xml使用了变量时，而恰好这个变量是写在application-properties时，那么就会获取不到，只要改成logback-spring-xml就可以解决。"><a href="#logback-xml加载早于application-properties，所以如果你在logback-xml使用了变量时，而恰好这个变量是写在application-properties时，那么就会获取不到，只要改成logback-spring-xml就可以解决。" class="headerlink" title="logback.xml加载早于application.properties，所以如果你在logback.xml使用了变量时，而恰好这个变量是写在application.properties时，那么就会获取不到，只要改成logback-spring.xml就可以解决。"></a>logback.xml加载早于application.properties，所以如果你在logback.xml使用了变量时，而恰好这个变量是写在application.properties时，那么就会获取不到，只要改成logback-spring.xml就可以解决。</h2>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>logBack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring security 配置</title>
    <link href="/2020/05/31/spring-security/"/>
    <url>/2020/05/31/spring-security/</url>
    
    <content type="html"><![CDATA[<p><strong>生活加油:摘一句子:</strong></p><p><strong>“我希望自己能写这样的诗。我希望自己也是一颗星星。如果我会发光，就不必害怕黑暗。如果我自己是那么美好，那么一切恐惧就可以烟消云散。于是我开始存下了一点希望—如果我能做到，那么我就战胜了寂寞的命运。”</strong></p><p>​                                         —————————–王小波《我在荒岛上迎接黎明》</p><h1 id="初步嘗試一下："><a href="#初步嘗試一下：" class="headerlink" title="初步嘗試一下："></a>初步嘗試一下：</h1><p><strong>新建项目,导入依赖</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.liruilong; <span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping; <span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController; <span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> : security学习</span><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Liruilong</span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2019/12/24 12:54</span><span class="hljs-comment"> */</span><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HollerController</span> </span>&#123;    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello Security&quot;</span>;    &#125;&#125;</code></pre></div><p><strong>访问接口:请求都被保护起来,用户名默认user,密码为控制台打印的字符串.</strong></p><p><a href="https://img-blog.csdnimg.cn/2019122413045146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/2019122413045146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70" alt="img"></a></p><p><a href="https://img-blog.csdnimg.cn/20191224130732495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20191224130732495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70" alt="img"></a></p><p> <strong>手工配置用户名和密码:</strong></p><p>一,配置类方式:</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.liruilong.securityl.demo; <span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;<span class="hljs-keyword">import</span> org.springframework.security.crypto.password.NoOpPasswordEncoder;<span class="hljs-keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder; <span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> : security配置</span><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Liruilong</span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2019/12/24 13:13</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">config</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@Author</span> Liruilong </span><span class="hljs-comment">     * <span class="hljs-doctag">@Description</span> 密码处理,告诉系统不加密访问</span><span class="hljs-comment">     * <span class="hljs-doctag">@Date</span> 13:20 2019/12/24</span><span class="hljs-comment">     * <span class="hljs-doctag">@Param</span> [] </span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> org.springframework.security.crypto.password.PasswordEncoder </span><span class="hljs-comment">     **/</span>        <span class="hljs-meta">@Bean</span>    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> NoOpPasswordEncoder.getInstance();    &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@Author</span> Liruilong </span><span class="hljs-comment">     * <span class="hljs-doctag">@Description</span> 配置用户名密码.密码必须加密</span><span class="hljs-comment">     * <span class="hljs-doctag">@Date</span> 13:16 2019/12/24</span><span class="hljs-comment">     * <span class="hljs-doctag">@Param</span> [auth] </span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> void </span><span class="hljs-comment">     **/</span>        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        auth.inMemoryAuthentication()                .withUser(<span class="hljs-string">&quot;liruilong&quot;</span>).password(<span class="hljs-string">&quot;123&quot;</span>).roles(<span class="hljs-string">&quot;admin&quot;</span>)                .and()                .withUser(<span class="hljs-string">&quot;liruilongs&quot;</span>).password(<span class="hljs-string">&quot;123&quot;</span>).roles(<span class="hljs-string">&quot;user&quot;</span>);     &#125; &#125;</code></pre></div><p><strong>配置文件方式:</strong></p><p><a href="https://img-blog.csdnimg.cn/2019122413304389.png"><img src="https://img-blog.csdnimg.cn/2019122413304389.png" alt="img"></a></p><h2 id="HttpScurity的简单配置"><a href="#HttpScurity的简单配置" class="headerlink" title="HttpScurity的简单配置:"></a>HttpScurity的简单配置:</h2><p><strong>基于内存的认证，以自定义类继承自 webSecurityConfigurerAdapter ，进行自定义配置。</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.liruilong.securityl.demo;  <span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> : security配置</span><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Liruilong</span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2019/12/24 13:13</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">config</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@Author</span> Liruilong </span><span class="hljs-comment">     * <span class="hljs-doctag">@Description</span> 密码处理,告诉系统不加密访问</span><span class="hljs-comment">     * <span class="hljs-doctag">@Date</span> 13:20 2019/12/24</span><span class="hljs-comment">     * <span class="hljs-doctag">@Param</span> [] </span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> org.springframework.security.crypto.password.PasswordEncoder </span><span class="hljs-comment">     **/</span>        <span class="hljs-meta">@Bean</span>    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> NoOpPasswordEncoder.getInstance();    &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@Author</span> Liruilong </span><span class="hljs-comment">     * <span class="hljs-doctag">@Description</span> 配置用户名密码.密码必须加密</span><span class="hljs-comment">     * <span class="hljs-doctag">@Date</span> 13:16 2019/12/24</span><span class="hljs-comment">     * <span class="hljs-doctag">@Param</span> [auth] </span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> void </span><span class="hljs-comment">     **/</span>        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        auth.inMemoryAuthentication()                .withUser(<span class="hljs-string">&quot;liruilong&quot;</span>).password(<span class="hljs-string">&quot;123&quot;</span>).roles(<span class="hljs-string">&quot;admin&quot;</span>)                .and()                .withUser(<span class="hljs-string">&quot;liruilongs&quot;</span>).password(<span class="hljs-string">&quot;123&quot;</span>).roles(<span class="hljs-string">&quot;user&quot;</span>);     &#125;     <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//开启配置，开启 HtψSecurity 的配直</span>        http.authorizeRequests()                <span class="hljs-comment">// 指定admin角色可以访问该路径</span>                .antMatchers(<span class="hljs-string">&quot;/admin/**&quot;</span>).hasRole(<span class="hljs-string">&quot;admin&quot;</span>)                <span class="hljs-comment">// 指定admin和user可以访问该路径</span>                .antMatchers(<span class="hljs-string">&quot;/user/**&quot;</span>).hasAnyRole(<span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;user&quot;</span>)                <span class="hljs-comment">// 剩下的请求登录之后就可以访问</span>                .anyRequest().authenticated()                .and()                <span class="hljs-comment">// 表单登录的url,请求地址</span>                .formLogin()                .loginProcessingUrl(<span class="hljs-string">&quot;/dolog&quot;</span>)                .permitAll()                .and()                <span class="hljs-comment">// 关闭csrf</span>                .csrf().disable();     &#125;&#125;</code></pre></div><h3 id="表单登录的详细配置"><a href="#表单登录的详细配置" class="headerlink" title="表单登录的详细配置:"></a>表单登录的详细配置:</h3><div class="hljs code-wrapper"><pre><code class="hljs java">     <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//开启配置</span>        http.authorizeRequests()                <span class="hljs-comment">// 指定admin角色可以访问该路径</span>                .antMatchers(<span class="hljs-string">&quot;/admin/**&quot;</span>).hasRole(<span class="hljs-string">&quot;admin&quot;</span>)                <span class="hljs-comment">// 指定admin和user可以访问该路径</span>                .antMatchers(<span class="hljs-string">&quot;/user/**&quot;</span>).hasAnyRole(<span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;user&quot;</span>)                <span class="hljs-comment">// 剩下的请求登录之后就可以访问</span>                .anyRequest().authenticated()                .and()                <span class="hljs-comment">// 表单登录的url,请求地址</span>                .formLogin()                <span class="hljs-comment">// url,请求地址</span>                .loginProcessingUrl(<span class="hljs-string">&quot;/dolog&quot;</span>)                <span class="hljs-comment">// 登录页面</span>                .loginPage(<span class="hljs-string">&quot;login&quot;</span>)                <span class="hljs-comment">// 修改默认的键,默认为username和password</span>                .usernameParameter(<span class="hljs-string">&quot;uname&quot;</span>)                .passwordParameter(<span class="hljs-string">&quot;passwd&quot;</span>)                <span class="hljs-comment">// 前后端分离,登录成功的处理</span>                .successHandler(<span class="hljs-keyword">new</span> AuthenticationSuccessHandler() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationSuccess</span><span class="hljs-params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;                        <span class="hljs-comment">//authentication里保存了登录成功的用户信息</span>                        httpServletResponse.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);                        PrintWriter out = httpServletResponse.getWriter();                        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();                        map.put(<span class="hljs-string">&quot;status&quot;</span>, <span class="hljs-number">200</span>);                        <span class="hljs-comment">// 登录成功的用户信息</span>                        map.put(<span class="hljs-string">&quot;mes&quot;</span>, authentication.getPrincipal());                        <span class="hljs-comment">// 返回一个json</span>                        out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(map));                        out.flush();                        out.close();                    &#125;                &#125;)                 <span class="hljs-comment">//前后端不分,页面跳转</span>                .successForwardUrl(<span class="hljs-string">&quot;成功跳转&quot;</span>)                <span class="hljs-comment">//登录失败的处理</span>                .failureHandler(<span class="hljs-keyword">new</span> AuthenticationFailureHandler() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationFailure</span><span class="hljs-params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;                        httpServletResponse.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);                        PrintWriter out = httpServletResponse.getWriter();                        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();                        map.put(<span class="hljs-string">&quot;status&quot;</span>, <span class="hljs-number">401</span>);                        <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> LockedException)&#123;                            map.put(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;账户被锁定请联系管理员!&quot;</span>);                        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e <span class="hljs-keyword">instanceof</span> CredentialsExpiredException)&#123;                            map.put(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;密码过期请联系管理员!&quot;</span>);                        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> AccountExpiredException)&#123;                            map.put(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;账户过期请联系管理员!&quot;</span>);                        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e <span class="hljs-keyword">instanceof</span> DisabledException)&#123;                            map.put(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;账户被禁用请联系管理员!&quot;</span>);                        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> BadCredentialsException)&#123;                            map.put(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;用户名密码输入错误,请重新输入!&quot;</span>);                        &#125;                        out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(map));                        out.flush();                        out.close();                    &#125;                &#125;)                <span class="hljs-comment">// 前后端不分跳转</span>                .failureForwardUrl(<span class="hljs-string">&quot;失败跳转&quot;</span>)                .permitAll()                .and()                <span class="hljs-comment">// 关闭csrf</span>                .csrf().disable();       &#125;&#125;</code></pre></div><p> <strong>登录接口为 “/login”，即可以直接调用“／login”接口，发起一个 POST 请求进行登录，登录参数中用户 名必须命名为 usemam巳，密码必须命名为 password，配置了 loginProcessingUrl 接口主要方便或者移动端调用登录接口 。最后还配置了 permitAll，表示和登录相关的接口都不需要认 证即可访问。</strong> </p><p><strong>anonymous() 允许匿名用户访问<br>permitAll() 无条件允许访问</strong></p><h3 id="注销登录的配置"><a href="#注销登录的配置" class="headerlink" title="注销登录的配置:"></a>注销登录的配置:</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//开启配置</span>        http.authorizeRequests()                <span class="hljs-comment">// 指定admin角色可以访问该路径</span>                .antMatchers(<span class="hljs-string">&quot;/admin/**&quot;</span>).hasRole(<span class="hljs-string">&quot;admin&quot;</span>)                <span class="hljs-comment">// 指定admin和user可以访问该路径</span>                .antMatchers(<span class="hljs-string">&quot;/user/**&quot;</span>).hasAnyRole(<span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;user&quot;</span>)                <span class="hljs-comment">// 剩下的请求登录之后就可以访问</span>                .anyRequest().authenticated()                .and()                <span class="hljs-comment">// 表单登录的url,请求地址</span>                .formLogin()                <span class="hljs-comment">// url,请求地址</span>                .loginProcessingUrl(<span class="hljs-string">&quot;/dolog&quot;</span>)                <span class="hljs-comment">// 登录页面</span>                .loginPage(<span class="hljs-string">&quot;login&quot;</span>)                <span class="hljs-comment">// 修改默认的键,默认为username和password</span>                .usernameParameter(<span class="hljs-string">&quot;uname&quot;</span>)                .passwordParameter(<span class="hljs-string">&quot;passwd&quot;</span>)                <span class="hljs-comment">// 前后端分离,登录成功的处理</span>                .successHandler(<span class="hljs-keyword">new</span> AuthenticationSuccessHandler() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationSuccess</span><span class="hljs-params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;                        <span class="hljs-comment">//authentication里保存了登录成功的用户信息</span>                        httpServletResponse.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);                        PrintWriter out = httpServletResponse.getWriter();                        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();                        map.put(<span class="hljs-string">&quot;status&quot;</span>, <span class="hljs-number">200</span>);                        <span class="hljs-comment">// 登录成功的用户信息</span>                        map.put(<span class="hljs-string">&quot;mes&quot;</span>, authentication.getPrincipal());                        <span class="hljs-comment">// 返回一个json</span>                        out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(map));                        out.flush();                        out.close();                    &#125;                &#125;)                 <span class="hljs-comment">//前后端不分,页面跳转</span>                .successForwardUrl(<span class="hljs-string">&quot;成功跳转&quot;</span>)                <span class="hljs-comment">//登录失败的处理</span>                .failureHandler(<span class="hljs-keyword">new</span> AuthenticationFailureHandler() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationFailure</span><span class="hljs-params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;                        httpServletResponse.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);                        PrintWriter out = httpServletResponse.getWriter();                        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();                        map.put(<span class="hljs-string">&quot;status&quot;</span>, <span class="hljs-number">401</span>);                        <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> LockedException)&#123;                            map.put(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;账户被锁定请联系管理员!&quot;</span>);                        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e <span class="hljs-keyword">instanceof</span> CredentialsExpiredException)&#123;                            map.put(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;密码过期请联系管理员!&quot;</span>);                        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> AccountExpiredException)&#123;                            map.put(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;账户过期请联系管理员!&quot;</span>);                        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e <span class="hljs-keyword">instanceof</span> DisabledException)&#123;                            map.put(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;账户被禁用请联系管理员!&quot;</span>);                        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> BadCredentialsException)&#123;                            map.put(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;用户名密码输入错误,请重新输入!&quot;</span>);                        &#125;                        out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(map));                        out.flush();                        out.close();                    &#125;                &#125;)                .failureForwardUrl(<span class="hljs-string">&quot;失败跳转&quot;</span>)                <span class="hljs-comment">// 任何角色可以访问</span>                .permitAll()                .and()                .logout()                <span class="hljs-comment">// 注销请求路劲</span>                .logoutUrl(<span class="hljs-string">&quot;/logout&quot;</span>)                <span class="hljs-comment">// 注销成功的处理</span>                .logoutSuccessHandler(<span class="hljs-keyword">new</span> LogoutSuccessHandler() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLogoutSuccess</span><span class="hljs-params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;                        httpServletResponse.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);                        PrintWriter out = httpServletResponse.getWriter();                        out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(<span class="hljs-string">&quot;注销成功!&quot;</span>)));                        out.flush();                        out.close();                    &#125;                &#125;)                .logoutSuccessUrl(<span class="hljs-string">&quot;注销成功的跳转&quot;</span>)                .and()                <span class="hljs-comment">// 关闭csrf</span>                .csrf().disable();    &#125;&#125;</code></pre></div><h3 id="多HttpSecurity配置："><a href="#多HttpSecurity配置：" class="headerlink" title="多HttpSecurity配置："></a>多HttpSecurity配置：</h3><p><strong>config 不需要继承 WebSecurityConfigurerAdapter, 在 MultiHttpSecurityConfig 中创建静态内部类继承 WebSecurityConfigurerAdapter 即可，静态 内部类上添加＠Configuration 注解和＠Order 注解，＠Order 注解表示该配直的优先级，数字 越小优先级越大，未加＠Order 注解的配直优先级最小。</strong> </p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> : 多HttpSecurity配置</span><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Liruilong</span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2019/12/24 17:01</span><span class="hljs-comment"> */</span> <span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultiHttpSecurity</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> NoOpPasswordEncoder.getInstance();    &#125;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        auth.inMemoryAuthentication()                .withUser(<span class="hljs-string">&quot;liruilong&quot;</span>).password(<span class="hljs-string">&quot;123&quot;</span>).roles(<span class="hljs-string">&quot;admin&quot;</span>)                .and()                .withUser(<span class="hljs-string">&quot;liruilongs&quot;</span>).password(<span class="hljs-string">&quot;123&quot;</span>).roles(<span class="hljs-string">&quot;user&quot;</span>);    &#125;    <span class="hljs-meta">@Configuration</span>    <span class="hljs-meta">@Order(1)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdminSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span></span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-comment">//开启配置</span>            http.antMatcher(<span class="hljs-string">&quot;/admin/**&quot;</span>).authorizeRequests().anyRequest().hasAnyRole(<span class="hljs-string">&quot;admin&quot;</span>)        &#125;    &#125;    <span class="hljs-meta">@Configuration</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span></span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-comment">//开启配置</span>            http.authorizeRequests().anyRequest().authenticated()                    .and()                    .formLogin()                    .failureForwardUrl(<span class="hljs-string">&quot;/dolog&quot;</span>)                    .permitAll()                    .and()                    .csrf().disable();        &#125;    &#125;&#125;</code></pre></div><h3 id="密码加盐处理"><a href="#密码加盐处理" class="headerlink" title="密码加盐处理:"></a>密码加盐处理:</h3><p><strong>通过BCryptPasswordEncoder生成密码密文,</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0</span>; i++)&#123;            BCryptPasswordEncoder encoder = <span class="hljs-keyword">new</span> BCryptPasswordEncoder();            System.out.println(encoder.encode(<span class="hljs-string">&quot;123&quot;</span>));        &#125;    &#125;   <span class="hljs-meta">@Bean</span>    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> NoOpPasswordEncoder.getInstance();    &#125; 替换为<span class="hljs-meta">@Bean</span>    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();    &#125;</code></pre></div><h3 id="方法安全"><a href="#方法安全" class="headerlink" title="方法安全:"></a>方法安全:</h3><p><strong>即该方法加一个权限,明确该方法是什么角色可以调用的.</strong></p><p><strong>开发者也可以通过注解来灵活地配置方法安全，要 使用相关注解，首先要通过＠EnableGloba!MethodSecurity 注解开启基于注解的安全配置：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-comment">//用于解锁注解。</span><span class="hljs-meta">@EnableGlobalMethodSecurity(prePostEnabled = true,securedEnabled = true)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultiHttpSecurityConfig</span> </span>&#123;     <span class="hljs-meta">@Bean</span>    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();    &#125;     <span class="hljs-meta">@Autowired</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        auth.inMemoryAuthentication()                .withUser(<span class="hljs-string">&quot;javaboy&quot;</span>).password(<span class="hljs-string">&quot;$2a$10$G3kVAJHvmRrr6sOj.j4xpO2Dsxl5EG8rHycPHFWyi9UMIhtdSH15u&quot;</span>).roles(<span class="hljs-string">&quot;admin&quot;</span>)                .and()                .withUser(<span class="hljs-string">&quot;江南一点雨&quot;</span>).password(<span class="hljs-string">&quot;$2a$10$kWjG2GxWhm/2tN2ZBpi7bexXjUneIKFxIAaMYJzY7WcziZLCD4PZS&quot;</span>).roles(<span class="hljs-string">&quot;user&quot;</span>);    &#125;     <span class="hljs-meta">@Configuration</span>    <span class="hljs-meta">@Order(1)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdminSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span></span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            http.antMatcher(<span class="hljs-string">&quot;/admin/**&quot;</span>).authorizeRequests().anyRequest().hasAnyRole(<span class="hljs-string">&quot;admin&quot;</span>);        &#125;    &#125;     <span class="hljs-meta">@Configuration</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span></span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            http.authorizeRequests().anyRequest().authenticated()                    .and()                    .formLogin()                    .loginProcessingUrl(<span class="hljs-string">&quot;/doLogin&quot;</span>)                    .permitAll()                    .and()                    .csrf().disable();        &#125;    &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.liruilong.securityl.demo.service; <span class="hljs-keyword">import</span> org.springframework.security.access.annotation.Secured;<span class="hljs-keyword">import</span> org.springframework.security.access.prepost.PreAuthorize;<span class="hljs-keyword">import</span> org.springframework.stereotype.Service; <span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> :</span><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Liruilong</span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2019/12/24 17:31</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">userservlce</span> </span>&#123;    <span class="hljs-comment">//</span>    <span class="hljs-meta">@PreAuthorize(&quot;hasRole(&#x27;admin&#x27;)&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">admin</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello admin&quot;</span>;    &#125;    <span class="hljs-meta">@Secured(&quot;ROLB_user&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">users</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello user&quot;</span>;    &#125;    <span class="hljs-meta">@PreAuthorize(&quot;hasAnyRole(&#x27;admin&#x27;,&#x27;user&#x27;)&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello hello&quot;</span>;    &#125;&#125;</code></pre></div><p>代码解释： •</p><ul><li><strong>@Secured(”ROLE_ AD MIN＂）注解表示访问该方法需要 ADMIN 角色，注意这里需要在角色前加一个前缀“ROLE ’</strong></li><li><strong>@PreAuthorize（”hasRole（’AD MIN’） and hasRole(‘DBA＇）”）注解表示访问该方法既需妥 ADMIN 角色又需要 DBA 角色。 •</strong></li><li><strong>@PreAuthorize(“hasAnyRole（’ADMIN’,’DBA’,’USER’）”）表示访问该方法需要 ADMIN、 DBA 或 USER 角色。</strong></li><li><strong>•@PreAuthorize 和＠PostAuthorize 中都可以使用基于表达式的语法。</strong></li></ul><h1 id="基于数据库的认证"><a href="#基于数据库的认证" class="headerlink" title="基于数据库的认证"></a>基于数据库的认证</h1><h3 id="动态配置权限"><a href="#动态配置权限" class="headerlink" title="动态配置权限"></a>动态配置权限</h3><ul><li>配置自定义权限拦截withObjectPostProcessor<ul><li><a href="https://img-blog.csdnimg.cn/20200216114348376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20200216114348376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70" alt="img"></a></li></ul></li><li>定义自定义拦截逻辑,获取有当前访问路径权限的所有角色,返回角色数组.<ul><li><strong>通过FilterlnvocationSecurityMetadataSource 接口中的 getAttributes 方法来确定一个请求需要哪些角色</strong></li><li><a href="https://img-blog.csdnimg.cn/20200216114755243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20200216114755243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70" alt="img"></a></li></ul></li><li>自定义角色比对之后的逻辑.判断当前用户是否有访问角色.的权利,<ul><li><strong>自定义 AccessDecisionManager 并重写 decide 方法，decide有三个参数,当前登录用户的信息,请求对象,上一个getAttribute返回的角色数组.</strong></li><li><a href="https://img-blog.csdnimg.cn/20200216124415775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20200216124415775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70" alt="img"></a></li></ul></li></ul><h1 id=""><a href="#" class="headerlink" title=" "></a><a href="https://img-blog.csdnimg.cn/20200213122344351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20200213122344351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70" alt="img"></a> <a href="https://img-blog.csdnimg.cn/20200213121307187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20200213121307187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70" alt="img"></a></h1><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.liruilong.hros.model;  <span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.JacksonInject;<span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.JsonIgnore;<span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.JsonIgnoreType;<span class="hljs-keyword">import</span> org.springframework.security.core.GrantedAuthority;<span class="hljs-keyword">import</span> org.springframework.security.core.authority.SimpleGrantedAuthority;<span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.UserDetails; <span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.Collection;<span class="hljs-keyword">import</span> java.util.List; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetails</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;     <span class="hljs-keyword">private</span> String name;     <span class="hljs-keyword">private</span> String phone;     <span class="hljs-keyword">private</span> String telephone;     <span class="hljs-keyword">private</span> String address;     <span class="hljs-keyword">private</span> Boolean enabled;     <span class="hljs-keyword">private</span> String username;     <span class="hljs-keyword">private</span> String password;     <span class="hljs-keyword">private</span> String userface;     <span class="hljs-keyword">private</span> String remark;     <span class="hljs-keyword">private</span> List&lt;Role&gt; roles;     <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : name.trim();    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPhone</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> phone;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPhone</span><span class="hljs-params">(String phone)</span> </span>&#123;        <span class="hljs-keyword">this</span>.phone = phone == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : phone.trim();    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTelephone</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> telephone;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTelephone</span><span class="hljs-params">(String telephone)</span> </span>&#123;        <span class="hljs-keyword">this</span>.telephone = telephone == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : telephone.trim();    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> address;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddress</span><span class="hljs-params">(String address)</span> </span>&#123;        <span class="hljs-keyword">this</span>.address = address == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : address.trim();    &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEnabled</span><span class="hljs-params">(Boolean enabled)</span> </span>&#123;        <span class="hljs-keyword">this</span>.enabled = enabled;    &#125;     <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> username;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;        <span class="hljs-keyword">this</span>.username = username == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : username.trim();    &#125;     <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPassword</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> password;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPassword</span><span class="hljs-params">(String password)</span> </span>&#123;        <span class="hljs-keyword">this</span>.password = password == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : password.trim();    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUserface</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> userface;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserface</span><span class="hljs-params">(String userface)</span> </span>&#123;        <span class="hljs-keyword">this</span>.userface = userface == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : userface.trim();    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getRemark</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> remark;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRemark</span><span class="hljs-params">(String remark)</span> </span>&#123;        <span class="hljs-keyword">this</span>.remark = remark == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : remark.trim();    &#125;     <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonExpired</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;     <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonLocked</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;     <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isCredentialsNonExpired</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;     <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnabled</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> enabled;    &#125;      <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@JsonIgnore</span>    <span class="hljs-keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;      List&lt;SimpleGrantedAuthority&gt; authorities = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(roles.size());      roles.stream().forEach( (role) -&gt;authorities.add(<span class="hljs-keyword">new</span> SimpleGrantedAuthority(role.getName())));        <span class="hljs-keyword">return</span> authorities;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Role&gt; <span class="hljs-title">getRoles</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> roles;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRoles</span><span class="hljs-params">(List&lt;Role&gt; roles)</span> </span>&#123;        <span class="hljs-keyword">this</span>.roles = roles;    &#125;&#125;</code></pre></div><p><a href="https://img-blog.csdnimg.cn/20200216112457918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20200216112457918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70" alt="img"></a></p><p><strong>要实现动态配置权限，首先要自定义 FilterlnvocationSecurityMetadataSource,自定义权限拦截,获取当前请求的所有角色</strong>, <strong>Spring Security 中通过 FilterlnvocationSecurityMetadataSource 接口中的 getAttributes 方法来确定一个请求需要哪些 角色， FilterlnvocationSecurityMetadataSource 接口的默认实现类是 DefaultFilterlnvocationSecurityMetadataSource ，参考 DefaultFilterlnvocationSecurityMetadataSource 的实现，开发者可以定义自己的 FilterlnvocationSecurityMetadataSource，</strong></p><p><strong><code>SecurityMetadataSource</code>是<code>Spring Security</code>的一个概念模型接口。用于表示对受权限保护的”安全对象”的权限设置信息。一个该类对象可以被理解成一个映射表，映射表中的每一项包含如下信息 :</strong></p><ul><li><strong>安全对象</strong></li><li><strong>安全对象所需权限信息</strong></li></ul><p><strong>围绕该映射表，</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.liruilong.hros.config; <span class="hljs-keyword">import</span> com.liruilong.hros.mapper.MenuMapper;<span class="hljs-keyword">import</span> com.liruilong.hros.model.Menu;<span class="hljs-keyword">import</span> com.liruilong.hros.model.Role;<span class="hljs-keyword">import</span> com.liruilong.hros.service.MenuService;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.security.access.ConfigAttribute;<span class="hljs-keyword">import</span> org.springframework.security.access.SecurityConfig;<span class="hljs-keyword">import</span> org.springframework.security.web.FilterInvocation;<span class="hljs-keyword">import</span> org.springframework.security.web.access.intercept.FilterInvocationSecurityMetadataSource;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-keyword">import</span> org.springframework.util.AntPathMatcher; <span class="hljs-keyword">import</span> java.util.Collection;<span class="hljs-keyword">import</span> java.util.List; <span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> : 权限处理,根据请求,分析需要的角色,该类的主要功能就是通过当前的请求地址，获取该地址需要的用户角色</span><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Liruilong</span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2019/12/24 12:17</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomFilterInvocationSecurityMetadataSource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FilterInvocationSecurityMetadataSource</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    MenuService menuService;    <span class="hljs-comment">//路径比较工具</span>    AntPathMatcher antPathMatcher = <span class="hljs-keyword">new</span> AntPathMatcher();    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> java.util.Collection&lt;org.springframework.security.access.ConfigAttribute&gt;</span><span class="hljs-comment">     * <span class="hljs-doctag">@Author</span> Liruilong</span><span class="hljs-comment">     * <span class="hljs-doctag">@Description</span> 当前请求需要的角色</span><span class="hljs-comment">     * <span class="hljs-doctag">@Date</span> 18:13 2019/12/24</span><span class="hljs-comment">     * <span class="hljs-doctag">@Param</span> [object]</span><span class="hljs-comment">     **/</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="hljs-title">getAttributes</span><span class="hljs-params">(Object object)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException </span>&#123;        <span class="hljs-comment">//获取当前请求路径</span>        String requestUrl = ((FilterInvocation) object).getRequestUrl();        <span class="hljs-comment">//获取所有的菜单url路径</span>        List&lt;Menu&gt; menus = menuService.getAllMenusWithRole();        <span class="hljs-keyword">for</span> (Menu menu : menus) &#123;            <span class="hljs-keyword">if</span> (antPathMatcher.match(menu.getUrl(), requestUrl)) &#123;                <span class="hljs-comment">//拥有当前菜单权限的角色</span>                List&lt;Role&gt; roles = menu.getRoles();                String[] strings = <span class="hljs-keyword">new</span> String[roles.size()];                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; roles.size(); i++) &#123;                    strings[i] = roles.get(i).getName();                &#125;                <span class="hljs-keyword">return</span> SecurityConfig.createList(strings);            &#125;        &#125;        <span class="hljs-comment">// 没匹配上的资源都是登录</span>        <span class="hljs-keyword">return</span> SecurityConfig.createList(<span class="hljs-string">&quot;ROLE_LOGIN&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="hljs-title">getAllConfigAttributes</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;     <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre></div><h3 id="开发者自定义-FilterlnvocationSecurityrMetadataSource"><a href="#开发者自定义-FilterlnvocationSecurityrMetadataSource" class="headerlink" title="开发者自定义 FilterlnvocationSecurityrMetadataSource :"></a><strong>开发者自定义 FilterlnvocationSecurityrMetadataSource</strong> :</h3><p><strong>主要实现该接口中的 getAttributes 方法， 该方法的参数是一个 FilterInvocation， 开发者可以从 Filterlnvocation 中提取出当前请求的 URL，返回值是 Collection<ConfigAttribute>，表示当前请求 URL 所需的角色</strong>。</p><ul><li>创建一个 AntPathMatcher，主要用来实现 ant 风格的 URL 匹配。</li><li>从参数中提取出当前请求的 URL。</li><li>从数据库中获取所有的资源信息，即本案例中的 menu 表以及 menu 所对应的 role,</li><li>追历资源信息，边历过程中获取当前请求的 URL 所需要的角色信息并返回。如 果当前请求的 URL 在资源表中不存在相应的模式，就假设该请求登录后即可访问，即直接返代码解释： ROLE LOGJN。</li><li>getAllConfigAttributes 方法用来返回所有定义好的权限资源， Spring Security 在启动时会校验 相关配置是否正确，如果不需要校验，那么该方法直接返回 null 即可。 supports 方法返回类对象是否支持校验。 </li></ul><h3 id="自定义-AccessDecisionManager"><a href="#自定义-AccessDecisionManager" class="headerlink" title="自定义 AccessDecisionManager"></a>自定义 AccessDecisionManager</h3><p><strong>当一个请求走完 FilterlnvocationSecurityMetadataSource 中的 getAttributes 方法后，接下来就会 来到 AccessDecisionManager 类中进行角色信息的比对，自定义 AccessDecisionManager 如下：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.liruilong.hros.config; <span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.security.access.AccessDecisionManager;<span class="hljs-keyword">import</span> org.springframework.security.access.AccessDeniedException;<span class="hljs-keyword">import</span> org.springframework.security.access.ConfigAttribute;<span class="hljs-keyword">import</span> org.springframework.security.authentication.AnonymousAuthenticationToken;<span class="hljs-keyword">import</span> org.springframework.security.authentication.InsufficientAuthenticationException;<span class="hljs-keyword">import</span> org.springframework.security.core.Authentication;<span class="hljs-keyword">import</span> org.springframework.security.core.GrantedAuthority;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component; <span class="hljs-keyword">import</span> java.util.Collection; <span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> : 判断当前用户是否具备菜单访问，当一个请求走完 FilterlnvocationSecurityMetadataSource 中的 getAttributes 方法后，接下来就会 来到 AccessDecisionManager 类中进行角色信息的比对</span><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Liruilong</span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2019/12/24 19:12</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomUrlDecisionManager</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AccessDecisionManager</span> </span>&#123;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> void</span><span class="hljs-comment">     * <span class="hljs-doctag">@Author</span> Liruilong</span><span class="hljs-comment">     * <span class="hljs-doctag">@Description</span> decide 方法有三个参数， 第一个参数包含当前登录用户的信息；</span><span class="hljs-comment">     * 第二个参数则是一个 Filterlnvocation 对 象 ，可以 获 取当前请求对 象等；</span><span class="hljs-comment">     * 第 三个参 数就是 FilterlnvocationSecurityMetadataSource 中的 getAttributes 方法的返回值， 即当前请求 URL 所 需要的角色。</span><span class="hljs-comment">     * <span class="hljs-doctag">@Date</span> 18:28 2020/2/13</span><span class="hljs-comment">     * <span class="hljs-doctag">@Param</span> [authentication, object, configAttributes]</span><span class="hljs-comment">     **/</span>     <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decide</span><span class="hljs-params">(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> AccessDeniedException, InsufficientAuthenticationException </span>&#123;        <span class="hljs-keyword">for</span> (ConfigAttribute configAttribute : configAttributes) &#123;            String needRole = configAttribute.getAttribute();            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;ROLE_LOGIN&quot;</span>.equals(needRole)) &#123;                <span class="hljs-comment">//判断用户是否登录</span>                <span class="hljs-keyword">if</span> (authentication <span class="hljs-keyword">instanceof</span> AnonymousAuthenticationToken) &#123;                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AccessDeniedException(<span class="hljs-string">&quot;尚未登录，请登录!&quot;</span>);                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">return</span>;                &#125;            &#125;            Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();            <span class="hljs-keyword">for</span> (GrantedAuthority authority : authorities) &#123;                <span class="hljs-keyword">if</span> (authority.getAuthority().equals(needRole)) &#123;                    <span class="hljs-keyword">return</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AccessDeniedException(<span class="hljs-string">&quot;权限不足，请联系管理员!&quot;</span>);    &#125;     <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(ConfigAttribute attribute)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;     <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;<span class="hljs-comment">// authorities.stream().anyMatch((authority) -&gt;authority.getAuthority().equals(attribute));</span></code></pre></div><p><strong>自定义 AccessDecisionManager 并重写 decide 方法，</strong></p><p><strong>在该方法中判断当前登录的用户是否具 备当前请求 URL 所需要的角色信息，如果不具备，就抛出 AccessDeniedException 异常，否 则不做任何事即可。</strong></p><p><strong>decide 方法有三个参数，</strong></p><p><strong>第一个参数包含当前登录用户的信息；</strong></p><p><strong>第二个参数则是一个 Filterlnvocation 对 象 ，可以 获 取当前请求对 象等；</strong></p><p><strong>第 三个参 数就是 FilterlnvocationSecurityMetadataSource 中的 getAttributes 方法的返回值， 即当前请求 URL 所 需要的角色。</strong></p><p><strong>进行角色信息对比，如果需要的角色是 ROLE_LOG，说明当前请求的 URL 用 户登录后即可访问，如果 auth 是 UsemamePasswordAuthenticationToken 的实例，那么说明当前用户已登录，该方法到此结束，否则进入正常的判断流程，如果当前用户具备当前请求需 要的角色，那么方法结束。</strong></p><p><strong>springSecurity配置流程分析:</strong></p><p><a href="https://img-blog.csdnimg.cn/20200216171913215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20200216171913215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70" alt="img"></a></p><p><a href="https://img-blog.csdnimg.cn/20200216171937340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20200216171937340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70" alt="img"></a></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.liruilong.hros.config; <span class="hljs-keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;<span class="hljs-keyword">import</span> com.liruilong.hros.filter.VerifyCodeFilter;<span class="hljs-keyword">import</span> com.liruilong.hros.model.Hr;<span class="hljs-keyword">import</span> com.liruilong.hros.model.RespBean;<span class="hljs-keyword">import</span> com.liruilong.hros.service.HrService;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> org.springframework.security.authentication.*;<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.ObjectPostProcessor;<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.builders.WebSecurity;<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;<span class="hljs-keyword">import</span> org.springframework.security.core.Authentication;<span class="hljs-keyword">import</span> org.springframework.security.core.AuthenticationException;<span class="hljs-keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;<span class="hljs-keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;<span class="hljs-keyword">import</span> org.springframework.security.web.AuthenticationEntryPoint;<span class="hljs-keyword">import</span> org.springframework.security.web.access.intercept.FilterSecurityInterceptor;<span class="hljs-keyword">import</span> org.springframework.security.web.authentication.AuthenticationSuccessHandler;<span class="hljs-keyword">import</span> org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;<span class="hljs-keyword">import</span> org.springframework.security.web.authentication.logout.LogoutSuccessHandler; <span class="hljs-keyword">import</span> javax.servlet.ServletException;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.PrintWriter; <span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> :</span><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Liruilong</span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2019/12/18 19:11</span><span class="hljs-comment"> */</span> <span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    HrService hrService;    <span class="hljs-meta">@Autowired</span>    CustomFilterInvocationSecurityMetadataSource customFilterInvocationSecurityMetadataSource;    <span class="hljs-meta">@Autowired</span>    CustomUrlDecisionManager customUrlDecisionManager;     <span class="hljs-meta">@Autowired</span>    VerifyCodeFilter verifyCodeFilter ;    <span class="hljs-meta">@Autowired</span>    MyAuthenticationFailureHandler myAuthenticationFailureHandler;     <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.addFilterBefore(verifyCodeFilter, UsernamePasswordAuthenticationFilter.class)                .authorizeRequests()                <span class="hljs-comment">//.anyRequest().authenticated()</span>                <span class="hljs-comment">//所有请求的都会经过这进行鉴权处理。返回当前请求需要的角色。</span>                .withObjectPostProcessor(<span class="hljs-keyword">new</span> ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-keyword">public</span> &lt;O extends FilterSecurityInterceptor&gt; <span class="hljs-function">O <span class="hljs-title">postProcess</span><span class="hljs-params">(O object)</span> </span>&#123;                        object.setSecurityMetadataSource(customFilterInvocationSecurityMetadataSource);                        object.setAccessDecisionManager(customUrlDecisionManager);                        <span class="hljs-keyword">return</span> object;                    &#125;                &#125;)                .and().formLogin().usernameParameter(<span class="hljs-string">&quot;username&quot;</span>).passwordParameter(<span class="hljs-string">&quot;password&quot;</span>)                <span class="hljs-comment">//设置登录请求的url路径</span>                .loginProcessingUrl(<span class="hljs-string">&quot;/doLogin&quot;</span>)                <span class="hljs-comment">/*需要身份验证时，将浏览器重定向到/ login</span><span class="hljs-comment">                我们负责在请求/ login时呈现登录页面</span><span class="hljs-comment">                当身份验证尝试失败时，将浏览器重定向到/ login？error（因为我们没有另外指定）</span><span class="hljs-comment">                当请求/ login？error时，我们负责呈现失败页面</span><span class="hljs-comment">                成功注销后，将浏览器重定向到/ login？logout（因为我们没有另外指定）</span><span class="hljs-comment">                我们负责在请求/ login？logout时呈现注销确认页面*/</span>                .loginPage(<span class="hljs-string">&quot;/login&quot;</span>)                <span class="hljs-comment">//登录成功回调</span>                .successHandler(<span class="hljs-keyword">new</span> AuthenticationSuccessHandler() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationSuccess</span><span class="hljs-params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;                        httpServletResponse.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);                        PrintWriter out = httpServletResponse.getWriter();                        Hr hr = (Hr) authentication.getPrincipal();                        <span class="hljs-comment">//密码不回传</span>                        hr.setPassword(<span class="hljs-keyword">null</span>);                        RespBean ok = RespBean.ok(<span class="hljs-string">&quot;登录成功！&quot;</span>, hr);                        <span class="hljs-comment">//将hr转化为Sting</span>                        String s = <span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(ok);                        out.write(s);                        out.flush();                        out.close();                    &#125;                &#125;)                <span class="hljs-comment">//登失败回调</span>                .failureHandler(myAuthenticationFailureHandler)                <span class="hljs-comment">//相关的接口直接返回</span>                .permitAll().and().logout()                <span class="hljs-comment">//注销登录</span>                .logoutSuccessHandler(<span class="hljs-keyword">new</span> LogoutSuccessHandler() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLogoutSuccess</span><span class="hljs-params">(HttpServletRequest httpServletRequest,</span></span><span class="hljs-function"><span class="hljs-params">                                                HttpServletResponse httpServletResponse,</span></span><span class="hljs-function"><span class="hljs-params">                                                Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;                        httpServletResponse.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);                        PrintWriter out = httpServletResponse.getWriter();                        out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(RespBean.ok(<span class="hljs-string">&quot;注销成功!&quot;</span>)));                        out.flush();                        out.close();                    &#125;                &#125;)                .permitAll().and().csrf().disable().exceptionHandling()                <span class="hljs-comment">//没有认证时，在这里处理结果，不要重定向</span>                .authenticationEntryPoint(                        <span class="hljs-comment">//myAuthenticationEntryPoint;</span>                        <span class="hljs-keyword">new</span> AuthenticationEntryPoint() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commence</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, AuthenticationException authException)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;                        resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);                        resp.setStatus(<span class="hljs-number">401</span>);                        PrintWriter out = resp.getWriter();                        RespBean respBean = RespBean.error(<span class="hljs-string">&quot;访问失败!&quot;</span>);                        <span class="hljs-keyword">if</span> (authException <span class="hljs-keyword">instanceof</span> InsufficientAuthenticationException) &#123;                            respBean.setMsg(<span class="hljs-string">&quot;请求失败，请联系管理员!&quot;</span>);                        &#125;                        out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(respBean));                        out.flush();                        out.close();                    &#125;                &#125;);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        auth.userDetailsService(hrService);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@Author</span> Liruilong</span><span class="hljs-comment">     * <span class="hljs-doctag">@Description</span>  放行的请求路径</span><span class="hljs-comment">     * <span class="hljs-doctag">@Date</span> 19:25 2020/2/7</span><span class="hljs-comment">     * <span class="hljs-doctag">@Param</span> [web]</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> void</span><span class="hljs-comment">     **/</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        web.ignoring().antMatchers(<span class="hljs-string">&quot;/auth/code&quot;</span>,<span class="hljs-string">&quot;/login&quot;</span>,<span class="hljs-string">&quot;/css/**&quot;</span>,<span class="hljs-string">&quot;/js/**&quot;</span>, <span class="hljs-string">&quot;/index.html&quot;</span>, <span class="hljs-string">&quot;/img/**&quot;</span>, <span class="hljs-string">&quot;/fonts/**&quot;</span>,<span class="hljs-string">&quot;/favicon.ico&quot;</span>);    &#125;&#125;</code></pre></div><p>SpringSecurity执行流程分析:</p><p><a href="https://img-blog.csdn.net/20180318211512445?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L3UwMTM0MzU4OTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"><img src="https://img-blog.csdn.net/20180318211512445?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L3UwMTM0MzU4OTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></a></p><p>UsernamePasswordAuthenticationFilter就是拦截我们通过表单提交接口提交的用户名和密码，如果是Basic提交的话，就会被BasicAuthenticationFilter拦截，最后的橙色FilterSecurityInterceptor是首先判断我们当前请求的url是否需要认证，如果需要认证，那么就看当前请求是否已经认证，是的话就放行到我们要访问的接口，否则重定向到认证页面。</p><p>UsernamePasswordAuthenticationFilter首先会拦截请求，而UsernamePasswordAuthenticationFilter是继承于AbstractAuthenticationProcessingFilter的，在这个抽象类中已经定义好了doFilter的方法，而里面有一个attemptAuthentication方法是由子类实现的。所以当提交表单时spring security会发现这个一个表单提交，然后就调用了UsernamePasswordAuthenticationFilter的doFilter方法</p><p>springSecurity其实就是一组过滤器，请求和响应都会经过这些过滤器，在系统启动的时候，spring boot会自动配上</p><p>黄色：已经存储的认证信息</p><p>绿色：处理用户身份认证</p><p>橙色：捕获黄色抛出的异常</p><p>蓝色：决定当前请求是否通过之前某个过滤器的身份认证，不能通过就抛出异常，通过了会帮我们直接跳转</p><p><a href="https://img-blog.csdnimg.cn/20191205165135360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW5kZWFpNTIw,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20191205165135360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW5kZWFpNTIw,size_16,color_FFFFFF,t_70" alt="img"></a></p><p>它的身份认证其实是始于访问资源开始。如果一个用户已登录，那么访问受保护的资源，则会校验该用户是否有权限访问。如果没有权限，则会调用权限拒绝的处理器进行处理。如果有权限，则能顺利访问该资源；</p><p>一个用户未登录情况下，也即匿名用户，访问受保护的资源时，spring security会首先检查该资源是否需要权限，如果需要权限，然后再检查，该资源是否是白名单里面。如果是白名单，也能正常访问。如果是受保护的资源，则会提示该用户需要登录。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springhttps</title>
    <link href="/2020/05/30/spring-https/"/>
    <url>/2020/05/30/spring-https/</url>
    
    <content type="html"><![CDATA[<h3 id="springHttps-的转发-自动将http浏览器默认80端口转发至https-443或自定义端口"><a href="#springHttps-的转发-自动将http浏览器默认80端口转发至https-443或自定义端口" class="headerlink" title="springHttps 的转发,自动将http浏览器默认80端口转发至https 443或自定义端口"></a>springHttps 的转发,自动将http浏览器默认80端口转发至https 443或自定义端口</h3><h4 id="1-获取证书"><a href="#1-获取证书" class="headerlink" title="1. 获取证书"></a>1. 获取证书</h4><ul><li><p>首先在需要生成证书页面进入控制台命令,输入</p></li><li><h4 id="keytool命令，keytool-genkey-alias-ccc-keyalg-RSA-validity-36500-keystore-server-keystore"><a href="#keytool命令，keytool-genkey-alias-ccc-keyalg-RSA-validity-36500-keystore-server-keystore" class="headerlink" title="keytool命令，keytool -genkey -alias ccc -keyalg RSA -validity 36500 -keystore server.keystore"></a>keytool命令，keytool -genkey -alias ccc -keyalg RSA -validity 36500 -keystore server.keystore</h4><p><img src="/img/springrest/keystore1.jpg"></p></li><li><p>然后输入密钥 ps: 一定要记住</p><p><img src="/img/springrest/keystore2.jpg"></p></li><li><p>随意输入相应信息,最后会在相应目录生成 server.keystore 文件</p><p><img src="/img/springrest/keystore3.jpg"></p></li></ul><h4 id="2-spring配置"><a href="#2-spring配置" class="headerlink" title="2. spring配置"></a>2. spring配置</h4><ul><li>新建spring配置文件注解@Configuration</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 配置 http(80) -&gt; 强制跳转到 https(443)</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Connector <span class="hljs-title">connector</span><span class="hljs-params">()</span> </span>&#123;        Connector connector = <span class="hljs-keyword">new</span> Connector(<span class="hljs-string">&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span>);        connector.setScheme(<span class="hljs-string">&quot;http&quot;</span>);        connector.setPort(<span class="hljs-number">80</span>);        connector.setSecure(<span class="hljs-keyword">false</span>);        connector.setRedirectPort(<span class="hljs-number">443</span>);        <span class="hljs-keyword">return</span> connector;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> TomcatServletWebServerFactory <span class="hljs-title">tomcatServletWebServerFactory</span><span class="hljs-params">(Connector connector)</span> </span>&#123;        TomcatServletWebServerFactory tomcat = <span class="hljs-keyword">new</span> TomcatServletWebServerFactory() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessContext</span><span class="hljs-params">(Context context)</span> </span>&#123;                SecurityConstraint securityConstraint = <span class="hljs-keyword">new</span> SecurityConstraint();                securityConstraint.setUserConstraint(<span class="hljs-string">&quot;CONFIDENTIAL&quot;</span>);                SecurityCollection collection = <span class="hljs-keyword">new</span> SecurityCollection();                collection.addPattern(<span class="hljs-string">&quot;/*&quot;</span>);                securityConstraint.addCollection(collection);                context.addConstraint(securityConstraint);            &#125;        &#125;;        tomcat.addAdditionalTomcatConnectors(connector);        <span class="hljs-keyword">return</span> tomcat;    &#125;</code></pre></div><ul><li>将server.keystore放至resource目录下</li><li>编写配置文件</li></ul><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">ssl:</span>    <span class="hljs-comment"># 证书路径</span>    <span class="hljs-attr">key-store:</span> <span class="hljs-string">classpath:server.keystore</span>    <span class="hljs-attr">key-alias:</span> <span class="hljs-string">tomcat</span>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">key-store-type:</span> <span class="hljs-string">JKS</span>    <span class="hljs-comment">#与申请时输入一致</span>    <span class="hljs-attr">key-store-password:</span> <span class="hljs-number">123456</span>    <span class="hljs-comment"># 浏览器默认端口 和 80 类似</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">443</span></code></pre></div><h3 id="启动项目-访问80就会自动跳转433端口了-若提示443端口被占用可修改相应端口号"><a href="#启动项目-访问80就会自动跳转433端口了-若提示443端口被占用可修改相应端口号" class="headerlink" title="启动项目,访问80就会自动跳转433端口了 ,若提示443端口被占用可修改相应端口号"></a>启动项目,访问80就会自动跳转433端口了 ,若提示443端口被占用可修改相应端口号</h3>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>https</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DateUtils方法</title>
    <link href="/2020/05/18/java-utils-date/"/>
    <url>/2020/05/18/java-utils-date/</url>
    
    <content type="html"><![CDATA[<div class="hljs code-wrapper"><pre><code class="hljs java">     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 以秒为标准时间的毫秒数</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> MILLIS_PER_SECOND = <span class="hljs-number">1000</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     *以分钟为标准时间的毫秒数</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> MILLIS_PER_MINUTE = <span class="hljs-number">60</span> * MILLIS_PER_SECOND    <span class="hljs-comment">/**</span><span class="hljs-comment">     *以小时为标准时间的毫秒数</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> MILLIS_PER_HOUR = <span class="hljs-number">60</span> * MILLIS_PER_MINUTE    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 以天为标准时间的毫秒数</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> MILLIS_PER_DAY = <span class="hljs-number">24</span> * MILLIS_PER_HOUR    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 这个类型是半个月， 所以这可以代表日期是上还是下半个月 。</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SEMI_MONTH = <span class="hljs-number">1001</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 周范围， 从星期日开始 。</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RANGE_WEEK_SUNDAY = <span class="hljs-number">1</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 周范围，从星期一开始 。</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RANGE_WEEK_MONDAY = <span class="hljs-number">2</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 周范围，从关注的那天开始。</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RANGE_WEEK_RELATIVE = <span class="hljs-number">3</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 周范围，以关注的天为中心。</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RANGE_WEEK_CENTER = <span class="hljs-number">4</span>     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 月范围，从星期日开始 。</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RANGE_MONTH_SUNDAY = <span class="hljs-number">5</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 月范围，从星期一开始 。</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RANGE_MONTH_MONDAY = <span class="hljs-number">6</span>     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 不应在标准编成构造获取实列， 而应该直接使用类中的静态方法，如：DateUtils.parseDate(str) 。</span><span class="hljs-comment">     * 此构造函数意在允许需要一个javabeen实列的工具中使用 。  </span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DateUtils</span><span class="hljs-params">()</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 判断两个日期时间是否是同一天 。</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * @param date1  第一个日期，不可修改，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param date2  第二个日期，不可修改，非null</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSameDay</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Date date1, <span class="hljs-keyword">final</span> Date date2)</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 判断两个日历时间是否是同一天 。   </span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * @param cal1  第一个日历，不可修改，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param cal2  第二个日历，不可修改，非null</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSameDay</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Calendar cal1, <span class="hljs-keyword">final</span> Calendar cal2)</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 判断两个日期是否相同</span></span><span class="hljs-function"><span class="hljs-comment">     * 这种方法比较两个对象的毫秒时间 </span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * @param date1  第一个日期，不可修改，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param date2  第二个日期，不可修改，非null</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSameInstant</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Date date1, <span class="hljs-keyword">final</span> Date date2)</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 判断两个日历是否相同</span></span><span class="hljs-function"><span class="hljs-comment">     * 这种方法比较两个对象的毫秒时间 </span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * @param cal1  第一个日历，不可修改，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param cal2  第二个日历，不可修改，非null</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSameInstant</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Calendar cal1, <span class="hljs-keyword">final</span> Calendar cal2)</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 判断两个日历本地时间是否相同</span></span><span class="hljs-function"><span class="hljs-comment">     * 除了比较数值外两个日历对象的类型还要相同</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * @param cal1  第一个日历，不可修改，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param cal2  第二个日历，不可修改，非null</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSameLocalTime</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Calendar cal1, <span class="hljs-keyword">final</span> Calendar cal2)</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 尝试用parsePatterns中各种不同的日期格式解析代表时间的字符串str 。</span></span><span class="hljs-function"><span class="hljs-comment">     * </span></span><span class="hljs-function"><span class="hljs-comment">     * 解析时会逐个使用parsePatterns中的格式，如果都没有匹配上， 则抛出异常ParseException 。</span></span><span class="hljs-function"><span class="hljs-comment">     * </span></span><span class="hljs-function"><span class="hljs-comment">     * @param str  被解析的时间字符串，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param parsePatterns  用于解析str的时间格式，有一个或几个，非null</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">parseDate</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String str, <span class="hljs-keyword">final</span> String... parsePatterns)</span> <span class="hljs-keyword">throws</span> ParseException</span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 尝试用parsePatterns中各种不同的日期格式解析代表时间的字符串str 。</span></span><span class="hljs-function"><span class="hljs-comment">     * 解析时会使用给定的日期格式符locale 。</span></span><span class="hljs-function"><span class="hljs-comment">     * </span></span><span class="hljs-function"><span class="hljs-comment">     * 解析时会逐个使用parsePatterns中的格式，如果都没有匹配上， 则抛出异常ParseException 。</span></span><span class="hljs-function"><span class="hljs-comment">     * </span></span><span class="hljs-function"><span class="hljs-comment">     * @param str  被解析的时间字符串，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param locale 使用locale中的日期格式符，如果为null，则使用系统默认的locale</span></span><span class="hljs-function"><span class="hljs-comment">     * @param parsePatterns  用于解析str的时间格式，有一个或几个，非null</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">parseDate</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String str, <span class="hljs-keyword">final</span> Locale locale, <span class="hljs-keyword">final</span> String... parsePatterns)</span> <span class="hljs-keyword">throws</span> ParseException</span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 尝试用parsePatterns中各种不同的日期格式解析代表时间的字符串str 。</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * 解析时会逐个使用parsePatterns中的格式，如果都没有匹配上， 则抛出异常ParseException 。</span></span><span class="hljs-function"><span class="hljs-comment">     * 解析器解析严格不允许的日期， 如：&quot;February 942, 1996&quot; 。</span></span><span class="hljs-function"><span class="hljs-comment">     * </span></span><span class="hljs-function"><span class="hljs-comment">     * @param str  被解析的时间字符串，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param parsePatterns  用于解析str的时间格式，有一个或几个，非null</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">parseDateStrictly</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String str, <span class="hljs-keyword">final</span> String... parsePatterns)</span> <span class="hljs-keyword">throws</span> ParseException</span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 尝试用parsePatterns中各种不同的日期格式解析代表时间的字符串str 。</span></span><span class="hljs-function"><span class="hljs-comment">     * 解析时会使用给定的日期格式符locale 。</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * 解析时会逐个使用parsePatterns中的格式，如果都没有匹配上， 则抛出异常ParseException 。</span></span><span class="hljs-function"><span class="hljs-comment">     * 解析器解析严格不允许的日期， 如：&quot;February 942, 1996&quot; 。</span></span><span class="hljs-function"><span class="hljs-comment">     * </span></span><span class="hljs-function"><span class="hljs-comment">     * @param str  被解析的时间字符串，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param locale 使用locale中的日期格式符，如果为null，则使用系统默认的locale</span></span><span class="hljs-function"><span class="hljs-comment">     * @param parsePatterns  用于解析str的时间格式，有一个或几个，非null</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">parseDateStrictly</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String str, <span class="hljs-keyword">final</span> Locale locale, <span class="hljs-keyword">final</span> String... parsePatterns)</span> <span class="hljs-keyword">throws</span> ParseException</span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 在日期date上增加amount年 。</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * @param date  处理的日期，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param amount  要加的年数，可能为负数</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">addYears</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Date date, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> amount)</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 在日期date上增加amount月 。</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * @param date  处理的日期，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param amount  要加的月数，可能为负数</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">addMonths</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Date date, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> amount)</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 在日期date上增加amount周 。</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * @param date  处理的日期，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param amount  要加的周数，可能为负数</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">addWeeks</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Date date, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> amount)</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 在日期date上增加amount天 。</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * @param date  处理的日期，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param amount  要加的天数，可能为负数</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">addDays</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Date date, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> amount)</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 在日期date上增加amount小时 。</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * @param date  处理的日期，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param amount  要加的小时数，可能为负数</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">addHours</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Date date, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> amount)</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 在日期date上增加amount分钟 。</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * @param date  处理的日期，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param amount  要加的分钟数，可能为负数</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">addMinutes</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Date date, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> amount)</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 在日期date上增加amount秒 。</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * @param date  处理的日期，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param amount  要加的秒数，可能为负数</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">addSeconds</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Date date, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> amount)</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 在日期date上增加amount 毫秒 。</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * @param date  处理的日期，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param amount  要加的毫秒数，可能为负数</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">addMilliseconds</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Date date, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> amount)</span></span><span class="hljs-function">     <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 给日期data设置一个新的年份 。</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * @param date 处理的日期，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param amount 要设置的年份</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">setYears</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Date date, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> amount)</span></span><span class="hljs-function">     <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 给日期data设置一个新的月份 。</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * @param date 处理的日期，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param amount 要设置的月份</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">setMonths</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Date date, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> amount)</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 给日期data设置一个新的天 。</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * @param date 处理的日期，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param amount 要设置的天</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">setDays</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Date date, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> amount)</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 给日期data设置一个新的小时 。</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * @param date 处理的日期，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param amount 要设置的小时</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">setHours</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Date date, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> amount)</span></span><span class="hljs-function">     <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 给日期data设置一个新的分钟 。</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * @param date 处理的日期，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param amount 要设置的分钟</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">setMinutes</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Date date, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> amount)</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 给日期data设置一个新的秒 。</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * @param date 处理的日期，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param amount 要设置的秒</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">setSeconds</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Date date, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> amount)</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 给日期data设置一个新的毫秒 。</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * @param date 处理的日期，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param amount 要设置的毫秒</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">setMilliseconds</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Date date, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> amount)</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 将一个日期放到日历中 。</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Calendar <span class="hljs-title">toCalendar</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Date date)</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 根据阈值field四舍五入日历date 。</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * 例如， 如果你的时间是 28 Mar 2002 13:45:01.231，</span></span><span class="hljs-function"><span class="hljs-comment">     * 如果field为HOUR，它将返回 28 Mar 2002 14:00:00.000；</span></span><span class="hljs-function"><span class="hljs-comment">     * 如果field为MONTH，它将返回 1 April 2002 0:00:00.000 。</span></span><span class="hljs-function"><span class="hljs-comment">     * </span></span><span class="hljs-function"><span class="hljs-comment">     * @param date  处理的日期，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param field  阈值</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">round</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Date date, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> field)</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 根据阈值field四舍五入日历date 。</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * 例如， 如果你的时间是 28 Mar 2002 13:45:01.231，</span></span><span class="hljs-function"><span class="hljs-comment">     * 如果field为HOUR，它将返回 28 Mar 2002 14:00:00.000；</span></span><span class="hljs-function"><span class="hljs-comment">     * 如果field为MONTH，它将返回 1 April 2002 0:00:00.000 。</span></span><span class="hljs-function"><span class="hljs-comment">     * </span></span><span class="hljs-function"><span class="hljs-comment">     * @param date  处理的日期，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param field  阈值  </span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Calendar <span class="hljs-title">round</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Calendar date, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> field)</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 根据阈值field四舍五入日历date 。</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * 例如， 如果你的时间是 28 Mar 2002 13:45:01.231，</span></span><span class="hljs-function"><span class="hljs-comment">     * 如果field为HOUR，它将返回 28 Mar 2002 14:00:00.000；</span></span><span class="hljs-function"><span class="hljs-comment">     * 如果field为MONTH，它将返回 1 April 2002 0:00:00.000 。</span></span><span class="hljs-function"><span class="hljs-comment">     * </span></span><span class="hljs-function"><span class="hljs-comment">     * @param date  处理的日期，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param field  阈值 </span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">round</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Object date, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> field)</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 根据阈值field截取日期date 。</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * 例如， 如果你的时间是 28 Mar 2002 13:45:01.231，</span></span><span class="hljs-function"><span class="hljs-comment">     * 如果field为HOUR，它将返回 28 Mar 2002 13:00:00.000；</span></span><span class="hljs-function"><span class="hljs-comment">     * 如果field为MONTH，它将返回 1 Mar 2002 0:00:00.000 。</span></span><span class="hljs-function"><span class="hljs-comment">     * </span></span><span class="hljs-function"><span class="hljs-comment">     * @param date  处理的日期，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param field  阈值 </span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">truncate</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Date date, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> field)</span></span><span class="hljs-function">     <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 根据阈值field截取日历date 。</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * 例如， 如果你的时间是 28 Mar 2002 13:45:01.231，</span></span><span class="hljs-function"><span class="hljs-comment">     * 如果field为HOUR，它将返回 28 Mar 2002 13:00:00.000；</span></span><span class="hljs-function"><span class="hljs-comment">     * 如果field为MONTH，它将返回 1 Mar 2002 0:00:00.000 。</span></span><span class="hljs-function"><span class="hljs-comment">     * </span></span><span class="hljs-function"><span class="hljs-comment">     * @param date  处理的日期，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param field  阈值</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Calendar <span class="hljs-title">truncate</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Calendar date, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> field)</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 根据阈值field截取日期date 。</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * 例如， 如果你的时间是 28 Mar 2002 13:45:01.231，</span></span><span class="hljs-function"><span class="hljs-comment">     * 如果field为HOUR，它将返回 28 Mar 2002 13:00:00.000；</span></span><span class="hljs-function"><span class="hljs-comment">     * 如果field为MONTH，它将返回 1 Mar 2002 0:00:00.000 。</span></span><span class="hljs-function"><span class="hljs-comment">     * </span></span><span class="hljs-function"><span class="hljs-comment">     * @param date  处理的日期，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param field  阈值</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">truncate</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Object date, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> field)</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 根据阈值field向上舍入日期date 。</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * 例如， 如果你的时间是 28 Mar 2002 13:45:01.231，</span></span><span class="hljs-function"><span class="hljs-comment">     * 如果field为HOUR，它将返回 28 Mar 2002 14:00:00.000；</span></span><span class="hljs-function"><span class="hljs-comment">     * 如果field为MONTH，它将返回 1 Apr 2002 0:00:00.000 。</span></span><span class="hljs-function"><span class="hljs-comment">     * </span></span><span class="hljs-function"><span class="hljs-comment">     * @param date  处理的日期，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param field  阈值</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">ceiling</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Date date, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> field)</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 根据阈值field向上舍入日期date 。</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * 例如， 如果你的时间是 28 Mar 2002 13:45:01.231，</span></span><span class="hljs-function"><span class="hljs-comment">     * 如果field为HOUR，它将返回 28 Mar 2002 14:00:00.000；</span></span><span class="hljs-function"><span class="hljs-comment">     * 如果field为MONTH，它将返回 1 Apr 2002 0:00:00.000 。</span></span><span class="hljs-function"><span class="hljs-comment">     * </span></span><span class="hljs-function"><span class="hljs-comment">     * @param date  处理的日期，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param field  阈值</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Calendar <span class="hljs-title">ceiling</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Calendar date, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> field)</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 根据阈值field向上舍入日期date 。</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * 例如， 如果你的时间是 28 Mar 2002 13:45:01.231，</span></span><span class="hljs-function"><span class="hljs-comment">     * 如果field为HOUR，它将返回 28 Mar 2002 14:00:00.000；</span></span><span class="hljs-function"><span class="hljs-comment">     * 如果field为MONTH，它将返回 1 Apr 2002 0:00:00.000 。</span></span><span class="hljs-function"><span class="hljs-comment">     * </span></span><span class="hljs-function"><span class="hljs-comment">     * @param date  处理的日期，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param field  阈值</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">ceiling</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Object date, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> field)</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 根据指定的时间focus和范围类型rangeStyle构建一个时间范围迭代器 。</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * 如传入的时间是Thursday, July 4, 2002，范围类型是RANGE_MONTH_SUNDAY，</span></span><span class="hljs-function"><span class="hljs-comment">     * 则返回迭代器的范围是从Sunday, June 30, 2002 到 Saturday, August 3, 2002</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * @param focus  指定的时间</span></span><span class="hljs-function"><span class="hljs-comment">     * @param rangeStyle  范围类型，值必须是如下之一：</span></span><span class="hljs-function"><span class="hljs-comment">     * DateUtils.RANGE_MONTH_SUNDAY， </span></span><span class="hljs-function"><span class="hljs-comment">     * DateUtils.RANGE_MONTH_MONDAY，</span></span><span class="hljs-function"><span class="hljs-comment">     * DateUtils.RANGE_WEEK_SUNDAY，</span></span><span class="hljs-function"><span class="hljs-comment">     * DateUtils.RANGE_WEEK_MONDAY，</span></span><span class="hljs-function"><span class="hljs-comment">     * DateUtils.RANGE_WEEK_RELATIVE，</span></span><span class="hljs-function"><span class="hljs-comment">     * DateUtils.RANGE_WEEK_CENTER</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Iterator&lt;Calendar&gt; <span class="hljs-title">iterator</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Date focus, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> rangeStyle)</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 根据指定的时间focus和范围类型rangeStyle构建一个时间范围迭代器 。</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * 如传入的时间是Thursday, July 4, 2002，范围类型是RANGE_MONTH_SUNDAY，</span></span><span class="hljs-function"><span class="hljs-comment">     * 则返回迭代器的范围是从Sunday, June 30, 2002 到 Saturday, August 3, 2002</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * @param focus  指定的时间</span></span><span class="hljs-function"><span class="hljs-comment">     * @param rangeStyle  范围类型，值必须是如下之一：</span></span><span class="hljs-function"><span class="hljs-comment">     * DateUtils.RANGE_MONTH_SUNDAY， </span></span><span class="hljs-function"><span class="hljs-comment">     * DateUtils.RANGE_MONTH_MONDAY，</span></span><span class="hljs-function"><span class="hljs-comment">     * DateUtils.RANGE_WEEK_SUNDAY，</span></span><span class="hljs-function"><span class="hljs-comment">     * DateUtils.RANGE_WEEK_MONDAY，</span></span><span class="hljs-function"><span class="hljs-comment">     * DateUtils.RANGE_WEEK_RELATIVE，</span></span><span class="hljs-function"><span class="hljs-comment">     * DateUtils.RANGE_WEEK_CENTER</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Iterator&lt;Calendar&gt; <span class="hljs-title">iterator</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Calendar focus, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> rangeStyle)</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 根据指定的时间focus和范围类型rangeStyle构建一个时间范围迭代器 。</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * 如传入的时间是Thursday, July 4, 2002，范围类型是RANGE_MONTH_SUNDAY，</span></span><span class="hljs-function"><span class="hljs-comment">     * 则返回迭代器的范围是从Sunday, June 30, 2002 到 Saturday, August 3, 2002</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * @param focus  指定的时间</span></span><span class="hljs-function"><span class="hljs-comment">     * @param rangeStyle  范围类型，值必须是iterator(Calendar, int)方法注释中列出的</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Iterator&lt;?&gt; <span class="hljs-title">iterator</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Object focus, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> rangeStyle)</span></span><span class="hljs-function"> </span><span class="hljs-function"><span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 返回指定分段内的毫秒数 。 所有大于分段的DateFields将被忽略 。</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * 请求任何日期毫秒，将返回当前秒的毫秒数 (返回一个数字在0和999之间) 。</span></span><span class="hljs-function"><span class="hljs-comment">     * 有效的分段值是： Calendar.YEAR、Calendar.MONTH、Calendar.DAY_OF_YEAR、</span></span><span class="hljs-function"><span class="hljs-comment">     * Calendar.DATE、Calendar.HOUR_OF_DAY、Calendar.MINUTE、</span></span><span class="hljs-function"><span class="hljs-comment">     * Calendar.SECOND 和 Calendar.MILLISECOND</span></span><span class="hljs-function"><span class="hljs-comment">     * 分段值小于或等于MILLISECOND，将返回0 。</span></span><span class="hljs-function"><span class="hljs-comment">     * </span></span><span class="hljs-function"><span class="hljs-comment">     *  January 1, 2008 7:15:10.538 with Calendar.SECOND as fragment will return 538</span></span><span class="hljs-function"><span class="hljs-comment">     *  January 6, 2008 7:15:10.538 with Calendar.SECOND as fragment will return 538</span></span><span class="hljs-function"><span class="hljs-comment">     *  January 6, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10538</span></span><span class="hljs-function"><span class="hljs-comment">     *  January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0</span></span><span class="hljs-function"><span class="hljs-comment">     *   (a millisecond cannot be split in milliseconds)</span></span><span class="hljs-function"><span class="hljs-comment">     * </span></span><span class="hljs-function"><span class="hljs-comment">     * @param calendar 获取值得日历对象，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param fragment 分段值</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getFragmentInMilliseconds</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Calendar calendar, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> fragment)</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 返回指定分段内的秒数 。 所有大于分段的DateFields将被忽略 。</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * 请求任何日期秒，将返回当前的分钟的秒数 (返回一个数字在0和59之间) 。</span></span><span class="hljs-function"><span class="hljs-comment">     * 有效的分段值是： Calendar.YEAR、Calendar.MONTH、Calendar.DAY_OF_YEAR、</span></span><span class="hljs-function"><span class="hljs-comment">     * Calendar.DATE、Calendar.HOUR_OF_DAY、Calendar.MINUTE、</span></span><span class="hljs-function"><span class="hljs-comment">     * Calendar.SECOND 和 Calendar.MILLISECOND</span></span><span class="hljs-function"><span class="hljs-comment">     * 分段值小于或等于SECOND，将返回0 。</span></span><span class="hljs-function"><span class="hljs-comment">     * </span></span><span class="hljs-function"><span class="hljs-comment">     *  January 1, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10</span></span><span class="hljs-function"><span class="hljs-comment">     *  January 6, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10</span></span><span class="hljs-function"><span class="hljs-comment">     *  January 6, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 26110</span></span><span class="hljs-function"><span class="hljs-comment">     *   (7*3600 + 15*60 + 10)&lt;/li&gt;</span></span><span class="hljs-function"><span class="hljs-comment">     *  January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0</span></span><span class="hljs-function"><span class="hljs-comment">     * </span></span><span class="hljs-function"><span class="hljs-comment">     * @param calendar 获取值得日历对象，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param fragment 分段值</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getFragmentInSeconds</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Calendar calendar, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> fragment)</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 返回指定分段内的分钟数 。 所有大于分段的DateFields将被忽略 。</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * 请求任何日期分钟，将返回当前的小时的分钟数 (返回一个数字在0和59之间)</span></span><span class="hljs-function"><span class="hljs-comment">     * 有效的分段值是： Calendar.YEAR、Calendar.MONTH、Calendar.DAY_OF_YEAR、</span></span><span class="hljs-function"><span class="hljs-comment">     * Calendar.DATE、Calendar.HOUR_OF_DAY、Calendar.MINUTE、</span></span><span class="hljs-function"><span class="hljs-comment">     * Calendar.SECOND 和 Calendar.MILLISECOND</span></span><span class="hljs-function"><span class="hljs-comment">     * 分段值小于或等于MINUTE，将返回0 。</span></span><span class="hljs-function"><span class="hljs-comment">     * </span></span><span class="hljs-function"><span class="hljs-comment">     *  January 1, 2008 7:15:10.538 with Calendar.HOUR_OF_DAY as fragment will return 15</span></span><span class="hljs-function"><span class="hljs-comment">     *  January 6, 2008 7:15:10.538 with Calendar.HOUR_OF_DAY as fragment will return 15</span></span><span class="hljs-function"><span class="hljs-comment">     *  January 1, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 15</span></span><span class="hljs-function"><span class="hljs-comment">     *  January 6, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 435 (7*60 + 15)</span></span><span class="hljs-function"><span class="hljs-comment">     *  January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0</span></span><span class="hljs-function"><span class="hljs-comment">     * </span></span><span class="hljs-function"><span class="hljs-comment">     * @param calendar 获取值得日历对象，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param fragment 分段值</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getFragmentInMinutes</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Calendar calendar, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> fragment)</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 返回指定分段内的小时数 。 所有大于分段的DateFields将被忽略 。</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * 请求任何日期小时，将返回当前的天的小时数 (返回一个数字在0和23之间) 。</span></span><span class="hljs-function"><span class="hljs-comment">     * 有效的分段值是： Calendar.YEAR、Calendar.MONTH、Calendar.DAY_OF_YEAR、</span></span><span class="hljs-function"><span class="hljs-comment">     * Calendar.DATE、Calendar.HOUR_OF_DAY、Calendar.MINUTE、</span></span><span class="hljs-function"><span class="hljs-comment">     * Calendar.SECOND 和 Calendar.MILLISECOND</span></span><span class="hljs-function"><span class="hljs-comment">     * 分段值小于或等于HOUR_OF_DAY，将返回0 。</span></span><span class="hljs-function"><span class="hljs-comment">     *  </span></span><span class="hljs-function"><span class="hljs-comment">     *  January 1, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 7</span></span><span class="hljs-function"><span class="hljs-comment">     *  January 6, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 7</span></span><span class="hljs-function"><span class="hljs-comment">     *  January 1, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 7</span></span><span class="hljs-function"><span class="hljs-comment">     *  January 6, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 127 (5*24 + 7)</span></span><span class="hljs-function"><span class="hljs-comment">     *  January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0</span></span><span class="hljs-function"><span class="hljs-comment">     *  </span></span><span class="hljs-function"><span class="hljs-comment">     * @param calendar 获取值得日历对象，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param fragment 分段值</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getFragmentInHours</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Calendar calendar, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> fragment)</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 返回指定分段内的天数 。 所有大于分段的DateFields将被忽略 。</span></span><span class="hljs-function"><span class="hljs-comment">     *</span></span><span class="hljs-function"><span class="hljs-comment">     * 请求任何日期天数，将返回当前的月的天数 (返回一个数字在1和31之间) 。</span></span><span class="hljs-function"><span class="hljs-comment">     * 有效的分段值是： Calendar.YEAR、Calendar.MONTH、Calendar.DAY_OF_YEAR、</span></span><span class="hljs-function"><span class="hljs-comment">     * Calendar.DATE、Calendar.HOUR_OF_DAY、Calendar.MINUTE、</span></span><span class="hljs-function"><span class="hljs-comment">     * Calendar.SECOND 和 Calendar.MILLISECOND</span></span><span class="hljs-function"><span class="hljs-comment">     * 分段值小于或等于DATE，将返回0 。</span></span><span class="hljs-function"><span class="hljs-comment">     * </span></span><span class="hljs-function"><span class="hljs-comment">     *  January 28, 2008 with Calendar.MONTH as fragment will return 28</span></span><span class="hljs-function"><span class="hljs-comment">     *  February 28, 2008 with Calendar.MONTH as fragment will return 28</span></span><span class="hljs-function"><span class="hljs-comment">     *  January 28, 2008 with Calendar.YEAR as fragment will return 28</span></span><span class="hljs-function"><span class="hljs-comment">     *  February 28, 2008 with Calendar.YEAR as fragment will return 59</span></span><span class="hljs-function"><span class="hljs-comment">     *  January 28, 2008 with Calendar.MILLISECOND as fragment will return 0</span></span><span class="hljs-function"><span class="hljs-comment">     * </span></span><span class="hljs-function"><span class="hljs-comment">     * @param calendar 获取值得日历对象，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param fragment 分段值</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getFragmentInDays</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Calendar calendar, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> fragment)</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 截取比较两个日历对象的field处的值是否相同 。</span></span><span class="hljs-function"><span class="hljs-comment">     * </span></span><span class="hljs-function"><span class="hljs-comment">     * @param cal1 第一个日历对象，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param cal2 第二个日历对象，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param field Calendar中的阈值</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">truncatedEquals</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Calendar cal1, <span class="hljs-keyword">final</span> Calendar cal2, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> field)</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 截取比较两个日期对象的field处的值是否相同 。</span></span><span class="hljs-function"><span class="hljs-comment">     * </span></span><span class="hljs-function"><span class="hljs-comment">     * @param date1 第一个日期对象，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param date2 第二个日期对象，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param field Calendar中的阈值</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">truncatedEquals</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Date date1, <span class="hljs-keyword">final</span> Date date2, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> field)</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 截取比较两个日历对象的field处的值 。</span></span><span class="hljs-function"><span class="hljs-comment">     * 如果第一个日历小于、等于、大于第二个，则对应返回负整数、0、正整数</span></span><span class="hljs-function"><span class="hljs-comment">     * </span></span><span class="hljs-function"><span class="hljs-comment">     * @param cal1 第一个日历对象，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param cal2 第二个日历对象，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param field Calendar中的阈值</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">truncatedCompareTo</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Calendar cal1, <span class="hljs-keyword">final</span> Calendar cal2, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> field)</span></span><span class="hljs-function">    <span class="hljs-comment">/**</span></span><span class="hljs-function"><span class="hljs-comment">     * 截取比较断两个日期对象的field处的值 。</span></span><span class="hljs-function"><span class="hljs-comment">     * 如果第一个日期小于、等于、大于第二个，则对应返回负整数、0、正整数</span></span><span class="hljs-function"><span class="hljs-comment">     * </span></span><span class="hljs-function"><span class="hljs-comment">     * @param date1 第一个日期对象，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param date2 第二个日期对象，非null</span></span><span class="hljs-function"><span class="hljs-comment">     * @param field Calendar中的阈值</span></span><span class="hljs-function"><span class="hljs-comment">     */</span></span><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">truncatedCompareTo</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Date date1, <span class="hljs-keyword">final</span> Date date2, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> field)</span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>date</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>apache-dav-config</title>
    <link href="/2020/05/05/apache-config-config/"/>
    <url>/2020/05/05/apache-config-config/</url>
    
    <content type="html"><![CDATA[<h2 id="1-安装apache"><a href="#1-安装apache" class="headerlink" title="1.安装apache"></a>1.安装apache</h2><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo apt-get install apache2 apache2-utils</code></pre></div><h2 id="2-启用dav模块"><a href="#2-启用dav模块" class="headerlink" title="2.启用dav模块"></a>2.启用dav模块</h2><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo a2enmod dav_fssudo a2enmod davsudo a2enmod dav_lock</code></pre></div><h2 id="3-创建webdav目录及DavLockDB文件"><a href="#3-创建webdav目录及DavLockDB文件" class="headerlink" title="3.创建webdav目录及DavLockDB文件"></a>3.创建webdav目录及DavLockDB文件</h2><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo mkdir /var/webdavsudo chown www-data:www-data /var/webdavsudo touch /var/DavLocksudo chown www-data:www-data /var/DavLock</code></pre></div><h2 id="4-增加访问用户-例如用户-alex"><a href="#4-增加访问用户-例如用户-alex" class="headerlink" title="4.增加访问用户(例如用户 alex)"></a>4.增加访问用户(例如用户 alex)</h2><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo htpasswd -c /var/passwd.dav alex<span class="hljs-meta">#</span><span class="bash"> 此处会输入密码2次</span>sudo chown www-data:www-data /var/passwd.davsudo chmod 640 /var/www/passwd.dav</code></pre></div><h2 id="5-配置虚拟主机"><a href="#5-配置虚拟主机" class="headerlink" title="5.配置虚拟主机"></a>5.配置虚拟主机</h2><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo vim /etc/apache2/site-available/000-default.conf<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">###########################</span></span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 内容开始</span></span><span class="hljs-meta">#</span><span class="bash"> 80端口冲突需要修改此处及 /etc/apache2/ports.conf 文件</span>&lt;VirtualHost *:80&gt;        ServerAdmin webmaster@localhost        DocumentRoot /var/webdav        ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log        CustomLog $&#123;APACHE_LOG_DIR&#125;/access.log combined                DavLockDB &quot;/var/DavLock&quot;        &lt;Directory /var/webdav/&gt;                Options Indexes MultiViews                AllowOverride None                Order allow,deny                allow from all        &lt;/Directory&gt;        Alias /webdav /var/webdav        &lt;Location /webdav&gt;             DAV On             AuthType Basic             AuthName &quot;webdav&quot;             AuthUserFile /var/webdav/passwd.dav             Require valid-user        &lt;/Location&gt;&lt;/VirtualHost&gt;<span class="hljs-meta">#</span><span class="bash"> vim: syntax=apache ts=4 sw=4 sts=4 sr noet</span>======================================</code></pre></div><h2 id="6-重启apache服务及测试"><a href="#6-重启apache服务及测试" class="headerlink" title="6.重启apache服务及测试"></a>6.重启apache服务及测试</h2><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo systemctl restart apache2<span class="hljs-meta">#</span><span class="bash"> 命令行测试用 cadaver</span>cadaver http://127.0.0.1/webdav<span class="hljs-meta">#</span><span class="bash"> Win客户端可以使用 WinSCP</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>apache</category>
      
    </categories>
    
    
    <tags>
      
      <tag>apache</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>apache-config-virtual</title>
    <link href="/2020/05/05/apache-config-virtual/"/>
    <url>/2020/05/05/apache-config-virtual/</url>
    
    <content type="html"><![CDATA[<h2 id="apache虚拟主机配置"><a href="#apache虚拟主机配置" class="headerlink" title="apache虚拟主机配置"></a>apache虚拟主机配置</h2><p>apache2.4的最终配置效果:</p><p><strong>httpd.conf</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml">Listen 19010# Virtual hostsInclude conf/extra/httpd-vhosts.conf</code></pre></div><p><strong>httpd-vhosts.conf</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"># IP:Port,以端口号配置虚拟机<span class="hljs-tag">&lt;<span class="hljs-name">VirtualHost</span> <span class="hljs-attr">127.0.0.1:19010</span>&gt;</span>    # 网站错误时提示的联系管理员邮箱（可不配置）    ServerAdmin webmaster@dummy-host.example.com    # 虚拟主机根目录    DocumentRoot &quot;$&#123;SRVROOT&#125;&quot;    # 服务器名称（可不配置）    ServerName dummy-host.example.com    # 服务器别名（可不配置）    ServerAlias www.dummy-host.example.com    # 错误日志    ErrorLog &quot;logs/dummy-host.example.com-error.log&quot;    # 访问日志    CustomLog &quot;logs/dummy-host.example.com-access.log&quot; common    # 访问目录的配置，可以是其的一个子文件夹    <span class="hljs-tag">&lt;<span class="hljs-name">Directory</span> &quot;$&#123;<span class="hljs-attr">SRVROOT</span>&#125;/<span class="hljs-attr">public</span>&quot;&gt;</span>        # 控制特定目录将启用哪些服务器特性Options FollowSymLinks        # 指明Apache服务器是否去找.htacess文件作为配置文件AllowOverride All        # 控制请求是否可以访问Require all granted<span class="hljs-tag">&lt;/<span class="hljs-name">Directory</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">VirtualHost</span>&gt;</span></code></pre></div><p>部分参数详细说明：</p><p><strong>Options FollowSymLinks</strong></p><p>Options指令是Apache配置文件中一个比较常见也比较重要的指令，Options指令可以在Apache服务器核心配置(server config)、虚拟主机配置(virtual host)、特定目录配置(directory)以及.htaccess文件中使用。</p><p>Options指令的主要作用是控制特定目录将启用哪些服务器特性。</p><p>All</p><p>表示除 <code>MultiViews</code>之外的所有特性。这也是Options指令的默认设置。</p><p>None</p><p>表示不启用任何的服务器特性。</p><p>FollowSymLinks</p><p>服务器允许在此目录中使用符号连接。如果该配置选项位于 <code>&lt;Location&gt;</code>配置段中，将会被忽略。</p><p>Indexes</p><p>如果输入的网址对应服务器上的一个文件目录，而此目录中又没有 <code>DirectoryIndex</code>指令(例如： <code>DirectoryIndex index.html index.php</code>)，那么服务器会返回由 <code>mod_autoindex</code>模块生成的一个格式化后的目录列表，并列出该目录下的所有文件。</p><p>MultiViews</p><p>允许使用 <code>mod_negotiation</code>模块提供内容协商的”多重视图”。</p><p>SymLinksIfOwnerMatch</p><p>服务器仅在符号连接与目标文件或目录的所有者具有相同的用户ID时才使用它。</p><p>ExecCGI</p><p>允许使用 <code>mod_cgi</code>模块执行CGI脚本。</p><p>Includes</p><p>允许使用 <code>mod_include</code>模块提供的服务器端包含功能。</p><p>IncludesNOEXEC</p><p>允许服务器端包含，但禁用”#exec cmd”和”#exec cgi”。但仍可以从 <code>ScriptAlias</code>目录使用”#include virtual”虚拟CGI脚本。</p><p><strong>AllowOverride All</strong></p><p>AllowOverride参数就是指明Apache服务器是否去找.htacess文件作为配置文件，如果设置为none,那么服务器将忽略.htacess文件，如果设置为All,那么所有在.htaccess文件里有的指令都将被重写。对于AllowOverride，还可以对它指定如下一些能被重写的指令类型。</p><p>从安全性考虑，根目录的AllowOverride属性一般都配置成不允许任何Override 。</p><p>None</p><p>网站 .htaccess 文件将被完全忽略。</p><p>All</p><p>所有具有 .htaccess 作用域的指令都允许出现在 .htaccess 文件中。</p><p>AuthConfig</p><p>允许使用与认证授权相关的指令(AuthDBMGroupFile, AuthDBMUserFile, AuthGroupFile, AuthName, AuthType, AuthUserFile, Require, 等)。</p><p>FileInfo</p><p>允许使用控制文档类型的指令(DefaultType, ErrorDocument, ForceType, LanguagePriority, SetHandler, SetInputFilter, SetOutputFilter, mod_mime中的 Add* 和 Remove* 指令等等)、控制文档元数据的指令(Header, RequestHeader, SetEnvIf, SetEnvIfNoCase, BrowserMatch, CookieExpires, CookieDomain, CookieStyle, CookieTracking, CookieName)、mod_rewrite中的指令(RewriteEngine, RewriteOptions, RewriteBase, RewriteCond, RewriteRule)和mod_actions中的Action指令。</p><p>Indexes</p><p>允许使用控制目录索引的指令(AddDescription, AddIcon, AddIconByEncoding, AddIconByType, DefaultIcon, DirectoryIndex, FancyIndexing, HeaderName, IndexIgnore, IndexOptions, ReadmeName, 等)。</p><p>Limit</p><p>允许使用控制主机访问的指令(Allow, Deny, Order)。 一般 Apache 新安装 AllowOverride 默认为「None」。</p><p>一般都尽可能避免使用.htaccess文件，任何希望放在.htaccess文件中的配置，都可放在主配置的”<Directory>”段中。避免使用的原因主要有：</p><p>性能问题</p><p>如果AllowOverride启用.htaccess文件，则Apache会在每个目录中查找.htaccess文件，因此启用.htaccess都会导致性能的下降。</p><p>另外，对每一个请求，都需要读取一次.htaccess文件。</p><p>还有，Apache必须在所有上级的目录中查找.htaccess文件，以使所有有效的指令都起作用(参见指令的生效)</p><p>安全问题</p><p>允许用户自己修改apache的配置，可能会导致某些意想不到的修改，如果给予用户较少的特权而不能满足其需要，则会带来额外的技术支持请求，所以必须明确地告诉用户已经给予他们的权限，说明AllowOverride设置的值，并引导他们参阅相应的说明，以免日后生出许多麻烦。</p><p><strong>Require all granted</strong></p><p>在Apache2.2版本中，访问控制是基于客户端的主机名、IP地址以及客户端请求中的其他特征，使用Order(排序), Allow(允许), Deny(拒绝),Satisfy(满足)指令来实现。</p><p>在Apache2.4版本中，使用mod_authz_host这个新的模块，来实现访问控制，其他授权检查也以同样的方式来完成。旧的访问控制语句应当被新的授权认证机制所取代，即便Apache已经提供了mod_access_compat这一新模块来兼容旧语句。</p><p>用新方法取代旧语句实现相同的访问控制示例：</p><p>1.所有请求都被拒绝</p><p>Apache2.2 配置:</p><p>Order deny,allow #排序，先拒绝后允许</p><p>Deny from all #拒绝所有</p><p>Apache2.4 配置:</p><p>Require all denied #拒绝所有</p><p>2.所有请求都被允许</p><p>Apache2.2 配置:</p><p>Order allow,deny #排序，先允许后拒绝</p><p>Allow from all #允许所有</p><p>Apache2.4 配置:</p><p>Require all granted #允许所有</p><p><a href="http://3.example.com所有请求都被允许,其他拒绝/">http://3.example.com所有请求都被允许，其他拒绝</a></p><p>Apache2.2 配置:</p><p>Order Deny,Allow #排序，先拒绝后允许</p><p>Deny from all #拒绝所有</p><p>Allow from <a href="https://link.zhihu.com/?target=http://example.com">Example Domain</a> #<a href="https://link.zhihu.com/?target=http://%E5%85%81%E8%AE%B8example.com">允许example.com</a></p><p>Apache2.4 配置:</p><p>Require host <a href="https://link.zhihu.com/?target=http://example.com">Example Domain</a> #<a href="https://link.zhihu.com/?target=http://%E5%85%81%E8%AE%B8example.com">允许example.com</a></p><p>附：常见访问控制指令</p><p>Require all granted #允许所有来源访问</p><p>Require all denied #拒绝所有来源访问</p><p>Require expr expression #允许表达式为true时访问</p><p>Require ip 10 172.1 192.168.2 #允许特定IP段访问，多个段之前用空格隔开，每个段使用开头几项表示</p><p>Require host <a href="https://link.zhihu.com/?target=http://example.com">Example Domain</a> #只允许来自域名example.com的主机访问</p>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>apache</category>
      
    </categories>
    
    
    <tags>
      
      <tag>apache</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时间和字符传的转化</title>
    <link href="/2020/05/05/java-date-time/"/>
    <url>/2020/05/05/java-date-time/</url>
    
    <content type="html"><![CDATA[<h1 id="时间和字符传的转化"><a href="#时间和字符传的转化" class="headerlink" title="时间和字符传的转化"></a>时间和字符传的转化</h1><ol><li>日期转为字符串</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<span class="hljs-keyword">import</span> java.util.Date; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test01</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Date date = <span class="hljs-keyword">new</span> Date(); <span class="hljs-comment">//获取当前时间</span>        System.out.println(date.getClass().getName());  <span class="hljs-comment">//打印date数据类型</span>        System.out.println(date);           <span class="hljs-comment">//打印当前时间</span>        SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);        String format = sdf.format(date);       <span class="hljs-comment">//将Date类型转换成String类型   </span>        System.out.println(format.getClass().getName());<span class="hljs-comment">//打印format数据类型</span>        System.out.println(format);　　　　　　　　　　　　<span class="hljs-comment">//打印当前时间</span>    &#125;&#125;结果：java.util.DateTue Dec <span class="hljs-number">26</span> <span class="hljs-number">19</span>:<span class="hljs-number">31</span>:<span class="hljs-number">48</span> CST <span class="hljs-number">2017</span>java.lang.String<span class="hljs-number">2017</span>-<span class="hljs-number">12</span>-<span class="hljs-number">26</span> <span class="hljs-number">19</span>:<span class="hljs-number">31</span>:<span class="hljs-number">48</span></code></pre></div><ol start="2"><li>字符串转为日期</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.text.ParseException;<span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<span class="hljs-keyword">import</span> java.util.Date; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test01</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        String time = <span class="hljs-string">&quot;1994-11-24 07:11:24&quot;</span>;           SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);        <span class="hljs-keyword">try</span> &#123;            Date date = sdf.parse(time);            System.out.println(date);        &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;            <span class="hljs-comment">// TODO Auto-generated catch block</span>            e.printStackTrace();        &#125;    &#125;&#125;结果：Thu Nov <span class="hljs-number">24</span> <span class="hljs-number">07</span>:<span class="hljs-number">11</span>:<span class="hljs-number">24</span> CST <span class="hljs-number">1994</span></code></pre></div><ol start="3"><li>对日期加减操作, 获得之前, 之后的时间</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<span class="hljs-keyword">import</span> java.util.Date; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);        Date date = <span class="hljs-keyword">new</span> Date();        <span class="hljs-keyword">long</span> dateTime = date.getTime(); <span class="hljs-comment">//将date类型转换成long类型进行计算</span>        System.out.println(sdf.format(date));   <span class="hljs-comment">//以字符串打印当前时间</span>                 <span class="hljs-keyword">long</span> time = (<span class="hljs-number">60</span>*<span class="hljs-number">60</span>+<span class="hljs-number">5</span>)*<span class="hljs-number">1000</span>;     <span class="hljs-comment">//60个60分钟加5分钟，乘以1000，一小时零五分转换成毫秒</span>        dateTime = dateTime + time;     <span class="hljs-comment">//将当前时间加上一小时零五分</span>        System.out.println(sdf.format(<span class="hljs-keyword">new</span> Date(dateTime))); <span class="hljs-comment">//打印一小时零五分之后的时间</span>    &#125; &#125; 结果：<span class="hljs-number">2018</span>-<span class="hljs-number">01</span>-<span class="hljs-number">07</span> 08:<span class="hljs-number">52</span>:<span class="hljs-number">21</span><span class="hljs-number">2018</span>-<span class="hljs-number">01</span>-<span class="hljs-number">07</span> 09:<span class="hljs-number">52</span>:<span class="hljs-number">26</span></code></pre></div><h3 id="时间和数字的转化"><a href="#时间和数字的转化" class="headerlink" title="时间和数字的转化"></a>时间和数字的转化</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.drew.utils; <span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<span class="hljs-keyword">import</span> java.util.Date; <span class="hljs-comment">/**</span><span class="hljs-comment"> * long类型数字转换成时分秒毫秒格式</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> zero 2019/04/11</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConvertorTime</span> </span>&#123;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> seconds = <span class="hljs-number">17854</span>, msec = <span class="hljs-number">360000</span>;<span class="hljs-comment">// 秒，毫秒</span>        System.out.println(secToTime(seconds));        System.out.println(msec + <span class="hljs-string">&quot;毫秒转换格式时间：\t&quot;</span> + msecToTime(msec));        System.out.println(<span class="hljs-string">&quot;当前时间（时:分：秒.毫秒）\t&quot;</span> + <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;HH:mm:ss.SSS&quot;</span>).format(<span class="hljs-keyword">new</span> Date()));    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 秒转换小时-分-秒analytics/util/DateUtil.java</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> seconds 秒为单位 比如..600秒</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 比如...2小时3分钟52秒</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">secToTime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> seconds)</span> </span>&#123;        <span class="hljs-keyword">int</span> hour = seconds / <span class="hljs-number">3600</span>;        <span class="hljs-keyword">int</span> minute = (seconds - hour * <span class="hljs-number">3600</span>) / <span class="hljs-number">60</span>;        <span class="hljs-keyword">int</span> second = (seconds - hour * <span class="hljs-number">3600</span> - minute * <span class="hljs-number">60</span>);         StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();        <span class="hljs-keyword">if</span> (hour &gt; <span class="hljs-number">0</span>) &#123;            sb.append(hour + <span class="hljs-string">&quot;小时&quot;</span>);        &#125;        <span class="hljs-keyword">if</span> (minute &gt; <span class="hljs-number">0</span>) &#123;            sb.append(minute + <span class="hljs-string">&quot;分&quot;</span>);        &#125;        <span class="hljs-keyword">if</span> (second &gt; <span class="hljs-number">0</span>) &#123;            sb.append(second + <span class="hljs-string">&quot;秒&quot;</span>);        &#125;        <span class="hljs-keyword">if</span> (second == <span class="hljs-number">0</span>) &#123;            sb.append(<span class="hljs-string">&quot;&lt;1秒&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> sb.toString();    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将int类型数字转换成时分秒毫秒的格式数据</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time long类型的数据</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> HH:mm:ss.SSS</span><span class="hljs-comment">     * <span class="hljs-doctag">@author</span> zero 2019/04/11</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">msecToTime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> time)</span> </span>&#123;        String timeStr = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">int</span> hour = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> minute = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> second = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> millisecond = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (time &lt;= <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;00:00:00.000&quot;</span>;        <span class="hljs-keyword">else</span> &#123;            second = time / <span class="hljs-number">1000</span>;            minute = second / <span class="hljs-number">60</span>;            millisecond = time % <span class="hljs-number">1000</span>;            <span class="hljs-keyword">if</span> (second &lt; <span class="hljs-number">60</span>) &#123;                timeStr = <span class="hljs-string">&quot;00:00:&quot;</span> + unitFormat(second) + <span class="hljs-string">&quot;.&quot;</span> + unitFormat2(millisecond);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (minute &lt; <span class="hljs-number">60</span>) &#123;                second = second % <span class="hljs-number">60</span>;                timeStr = <span class="hljs-string">&quot;00:&quot;</span> + unitFormat(minute) + <span class="hljs-string">&quot;:&quot;</span> + unitFormat(second) + <span class="hljs-string">&quot;.&quot;</span> + unitFormat2(millisecond);            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 数字&gt;=3600 000的时候</span>                hour = minute / <span class="hljs-number">60</span>;                minute = minute % <span class="hljs-number">60</span>;                second = second - hour * <span class="hljs-number">3600</span> - minute * <span class="hljs-number">60</span>;                timeStr = unitFormat(hour) + <span class="hljs-string">&quot;:&quot;</span> + unitFormat(minute) + <span class="hljs-string">&quot;:&quot;</span> + unitFormat(second) + <span class="hljs-string">&quot;.&quot;</span>                    + unitFormat2(millisecond);            &#125;        &#125;        <span class="hljs-keyword">return</span> timeStr;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">unitFormat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<span class="hljs-comment">// 时分秒的格式转换</span>        String retStr = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; <span class="hljs-number">10</span>)            retStr = <span class="hljs-string">&quot;0&quot;</span> + Integer.toString(i);        <span class="hljs-keyword">else</span>            retStr = <span class="hljs-string">&quot;&quot;</span> + i;        <span class="hljs-keyword">return</span> retStr;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">unitFormat2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<span class="hljs-comment">// 毫秒的格式转换</span>        String retStr = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; <span class="hljs-number">10</span>)            retStr = <span class="hljs-string">&quot;00&quot;</span> + Integer.toString(i);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">10</span> &amp;&amp; i &lt; <span class="hljs-number">100</span>) &#123;            retStr = <span class="hljs-string">&quot;0&quot;</span> + Integer.toString(i);        &#125; <span class="hljs-keyword">else</span>            retStr = <span class="hljs-string">&quot;&quot;</span> + i;        <span class="hljs-keyword">return</span> retStr;    &#125; &#125;</code></pre></div><h6 id="可转为工具类-gt-测试结果"><a href="#可转为工具类-gt-测试结果" class="headerlink" title="可转为工具类=&gt;测试结果"></a>可转为工具类=&gt;测试结果</h6><p><img src="https://img2018.cnblogs.com/blog/1301422/201904/1301422-20190411160134848-2110597655.png" alt="测试结果"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>date</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ssh 配置教程</title>
    <link href="/2020/05/05/linux-ssh-password/"/>
    <url>/2020/05/05/linux-ssh-password/</url>
    
    <content type="html"><![CDATA[<h1 id="1、环境说明"><a href="#1、环境说明" class="headerlink" title="1、环境说明"></a>1、环境说明</h1><p>环境就不进行说明了，比较三次配置，一个配过九台，每每情况各有不同。只能告知各位读者，博主这里使用的是red hat红帽，估计centOS也差不太多，不过有差异也无妨，学会博主方法，相信你就不会蒙蔽了，知道怎么往对的方向走了</p><h1 id="2、场景说明"><a href="#2、场景说明" class="headerlink" title="2、场景说明"></a>2、场景说明</h1><p>要求node1免密登录到node2，这里任选了一个用户，也即是</p><div class="hljs code-wrapper"><pre><code class="hljs java">[hadoop<span class="hljs-meta">@node1</span> .ssh]$ ssh node2</code></pre></div><h1 id="3、ssh登录原理过程"><a href="#3、ssh登录原理过程" class="headerlink" title="3、ssh登录原理过程"></a>3、ssh登录原理过程</h1><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvmrb9225nj60jj08ydgu02.jpg" alt="../img/ssh/ssh-2.png"></p><p>这里看不懂也没关系，楼主详解一番：</p><p>node1发送一个请求，问：node2，你在不在？我想连接你</p><p>node2查找本地是否有node1的公钥，情况一：没有，情况二：有</p><p>情况一：</p><p>node2回复说：我在！你的公钥告诉我一下。</p><p>node1再次发送过去，自己的公钥，</p><p>node2在本地进行计算，存储，得到的一串通过公钥得到的不知道什么钥，返回给node1，说：你看看对不对</p><p>node1告知node2：对！咱们已经建立连接了</p><p>node2警惕的回复node1：你知道我登录密码多少吗？</p><p>用户输入密码…..</p><p>node1把密码封装了发过去：你看是这个不？</p><p>node2回复：对，咱们已经建立连接！</p><p>情况二：</p><p>node2一看本地有node1的公钥，心想原来认识的，然后通过公钥计算出一个不知道什么钥匙，回复：你看看是这个钥匙吗？</p><p>node1告知node2：对！咱们已经建立连接了</p><p>node2回复node1：连接建立成功！</p><p>具体几次握手，博主不知道，大致就是这么个过程</p><p>ssh配置中，会用到下面几个文件：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvmrb678tij60co0273yr02.jpg" alt="../img/ssh/ssh-1.png"></p><p>恩~毫无PS痕迹。。。</p><p>1、需要在node1上生成公钥以及私钥，而id_rsa就是私钥，id_rsa.pub文件就是公钥文件。私钥我们这里就不用了，就用公钥，用完了为了保证安全性，你可以选择删掉，也可以不删，根据你的喜好决定，也就是pub文件</p><p>2、authorized文件，是为了方便node2的，不用询问node1的公钥本地文件，这个单词读者们需要记住，要建立这个文件！</p><p>3、known_hosts，表名node2是认识的主机，这个不用配置，读者可以不用管，可以作为了解原理。比如，一台新系统，.ssh目录下你会发现没有这个文件，但在你第一次ssh以后，这个文件就会生成。</p><p>简单说明：</p><p>​       上面做了原理说明，简单来说：就是node1想要连接node2免密登录node2，需要把node1的id_rsa.pub文件内容写进node2的authorized_keys里面。就大功告成了</p><h1 id="4、最简单配置"><a href="#4、最简单配置" class="headerlink" title="4、最简单配置"></a>4、最简单配置</h1><h2 id="4-1、生成公钥以及密钥："><a href="#4-1、生成公钥以及密钥：" class="headerlink" title="4.1、生成公钥以及密钥："></a>4.1、生成公钥以及密钥：</h2><p>在node1上：</p><div class="hljs code-wrapper"><pre><code class="hljs java">[hadoop<span class="hljs-meta">@node1</span> ~]$ ssh-keygen -t rsa</code></pre></div><p>一路回车。</p><p>若是不想回车，可在上面代码末尾加上，-P “”</p><h2 id="4-2、处理"><a href="#4-2、处理" class="headerlink" title="4.2、处理"></a>4.2、处理</h2><p>方法一：</p><h2 id="将node1的公钥拷贝到node2"><a href="#将node1的公钥拷贝到node2" class="headerlink" title="将node1的公钥拷贝到node2"></a>将node1的公钥拷贝到node2</h2><p>node1上(小心别把node2的id_rsa.pub覆盖掉)</p><div class="hljs code-wrapper"><pre><code class="hljs java">[hadoop<span class="hljs-meta">@node1</span> .ssh]$ scp -p id_rsa.pub hadoop<span class="hljs-meta">@node2</span>:~/.ssh/id_rsa.pub1</code></pre></div><h2 id="然后，node2将公钥加入自身认证"><a href="#然后，node2将公钥加入自身认证" class="headerlink" title="然后，node2将公钥加入自身认证"></a>然后，node2将公钥加入自身认证</h2><p>在node2上：</p><div class="hljs code-wrapper"><pre><code class="hljs java">[hadoop<span class="hljs-meta">@node1</span>.ssh]$ cat id_rsa.pub1 &gt; authorized_key</code></pre></div><p>验证查看文件authorized_key中是否有id_rsa.pub1文件的内容</p><p>方法二：</p><h2 id="直接把自己密钥拷贝到需要免密的机器上："><a href="#直接把自己密钥拷贝到需要免密的机器上：" class="headerlink" title="直接把自己密钥拷贝到需要免密的机器上："></a>直接把自己密钥拷贝到需要免密的机器上：</h2><div class="hljs code-wrapper"><pre><code class="hljs typescript">ssh-copy-id -i ~<span class="hljs-regexp">/.ssh/i</span>d_rsa.pub 用户名<span class="hljs-meta">@ip</span></code></pre></div><p> 将密钥文件直接拷贝到指定用户名、ip。输入密码后，下次你当前用户执行ssh到刚刚指定的用户名ip就不用再输入密码了。</p><p>方法二较方法一方便很多</p><h2 id="4-4、验证：node1连接node2"><a href="#4-4、验证：node1连接node2" class="headerlink" title="4.4、验证：node1连接node2"></a>4.4、验证：node1连接node2</h2><p>在node1上：</p><div class="hljs code-wrapper"><pre><code class="hljs java">[hadoop<span class="hljs-meta">@node1</span> .ssh]$ ssh hadoop<span class="hljs-meta">@node2</span></code></pre></div><p>楼主这里没有截图，不用输入密码发现主机名变了即为成功</p><h1 id="5、调试及常规报错解决"><a href="#5、调试及常规报错解决" class="headerlink" title="5、调试及常规报错解决"></a>5、调试及常规报错解决</h1><h2 id="5-1、说明"><a href="#5-1、说明" class="headerlink" title="5.1、说明"></a>5.1、说明</h2><p>   系统日志：/var/log/secure，是个不知道干什么用的日志。ssh连接失败的报错，在这里记录</p><h2 id="5-2、报错"><a href="#5-2、报错" class="headerlink" title="5.2、报错"></a>5.2、报错</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvmratn4gyj60rd0180ti02.jpg" alt="../img/ssh/ssh-3.png"></p><p>解决：相关目录权限不对，一下列出相关权限。读者根据具体去修改</p><p>​    1、755         ~</p><p>​    2、700         ~/.ssh</p><p>​    3、644         ~/.ssh/authorized_keys(博主实测，600也可，具体的读者试试也就知道了，也不麻烦)</p><p>配置文件选项未开（无图）</p><p>这里楼主没有碰到过，所以没有图，各位读者碰到修改了就好</p><p>解决： vi   /etc/ssh/sshd_config</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvmrawvj78j60l50bvgnp02.jpg" alt="../img/ssh/ssh-4.png"></p><p>这三项需要注释掉，按博主图片中这样就好。</p>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>ssh</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ssh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>homebrew教程</title>
    <link href="/2020/05/05/macos-brew/"/>
    <url>/2020/05/05/macos-brew/</url>
    
    <content type="html"><![CDATA[<h2 id="homebrew"><a href="#homebrew" class="headerlink" title="homebrew"></a>homebrew</h2><p>是osx下的一个包管理工具，可以很方便的管理各类包。官方给出的定义是</p><blockquote><p>macOS缺失的软件包管理器<br> <a href="https://links.jianshu.com/go?to=https://brew.sh/">官方地址</a></p></blockquote><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="1、自动安装-推荐"><a href="#1、自动安装-推荐" class="headerlink" title="1、自动安装(推荐)"></a>1、自动安装(推荐)</h2><p>执行如下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">/usr/bin/ruby -e <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>&quot;</span></code></pre></div><p>上边的命令行是两个命令，首先下载install文件，然后用系统的ruby工具安装。</p><p>尽量再bash或者zsh下安装，fish下会提示不识别’$’。</p><p>不需要使用超级权限（sudo），该文件会将HomeBrew安装至 <code>usr/local</code> 目录下。安装过程中会提示你絮语奥执行哪些动作。</p><div class="hljs code-wrapper"><pre><code class="hljs bash">==&gt; This script will install:/usr/<span class="hljs-built_in">local</span>/bin/brew/usr/<span class="hljs-built_in">local</span>/share/doc/homebrew/usr/<span class="hljs-built_in">local</span>/share/man/man1/brew.1/usr/<span class="hljs-built_in">local</span>/share/zsh/site-functions/_brew/usr/<span class="hljs-built_in">local</span>/etc/bash_completion.d/brew/usr/<span class="hljs-built_in">local</span>/Homebrew==&gt; The following new directories will be created:/usr/<span class="hljs-built_in">local</span>/bin/usr/<span class="hljs-built_in">local</span>/etc/usr/<span class="hljs-built_in">local</span>/include/usr/<span class="hljs-built_in">local</span>/lib/usr/<span class="hljs-built_in">local</span>/sbin/usr/<span class="hljs-built_in">local</span>/share/usr/<span class="hljs-built_in">local</span>/var/usr/<span class="hljs-built_in">local</span>/opt/usr/<span class="hljs-built_in">local</span>/share/zsh/usr/<span class="hljs-built_in">local</span>/share/zsh/site-functions/usr/<span class="hljs-built_in">local</span>/var/homebrew/usr/<span class="hljs-built_in">local</span>/var/homebrew/linked/usr/<span class="hljs-built_in">local</span>/Cellar/usr/<span class="hljs-built_in">local</span>/Caskroom/usr/<span class="hljs-built_in">local</span>/Homebrew/usr/<span class="hljs-built_in">local</span>/Frameworks==&gt; The Xcode Command Line Tools will be installed.</code></pre></div><p>后边还会有一些提示。继续的话会提示输入密码，等待安装完成。</p><p>安装完成后输入 <code>brew -v</code> 即可显示是否安装成功：</p><div class="hljs code-wrapper"><pre><code class="hljs undefined">Homebrew 2.1.9Homebrew&#x2F;homebrew-core (git revision 84988; last commit 2019-07-29)</code></pre></div><h2 id="2、手动安装"><a href="#2、手动安装" class="headerlink" title="2、手动安装"></a>2、手动安装</h2><p>执行如下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs cpp">mkdir homebrew &amp;&amp; curl -L https:<span class="hljs-comment">//github.com/Homebrew/brew/tarball/master | tar xz --strip 1 -C homebrew</span></code></pre></div><p>避免以下两点：</p><p>目录内包含空格<br> 不要安装在 <code>/sw</code> 或者 <code>/opt/local</code> 目录下<br> 当然也可以手动下载安装脚本，然后修改 <code>HOMEBREW_PREFIX</code> 变量的值，改为自己的安装目录。</p><hr><h1 id="brew常用命令"><a href="#brew常用命令" class="headerlink" title="brew常用命令"></a>brew常用命令</h1><h2 id="1、安装卸载软件"><a href="#1、安装卸载软件" class="headerlink" title="1、安装卸载软件"></a>1、安装卸载软件</h2><div class="hljs code-wrapper"><pre><code class="hljs bash">1. `brew --version` 或者 `brew -v` 显示brew版本信息2. `brew install &lt;formula&gt;` 安装指定软件3. `brew uninstall &lt;formula&gt;` 卸载指定软件4. `brew list` 显示所有的已安装的软件5. `brew search text` 搜索本地远程仓库的软件，已安装会显示绿色的勾6. `brew search /text/` 使用正则表达式搜软件7. `brew info &lt;formula&gt;` 显示指定软件信息8. `brew reinstall &lt;formula&gt;` 重新安装指定软件，先卸载后安装9. `brew install &lt;formula&gt; --build-from-source` 源码安装指定软件，可以给定指定参数10. `brew commands`  列出所有可用命令11. brew link &lt;apps&gt; 添加路径</code></pre></div><h2 id="2、升级软件相关"><a href="#2、升级软件相关" class="headerlink" title="2、升级软件相关"></a>2、升级软件相关</h2><div class="hljs code-wrapper"><pre><code class="hljs bash">1. `brew update` 自动升级homebrew （从github下载最新版本）2. `brew outdated` 检测已经过时的软件3. `brew upgrade` 升级所有已过时的软件，即列出的以过时软件4. `brew upgrade &lt;formula&gt;` 升级指定的软件5. `brew pin &lt;formula&gt;` 禁止指定软件升级6. `brew unpin &lt;formula&gt;` 解锁禁止升级7. `brew upgrade --all` 升级所有的软件包，包括未清理干净的旧版本的包8. `brew edit &lt;formula&gt;` 编辑软件，不会的情况下慎用9. `brew tap` 列出本地资源仓库，其中 homebrew 是默认仓库，其它都是第三方仓库10. `brew tap &lt;user/repo&gt;` 添加第三方仓库，命名的规则按照github来定的。[使用](https://links.jianshu.com/go?to=https%3A%2F%2Fdocs.brew.sh%2FTaps)11. `brew untap &lt;user/repo&gt;`  删除仓库12. `brew deps &lt;formula&gt;` 查看指定软件依赖于哪些软件13. `brew uses &lt;formula&gt;` 查看指定软件被哪些软件所依赖</code></pre></div><h2 id="3、清理相关"><a href="#3、清理相关" class="headerlink" title="3、清理相关"></a>3、清理相关</h2><div class="hljs code-wrapper"><pre><code class="hljs bash">homebrew再升级软件时候不会清理相关的旧版本，在软件升级后我们可以使用如下命令清理1. `brew cleanup -n` 列出需要清理的内容2. `brew cleanup &lt;formula&gt;` 清理指定的软件过时包3. `brew cleanup` 清理所有的过时软件4. `brew unistall &lt;formula&gt;` 卸载指定软件5. `brew unistall &lt;fromula&gt; --force` 彻底卸载指定软件，包括旧版本通过brew安装的文件会自动设置环境变量，所以不用担心命令行不能启动的问题。 比如安装好了gradle，即可运行 `gradle -v`</code></pre></div><h2 id="3、brew-services管理后台服务"><a href="#3、brew-services管理后台服务" class="headerlink" title="3、brew services管理后台服务"></a>3、brew services管理后台服务</h2><p>macOS使用 <code>launchctl</code> 命令加载开机自动运行的服务，<code>brew service</code> 可以简化 <code>lauchctl</code> 的操作。</p><p>以MySQL为例，使用launchctl启动:</p><div class="hljs code-wrapper"><pre><code class="hljs ruby">ln -sfv /usr/local/opt/mysql/*.plist ~<span class="hljs-regexp">/Library/</span>LaunchAgentslaunchctl load ~<span class="hljs-regexp">/Library/</span>LaunchAgents/homebrew.mxcl.mysql.plist</code></pre></div><p>如使用 <code>brew service</code> 可以简化为:</p><div class="hljs code-wrapper"><pre><code class="hljs undefined">brew services start mysql</code></pre></div><ul><li>services 常用命令</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash">brew services list  <span class="hljs-comment"># 查看使用brew安装的服务列表</span>brew services run formula|--all  <span class="hljs-comment"># 启动服务（仅启动不注册）</span>brew services start formula|--all  <span class="hljs-comment"># 启动服务，并注册</span>brew services stop formula|--all   <span class="hljs-comment"># 停止服务，并取消注册</span>brew services restart formula|--all  <span class="hljs-comment"># 重启服务，并注册</span>brew services cleanup  <span class="hljs-comment"># 清除已卸载应用的无用的配置</span></code></pre></div><ul><li>配置文件目录</li></ul><div class="hljs code-wrapper"><pre><code class="hljs ruby">/Library/LaunchDaemons <span class="hljs-comment"># 开机自启，需要sudo</span>~<span class="hljs-regexp">/Library/</span>LaunchAgents <span class="hljs-comment"># 用户登录后自启</span></code></pre></div><p>以homebrew.mxcl.kafka.plist为例：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">plist</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//Apple//DTD PLIST 1.0//EN&quot;</span> <span class="hljs-meta-string">&quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plist</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.0&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dict</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>Label<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>homebrew.mxcl.kafka<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>WorkingDirectory<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>/usr/local<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>ProgramArguments<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>/usr/local/opt/kafka/bin/kafka-server-start<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>/usr/local/etc/kafka/server.properties<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>RunAtLoad<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">true</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>KeepAlive<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">true</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>StandardErrorPath<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>/usr/local/var/log/kafka/kafka_output.log<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>StandardOutPath<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>/usr/local/var/log/kafka/kafka_output.log<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dict</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plist</span>&gt;</span></code></pre></div><p>在这里可以找到服务路径、启动参数、日志路径等</p><h2 id="4、brew-cask"><a href="#4、brew-cask" class="headerlink" title="4、brew cask"></a>4、brew cask</h2><p>Homebrew Cask 是 Homebrew 的扩展，借助它可以方便地在 macOS 上安装图形界面程序，即我们常用的各类应用。Homebrew 中文含义为自制、自酿酒，Cask 中文含义为桶、木桶，桶装酒是一种成品，也就是说每一个 homebrew cask 都可以直接使用的，比如 Atom 的 Cask 名称为 atom，那么就可以使用如下命令安装：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">brew cask install atom</code></pre></div><p>甚至也可以提交新的 Cask，比如假设有桌面客户端少数派，则用 <code>brew cask create sspai</code> 创建新的名称为 <code>sspai</code> 的 Cask，当然还要提供官网下载链接、官方主页、应用版本等信息，可以参照 <a href="https://links.jianshu.com/go?to=https://github.com/Homebrew/homebrew-cask/blob/master/CONTRIBUTING.md">官方教程</a>，此处就不再细说。</p><blockquote><p><strong>安装 Homebrew Cask【以后新版不需要安装】</strong><br> 安装好brew 后，就可以执行命令 <code>brew tap caskroom/cask</code> 获取 Homebrew Cask。</p><p><strong>注意：</strong><br> Caskroom 的 Git 地址在 2018 年 5 月 25 日从 <a href="https://links.jianshu.com/go?to=https://github.com/caskroom/homebrew-cask">https://github.com/caskroom/homebrew-cask</a> 迁移到了 <a href="https://links.jianshu.com/go?to=https://github.com/Homebrew/homebrew-cask">https://github.com/Homebrew/homebrew-cask</a><br> 所以，以后就不需要安装 Homebrew Cask</p></blockquote><h4 id="使用-Homebrew-Cask"><a href="#使用-Homebrew-Cask" class="headerlink" title="使用 Homebrew Cask"></a>使用 Homebrew Cask</h4><div class="hljs code-wrapper"><pre><code class="hljs bash">github使用：[https://github.com/Homebrew/homebrew-cask/blob/master/USAGE.md](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FHomebrew%2Fhomebrew-cask%2Fblob%2Fmaster%2FUSAGE.md)1. `brew cask install &lt;formula&gt;`  安装指定图形界面软件2. `brew cask uninstall &lt;formula&gt;`   卸载软件3. `brew cask uninstall --force &lt;formula&gt;`   卸载软件，带参数4. `brew cask search text`   搜索软件5. `brew cask list`   列出所有通过cask安装的软件6. 其它可以参考：[https://github.com/Homebrew/homebrew-cask/blob/master/USAGE.md](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FHomebrew%2Fhomebrew-cask%2Fblob%2Fmaster%2FUSAGE.md)举例可安装的软件</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 安装chrome</span>brew cask install google-chrome<span class="hljs-comment"># 安装LaunchRocket</span>brew cask install launchrocket</code></pre></div><hr><h1 id="Homebrew-更换为国内镜像"><a href="#Homebrew-更换为国内镜像" class="headerlink" title="Homebrew 更换为国内镜像"></a>Homebrew 更换为国内镜像</h1><p>查看镜像地址</p><div class="hljs code-wrapper"><pre><code class="hljs bash">➜  ~ <span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(brew --repo)</span>&quot;</span> ➜  Homebrew git:(stable) <span class="hljs-built_in">pwd</span>/usr/<span class="hljs-built_in">local</span>/Homebrew➜  Homebrew git:(stable) git remote -vorigin  https://github.com/Homebrew/brew (fetch)origin  https://github.com/Homebrew/brew (push)</code></pre></div><h2 id="1、国内镜像安装"><a href="#1、国内镜像安装" class="headerlink" title="1、国内镜像安装"></a>1、国内镜像安装</h2><ul><li>获取官网脚本 并保存名为 brew_install；</li></ul><div class="hljs code-wrapper"><pre><code class="hljs cpp">curl -fsSL https:<span class="hljs-comment">//raw.githubusercontent.com/Homebrew/install/master/install &gt;&gt; brew_install</span></code></pre></div><ul><li>编辑brew_install文件，更改脚本中的资源链接，替换成 <em>中国科学技术大学</em> 的镜像</li></ul><div class="hljs code-wrapper"><pre><code class="hljs objectivec">#BREW_REPO = <span class="hljs-string">&quot;https://github.com/Homebrew/brew&quot;</span>.freezeBREW_REPO = <span class="hljs-string">&quot;git://mirrors.ustc.edu.cn/brew.git&quot;</span>.freeze</code></pre></div><ul><li>安装brew</li></ul><div class="hljs code-wrapper"><pre><code class="hljs undefined">&#x2F;usr&#x2F;bin&#x2F;ruby .&#x2F;brew_install</code></pre></div><h2 id="2、Homebrew替换为中科大源"><a href="#2、Homebrew替换为中科大源" class="headerlink" title="2、Homebrew替换为中科大源"></a>2、Homebrew替换为<a href="https://links.jianshu.com/go?to=https://mirrors.ustc.edu.cn/">中科大源</a></h2><ul><li>Homebrew 源使用帮助 <a href="https://links.jianshu.com/go?to=http://mirrors.ustc.edu.cn/help/brew.git.html">http://mirrors.ustc.edu.cn/help/brew.git.html</a></li><li>Homebrew Core 源使用帮助 <a href="https://links.jianshu.com/go?to=http://mirrors.ustc.edu.cn/help/homebrew-core.git.html">http://mirrors.ustc.edu.cn/help/homebrew-core.git.html</a></li><li>Homebrew Cask 源使用帮助 <a href="https://links.jianshu.com/go?to=http://mirrors.ustc.edu.cn/help/homebrew-cask.git.html">http://mirrors.ustc.edu.cn/help/homebrew-cask.git.html</a></li><li>Homebrew Bottles 源使用帮助 <a href="https://links.jianshu.com/go?to=http://mirrors.ustc.edu.cn/help/homebrew-bottles.html">http://mirrors.ustc.edu.cn/help/homebrew-bottles.html</a></li></ul><h3 id="替换默认源"><a href="#替换默认源" class="headerlink" title="替换默认源"></a>替换默认源</h3><ul><li>替换brew.git</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(brew --repo)</span>&quot;</span>     <span class="hljs-comment"># 其实就是定位至 /usr/local/Homebrew 目录下</span>git remote set-url origin https://mirrors.ustc.edu.cn/brew.git<span class="hljs-comment"># git remote set-url origin git://mirrors.ustc.edu.cn/brew.git</span><span class="hljs-comment"># 重置为官方地址：</span><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(brew --repo)</span>&quot;</span>git remote set-url origin https://github.com/Homebrew/brew.git</code></pre></div><ul><li>替换homebrew-core.git</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(brew --repo)</span>/Library/Taps/homebrew/homebrew-core&quot;</span>git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git<span class="hljs-comment"># git remote set-url origin git://mirrors.ustc.edu.cn/homebrew-core.git</span><span class="hljs-comment"># 重置为官方地址：</span><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(brew --repo)</span>/Library/Taps/homebrew/homebrew-core&quot;</span>git remote set-url origin https://github.com/Homebrew/homebrew-core</code></pre></div><ul><li>默认不安装cask 有需要的可以替换<br> [Homebrew cask 软件仓库，提供 macOS 应用和大型二进制文件]</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(brew --repo)</span>&quot;</span>/Library/Taps/homebrew/homebrew-caskgit remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git<span class="hljs-comment"># git remote set-url origin git://mirrors.ustc.edu.cn/homebrew-cask.git</span><span class="hljs-comment"># 重置为官方地址：</span><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(brew --repo)</span>&quot;</span>/Library/Taps/homebrew/homebrew-caskgit remote set-url origin https://github.com/Homebrew/homebrew-cask</code></pre></div><ul><li>brew 更新</li></ul><div class="hljs code-wrapper"><pre><code class="hljs undefined">brew update</code></pre></div><ul><li>检查是否有误</li></ul><div class="hljs code-wrapper"><pre><code class="hljs undefined">brew doctor</code></pre></div><h3 id="替换Homebrew-Bottles源"><a href="#替换Homebrew-Bottles源" class="headerlink" title="替换Homebrew Bottles源"></a>替换Homebrew Bottles源</h3><ul><li>bash用户</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&#x27;</span> &gt;&gt; ~/.bash_profile<span class="hljs-built_in">source</span> ~/.bash_profile</code></pre></div><ul><li>zsh用户</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&#x27;</span> &gt;&gt; ~/.zshrc<span class="hljs-built_in">source</span> ~/.zshrc</code></pre></div><h2 id="3、Homebrew替换为清华大学源"><a href="#3、Homebrew替换为清华大学源" class="headerlink" title="3、Homebrew替换为清华大学源"></a>3、Homebrew替换为<a href="https://links.jianshu.com/go?to=https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/">清华大学源</a></h2><h3 id="替换默认源-1"><a href="#替换默认源-1" class="headerlink" title="替换默认源"></a>替换默认源</h3><ul><li>替换现有上游</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash">git -C <span class="hljs-string">&quot;<span class="hljs-subst">$(brew --repo)</span>&quot;</span> remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.gitgit -C <span class="hljs-string">&quot;<span class="hljs-subst">$(brew --repo homebrew/core)</span>&quot;</span> remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.gitbrew update</code></pre></div><ul><li>复原</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash">git -C <span class="hljs-string">&quot;<span class="hljs-subst">$(brew --repo)</span>&quot;</span> remote set-url origin https://github.com/Homebrew/brew.gitgit -C <span class="hljs-string">&quot;<span class="hljs-subst">$(brew --repo homebrew/core)</span>&quot;</span> remote set-url origin https://github.com/Homebrew/homebrew-corebrew update</code></pre></div><h3 id="替换Homebrew-Bottles源-1"><a href="#替换Homebrew-Bottles源-1" class="headerlink" title="替换Homebrew Bottles源"></a>替换Homebrew Bottles源</h3><ul><li>bash用户</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles&#x27;</span> &gt;&gt; ~/.bash_profile<span class="hljs-built_in">source</span> ~/.bash_profile</code></pre></div><ul><li>zsh用户</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles&#x27;</span> &gt;&gt; ~/.zshrc<span class="hljs-built_in">source</span> ~/.zshrc</code></pre></div><blockquote><p>中科大源 和 清华大学源 其实在操作上是一样的，而本文档分了两部份整理，是为了区分 和更容易理解</p></blockquote><h1 id="常用软件安装"><a href="#常用软件安装" class="headerlink" title="常用软件安装"></a>常用软件安装</h1><h2 id="ccat-安装（查看工具）"><a href="#ccat-安装（查看工具）" class="headerlink" title="ccat 安装（查看工具）"></a>ccat 安装（查看工具）</h2><div class="hljs code-wrapper"><pre><code class="hljs undefined">brew install ccat</code></pre></div><p>添加快捷方式</p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 修改配置</span>vi ~/.zshrc<span class="hljs-comment"># 底部添加（覆盖掉之前的 cat功能。最好不要有换行）</span><span class="hljs-built_in">alias</span> cat=ccat</code></pre></div><h2 id="git-安装（git插件）"><a href="#git-安装（git插件）" class="headerlink" title="git 安装（git插件）"></a>git 安装（git插件）</h2><div class="hljs code-wrapper"><pre><code class="hljs undefined">brew install tig</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 在git项目下 输入</span>tig<span class="hljs-comment"># 进入tig界面，上下键选择提交的信息</span><span class="hljs-comment"># 按住 cmd 按键查看</span><span class="hljs-comment"># q 键退出</span></code></pre></div><h4 id="安装常用的开发包"><a href="#安装常用的开发包" class="headerlink" title="安装常用的开发包"></a>安装常用的开发包</h4><div class="hljs code-wrapper"><pre><code class="hljs bash">brew install wget watch tmux cmake openssl imagemagick graphicsmagick gearman geoip readline autoconf multitail source-highlight autojump zsh-completions sshfs</code></pre></div><h4 id="安装常用的软件"><a href="#安装常用的软件" class="headerlink" title="安装常用的软件"></a>安装常用的软件</h4><div class="hljs code-wrapper"><pre><code class="hljs undefined">brew cask install firefox google-chrome  thunder qq phpstorm sublime-textbrew cask install alfred appcleaner  sequel-pro sketch mplayerx</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>system</category>
      
      <category>macos</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mac-brew</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>idea plugs</title>
    <link href="/2020/04/13/idea-plugs/"/>
    <url>/2020/04/13/idea-plugs/</url>
    
    <content type="html"><![CDATA[<h1 id="IDEA插件"><a href="#IDEA插件" class="headerlink" title="IDEA插件"></a>IDEA插件</h1><p>今天介绍一下IDEA的一些炫酷的插件，IDEA强大的插件库，不仅能给我们带来一些开发的便捷，还能体现我们的与众不同。</p><h3 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h3><h3 id="各种插件"><a href="#各种插件" class="headerlink" title="各种插件"></a>各种插件</h3><ol><li><p>activate-power-mode 和 Power mode II</p><p>根据Atom的插件activate-power-mode的效果移植到IDEA上</p><p>写代码是整个屏幕都在抖动，activate-power-mode是白的的，Power mode II色彩更酷炫点。</p></li><li><p>Background Image Plus</p><p>idea背景修改插件，让你的idea与众不同，可以设置自己喜欢的图片作为code背景。</p><p>安装成功之后重启，菜单栏的VIew标签&gt;点击Set Background Image(没安装插件是没有这个标签的)，在弹框中路由选择到本地图片，点击OK即可。</p></li><li><p>Grep console</p><p>自定义日志颜色，idea控制台可以彩色显示各种级别的log，安装完成后，在console中右键就能打开。</p><p>并且可以设置不同的日志级别的显示样式。</p><p>可以直接根据关键字搜索你想要的，搜索条件是支持正则表达式的。官网地址</p><p><a href="https://plugins.jetbrains.com/idea/plugin/7125-grep-console">https://plugins.jetbrains.com/idea/plugin/7125-grep-console</a></p></li><li><p>Free Mybatis plugin</p><p>mybatis 插件，让你的mybatis.xml像java代码一样编辑。我们开发中使用mybatis时时长需要通过mapper接口查找对应的xml中的sql语句，该插件方便了我们的操作。</p><p>安装完成重启IDEA之后，我们会看到code左侧或多出一列绿色的箭头，点击箭头我们就可以直接定位到xml相应文件的位置。</p><p>mapper</p></li></ol><p><img src="https://img-blog.csdnimg.cn/20190408111052416.png" alt="mapper"></p><div class="hljs code-wrapper"><pre><code>    xml</code></pre></div><p><img src="https://img-blog.csdnimg.cn/20190408111107597.png" alt="xml"></p><ol start="5"><li><p>MyBatis Log Plugin</p><p>Mybatis现在是java中操作数据库的首选，在开发的时候，我们都会把Mybatis的脚本直接输出在console中，但是默认的情况下，输出的脚本不是一个可以直接执行的。</p><p><img src="https://img-blog.csdnimg.cn/20190408111123402.png"></p><p>如果我们想直接执行，还需要在手动转化一下。</p><p>MyBatis Log Plugin 这款插件是直接将Mybatis执行的sql脚本显示出来，无需处理，可以直接复制出来执行的，如图：</p><p><img src="https://img-blog.csdnimg.cn/20190408111137891.png"></p><p>执行程序后，我们可以很清晰的看到我们执行了哪些sql脚本，而且脚本可以执行拿出来运行。</p></li><li><p>String Manipulation</p><p>强大的字符串转换工具。使用快捷键，Alt+m。</p><p><img src="https://img-blog.csdnimg.cn/20190408111154893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTY3MDM5,size_16,color_FFFFFF,t_70"></p><p>切换样式（camelCase, hyphen-lowercase, HYPHEN-UPPERCASE, snake_case, SCREAMING_SNAKE_CASE, dot.case, words lowercase, Words Capitalized, PascalCase）</p><ul><li><p>转换为SCREAMING_SNAKE_CASE (或转换为camelCase)</p></li><li><p>转换为 snake_case (或转换为camelCase)</p></li><li><p>转换为dot.case (或转换为camelCase)</p></li><li><p>转换为hyphen-case (或转换为camelCase)</p></li><li><p>转换为hyphen-case (或转换为snake_case)</p></li><li><p>转换为camelCase (或转换为Words)</p></li><li><p>转换为camelCase (或转换为lowercase words)</p></li><li><p>转换为PascalCase (或转换为camelCase)</p><p>选定文本大写</p><p>样式反转</p></li></ul></li><li><p>Alibaba Java Coding Guidelines</p><p>阿里巴巴代码规范检查插件，当然规范可以参考《阿里巴巴Java开发手册》。</p><p><img src="https://img-blog.csdnimg.cn/20190408111210770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTY3MDM5,size_16,color_FFFFFF,t_70"></p></li><li><p>Lombok</p><p>Java语言，每次写实体类的时候都需要写一大堆的setter，getter，如果bean中的属性一旦有修改、删除或增加时，需要重新生成或删除get/set等方法，给代码维护增加负担，这也是Java被诟病的一种原因。</p><p>Lombok则为我们解决了这些问题，使用了lombok的注解(@Setter,@Getter,@ToString,@@RequiredArgsConstructor,@EqualsAndHashCode或@Data)之后，就不需要编写或生成get/set等方法，很大程度上减少了代码量，而且减少了代码维护的负担。</p><p>安装完成之后，在应用Lombok的时候注意别忘了需要添加依，maven为例：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Setter</span><span class="hljs-meta">@Getter</span><span class="hljs-meta">@ToString</span><span class="hljs-meta">@EqualsAndHashCode</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;    <span class="hljs-keyword">private</span> String male;&#125;</code></pre></div></li><li><p>Key promoter</p><p>Key promoter 是IntelliJ IDEA的快捷键提示插件，会统计你鼠标点击某个功能的次数，提示你应该用什么快捷键，帮助记忆快捷键，等熟悉了之后可以关闭掉这个插件。</p></li><li><p>Gsonformat</p><p>可根据json数据快速生成java实体类。</p><p>自定义个javaBean(无任何内容，就一个空的类)，复制你要解析的Json，然后alt+insert弹出如下界面或者使用快捷键 Alt+S，在里面粘贴刚刚复制的Json，点击OK即可。</p><p><img src="https://img-blog.csdnimg.cn/20190408111253652.png"></p></li><li><p>Restfultookit</p><p>Spring MVC网页开发的时候，我们都是通过requestmapping的方式来定义页面的URL地址的，为了找到这个地址我们一般都是cmd+shift+F的方式进行查找，大家都知道，我们URL的命名一个是类requestmapping+方法requestmapping，查找的时候还是有那么一点不方便的，restfultookit就能很方便的帮忙进行查找。</p><p>例如：我要找到/user/add 对应的controller,那么只要Ctrl+斜杠 ,（图片来自于网络）</p></li></ol><p><img src="https://img-blog.csdnimg.cn/20190408111322532.png"></p><div class="hljs code-wrapper"><pre><code>就能直接定位到我们想要的controller。这个也是真心方便，当然restfultookit还为我们提供的其他的功能。根据我们的controller帮我们生成默认的测试数据，还能直接调用测试，这个可以是解决了我们每次postman调试数据时，自己傻傻的组装数据的的操作，这个更加清晰，比在console找数据包要方便多了。（图片来自于网络）</code></pre></div><ol start="12"><li><p>JRebel</p><p>JRebel是一种热部署生产力工具，修改代码后不用重新启动程序，所有的更改便可以生效。它跳过了Java开发中常见的重建、重新启动和重新部署周期。<br>使用方式参考此处:<br><a href="https://jingyan.baidu.com/article/ac6a9a5e31417c2b653eace8.html">https://jingyan.baidu.com/article/ac6a9a5e31417c2b653eace8.html</a></p></li></ol><h3 id="常用插件推荐"><a href="#常用插件推荐" class="headerlink" title="常用插件推荐"></a>常用插件推荐</h3><div class="hljs code-wrapper"><pre><code>注：微信不支持外链，如需打开请自行复制链接</code></pre></div><ol><li><p>Gitee<br>开源中国的码云插件<br><a href="https://plugins.jetbrains.com/plugin/8383-gitee">https://plugins.jetbrains.com/plugin/8383-gitee</a></p></li><li><p>Alibaba Java Coding Guidelines<br>阿里巴巴出的代码规范检查插件<br><a href="https://plugins.jetbrains.com/plugin/10046-alibaba-java-coding-guidelines">https://plugins.jetbrains.com/plugin/10046-alibaba-java-coding-guidelines</a></p></li><li><p>IDE Features Trainer<br>IntelliJ IDEA 官方出的学习辅助插件<br><a href="https://plugins.jetbrains.com/plugin/8554?pr=idea">https://plugins.jetbrains.com/plugin/8554?pr=idea</a></p></li><li><p>Key promoter<br>快捷键提示<br><a href="https://plugins.jetbrains.com/plugin/4455?pr=idea">https://plugins.jetbrains.com/plugin/4455?pr=idea</a></p></li><li><p>Grep Console<br>自定义设置控制台输出颜色<br><a href="https://plugins.jetbrains.com/idea/plugin/7125-grep-console">https://plugins.jetbrains.com/idea/plugin/7125-grep-console</a></p></li><li><p>String Manipulation<br>驼峰式命名和下划线命名交替变化<br><a href="https://plugins.jetbrains.com/plugin/2162?pr=idea">https://plugins.jetbrains.com/plugin/2162?pr=idea</a></p></li><li><p>CheckStyle-IDEA<br>代码规范检查<br><a href="https://plugins.jetbrains.com/plugin/1065?pr=idea">https://plugins.jetbrains.com/plugin/1065?pr=idea</a></p></li><li><p>FindBugs-IDEA<br>潜在 Bug 检查<br><a href="https://plugins.jetbrains.com/plugin/3847?pr=idea">https://plugins.jetbrains.com/plugin/3847?pr=idea</a></p></li><li><p>MetricsReloaded<br>代码复杂度检查<br><a href="https://plugins.jetbrains.com/plugin/93?pr=idea">https://plugins.jetbrains.com/plugin/93?pr=idea</a></p></li><li><p>Statistic<br>代码统计<br><a href="https://plugins.jetbrains.com/plugin/4509?pr=idea">https://plugins.jetbrains.com/plugin/4509?pr=idea</a></p></li><li><p>JRebel Plugin<br>热部署<br><a href="https://plugins.jetbrains.com/plugin/?id=4441">https://plugins.jetbrains.com/plugin/?id=4441</a></p></li><li><p>CodeGlance<br>在编辑代码最右侧，显示一块代码小地图<br><a href="https://plugins.jetbrains.com/plugin/7275?pr=idea">https://plugins.jetbrains.com/plugin/7275?pr=idea</a></p></li><li><p>GsonFormat<br>把 JSON 字符串直接实例化成类<br><a href="https://plugins.jetbrains.com/plugin/7654?pr=idea">https://plugins.jetbrains.com/plugin/7654?pr=idea</a></p></li><li><p>Markdown Navigator<br>书写 Markdown 文章<br><a href="https://plugins.jetbrains.com/plugin/7896?pr=idea">https://plugins.jetbrains.com/plugin/7896?pr=idea</a></p></li><li><p>Eclipse Code Formatter<br>使用 Eclipse 的代码格式化风格，在一个团队中如果公司有规定格式化风格，这个可以使用。<br><a href="https://plugins.jetbrains.com/plugin/6546?pr=idea">https://plugins.jetbrains.com/plugin/6546?pr=idea</a></p></li><li><p>Jindent-Source Code Formatter<br>自定义类、方法、doc、变量注释模板<br><a href="http://plugins.jetbrains.com/plugin/2170?pr=idea">http://plugins.jetbrains.com/plugin/2170?pr=idea</a></p></li><li><p>Translation<br>翻译插件<br><a href="https://github.com/YiiGuxing/TranslationPlugin">https://github.com/YiiGuxing/TranslationPlugin</a></p></li><li><p>Maven Helper<br>Maven 辅助插件<br><a href="https://plugins.jetbrains.com/plugin/7179-maven-helper">https://plugins.jetbrains.com/plugin/7179-maven-helper</a></p></li><li><p>Properties to YAML Converter<br>把 Properties 的配置格式改为 YAML 格式<br><a href="https://plugins.jetbrains.com/plugin/8000-properties-to-yaml-converter">https://plugins.jetbrains.com/plugin/8000-properties-to-yaml-converter</a></p></li><li><p>Git Flow Integration<br>Git Flow 的图形界面操作<br><a href="https://plugins.jetbrains.com/plugin/7315-git-flow-integration">https://plugins.jetbrains.com/plugin/7315-git-flow-integration</a></p></li><li><p>Rainbow Brackets<br>对各个对称括号进行着色，方便查看<br><a href="https://github.com/izhangzhihao/intellij-rainbow-brackets">https://github.com/izhangzhihao/intellij-rainbow-brackets</a></p></li><li><p>MybatisX<br>mybatis 框架辅助（免费）<br><a href="https://plugins.jetbrains.com/plugin/10119-mybatisx">https://plugins.jetbrains.com/plugin/10119-mybatisx</a></p></li><li><p>Lombok Plugin<br>Lombok 功能辅助插件<br><a href="https://plugins.jetbrains.com/plugin/6317-lombok-plugin">https://plugins.jetbrains.com/plugin/6317-lombok-plugin</a></p></li><li><p>.ignore<br>各类版本控制忽略文件生成工具<br><a href="https://plugins.jetbrains.com/plugin/7495--ignore">https://plugins.jetbrains.com/plugin/7495--ignore</a></p></li><li><p>mongo4idea<br>mongo客户端<br><a href="https://github.com/dboissier/mongo4idea">https://github.com/dboissier/mongo4idea</a></p></li><li><p>iedis<br>redis客户端<br><a href="https://plugins.jetbrains.com/plugin/9228-iedis">https://plugins.jetbrains.com/plugin/9228-iedis</a></p></li><li><p>GenerateAllSetter<br>new POJO类的快速生成 set 方法<br><a href="https://plugins.jetbrains.com/plugin/9360-generateallsetter">https://plugins.jetbrains.com/plugin/9360-generateallsetter</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>basic-component</category>
      
      <category>idea</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idea</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时间和字符传的转化</title>
    <link href="/2020/04/13/java-time-ordate/"/>
    <url>/2020/04/13/java-time-ordate/</url>
    
    <content type="html"><![CDATA[<h3 id="时间和字符传的转化"><a href="#时间和字符传的转化" class="headerlink" title="时间和字符传的转化"></a>时间和字符传的转化</h3><ol><li><p>日期转为字符串</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<span class="hljs-keyword">import</span> java.util.Date; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test01</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Date date = <span class="hljs-keyword">new</span> Date(); <span class="hljs-comment">//获取当前时间</span>        System.out.println(date.getClass().getName());  <span class="hljs-comment">//打印date数据类型</span>        System.out.println(date);           <span class="hljs-comment">//打印当前时间</span>        SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);        String format = sdf.format(date);       <span class="hljs-comment">//将Date类型转换成String类型   </span>        System.out.println(format.getClass().getName());<span class="hljs-comment">//打印format数据类型</span>        System.out.println(format);　　　　　　　　　　　　<span class="hljs-comment">//打印当前时间</span>    &#125;&#125;结果：java.util.DateTue Dec <span class="hljs-number">26</span> <span class="hljs-number">19</span>:<span class="hljs-number">31</span>:<span class="hljs-number">48</span> CST <span class="hljs-number">2017</span>java.lang.String<span class="hljs-number">2017</span>-<span class="hljs-number">12</span>-<span class="hljs-number">26</span> <span class="hljs-number">19</span>:<span class="hljs-number">31</span>:<span class="hljs-number">48</span></code></pre></div><ol start="2"><li>字符串转为日期</li></ol> <div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.text.ParseException;<span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<span class="hljs-keyword">import</span> java.util.Date; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test01</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        String time = <span class="hljs-string">&quot;1994-11-24 07:11:24&quot;</span>;           SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);        <span class="hljs-keyword">try</span> &#123;            Date date = sdf.parse(time);            System.out.println(date);        &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;            <span class="hljs-comment">// TODO Auto-generated catch block</span>            e.printStackTrace();        &#125;    &#125;&#125;结果：Thu Nov <span class="hljs-number">24</span> <span class="hljs-number">07</span>:<span class="hljs-number">11</span>:<span class="hljs-number">24</span> CST <span class="hljs-number">1994</span></code></pre></div><ol start="3"><li>对日期加减操作, 获得之前, 之后的时间</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<span class="hljs-keyword">import</span> java.util.Date; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);        Date date = <span class="hljs-keyword">new</span> Date();        <span class="hljs-keyword">long</span> dateTime = date.getTime(); <span class="hljs-comment">//将date类型转换成long类型进行计算</span>        System.out.println(sdf.format(date));   <span class="hljs-comment">//以字符串打印当前时间</span>                 <span class="hljs-keyword">long</span> time = (<span class="hljs-number">60</span>*<span class="hljs-number">60</span>+<span class="hljs-number">5</span>)*<span class="hljs-number">1000</span>;     <span class="hljs-comment">//60个60分钟加5分钟，乘以1000，一小时零五分转换成毫秒</span>        dateTime = dateTime + time;     <span class="hljs-comment">//将当前时间加上一小时零五分</span>        System.out.println(sdf.format(<span class="hljs-keyword">new</span> Date(dateTime))); <span class="hljs-comment">//打印一小时零五分之后的时间</span>    &#125; &#125; 结果：<span class="hljs-number">2018</span>-<span class="hljs-number">01</span>-<span class="hljs-number">07</span> 08:<span class="hljs-number">52</span>:<span class="hljs-number">21</span><span class="hljs-number">2018</span>-<span class="hljs-number">01</span>-<span class="hljs-number">07</span> 09:<span class="hljs-number">52</span>:<span class="hljs-number">26</span></code></pre></div><h3 id="时间和数字的转化"><a href="#时间和数字的转化" class="headerlink" title="时间和数字的转化"></a>时间和数字的转化</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.drew.utils; <span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<span class="hljs-keyword">import</span> java.util.Date; <span class="hljs-comment">/**</span><span class="hljs-comment"> * long类型数字转换成时分秒毫秒格式</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Iszychen 2020/02/19</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConvertorTime</span> </span>&#123;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> seconds = <span class="hljs-number">17854</span>, msec = <span class="hljs-number">360000</span>;<span class="hljs-comment">// 秒，毫秒</span>        System.out.println(secToTime(seconds));        System.out.println(msec + <span class="hljs-string">&quot;毫秒转换格式时间：\t&quot;</span> + msecToTime(msec));        System.out.println(<span class="hljs-string">&quot;当前时间（时:分：秒.毫秒）\t&quot;</span> + <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;HH:mm:ss.SSS&quot;</span>).format(<span class="hljs-keyword">new</span> Date()));    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 秒转换小时-分-秒analytics/util/DateUtil.java</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> seconds 秒为单位 比如..600秒</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 比如...2小时3分钟52秒</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">secToTime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> seconds)</span> </span>&#123;        <span class="hljs-keyword">int</span> hour = seconds / <span class="hljs-number">3600</span>;        <span class="hljs-keyword">int</span> minute = (seconds - hour * <span class="hljs-number">3600</span>) / <span class="hljs-number">60</span>;        <span class="hljs-keyword">int</span> second = (seconds - hour * <span class="hljs-number">3600</span> - minute * <span class="hljs-number">60</span>);         StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();        <span class="hljs-keyword">if</span> (hour &gt; <span class="hljs-number">0</span>) &#123;            sb.append(hour + <span class="hljs-string">&quot;小时&quot;</span>);        &#125;        <span class="hljs-keyword">if</span> (minute &gt; <span class="hljs-number">0</span>) &#123;            sb.append(minute + <span class="hljs-string">&quot;分&quot;</span>);        &#125;        <span class="hljs-keyword">if</span> (second &gt; <span class="hljs-number">0</span>) &#123;            sb.append(second + <span class="hljs-string">&quot;秒&quot;</span>);        &#125;        <span class="hljs-keyword">if</span> (second == <span class="hljs-number">0</span>) &#123;            sb.append(<span class="hljs-string">&quot;&lt;1秒&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> sb.toString();    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将int类型数字转换成时分秒毫秒的格式数据</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time long类型的数据</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> HH:mm:ss.SSS</span><span class="hljs-comment">     * <span class="hljs-doctag">@author</span> Iszychen 2020/02/19</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">msecToTime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> time)</span> </span>&#123;        String timeStr = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">int</span> hour = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> minute = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> second = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> millisecond = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (time &lt;= <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;00:00:00.000&quot;</span>;        <span class="hljs-keyword">else</span> &#123;            second = time / <span class="hljs-number">1000</span>;            minute = second / <span class="hljs-number">60</span>;            millisecond = time % <span class="hljs-number">1000</span>;            <span class="hljs-keyword">if</span> (second &lt; <span class="hljs-number">60</span>) &#123;                timeStr = <span class="hljs-string">&quot;00:00:&quot;</span> + unitFormat(second) + <span class="hljs-string">&quot;.&quot;</span> + unitFormat2(millisecond);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (minute &lt; <span class="hljs-number">60</span>) &#123;                second = second % <span class="hljs-number">60</span>;                timeStr = <span class="hljs-string">&quot;00:&quot;</span> + unitFormat(minute) + <span class="hljs-string">&quot;:&quot;</span> + unitFormat(second) + <span class="hljs-string">&quot;.&quot;</span> + unitFormat2(millisecond);            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 数字&gt;=3600 000的时候</span>                hour = minute / <span class="hljs-number">60</span>;                minute = minute % <span class="hljs-number">60</span>;                second = second - hour * <span class="hljs-number">3600</span> - minute * <span class="hljs-number">60</span>;                timeStr = unitFormat(hour) + <span class="hljs-string">&quot;:&quot;</span> + unitFormat(minute) + <span class="hljs-string">&quot;:&quot;</span> + unitFormat(second) + <span class="hljs-string">&quot;.&quot;</span>                    + unitFormat2(millisecond);            &#125;        &#125;        <span class="hljs-keyword">return</span> timeStr;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">unitFormat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<span class="hljs-comment">// 时分秒的格式转换</span>        String retStr = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; <span class="hljs-number">10</span>)            retStr = <span class="hljs-string">&quot;0&quot;</span> + Integer.toString(i);        <span class="hljs-keyword">else</span>            retStr = <span class="hljs-string">&quot;&quot;</span> + i;        <span class="hljs-keyword">return</span> retStr;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">unitFormat2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<span class="hljs-comment">// 毫秒的格式转换</span>        String retStr = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; <span class="hljs-number">10</span>)            retStr = <span class="hljs-string">&quot;00&quot;</span> + Integer.toString(i);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">10</span> &amp;&amp; i &lt; <span class="hljs-number">100</span>) &#123;            retStr = <span class="hljs-string">&quot;0&quot;</span> + Integer.toString(i);        &#125; <span class="hljs-keyword">else</span>            retStr = <span class="hljs-string">&quot;&quot;</span> + i;        <span class="hljs-keyword">return</span> retStr;    &#125; &#125;</code></pre></div><h6 id="可转为工具类-gt-测试结果"><a href="#可转为工具类-gt-测试结果" class="headerlink" title="可转为工具类=&gt;测试结果"></a>可转为工具类=&gt;测试结果</h6><p><img src="https://img2018.cnblogs.com/blog/1301422/201904/1301422-20190411160134848-2110597655.png" alt="测试结果"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>date</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pyGetterSetter</title>
    <link href="/2020/04/13/python-getter-setter/"/>
    <url>/2020/04/13/python-getter-setter/</url>
    
    <content type="html"><![CDATA[<p>Java中我们在定义类的成员变量时，如果是私有属性，我们通过调用属性对应的set和get方法来获取和设置变量的值，如果我们将这种方式来用于python那么代码如下:</p><div class="hljs code-wrapper"><pre><div class="caption"><span>coding</span></div><code class="hljs #">class Money(object):    def __init__(self):        self.money &#x3D; 0     def getMoney(self):        return self.money     def setMoney(self, value):        if isinstance(value, int):            self.money &#x3D; value        else:            print(&quot;error：输入类型与预设类型不一致&quot;)  def main():    money &#x3D; Money()    money.setMoney(10)    print(money.getMoney())  if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre></div><p>但是在python中我们可以利用python属性来实现，代码如下：</p><div class="hljs code-wrapper"><pre><div class="caption"><span>coding</span></div><code class="hljs #">class Money(object):    def __init__(self):        self.money &#x3D; 0     def getMoney(self):        return self.money     def setMoney(self, value):        if isinstance(value, int):            self.money &#x3D; value        else:            print(&quot;error：输入类型与预设类型不一致&quot;)     dealValue &#x3D; property(getMoney, setMoney)  def main():    money &#x3D; Money()    money.dealValue&#x3D;100    print(money.dealValue)  if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre></div><p>也使用property完全取代get/set</p><div class="hljs code-wrapper"><pre><div class="caption"><span>coding</span></div><code class="hljs #">class Money(object):    def __init__(self):        self.__money &#x3D; 0     @property    def money(self):        return self.__money     @money.setter    def money(self, value):        if isinstance(value, int):            self.__money &#x3D; value        else:            print(&quot;error：输入类型与预设类型不一致&quot;)  def main():    a &#x3D; Money()    a.money &#x3D; 10    print(a.money)  if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>anno</title>
    <link href="/2020/04/13/spring-anno/"/>
    <url>/2020/04/13/spring-anno/</url>
    
    <content type="html"><![CDATA[<h2 id="Java注解获取"><a href="#Java注解获取" class="headerlink" title="Java注解获取"></a>Java注解获取</h2><p>java.lang.reflect.AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的如下四个个方法来访问Annotation信息：</p><ul><li>方法：<T extends Annotation> T getAnnotation(Class<T> annotationClass): 返回改程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。</li><li>方法：Annotation[] getAnnotations():返回该程序元素上存在的所有注解。</li><li>方法：boolean is AnnotationPresent(Class&lt;?extends Annotation&gt; annotationClass):判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false.</li><li>方法：Annotation[] getDeclaredAnnotations()：返回直接存在于此元素上的所有注释。与此接口中的其他方法不同，该方法将忽略继承的注释。（如果没有注释直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响</li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>anno</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/2020/04/05/java-regular/"/>
    <url>/2020/04/05/java-regular/</url>
    
    <content type="html"><![CDATA[<h1 id="构建正则表达式"><a href="#构建正则表达式" class="headerlink" title="构建正则表达式"></a>构建正则表达式</h1><ul><li><p>pattern() 返回正则表达式的字符串形式,其实就是返回Pattern.complile(String regex)的regex参数</p><p><code>p.pattern();//返回 \d+</code></p></li><li><p>split(CharSequence input)方法,用于分隔字符串,并返回一个String[]</p><p>`String[] str = p.split(“我的QQ是:456456我的电话是:0532214我的邮箱是:<a href="mailto:&#x61;&#x61;&#x61;&#64;&#x61;&#97;&#x61;&#46;&#x63;&#111;&#109;">&#x61;&#x61;&#x61;&#64;&#x61;&#97;&#x61;&#46;&#x63;&#111;&#109;</a>“);</p><div class="hljs code-wrapper"><pre><code>    System.out.println(Arrays.toString(str));`</code></pre></div></li><li><p>Pattern.matchers(String regex,CharSequence input)是一个静态方法,用于快速匹配字符串,该方法适合用于只匹配一次,且匹配全部字符串.</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs java">System.out.println(Pattern.matches(<span class="hljs-string">&quot;\\d+&quot;</span>, <span class="hljs-string">&quot;2223&quot;</span>));<span class="hljs-comment">//返回true</span>System.out.println(Pattern.matches(<span class="hljs-string">&quot;\\d+&quot;</span>, <span class="hljs-string">&quot;2223aa&quot;</span>));<span class="hljs-comment">//返回false,需要匹配到所有字符串才能返回true,这里aa不能匹配到</span>System.out.println(Pattern.matches(<span class="hljs-string">&quot;\\d+&quot;</span>, <span class="hljs-string">&quot;22bb23&quot;</span>));<span class="hljs-comment">//返回false,需要匹配到所有字符串才能返回true,这里bb不能匹配到</span></code></pre></div><ul><li>//Pattern.matcher(CharSequence input)返回一个Matcher对象.</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java">Matcher mq = p.matcher(<span class="hljs-string">&quot;22bb23&quot;</span>);Pattern mx = mq.pattern();<span class="hljs-comment">//返回 p 也就是返回该 Matcher 对象是由哪个 Pattern 对象的创建的</span>System.out.println(p.toString());System.out.println(mx.equals(p));</code></pre></div><h3 id="2-常用方法"><a href="#2-常用方法" class="headerlink" title="2. 常用方法"></a>2. 常用方法</h3><p>   Matcher.matches()/ Matcher.lookingAt()/ Matcher.find() * 三个方法均返回boolean类型,当匹配到时返回true,没匹配到则返回false</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//TODO matches()对整个字符串进行匹配,只有整个字符串都匹配了才返回true</span>Matcher m1 = p.matcher(<span class="hljs-string">&quot;22bb23&quot;</span>);System.out.println(m1.matches());<span class="hljs-comment">//返回false,因为bb不能被\d+匹配,导致整个字符串匹配未成功.</span>Matcher m2 = p.matcher(<span class="hljs-string">&quot;2223&quot;</span>);System.out.println(m2.matches());<span class="hljs-comment">//返回true,因为\d+匹配到了整个字符串</span><span class="hljs-comment">//TODO lookingAt()对前面的字符串进行匹配,只有匹配到的字符串在最前面才返回true</span>Matcher m3 = p.matcher(<span class="hljs-string">&quot;22bb23&quot;</span>);System.out.println(m3.lookingAt());<span class="hljs-comment">//返回true,因为\d+匹配到了前面的22</span>Matcher m4 = p.matcher(<span class="hljs-string">&quot;aa2223&quot;</span>);System.out.println(m4.lookingAt());<span class="hljs-comment">//返回false,因为\d+不能匹配前面的aa</span><span class="hljs-comment">// TODO find()对字符串进行匹配,匹配到的字符串可以在任何位置.</span>Matcher m5 = p.matcher(<span class="hljs-string">&quot;22bb23&quot;</span>);System.out.println(m5.find());<span class="hljs-comment">//返回true</span>Matcher m6 = p.matcher(<span class="hljs-string">&quot;aa2223&quot;</span>);System.out.println(m6.find());<span class="hljs-comment">//返回true</span>Matcher m7 = p.matcher(<span class="hljs-string">&quot;aa2223bb&quot;</span>);System.out.println(m7.find());<span class="hljs-comment">//返回true</span>Matcher m8 = p.matcher(<span class="hljs-string">&quot;aabb&quot;</span>);System.out.println(m8.find());<span class="hljs-comment">//返回false</span></code></pre></div><h3 id="3-获取位置方法"><a href="#3-获取位置方法" class="headerlink" title="3. 获取位置方法"></a>3. 获取位置方法</h3><p>   Mathcer.start()/ Matcher.end()/ Matcher.group() * * 当使用matches(),lookingAt(),find()执行匹配操作后,就可以利用以上三个方法得到更详细的信息. </p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//TODO start()返回匹配到的子字符串在字符串中的索引位置.</span><span class="hljs-comment">//TODO end()返回匹配到的子字符串的最后一个字符在字符串中的索引位置.</span><span class="hljs-comment">//TODO group()返回匹配到的子字符串</span>Matcher mz = p.matcher(<span class="hljs-string">&quot;aaa2223bb&quot;</span>);System.out.println(mz.find());<span class="hljs-comment">//匹配2223</span>System.out.println(mz.start());<span class="hljs-comment">//返回3</span>System.out.println(mz.end());<span class="hljs-comment">//返回7,返回的是2223后的索引号</span>System.out.println(mz.group());<span class="hljs-comment">//返回2223</span>Matcher mw = p.matcher(<span class="hljs-string">&quot;2223bb&quot;</span>);System.out.println(mw.lookingAt());<span class="hljs-comment">//匹配2223</span>System.out.println(mw.start());<span class="hljs-comment">//返回0,由于lookingAt()只能匹配前面的字符串,所以当使用lookingAt()匹配时,start()方法总是返回0</span>System.out.println(mw.end());<span class="hljs-comment">//返回4</span>System.out.println(mw.group());<span class="hljs-comment">//返回2223</span>Matcher mn = p.matcher(<span class="hljs-string">&quot;123213&quot;</span>);System.out.println(mn.matches());<span class="hljs-comment">//匹配整个字符串</span>System.out.println(mn.start());<span class="hljs-comment">//匹配成功返回0 ,异常,因为没有匹配到</span>System.out.println(mn.end());<span class="hljs-comment">//匹配成功返回结尾数,因为matches()需要匹配所有字符串 不成功抛出异常</span>System.out.println(mn.group());<span class="hljs-comment">//成功返回字符 失败抛出异常</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * 正则表达式的分组在java中是怎么使用的.</span><span class="hljs-comment"> * start(),end(),group()均有一个重载方法它们是start(int i),end(int i),group(int i)专用于分组操作,Mathcer 类还有一个groupCount()用于返回有多少组.</span><span class="hljs-comment"> */</span>Pattern p=Pattern.compile(<span class="hljs-string">&quot;([a-z]+)(\\d+)&quot;</span>);Matcher m=p.matcher(<span class="hljs-string">&quot;aaa2223bb&quot;</span>);System.out.println(m.find());<span class="hljs-comment">//匹配aaa2223</span>System.out.println(m.groupCount());<span class="hljs-comment">//返回2,因为有2组</span>System.out.println(m.start(<span class="hljs-number">1</span>));<span class="hljs-comment">//返回0 返回第一组匹配到的子字符串在字符串中的索引号</span>System.out.println(m.start(<span class="hljs-number">2</span>));<span class="hljs-comment">//返回3</span>System.out.println(m.end(<span class="hljs-number">1</span>));<span class="hljs-comment">//返回3 返回第一组匹配到的子字符串的最后一个字符在字符串中的索引位置.</span>System.out.println(m.end(<span class="hljs-number">2</span>));<span class="hljs-comment">//返回7</span>System.out.println(m.group(<span class="hljs-number">1</span>));<span class="hljs-comment">//返回aaa,返回第一组匹配到的子字符串</span>System.out.println(m.group(<span class="hljs-number">2</span>));<span class="hljs-comment">//返回2223,返回第二组匹配到的子字符串</span></code></pre></div><h3 id="4-分组的使用"><a href="#4-分组的使用" class="headerlink" title="4. 分组的使用"></a>4. 分组的使用</h3><p>   一段文本,里面有很多数字,而且这些数字是分开的,我们现在要将文本中所有数字都取出</p><div class="hljs code-wrapper"><pre><code class="hljs java">Pattern p=Pattern.compile(<span class="hljs-string">&quot;\\d+&quot;</span>);Matcher m=p.matcher(<span class="hljs-string">&quot;我的QQ是:456456 我的电话是:0532214 我的邮箱是:aaa123@aaa.com&quot;</span>);<span class="hljs-comment">//while(m.find()) &#123;</span><span class="hljs-comment">//System.out.println(m.group());</span><span class="hljs-comment">//&#125;</span><span class="hljs-comment">// TODO 或者</span><span class="hljs-keyword">while</span>(m.find()) &#123;System.out.println(m.group());System.out.print(<span class="hljs-string">&quot;start:&quot;</span>+m.start());System.out.println(<span class="hljs-string">&quot; end:&quot;</span>+m.end());&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>basic-language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>regular</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA常用工具类</title>
    <link href="/2020/04/04/java-util/"/>
    <url>/2020/04/04/java-util/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA常用工具类"><a href="#JAVA常用工具类" class="headerlink" title="JAVA常用工具类"></a>JAVA常用工具类</h1><h4 id="第一部分：常用的16个工具类"><a href="#第一部分：常用的16个工具类" class="headerlink" title="第一部分：常用的16个工具类"></a>第一部分：常用的16个工具类</h4><div class="hljs code-wrapper"><pre><code class="hljs xml">https://mvnrepository.com/artifact/org.apache.commons/org.apache.commons.lang --&gt;<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>org.apache.commons.lang<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h5 id="一、org-apache-commons-io-IOUtils"><a href="#一、org-apache-commons-io-IOUtils" class="headerlink" title="一、org.apache.commons.io.IOUtils"></a>一、org.apache.commons.io.IOUtils</h5><p>1、closeQuietly 关闭一个IO流、socket、或者selector且不抛出异常。通常放在finally块。</p><p>2、toString 转换IO流、Uri、byte[]为String。</p><p>3、copy IO流数据复制，从输入流写到输出流中，最大支持2GB。</p><p>4、toByteArray 从输入流、URI获取byte[]。</p><p>5、write 把字节、字符等写入输出流。</p><p>6、toInputStream 把字符转换为输入流。</p><p>7、readLines 从输入流中读取多行数据，返回List</p><p>8、copyLarge 同copy，支持2GB以上数据的复制。</p><p>9、lineIterator 从输入流返回一个迭代器，</p><p>10、根据参数要求读取的数据量，全部读取，如果数据不够，则失败。</p><h5 id="二、org-apache-commons-io-FileUtils"><a href="#二、org-apache-commons-io-FileUtils" class="headerlink" title="二、org.apache.commons.io.FileUtils"></a>二、org.apache.commons.io.FileUtils</h5><p>1、deleteDirectory 删除文件夹</p><p>2、readFileToString 以字符形式读取文件内容。</p><p>3、deleteQueitly 删除文件或文件夹且不会抛出异常。</p><p>4、copyFile 复制文件</p><p>5、writeStringToFile 把字符写到目标文件，如果文件不存在，则创建。</p><p>6、forceMkdir 强制创建文件夹，如果该文件夹父级目录不存在，则创建父级。</p><p>7、write 把字符写到指定文件中</p><p>8、listFiles 列举某个目录下的文件(根据过滤器)</p><p>9、copyDirectory 复制文件夹</p><p>10、forceDelete 强制删除文件</p><h5 id="三、org-apache-commons-lang-StringUtils"><a href="#三、org-apache-commons-lang-StringUtils" class="headerlink" title="三、org.apache.commons.lang.StringUtils"></a>三、org.apache.commons.lang.StringUtils</h5><p>1、isBlank 字符串是否为空 (trim后判断)</p><p>2、isEmpty 字符串是否为空 (不trim并判断)</p><p>3、equals 字符串是否相等</p><p>4、join 合并数组为单一字符串，可传分隔符</p><p>5、split 分割字符串</p><p>6、EMPTY 空字符串</p><p>7、trimToNull trim后为空字符串则转换为null</p><p>8、replace 替换字符串</p><h5 id="四、org-apache-http-util-EntityUtils"><a href="#四、org-apache-http-util-EntityUtils" class="headerlink" title="四、org.apache.http.util.EntityUtils"></a>四、org.apache.http.util.EntityUtils</h5><p>1、toString 把Entity转换为字符串</p><p>2、consume 确保Entity中的内容全部被消费。可以看到源码里又一次消费了Entity的内容，假如用户没有消费，那调用Entity时候将会把它消费掉。</p><p>3、toByteArray 把Entity转换为字节流</p><p>4、consumeQuietly 和consume一样，但不抛异常</p><p>5、getContentCharset 获取内容的编码</p><h5 id="五、org-apache-commons-lang3-StringUtils"><a href="#五、org-apache-commons-lang3-StringUtils" class="headerlink" title="五、org.apache.commons.lang3.StringUtils"></a>五、org.apache.commons.lang3.StringUtils</h5><p>1、isBlank 字符串是否为空 (trim后判断)</p><p>2、isEmpty 字符串是否为空 (不trim并判断)</p><p>3、equals 字符串是否相等</p><p>4、join 合并数组为单一字符串，可传分隔符</p><p>5、split 分割字符串</p><p>6、EMPTY 空字符串</p><p>7、replace 替换字符串</p><p>9、capitalize 首字符大写</p><h5 id="六、org-apache-commons-io-FilenameUtils"><a href="#六、org-apache-commons-io-FilenameUtils" class="headerlink" title="六、org.apache.commons.io.FilenameUtils"></a>六、org.apache.commons.io.FilenameUtils</h5><p>1、getExtension 返回文件后缀名</p><p>2、getBaseName 返回文件名，不包含后缀名</p><p>3、getName 返回文件全名</p><p>4、concat 按命令行风格组合文件路径(详见方法注释)</p><p>5、removeExtension 删除后缀名</p><p>6、normalize 使路径正常化</p><p>7、wildcardMatch 匹配通配符</p><p>8、seperatorToUnix 路径分隔符改成unix系统格式的，即/</p><p>9、getFullPath 获取文件路径，不包括文件名</p><p>10、isExtension 检查文件后缀名是不是传入参数(List)中的一个</p><h5 id="七、org-springframework-util-StringUtils"><a href="#七、org-springframework-util-StringUtils" class="headerlink" title="七、org.springframework.util.StringUtils"></a>七、org.springframework.util.StringUtils</h5><p>1、hasText 检查字符串中是否包含文本</p><p>2、hasLength 检测字符串是否长度大于0</p><p>3、isEmpty 检测字符串是否为空（若传入为对象，则判断对象是否为null）</p><p>4、commaDelimitedStringToArray 逗号分隔的String转换为数组</p><p>5、collectionToDelimitedString 把集合转为CSV格式字符串</p><p>6、replace 替换字符串</p><p>7、delimitedListToStringArray 相当于split</p><p>8、uncapitalize 首字母小写</p><p>9、collectionToDelimitedCommaString 把集合转为CSV格式字符串</p><p>10、tokenizeToStringArray 和split基本一样，但能自动去掉空白的单词</p><h5 id="八、org-apache-commons-lang-ArrayUtils"><a href="#八、org-apache-commons-lang-ArrayUtils" class="headerlink" title="八、org.apache.commons.lang.ArrayUtils"></a>八、org.apache.commons.lang.ArrayUtils</h5><p>1、contains 是否包含某字符串</p><p>2、addAll 添加所有</p><p>3、clone 克隆一个数组</p><p>4、isEmpty 是否空数组</p><p>5、add 向数组添加元素</p><p>6、subarray 截取数组</p><p>7、indexOf 查找下标</p><p>8、isEquals 比较数组是否相等</p><p>9、toObject 基础类型数据数组转换为对应的Object数组</p><h5 id="九、org-apache-commons-lang-StringEscapeUtils支持编码转换"><a href="#九、org-apache-commons-lang-StringEscapeUtils支持编码转换" class="headerlink" title="九、org.apache.commons.lang.StringEscapeUtils支持编码转换"></a>九、org.apache.commons.lang.StringEscapeUtils支持编码转换</h5><p>escapeXml unEscapeXml。</p><p>此外，还支持html、java、JavaScript、sql、csv等</p><h5 id="十、org-apache-http-client-utils-URLEncodedUtils"><a href="#十、org-apache-http-client-utils-URLEncodedUtils" class="headerlink" title="十、org.apache.http.client.utils.URLEncodedUtils"></a>十、org.apache.http.client.utils.URLEncodedUtils</h5><p>1、format 格式化参数，返回一个HTTP POST或者HTTP PUT可用 application/x-www-form-urlencoded字符串</p><p>2、parse 把String或者URI等转换为List</p><h5 id="十一、org-apache-commons-codec-digest-DigestUtils"><a href="#十一、org-apache-commons-codec-digest-DigestUtils" class="headerlink" title="十一、org.apache.commons.codec.digest.DigestUtils"></a>十一、org.apache.commons.codec.digest.DigestUtils</h5><p>1、md5Hex MD5加密，返回32位</p><p>2、sha1Hex SHA-1加密</p><p>3、sha256Hex SHA-256加密</p><p>4、sha512Hex SHA-512加密</p><p>5、md5 MD5加密，返回16位</p><h5 id="十二、org-apache-commons-collections-CollectionUtils"><a href="#十二、org-apache-commons-collections-CollectionUtils" class="headerlink" title="十二、org.apache.commons.collections.CollectionUtils"></a>十二、org.apache.commons.collections.CollectionUtils</h5><p>1、isEmpty 是否为空</p><p>2、select 根据条件筛选集合元素</p><p>3、transform 根据指定方法处理集合元素，类似List的map()。</p><p>4、filter 过滤元素，雷瑟List的filter()</p><p>5、find 基本和select一样</p><p>6、collect 和transform 差不多一样，但是返回新数组</p><p>7、forAllDo 调用每个元素的指定方法。</p><p>8、isEqualCollection 判断两个集合是否一致</p><h5 id="十三、org-apache-commons-lang3-ArrayUtils"><a href="#十三、org-apache-commons-lang3-ArrayUtils" class="headerlink" title="十三、org.apache.commons.lang3.ArrayUtils"></a>十三、org.apache.commons.lang3.ArrayUtils</h5><p>1、contains 是否包含某字符串</p><p>2、addAll 添加所有</p><p>3、clone 克隆一个数组</p><p>4、isEmpty 是否空数组</p><p>5、add 向数组添加元素</p><p>6、subarray 截取数组</p><p>7、indexOf 查找下标</p><p>8、isEquals 比较数组是否相等</p><p>9、toObject 基础类型数据数组转换为对应的Object数组</p><h5 id="十四、org-apache-commons-beanutils-PropertyUtils"><a href="#十四、org-apache-commons-beanutils-PropertyUtils" class="headerlink" title="十四、org.apache.commons.beanutils.PropertyUtils"></a>十四、org.apache.commons.beanutils.PropertyUtils</h5><p>1、getProperty 获取对象属性值</p><p>2、setProperty 设置对象属性值</p><p>3、getPropertyDiscriptor 获取属性描述器</p><p>4、isReadable 检查属性是否可访问</p><p>5、copyProperties 复制属性值，从一个对象到另一个对象</p><p>6、getPropertyDiscriptors 获取所有属性描述器</p><p>7、isWriteable 检查属性是否可写</p><p>8、getPropertyType 获取对象属性类型</p><h5 id="十五、org-apache-commons-lang3-StringEscapeUtils"><a href="#十五、org-apache-commons-lang3-StringEscapeUtils" class="headerlink" title="十五、org.apache.commons.lang3.StringEscapeUtils"></a>十五、org.apache.commons.lang3.StringEscapeUtils</h5><p>支持编码转换</p><p>escapeJson unEscapeJson。</p><p>此外，还支持html、java、JavaScript、sql、csv、xml等</p><h5 id="十六、org-apache-commons-beanutils-BeanUtils"><a href="#十六、org-apache-commons-beanutils-BeanUtils" class="headerlink" title="十六、org.apache.commons.beanutils.BeanUtils"></a>十六、org.apache.commons.beanutils.BeanUtils</h5><p>1、copyPeoperties 复制属性值，从一个对象到另一个对象</p><p>2、getProperty 获取对象属性值</p><p>3、setProperty 设置对象属性值</p><p>4、populate 根据Map给属性复制</p><p>5、copyPeoperty 复制单个值，从一个对象到另一个对象。</p><p>6、cloneBean 克隆</p><h4 id="第二部分：常用的测试库（链接及用法）"><a href="#第二部分：常用的测试库（链接及用法）" class="headerlink" title="第二部分：常用的测试库（链接及用法）"></a>第二部分：常用的测试库（链接及用法）</h4><p>以下提供一些类库的测试，希望对大家有用：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><li>Java命令行选项解析之Commons-CLI &amp; Args4J &amp; JCommander<a href="http://rensanning.iteye.com/blog/2161201" rel="nofollow" target="_blank">详细内容</a></li></td></tr><tr><td></td><td><li>Java调用Native API之JNA<a href="http://rensanning.iteye.com/blog/2154075" rel="nofollow" target="_blank">详细内容</a></li></td></tr><tr><td></td><td><li>Java执行SSH/SCP之JSch<a href="http://rensanning.iteye.com/blog/2109675" rel="nofollow" target="_blank">详细内容</a></li></td></tr><tr><td></td><td><li>Java元组类型之javatuples<a href="http://rensanning.iteye.com/blog/2068554" rel="nofollow" target="_blank">详细内容</a></li></td></tr><tr><td></td><td><li>Java读写Excel之POI超入门<a href="http://rensanning.iteye.com/blog/1538591" rel="nofollow" target="_blank">详细内容</a></li></td></tr><tr><td></td><td><li>Java操作PDF之iText超入门<a href="http://rensanning.iteye.com/blog/1538689" rel="nofollow" target="_blank">详细内容</a></li></td></tr><tr><td></td><td><li>Java构建工具之Ant<a href="http://rensanning.iteye.com/blog/1540336" rel="nofollow" target="_blank">详细内容</a></li></td></tr><tr><td></td><td><li>Java模板引擎之FreeMarker<a href="http://rensanning.iteye.com/blog/1540613" rel="nofollow" target="_blank">详细内容</a></li></td></tr><tr><td></td><td><li>Java生成缩略图之Thumbnailator<a href="http://rensanning.iteye.com/blog/1545708" rel="nofollow" target="_blank">详细内容</a></li></td></tr><tr><td></td><td><li>Java日期计算之Joda-Time<a href="http://rensanning.iteye.com/blog/1546652" rel="nofollow" target="_blank">详细内容</a></li></td></tr><tr><td></td><td><li>Java工具类之Apache的Commons Lang和BeanUtils<a href="http://rensanning.iteye.com/blog/1547845" rel="nofollow" target="_blank">详细内容</a></li></td></tr><tr><td></td><td><li>Java集合框架之fastutil<a href="http://rensanning.iteye.com/blog/1548162" rel="nofollow" target="_blank">详细内容</a></li></td></tr><tr><td></td><td><li>Java网络通信之HttpClient<a href="http://rensanning.iteye.com/blog/1550436" rel="nofollow" target="_blank">详细内容</a></li></td></tr><tr><td></td><td><li>Java解析HTML之NekoHTML<a href="http://rensanning.iteye.com/blog/1551831" rel="nofollow" target="_blank">详细内容</a></li></td></tr><tr><td></td><td><li>Java读写CSV之SuperCSV<a href="http://rensanning.iteye.com/blog/1552053" rel="nofollow" target="_blank">详细内容</a></li></td></tr><tr><td></td><td><li>Java作业调度之Quartz<a href="http://rensanning.iteye.com/blog/1836263" rel="nofollow" target="_blank">详细内容</a></li></td></tr><tr><td></td><td><li>Java压缩解压ZIP之Zip4j<a href="http://rensanning.iteye.com/blog/1836727" rel="nofollow" target="_blank">详细内容</a></li></td></tr><tr><td></td><td><li>Java嵌入式NoSQL数据库之Berkeley DB Java Edition<a href="http://rensanning.iteye.com/blog/1872481" rel="nofollow" target="_blank">详细内容</a></li></td></tr><tr><td></td><td><li>Java单元测试之邮件测试-GreenMail<a href="http://rensanning.iteye.com/blog/2001617" rel="nofollow" target="_blank">详细内容</a></li></td></tr><tr><td></td><td><li>Java单元测试之代码覆盖率-JaCoCo<a href="http://rensanning.iteye.com/blog/2002371" rel="nofollow" target="_blank">详细内容</a></li></td></tr><tr><td></td><td><li>Java日文分词器之Kuromoji<a href="http://rensanning.iteye.com/blog/2008575" rel="nofollow" target="_blank">详细内容</a></li></td></tr><tr><td></td><td><li>Java数学表达式计算(Expression Evaluator)<a href="http://rensanning.iteye.com/blog/2011558" rel="nofollow" target="_blank">详细内容</a></li></td></tr><tr><td></td><td><li>Java检测无用代码之UCDetector<a href="http://rensanning.iteye.com/blog/2012010" rel="nofollow" target="_blank">详细内容</a></li></td></tr><tr><td></td><td><li>Java简化臃肿代码之Lombok<a href="http://rensanning.iteye.com/blog/1930853" rel="nofollow" target="_blank">详细内容</a></li></td></tr></tbody></table><p>|      | </ul>                                                        </p><h4 id="第三部分：java开发常用工具类（正则校验）原文链接"><a href="#第三部分：java开发常用工具类（正则校验）原文链接" class="headerlink" title="第三部分：java开发常用工具类（正则校验）原文链接"></a>第三部分：java开发常用工具类（正则校验）<a href="https://www.cnblogs.com/ITzhangda/p/9146452.html">原文链接</a></h4><p>==java正则表达式的匹配包括：==</p><ul><li><p>邮箱，手机，姓名，昵称，身份证号，银行卡号等；</p></li><li><p>生成6位随机数；</p></li><li><p>对url中字符串进行编码和解码；</p></li><li><p>获取客户端ip地址；</p></li><li><p>获取系统当前时间；</p></li><li><p>生成32位编码不含横线；</p></li><li><p>生成MD5编码；</p></li><li><p>通过身份证获取性别；</p></li><li><p>通过身份证获取生日；</p></li><li><p>手机号中间4位替换成星号；</p></li><li><p>邮箱地址加星号；</p></li><li><p>生成随机密码；</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>util</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Json处理</title>
    <link href="/2020/04/02/java-json/"/>
    <url>/2020/04/02/java-json/</url>
    
    <content type="html"><![CDATA[<h3 id="FastJSON"><a href="#FastJSON" class="headerlink" title="FastJSON"></a>FastJSON</h3><ol><li><p>引入依赖或者Jar包</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.23<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>将Map转成JSON</p><div class="hljs code-wrapper"><pre><code class="hljs java">Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;();map.put(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);map.put(<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>);String mapJson = JSON.toJSONString(map);System.out.println(mapJson);<span class="hljs-comment">//输出&#123;&quot;key1&quot;:&quot;value1&quot;,&quot;key2&quot;:&quot;value2&quot;&#125;</span><span class="hljs-comment">//TODO 泛型的反序列化（使用TypeReference传入类型信息）</span>Map&lt;String, Object&gt; map2 = JSON.parseObject(mapJson, <span class="hljs-keyword">new</span> TypeReference&lt;Map&lt;String, Object&gt;&gt;()&#123;&#125;);System.out.println(map2);</code></pre></div></li><li><p>将List&lt;Map转成JSON</p><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Map&lt;String, Object&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Map&lt;String, Object&gt;&gt;();Map&lt;String, Object&gt; map1 = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;();map1.put(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);map1.put(<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>);Map&lt;String, Object&gt; map2 = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;();map2.put(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;value3&quot;</span>);map2.put(<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;value4&quot;</span>);list.add(map1);list.add(map2);String jsonstr = JSON.toJSONString(list);System.out.println(jsonstr);System.out.println(<span class="hljs-string">&quot;==========================================&quot;</span>);<span class="hljs-comment">//输出 [&#123;&quot;key1&quot;:&quot;value1&quot;,&quot;key2&quot;:&quot;value2&quot;&#125;,&#123;&quot;key1&quot;:&quot;value3&quot;,&quot;key2&quot;:&quot;value4&quot;&#125;]</span><span class="hljs-comment">// TODO String objJson = JSON.toJSONString(Object object, boolean prettyFormat)</span><span class="hljs-comment">//TODO 传入一个对象和一个布尔类型（是否格式化），将对象转成格式化后的JSON字符串。</span>String listJson1 = JSONArray.toJSONString(list, <span class="hljs-keyword">true</span>);System.out.println(listJson1);System.out.println(<span class="hljs-string">&quot;==========================================&quot;</span>);String listJson2 = JSONArray.toJSONString(list, <span class="hljs-keyword">false</span>);System.out.println(listJson2);System.out.println(<span class="hljs-string">&quot;==========================================&quot;</span>);<span class="hljs-comment">//TODO 使用单引号</span>String listJson = JSON.toJSONString(list, SerializerFeature.UseSingleQuotes);<span class="hljs-comment">//输出 [&#123;&#x27;key1&#x27;:&#x27;value1&#x27;,&#x27;key2&#x27;:&#x27;value2&#x27;&#125;,&#123;&#x27;key1&#x27;:&#x27;value3&#x27;,&#x27;key2&#x27;:&#x27;value4&#x27;&#125;]</span>System.out.println(listJson);System.out.println(<span class="hljs-string">&quot;==========================================&quot;</span>);<span class="hljs-comment">//TODO集合反序列化</span>List&lt;Map&gt; list1 = JSON.parseArray(listJson, Map.class);<span class="hljs-keyword">for</span>(Map&lt;String, Object&gt; map : list1)&#123;System.out.println(map.get(<span class="hljs-string">&quot;key1&quot;</span>));System.out.println(map.get(<span class="hljs-string">&quot;key2&quot;</span>));&#125;<span class="hljs-comment">//输出 value1 value2 value3 value4</span></code></pre></div></li><li><p>Java bean</p><div class="hljs code-wrapper"><pre><code class="hljs java">UserDO userDO = <span class="hljs-keyword">new</span> UserDO();userDO.setId(<span class="hljs-number">1</span>);userDO.setName(<span class="hljs-string">&quot;乐乐&quot;</span>);userDO.setAge(<span class="hljs-number">12</span>);String userJson = JSON.toJSONString(userDO);System.out.println(userJson);<span class="hljs-comment">//输出 &#123;&quot;age&quot;:12,&quot;id&quot;:1,&quot;username&quot;:&quot;乐乐&quot;&#125;</span><span class="hljs-comment">//TODO 普通序列化</span>UserDO user1 = (UserDO) JSON.parse(userJson);System.out.println(user1.getAge());<span class="hljs-comment">//输出 12</span><span class="hljs-comment">//TODO 指定Class信息反序列化</span>UserDO user2 = JSON.parseObject(userJson,UserDO.class);System.out.println(user2.getName());<span class="hljs-comment">//输出 乐乐</span></code></pre></div></li><li><p>时间</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//TODO （1）FastJSON将java.util.Date转成long。</span>String dateJson1 = JSON.toJSONString(<span class="hljs-keyword">new</span> Date());System.out.println(dateJson1);System.out.println(<span class="hljs-string">&quot;==========================================&quot;</span>);<span class="hljs-comment">//输出 1547900848449</span><span class="hljs-comment">//TODO（2）使用SerializerFeature特性格式化日期。</span>String dateJson2 = JSON.toJSONString(<span class="hljs-keyword">new</span> Date(), SerializerFeature.WriteDateUseDateFormat);System.out.println(dateJson2);System.out.println(<span class="hljs-string">&quot;==========================================&quot;</span>);<span class="hljs-comment">//输出 &quot;2019-01-19 20:29:24&quot;</span><span class="hljs-comment">//TODO（3）指定输出日期格式</span>String dateJson3 = JSON.toJSONStringWithDateFormat(<span class="hljs-keyword">new</span> Date(), <span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);System.out.println(dateJson3);System.out.println(<span class="hljs-string">&quot;==========================================&quot;</span>);<span class="hljs-comment">//输出&quot;2019-01-19 20:32:34&quot;</span></code></pre></div></li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>json</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux systemctl</title>
    <link href="/2020/04/02/linux-systemctl/"/>
    <url>/2020/04/02/linux-systemctl/</url>
    
    <content type="html"><![CDATA[<h1 id="systemctl配置管理文件详解"><a href="#systemctl配置管理文件详解" class="headerlink" title="systemctl配置管理文件详解"></a>systemctl配置管理文件详解</h1><ul><li>文件存放位置：（共三处）<br>/etc/systemd/system/<br>/usr/lib/systemd/system<br>/lib/systemd/system</li></ul><h2 id="文件内容"><a href="#文件内容" class="headerlink" title="文件内容"></a>文件内容</h2><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$cat</span> sshd.service    [Unit]    Description=OpenSSH server daemon    Documentation=man:sshd(8) man:sshd_config(5)    After=network.target sshd-keygen.service    Wants=sshd-keygen.service    [Service]    Type=forking    PIDFile=/var/run/sshd.pid    EnvironmentFile=/etc/sysconfig/sshd    ExecStart=/usr/sbin/sshd <span class="hljs-variable">$OPTIONS</span>    ExecReload=/bin/<span class="hljs-built_in">kill</span> -HUP <span class="hljs-variable">$MAINPID</span>    KillMode=process    Restart=on-failure    RestartSec=42s    [Install]    WantedBy=multi-user.target</code></pre></div><h2 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h2><div class="hljs code-wrapper"><pre><code class="hljs bash">[Unit] 区块：启动顺序与依赖关系。Description：当前配置文件的描述信息。Documentation：帮助信息。After：表示当前服务是在那个服务后面启动，一般定义为网络服务启动后启动Wants：表示sshd.service与sshd-keygen.service之间存在”弱依赖”关系，即如果”sshd-keygen.service”启动失败或停止运行，不影响sshd.service继续执行。[Service] 区块：启动行为Type：定义启动类型。PIDFile：服务的pid文件路径。EnvironmentFile：指定当前服务依赖的环境参数文件。ExecStart：定义启动进程时执行的命令。ExecReload：重启服务时执行的命令KillMode：定义 Systemd 如何停止 sshd 服务。Restart：定义了 sshd 退出后，Systemd 的重启方式。RestartSec：表示Systemd重启服务之前，需要等待的秒数。上面的例子设为等待42秒。[Install] 区块：定义如何安装这个配置文件，即怎样做到开机启动。WantedBy：表示该服务所在的 Target。multi-user.target表明当系统以多用户方式（默认的运行级别）启动时，这个服务需要被自动运行。</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>system</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux tar</title>
    <link href="/2020/04/02/linux-tar/"/>
    <url>/2020/04/02/linux-tar/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-Tar"><a href="#Linux-Tar" class="headerlink" title="Linux Tar"></a>Linux Tar</h1><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><ul><li>-c: 建立压缩档案<br>-x：解压<br>-t：查看内容<br>-r：向压缩归档文件末尾追加文件<br>-u：更新原压缩包中的文件</li></ul><p>这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。</p><ul><li>-z：有gzip属性的<br>-j：有bz2属性的<br>-Z：有compress属性的<br>-v：显示所有过程<br>-O：将文件解开到标准输出</li></ul><p>下面的参数-f是必须的</p><p>-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。</p><p># tar -cf all.tar *.jpg<br>这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。</p><p># tar -rf all.tar *.gif<br>这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。</p><p># tar -uf all.tar logo.gif<br>这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。</p><p># tar -tf all.tar<br>这条命令是列出all.tar包中所有文件，-t是列出文件的意思</p><p># tar -xf all.tar<br>这条命令是解出all.tar包中所有文件，-t是解开的意思</p><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>tar -cvf jpg.tar *.jpg //将目录里所有jpg文件打包成jpg.tar </p><p>tar -czf jpg.tar.gz *.jpg  //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz</p><p> tar -cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2</p><p>tar -cZf jpg.tar.Z *.jpg  //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z</p><p>rar a jpg.rar *.jpg //rar格式的压缩，需要先下载rar for linux</p><p>zip jpg.zip *.jpg //zip格式的压缩，需要先下载zip for linux</p><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p>tar -xvf file.tar //解压 tar包</p><p>tar -xzvf file.tar.gz //解压tar.gz</p><p>tar -xjvf file.tar.bz2  //解压 tar.bz2</p><p>tar -xZvf file.tar.Z  //解压tar.Z</p><p>unrar e file.rar //解压rar</p><p>unzip file.zip //解压zip</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、*.tar 用 tar -xvf 解压</p><p>2、*.gz 用 gzip -d或者gunzip 解压</p><p>3、*.tar.gz和*.tgz 用 tar -xzf 解压</p><p>4、*.bz2 用 bzip2 -d或者用bunzip2 解压</p><p>5、*.tar.bz2用tar -xjf 解压</p><p>6、*.Z 用 uncompress 解压</p><p>7、*.tar.Z 用tar -xZf 解压</p><p>8、*.rar 用 unrar e解压</p><p>9、*.zip 用 unzip 解压</p><div class="hljs code-wrapper"><pre><code class="hljs bash">-A或--catenate 新增文件到已存在的备份文件。-b&lt;区块数目&gt;或--blocking-factor=&lt;区块数目&gt; 设置每笔记录的区块数目，每个区块大小为12Bytes。-B或--read-full-records 读取数据时重设区块大小。-c或--create 建立新的备份文件。-C&lt;目的目录&gt;或--directory=&lt;目的目录&gt; 切换到指定的目录。-d或--diff或--compare 对比备份文件内和文件系统上的文件的差异。-f&lt;备份文件&gt;或--file=&lt;备份文件&gt; 指定备份文件。-F&lt;Script文件&gt;或--info-script=&lt;Script文件&gt; 每次更换磁带时，就执行指定的Script文件。-g或--listed-incremental 处理GNU格式的大量备份。-G或--incremental 处理旧的GNU格式的大量备份。-h或--dereference 不建立符号连接，直接复制该连接所指向的原始文件。-i或--ignore-zeros 忽略备份文件中的0 Byte区块，也就是EOF。-k或--keep-old-files 解开备份文件时，不覆盖已有的文件。-K&lt;文件&gt;或--starting-file=&lt;文件&gt; 从指定的文件开始还原。-l或--one-file-system 复制的文件或目录存放的文件系统，必须与tar指令执行时所处的文件系统相同，否则不予复制。-L&lt;媒体容量&gt;或-tape-length=&lt;媒体容量&gt; 设置存放每体的容量，单位以1024 Bytes计算。-m或--modification-time 还原文件时，不变更文件的更改时间。-M或--multi-volume 在建立，还原备份文件或列出其中的内容时，采用多卷册模式。-N&lt;日期格式&gt;或--newer=&lt;日期时间&gt; 只将较指定日期更新的文件保存到备份文件里。-o或--old-archive或--portability 将资料写入备份文件时使用V7格式。-O或--stdout 把从备份文件里还原的文件输出到标准输出设备。-p或--same-permissions 用原来的文件权限还原文件。-P或--absolute-names 文件名使用绝对名称，不移除文件名称前的<span class="hljs-string">&quot;/&quot;</span>号。-r或--append 新增文件到已存在的备份文件的结尾部分。-R或--block-number 列出每个信息在备份文件中的区块编号。-s或--same-order 还原文件的顺序和备份文件内的存放顺序相同。-S或--sparse 倘若一个文件内含大量的连续0字节，则将此文件存成稀疏文件。-t或--list 列出备份文件的内容。-T&lt;范本文件&gt;或--files-from=&lt;范本文件&gt; 指定范本文件，其内含有一个或多个范本样式，让tar解开或建立符合设置条件的文件。-u或--update 仅置换较备份文件内的文件更新的文件。-U或--unlink-first 解开压缩文件还原文件之前，先解除文件的连接。-v或--verbose 显示指令执行过程。-V&lt;卷册名称&gt;或--label=&lt;卷册名称&gt; 建立使用指定的卷册名称的备份文件。-w或--interactive 遭遇问题时先询问用户。-W或--verify 写入备份文件后，确认文件正确无误。-x或--extract或--get 从备份文件中还原文件。-X&lt;范本文件&gt;或--exclude-from=&lt;范本文件&gt; 指定范本文件，其内含有一个或多个范本样式，让ar排除符合设置条件的文件。-z或--gzip或--ungzip 通过gzip指令处理备份文件。-Z或--compress或--uncompress 通过compress指令处理备份文件。-&lt;设备编号&gt;&lt;存储密度&gt; 设置备份用的外围设备编号及存放数据的密度。--after-date=&lt;日期时间&gt; 此参数的效果和指定<span class="hljs-string">&quot;-N&quot;</span>参数相同。--atime-preserve 不变更文件的存取时间。--backup=&lt;备份方式&gt;或--backup 移除文件前先进行备份。--checkpoint 读取备份文件时列出目录名称。--concatenate 此参数的效果和指定<span class="hljs-string">&quot;-A&quot;</span>参数相同。--confirmation 此参数的效果和指定<span class="hljs-string">&quot;-w&quot;</span>参数相同。--delete 从备份文件中删除指定的文件。--exclude=&lt;范本样式&gt; 排除符合范本样式的文件。--group=&lt;群组名称&gt; 把加入设备文件中的文件的所属群组设成指定的群组。--<span class="hljs-built_in">help</span> 在线帮助。--ignore-failed-read 忽略数据读取错误，不中断程序的执行。--new-volume-script=&lt;Script文件&gt; 此参数的效果和指定<span class="hljs-string">&quot;-F&quot;</span>参数相同。--newer-mtime 只保存更改过的文件。--no-recursion 不做递归处理，也就是指定目录下的所有文件及子目录不予处理。--null 从null设备读取文件名称。--numeric-owner 以用户识别码及群组识别码取代用户名称和群组名称。--owner=&lt;用户名称&gt; 把加入备份文件中的文件的拥有者设成指定的用户。--posix 将数据写入备份文件时使用POSIX格式。--preserve 此参数的效果和指定<span class="hljs-string">&quot;-ps&quot;</span>参数相同。--preserve-order 此参数的效果和指定<span class="hljs-string">&quot;-A&quot;</span>参数相同。--preserve-permissions 此参数的效果和指定<span class="hljs-string">&quot;-p&quot;</span>参数相同。--record-size=&lt;区块数目&gt; 此参数的效果和指定<span class="hljs-string">&quot;-b&quot;</span>参数相同。--recursive-unlink 解开压缩文件还原目录之前，先解除整个目录下所有文件的连接。--remove-files 文件加入备份文件后，就将其删除。--rsh-command=&lt;执行指令&gt; 设置要在远端主机上执行的指令，以取代rsh指令。--same-owner 尝试以相同的文件拥有者还原文件。--suffix=&lt;备份字尾字符串&gt; 移除文件前先行备份。--totals 备份文件建立后，列出文件大小。--use-compress-program=&lt;执行指令&gt; 通过指定的指令处理备份文件。--version 显示版本信息。--volno-file=&lt;编号文件&gt; 使用指定文件内的编号取代预设的卷册编号。</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>system</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>welcome!</title>
    <link href="/2020/04/02/luna-welcome/"/>
    <url>/2020/04/02/luna-welcome/</url>
    
    <content type="html"><![CDATA[<h2 id="welcome"><a href="#welcome" class="headerlink" title="welcome!"></a>welcome!</h2><p>欢迎访问本系统~希望能帮助到您.</p><p>来自-&gt;<em>luna</em></p><h3 id="Hi-there-👋"><a href="#Hi-there-👋" class="headerlink" title="Hi there 👋"></a>Hi there 👋</h3><h1 id="𝗛𝗲𝗹𝗹𝗼-𝗜’𝗺-LUNA"><a href="#𝗛𝗲𝗹𝗹𝗼-𝗜’𝗺-LUNA" class="headerlink" title="𝗛𝗲𝗹𝗹𝗼! 𝗜’𝗺 LUNA"></a>𝗛𝗲𝗹𝗹𝗼! 𝗜’𝗺 LUNA</h1><p>𝑰 ❤️ 𝑫𝒆𝒗𝒆𝒍𝒐𝒑𝒎𝒆𝒏𝒕!</p><h2 id="𝗠𝘆-𝗧𝗲𝗰𝗸-𝗦𝘁𝗮𝗰𝗸"><a href="#𝗠𝘆-𝗧𝗲𝗰𝗸-𝗦𝘁𝗮𝗰𝗸" class="headerlink" title="𝗠𝘆 𝗧𝗲𝗰𝗸 𝗦𝘁𝗮𝗰𝗸"></a>𝗠𝘆 𝗧𝗲𝗰𝗸 𝗦𝘁𝗮𝗰𝗸</h2><table>    <tbody>        <tr valign="top">            <td width="10%" align="center">                <span>Java</span><br>                <img height="64px" src="https://cdn.svgporn.com/logos/java.svg">            </td>            <td width="10%" align="center">                <span>Linux</span><br>                <img height="64px" src="https://cdn.svgporn.com/logos/linux-tux.svg">            </td>            <td width="10%" align="center">                <span>Apache</span><br>                <img height="64px" src="https://cdn.svgporn.com/logos/apache.svg">            </td>            <td width="10%" align="center">                <span>Spring</span><br>                <img height="64px" src="https://cdn.svgporn.com/logos/spring.svg">            </td>            <td width="10%" align="center">                <span>Mysql</span><br>                <img height="64px" src="https://cdn.svgporn.com/logos/mysql.svg">            </td>            <td width="10%" align="center">                <span>Nginx</span><br>                <img height="64px" src="https://cdn.svgporn.com/logos/nginx.svg">            </td>            <td width="10%" align="center">                <span>Tomcat</span><br>                <img height="64px" src="https://cdn.svgporn.com/logos/tomcat.svg">            </td>            <td width="10%" align="center">                <span>Redis</span><br>                <img height="64px" src="https://cdn.svgporn.com/logos/redis.svg">            </td>            <td width="10%" align="center">                <span>Git</span><br>                <img height="64px" src="https://cdn.svgporn.com/logos/git-icon.svg">            </td>            <td width="10%" align="center">                <span>IDEA</span><br>                <img height="64px" src="https://cdn.svgporn.com/logos/intellij-idea.svg">            </td>        </tr>    </tbody></table><p><img src="https://github-readme-stats.vercel.app/api?username=czy1024&show_icons=true" alt="Anurag&#39;s github stats"></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>luna</category>
      
    </categories>
    
    
    <tags>
      
      <tag>welcome</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springMVC</title>
    <link href="/2020/04/02/spring-mvc/"/>
    <url>/2020/04/02/spring-mvc/</url>
    
    <content type="html"><![CDATA[<h3 id="1-页面模板解析"><a href="#1-页面模板解析" class="headerlink" title="1.页面模板解析"></a>1.页面模板解析</h3><p>可通过使用thymeleaf模板对应的spring配置，默认已经配置好，可手动配置其他路径</p><div class="hljs code-wrapper"><pre><code class="hljs gradle">spring.thymeleaf.prefix=<span class="hljs-keyword">classpath</span>:<span class="hljs-regexp">/templates/</span></code></pre></div><p>并且引入依赖</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- SpringBoot集成thymeleaf模板 --&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>即可在控制层实现页面跳转</p><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-meta">@Controller</span><span class="hljs-meta">@RequestMapping(path = &quot;crud&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseController</span> </span>&#123;<span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> UserDAO userDAO;<span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> DepartmentDAO departmentDAO;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 查询所有用户</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-meta">@GetMapping(&quot;/users&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">list</span><span class="hljs-params">(ModelMap map)</span> </span>&#123;List&lt;UserDO&gt; all = userDAO.getAll();map.put(<span class="hljs-string">&quot;users&quot;</span>, all);<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;user/users&quot;</span>; <span class="hljs-comment">//对应templates/user/users.html</span>&#125;</code></pre></div><p>在页面访问 {ip：端口}/项目路径/curd/users 即可访问对应页面。其中若<br>注解 @@RequestMapping(path = “crud”) 为 “/curd” 或者 @GetMapping(“users”)为”/users” 都可。</p><h3 id="2-重定向"><a href="#2-重定向" class="headerlink" title="2. 重定向"></a>2. 重定向</h3><p>重定向可带参数或者不带参数</p><ol><li>不带参数<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 添加用户请求</span><span class="hljs-comment"> * SpringMVC 自动将属性绑定  入参名和对象属性名一样</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-meta">@PostMapping(&quot;/user&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String  <span class="hljs-title">addUser</span><span class="hljs-params">(UserDO userDO)</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;提交的用户信息&quot;</span> + userDO);userDAO.insert(userDO);<span class="hljs-comment">//　TODO　添加完成后来到用户列表页面 redirect: 重定向地址  forward:转发地址 不能有空格</span><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/crud/users&quot;</span>;&#125;</code></pre></div></li><li>带参数传递</li></ol><div class="hljs code-wrapper"><pre><code class="hljs txt">redirect 目标有三种构建方式：1. 使用 redirect: 前缀url方式构建目标url2. 使用 RedirectView 类型指定目标, 推荐使用这个,3. 使用 ModelAndView 类型指定目标, ModelAndView 视图名默认是forward, 所以对于redirect, 需要加上 redirect: 前缀传参和取参方式:1. 传参: 以字符串的形式构建目标url, 可以使用 query variable的格式拼url. 取参: @RequestParam()来fetch2. 传参: redirectAttributes.addAttribute() 加的attr. 取参: @RequestParam()来fetch3. 传参: redirectAttributes.addFlashAttribute() 加的attr. 取参: @ModelAttribute()来fetchFlash attribute的特点:1. addFlashAttribute() 可以是任意类型的数据(不局限在String等基本类型), addAttribute()只能加基本类型的参数.2. addFlashAttribute() 加的 attr, 不会出现在url 地址栏上.3. addFlashAttribute() 加的 attr, 一旦fetch后, 就会自动清空, 非常适合 form 提交后 feedback Message.</code></pre></div><h3 id="3-请求转发"><a href="#3-请求转发" class="headerlink" title="3. 请求转发"></a>3. 请求转发</h3><p>在Spring MVC 中, 构建forward 目标有两种方式:</p><ol><li>以字符串的形式构建目标url, url 需要加上 forward: 前缀</li><li>使用 ModelAndView 对象来设置转发的forward目标, viewName 可以省略 forward: 前缀, viewName 应该是目标url, 而不是目标视图的函数名.<br>传参方式:</li><li>以字符串的形式构建目标url, 可以使用 query variable的格式拼url</li><li>使用 ModelAndView 对象来增加 attribute Object, 其结果也是在拼接url.<br>取参的方式: 可以使用 @RequestParam 来取参. </li></ol><p>eg：Java代码</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-meta">@RequestMapping(&quot;/&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoController</span> </span>&#123;    <span class="hljs-comment">/*</span><span class="hljs-comment">     * forward 示例: 以字符串的形式构建目标url, url 需要加上 forward: 前缀</span><span class="hljs-comment">     * */</span>    <span class="hljs-meta">@RequestMapping(&quot;/forwardTest1&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">forwardTest1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forward:/forwardTarget?param1=v1&amp;param2=v2&quot;</span>;    &#125;    <span class="hljs-comment">/*</span><span class="hljs-comment">     * forward 示例: 使用 ModelAndView() 设置转发的目标url</span><span class="hljs-comment">     * */</span>    <span class="hljs-meta">@RequestMapping(&quot;/forwardTest2&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">forwardTest2</span><span class="hljs-params">()</span> </span>&#123;        ModelAndView mav=<span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;/forwardTarget&quot;</span>); <span class="hljs-comment">// 绝对路径OK</span>        <span class="hljs-comment">//ModelAndView mav=new ModelAndView(&quot;forwardTarget&quot;); // 相对路径也OK</span>        mav.addObject(<span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);        mav.addObject(<span class="hljs-string">&quot;param2&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>);        <span class="hljs-keyword">return</span> mav ;    &#125;    <span class="hljs-meta">@RequestMapping(&quot;/forwardTarget&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">forwardTargetView</span><span class="hljs-params">(Model model, <span class="hljs-meta">@RequestParam(&quot;param1&quot;)</span> String param1,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@RequestParam(&quot;param2&quot;)</span> String param2)</span> </span>&#123;        model.addAttribute(<span class="hljs-string">&quot;param1&quot;</span>, param1);        model.addAttribute(<span class="hljs-string">&quot;param2&quot;</span>, param2);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forwardTarget&quot;</span>;    &#125;    <span class="hljs-comment">/*</span><span class="hljs-comment">     * redirect 目标有三种构建方式</span><span class="hljs-comment">     * 1. 使用 redirect: 前缀url方式构建目标url</span><span class="hljs-comment">     * 2. 使用 RedirectView 类型指定目标</span><span class="hljs-comment">     * 3. 使用 ModelAndView 类型指定目标, ModelAndView 视图名默认是forward, 所以对于redirect, 需要加上 redirect: 前缀</span><span class="hljs-comment">     * */</span>    <span class="hljs-meta">@RequestMapping(&quot;/noParamRedirect&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RedirectView <span class="hljs-title">noParamTest</span><span class="hljs-params">()</span> </span>&#123;        RedirectView redirectTarget = <span class="hljs-keyword">new</span> RedirectView();        redirectTarget.setContextRelative(<span class="hljs-keyword">true</span>);        redirectTarget.setUrl(<span class="hljs-string">&quot;noParamTarget&quot;</span>);        <span class="hljs-keyword">return</span> redirectTarget;    &#125;    <span class="hljs-meta">@RequestMapping(&quot;/noParamTarget&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">redirectTarget</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;noParamTarget&quot;</span>;    &#125;    <span class="hljs-meta">@RequestMapping(&quot;/withParamRedirect&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RedirectView <span class="hljs-title">withParamRedirect</span><span class="hljs-params">(RedirectAttributes redirectAttributes)</span> </span>&#123;        RedirectView redirectTarget = <span class="hljs-keyword">new</span> RedirectView();        redirectTarget.setContextRelative(<span class="hljs-keyword">true</span>);        redirectTarget.setUrl(<span class="hljs-string">&quot;withParamTarget&quot;</span>);        redirectAttributes.addAttribute(<span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);        redirectAttributes.addAttribute(<span class="hljs-string">&quot;param2&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>);        <span class="hljs-keyword">return</span> redirectTarget;    &#125;    <span class="hljs-meta">@RequestMapping(&quot;/withParamTarget&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">withParamTarget</span><span class="hljs-params">(Model model, <span class="hljs-meta">@RequestParam(&quot;param1&quot;)</span> String param1,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@RequestParam(&quot;param2&quot;)</span> String param2)</span> </span>&#123;        model.addAttribute(<span class="hljs-string">&quot;param1&quot;</span>, param1);        model.addAttribute(<span class="hljs-string">&quot;param2&quot;</span>, param2);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;withParamTarget&quot;</span>;    &#125;    <span class="hljs-meta">@RequestMapping(&quot;/withFlashRedirect&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RedirectView <span class="hljs-title">withFlashTest</span><span class="hljs-params">(RedirectAttributes redirectAttributes)</span> </span>&#123;        RedirectView redirectTarget = <span class="hljs-keyword">new</span> RedirectView();        redirectTarget.setContextRelative(<span class="hljs-keyword">true</span>);        redirectTarget.setUrl(<span class="hljs-string">&quot;withFlashTarget&quot;</span>);        redirectAttributes.addAttribute(<span class="hljs-string">&quot;param&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);        redirectAttributes.addFlashAttribute(<span class="hljs-string">&quot;flashParam&quot;</span>, <span class="hljs-string">&quot;flashValue&quot;</span>);        <span class="hljs-keyword">return</span> redirectTarget;    &#125;    <span class="hljs-comment">/*</span><span class="hljs-comment">     * redirectAttributes.addAttribute加的attr, 使用 @RequestParam()来fetch</span><span class="hljs-comment">     * redirectAttributes.addFlashAttribute()加的attr, 使用 @ModelAttribute()来fetch</span><span class="hljs-comment">     * */</span>    <span class="hljs-meta">@RequestMapping(&quot;/withFlashTarget&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">withFlashTarget</span><span class="hljs-params">(Model model, <span class="hljs-meta">@RequestParam(&quot;param&quot;)</span> String param,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@ModelAttribute(&quot;flashParam&quot;)</span> String flashParam)</span> </span>&#123;        model.addAttribute(<span class="hljs-string">&quot;param&quot;</span>, param);        model.addAttribute(<span class="hljs-string">&quot;flashParam&quot;</span>, flashParam);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;withFlashTarget&quot;</span>;    &#125;    <span class="hljs-meta">@GetMapping(&quot;/input&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">input</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;input&quot;</span>;    &#125;    <span class="hljs-comment">/*</span><span class="hljs-comment">     * form 提交后, 如果form数据有问题, 使用redirectAttributes.addFlashAttribute()加上 flash message.</span><span class="hljs-comment">     * addFlashAttribute()可以是任意类型的数据(不局限在String等基本类型)</span><span class="hljs-comment">     * addFlashAttribute() 加的 attr, 不会出现在url 地址栏上.</span><span class="hljs-comment">     * addFlashAttribute() 加的 attr, 一旦fetch后, 就会自动清空, 非常适合 form 提交后 feedback Message.</span><span class="hljs-comment">     * */</span>    <span class="hljs-meta">@PostMapping(&quot;/submit&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RedirectView <span class="hljs-title">submit</span><span class="hljs-params">(RedirectAttributes redirectAttributes)</span> </span>&#123;        <span class="hljs-keyword">boolean</span> passed = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span> (passed==<span class="hljs-keyword">false</span>) &#123;            RedirectView redirectTarget = <span class="hljs-keyword">new</span> RedirectView();            redirectTarget.setContextRelative(<span class="hljs-keyword">true</span>);            redirectTarget.setUrl(<span class="hljs-string">&quot;input&quot;</span>);            redirectAttributes.addFlashAttribute(<span class="hljs-string">&quot;errorMessage&quot;</span>, <span class="hljs-string">&quot;some error information here&quot;</span>);            <span class="hljs-keyword">return</span> redirectTarget;        &#125;<span class="hljs-keyword">else</span> &#123;            RedirectView redirectTarget = <span class="hljs-keyword">new</span> RedirectView();            redirectTarget.setContextRelative(<span class="hljs-keyword">true</span>);            redirectTarget.setUrl(<span class="hljs-string">&quot;inputOK&quot;</span>);            <span class="hljs-keyword">return</span> redirectTarget;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springmvc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shiro</title>
    <link href="/2020/04/02/shiro-start/"/>
    <url>/2020/04/02/shiro-start/</url>
    
    <content type="html"><![CDATA[<h2 id="Shiro框架中有三个核心概念：Subject-，SecurityManager和Realms。"><a href="#Shiro框架中有三个核心概念：Subject-，SecurityManager和Realms。" class="headerlink" title="Shiro框架中有三个核心概念：Subject ，SecurityManager和Realms。"></a>Shiro框架中有三个核心概念：Subject ，SecurityManager和Realms。</h2><h3 id="1-Subject"><a href="#1-Subject" class="headerlink" title="1    Subject"></a>1    Subject</h3><p>Subject一词是一个安全术语，其基本意思是“当前的操作用户”。称之为“用户”并不准确，因为“用户”一词通常跟人相关。在安全领域，术语“Subject”可以是人，也可以是第三方进程、后台帐户（Daemon Account）、定时作业（Corn Job）或其他类似事物。它仅仅意味着“当前跟软件交互的东西”。但考虑到大多数目的和用途，你可以把它认为是Shiro的“用户”概念。<br>在程序中你都能轻易的获得Subject，允许在任何需要的地方进行安全操作。每个Subject对象都必须与一个SecurityManager进行绑定，你访问Subject对象其实都是在与SecurityManager里的特定Subject进行交互。</p><h3 id="2-SecurityManager"><a href="#2-SecurityManager" class="headerlink" title="2    SecurityManager"></a>2    SecurityManager</h3><p>Subject的“幕后”推手是SecurityManager。Subject代表了当前用户的安全操作，SecurityManager则管理所有用户的安全操作。它是Shiro框架的核心，充当“保护伞”，引用了多个内部嵌套安全组件，它们形成了对象图。但是，一旦SecurityManager及其内部对象图配置好，它就会退居幕后，应用开发人员几乎把他们的所有时间都花在Subject API调用上。<br>那么，如何设置SecurityManager呢？嗯，这要看应用的环境。例如，Web应用通常会在Web.xml中指定一个Shiro Servlet Filter，这会创建SecurityManager实例，如果你运行的是一个独立应用，你需要用其他配置方式，但有很多配置选项。<br>一个应用几乎总是只有一个SecurityManager实例。它实际是应用的Singleton（尽管不必是一个静态Singleton）。跟Shiro里的几乎所有组件一样，SecurityManager的缺省实现是POJO，而且可用POJO兼容的任何配置机制进行配置 - 普通的Java代码、Spring XML、YAML、.properties和.ini文件等。基本来讲，能够实例化类和调用JavaBean兼容方法的任何配置形式都可使用。</p><h3 id="3-Realms"><a href="#3-Realms" class="headerlink" title="3    Realms"></a>3    Realms</h3><p>Shiro的第三个也是最后一个概念是Realm。Realm充当了Shiro与应用安全数据间的“桥梁”或者“连接器”。也就是说，当与像用户帐户这类安全相关数据进行交互，执行认证（登录）和授权（访问控制）时，Shiro会从应用配置的Realm中查找很多内容。<br>从这个意义上讲，Realm实质上是一个安全相关的DAO：它封装了数据源的连接细节，并在需要时将相关数据提供给Shiro。当配置Shiro时，你必须至少指定一个Realm，用于认证和（或）授权。配置多个Realm是可以的，但是至少需要一个。<br>Shiro内置了可以连接大量安全数据源（又名目录）的Realm，如LDAP、关系数据库（JDBC）、类似INI的文本配置资源以及属性文件 等。如果缺省的Realm不能满足需求，你还可以插入代表自定义数据源的自己的Realm实现。<br>象其他内部组件一样，由SecurityManager来管理如何使用Realms来获取安全的身份数据。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>middle-component</category>
      
      <category>shiro</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shiro</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
