

<!DOCTYPE html>
<html lang="ZH-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" href="/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="luna">
  <meta name="keywords" content="博客,luna,java,spring,utils,linux,idea">
  <meta name="description" content="掌握 Spring 之 RestTemplate前言在 Java 服务端开发领域里，Spring 是绕不开的话题，尤其是现在微服务概念盛行，Spring Boot 的出现更是给 Spring 注入了新的活力，除此之外还有 Spring Cloud，这些框架让 Spring 技术体系更加丰富。Spring 从 2014 年的 1.0.0 版本迭代到 现在的 5.2.0 M1 版本，紧随着 Java">
<meta property="og:type" content="article">
<meta property="og:title" content="spring RestTemplate">
<meta property="og:url" content="https://lunasaw.github.io/2020/11/24/spring-rest-template/index.html">
<meta property="og:site_name" content="十平方米小屋">
<meta property="og:description" content="掌握 Spring 之 RestTemplate前言在 Java 服务端开发领域里，Spring 是绕不开的话题，尤其是现在微服务概念盛行，Spring Boot 的出现更是给 Spring 注入了新的活力，除此之外还有 Spring Cloud，这些框架让 Spring 技术体系更加丰富。Spring 从 2014 年的 1.0.0 版本迭代到 现在的 5.2.0 M1 版本，紧随着 Java">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lunasaw.github.io/img/springrest/1.jpg">
<meta property="og:image" content="https://lunasaw.github.io/img/springrest/2.jpg">
<meta property="og:image" content="https://lunasaw.github.io/img/springrest/3.jpg">
<meta property="og:image" content="https://lunasaw.github.io/img/springrest/4.jpg">
<meta property="og:image" content="https://lunasaw.github.io/img/springrest/5.jpg">
<meta property="article:published_time" content="2020-11-23T16:00:00.000Z">
<meta property="article:modified_time" content="2022-09-16T02:41:51.995Z">
<meta property="article:author" content="luna">
<meta property="article:tag" content="RestTemplate">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://lunasaw.github.io/img/springrest/1.jpg">
  
    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas><script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
  
  <title>spring RestTemplate - 十平方米小屋</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/idea.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"lunasaw.github.io","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":65,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":true,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"1WlABYJFX3ooWNnixAEsUHg2-gzGzoHsz","app_key":"4HAsQYXea2QPsxkF5wOFFpbH","server_url":"https://cn-n1-cell1.leancloud.cn","path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>十平方米小屋</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                链接
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/basic/spring-binner.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.2)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="spring RestTemplate">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      luna
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-11-24 00:00" pubdate>
        2020年11月24日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      17k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      54 分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">spring RestTemplate</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：10 天前
                
              </p>
            
            <div class="markdown-body">
              <h1 id="掌握-Spring-之-RestTemplate"><a href="#掌握-Spring-之-RestTemplate" class="headerlink" title="掌握 Spring 之 RestTemplate"></a>掌握 Spring 之 RestTemplate</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Java 服务端开发领域里，Spring 是绕不开的话题，尤其是现在微服务概念盛行，Spring Boot 的出现更是给 Spring 注入了新的活力，除此之外还有 Spring Cloud，这些框架让 Spring 技术体系更加丰富。Spring 从 2014 年的 1.0.0 版本迭代到 现在的 5.2.0 M1 版本，紧随着 Java 语言发展，不断引入新的特性和功能。本文关注的是 Spring 框架中 <code>RestTemplate</code> 内容，可以减少我们平时开发常使用的 <code>HttpClient</code> API 依赖。文章所涉及的示例 Demo 详见Github 地址：<a target="_blank" rel="noopener" href="https://github.com/wrcj12138aaa/resttemplate/tree/master">Resttemplate demo</a> 。感谢小七同学的认真校对，如果有任何技术问题或者文章纰漏，欢迎留言联系，一起交流探讨 😁。</p>
<h2 id="认识-RestTemplate"><a href="#认识-RestTemplate" class="headerlink" title="认识 RestTemplate"></a>认识 <code>RestTemplate</code></h2><p>首先在我们学习使用 <code>RestTemplate</code> 之前，先认识下这个类，来看 Spring 官方怎么描述的。 从官方 API 文档 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html">RestTemplate javadoc</a> 可以找该类的描述如下：</p>
<blockquote>
<p>Synchronous client to perform HTTP requests, exposing a simple, template method API over underlying HTTP client libraries such as the JDK HttpURLConnection, Apache HttpComponents, and others. The RestTemplate offers templates for common scenarios by HTTP method, in addition to the generalized exchange and execute methods that support of less frequent cases.</p>
</blockquote>
<p>从这里可以清楚地了解到 <code>RestTemplate</code> 采用同步方式执行 HTTP 请求的类，底层使用 JDK 原生 <code>HttpURLConnection</code> API ，或者 <code>HttpComponents</code>等其他 HTTP 客户端请求类库。还有一处强调的就是 <code>RestTemplate</code> 提供模板化的方法让开发者能更简单地发送 HTTP 请求。</p>
<p>值得注意的是，<code>RestTemplate</code> 类是在 Spring Framework 3.0 开始引入的，这里我们使用的 Spring 版本为当前最新的 GA 版本 5.1.6。而在 5.0 以上，官方标注了更推荐使用非阻塞的响应式 HTTP 请求处理类 <code>org.springframework.web.reactive.client.WebClient</code> 来替代 <code>RestTemplate</code>，尤其是对应异步请求处理的场景上 。</p>
<p>这里我们先简单总结下什么是 <code>RestTemplate</code> ： <code>RestTemplate</code> 就是 Spring 封装的处理同步 HTTP 请求的类。具体如何使用这个类进行 HTTP 请求操作，可见文章的实战部分。</p>
<p>接下来我们看下 <code>RestTemplate</code> 类提供的 API 有哪些,<code>RestTemplate</code> 提供了将近 30 个请求方法，其中多数是单个方法重载实现，这里我主要参考官方文档 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.6.RELEASE/spring-framework-reference/integration.html#rest-client-access">rest-client-access</a> 进行如下分类：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>getForObject</code></td>
<td>通过 GET 请求获得响应结果</td>
</tr>
<tr>
<td><code>getForEntity</code></td>
<td>通过 GET 请求获取 <code>ResponseEntity</code> 对象，包容有状态码，响应头和响应数据</td>
</tr>
<tr>
<td><code>headForHeaders</code></td>
<td>以 HEAD 请求资源返回所有响应头信息</td>
</tr>
<tr>
<td><code>postForLocation</code></td>
<td>用 POST 请求创建资源，并返回响应数据中响应头的字段 <code>Location</code> 的数据</td>
</tr>
<tr>
<td><code>postForObject</code></td>
<td>通过 POST 请求创建资源，获得响应结果</td>
</tr>
<tr>
<td><code>put</code></td>
<td>通过 PUT 方式请求来创建或者更新资源</td>
</tr>
<tr>
<td><code>patchForObject</code></td>
<td>通过 PATH 方式请求来更新资源，并获得响应结果。(JDK <code>HttpURLConnection</code> 不支持 PATH 方式请求，其他 HTTP 客户端库支持)</td>
</tr>
<tr>
<td><code>delete</code></td>
<td>通过 DELETE 方式删除资源</td>
</tr>
<tr>
<td><code>optionsForAllow</code></td>
<td>通过 ALLOW 方式请求来获得资源所允许访问的所有 HTTP 方法，可用看某个请求支持哪些请求方式</td>
</tr>
<tr>
<td><code>exchange</code></td>
<td>更通用版本的请求处理方法，接受一个 <code>RequestEntity</code> 对象，可以设置路径，请求头，请求信息等，最后返回一个 <code>ResponseEntity</code> 实体</td>
</tr>
<tr>
<td><code>execute</code></td>
<td>最通用的执行 HTTP 请求的方法，上面所有方法都是基于 <code>execute</code> 的封装，全面控制请求信息，并通过回调接口获得响应数据</td>
</tr>
</tbody></table>
<p>看到那么多方法也记不全，为了更好理解，可以简单看下 <code>RestTemplate</code> 的类层级体系，通过官方源代码就能看到:</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Interface specifying a basic set of RESTful operations.</span>
<span class="hljs-comment"> * Implemented by &#123;<span class="hljs-doctag">@link</span> RestTemplate&#125;. Not often used directly, but a useful</span>
<span class="hljs-comment"> * option to enhance testability, as it can easily be mocked or stubbed.</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Arjen Poutsma</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Juergen Hoeller</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 3.0</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@see</span> RestTemplate</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RestOperations</span> </span>&#123;
					    ...
&#125;
</code></pre></div>

<p>其实 <code>RestTemplate</code> 类的请求方法都是来自 <code>RestOperations</code> 接口的，根据这个名字就可以大概知道这个接口主要就是提供了 RESTful 请求操作的接口，如 GET，POST，PUT，DELETE 等，具体信息可以参见 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/client/RestOperations.html">RestOperation javadoc</a>。</p>
<p><img src="/img/springrest/1.jpg" srcset="/img/loading.gif" lazyload alt="RestTemplate 类层次图"></p>
<blockquote>
<p>关于 RESTful：</p>
<p>来自Wikipedia 定义：<strong>表现层状态转换</strong>，一种设计提供万维网络服务的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E4%BB%B6%E6%9E%B6%E6%A7%8B">软件构建风格</a>，又简称为 REST。</p>
<p><strong>用 URL 定位资源，用 HTTP 动词描述操作，如 GET,POST,DELETE,PUT</strong>，简单来说通过 URL 就知道访问什么资源，通过 HTTP Method 就知道执行什么操作，通过 HTTP Status Code 就知道执行结果。</p>
</blockquote>
<h2 id="实战-RestTemplate"><a href="#实战-RestTemplate" class="headerlink" title="实战 RestTemplate"></a>实战 <code>RestTemplate</code></h2><p>好了，简单认识了 <code>RestTemplate</code> 类之后，我们先牛刀小试，看看如何上手使用。</p>
<h3 id="1-生成-Demo-项目，导入-IDE"><a href="#1-生成-Demo-项目，导入-IDE" class="headerlink" title="1. 生成 Demo 项目，导入 IDE"></a>1. 生成 Demo 项目，导入 IDE</h3><p>为了能快速搭建一个 Demo，我们这边用 Spring Boot 框架搭建，首先用官方提供的 <a target="_blank" rel="noopener" href="https://start.spring.io/">Spring Initializr</a> 来生成快速构建项目骨架，选择 Spring Boot 版本 2.1.4,其底层依赖的 Spring Framework 版本为最新发布版本 5.1.6，对于 POM 依赖只选择一个 Web 模块即可，这样便于快速搭建 Web 应用。</p>
<p><img src="/img/springrest/2.jpg" srcset="/img/loading.gif" lazyload alt="spring initializr"></p>
<p>点击生成工程按钮，就可以下载到项目的压缩包，解压后用自己常用的 IDE 导入项目，项目结构整理如下：</p>
<p><img src="/img/springrest/3.jpg" srcset="/img/loading.gif" lazyload alt="项目骨架"></p>
<p>项目中 <code>ResttemplateApplication.java</code> 为整个程序的引导类，用于启动项目。</p>
<h3 id="2-编写请求控制器类-ProductController"><a href="#2-编写请求控制器类-ProductController" class="headerlink" title="2. 编写请求控制器类 ProductController"></a>2. 编写请求控制器类 ProductController</h3><p>首先为了能够使用 <code>RestTemplate</code> 发送多种方式 HTTP 请求，先本地构建接受 HTTP 请求的产品控制器，新建包 <code>com.one.learn.resttemplate.controller</code>,新建产品 Controller <code>ProductController</code> , 代码如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/product&quot;)</span>
<span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductController</span> </span>&#123;

    <span class="hljs-meta">@GetMapping(&quot;/get_product1&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">get_product1</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Product(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;ProductA&quot;</span>, BigDecimal.valueOf(<span class="hljs-number">6666.0</span>));
    &#125;

    <span class="hljs-meta">@GetMapping(&quot;/get_product2&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">get_product2</span><span class="hljs-params">(Integer id)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Product(id, <span class="hljs-string">&quot;ProductC&quot;</span>, BigDecimal.valueOf(<span class="hljs-number">6666.0</span>));
    &#125;

    <span class="hljs-meta">@GetMapping(&quot;/get_product3&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get_product3</span><span class="hljs-params">(Product product)</span> </span>&#123;
        <span class="hljs-keyword">return</span> product.toString();
    &#125;


    <span class="hljs-meta">@PostMapping(&quot;/post_product1&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">post_product1</span><span class="hljs-params">(Product product)</span> </span>&#123;
        <span class="hljs-keyword">return</span> product.toString();
    &#125;

    <span class="hljs-meta">@PostMapping(&quot;/post_product2&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">post_product2</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Product product)</span> </span>&#123;
        <span class="hljs-keyword">return</span> product.toString();
    &#125;

    <span class="hljs-meta">@DeleteMapping(&quot;/delete/&#123;id&#125;&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span> </span>&#123;
        String result = String.format(<span class="hljs-string">&quot;编号为%s的产品删除成功&quot;</span>, id);
        System.out.println(result);
        <span class="hljs-keyword">return</span> result;
    &#125;

    <span class="hljs-meta">@PutMapping(&quot;/update&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">updateByPut</span><span class="hljs-params">(Product product)</span> </span>&#123;
        String result = product.toString() + <span class="hljs-string">&quot; 更新成功&quot;</span>;
        System.out.println(result);
        <span class="hljs-keyword">return</span> result;
    &#125;

    <span class="hljs-meta">@PostMapping(&quot;/upload&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">upload</span><span class="hljs-params">(MultipartRequest request)</span> </span>&#123;
 	       <span class="hljs-comment">// Spring MVC 使用 MultipartRequest 接受带文件的 HTTP 请求</span>
        MultipartFile file = request.getFile(<span class="hljs-string">&quot;file&quot;</span>); 
        String originalFilename = file.getOriginalFilename();
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;upload success filename: &quot;</span> + originalFilename;
    &#125;
&#125;
</code></pre></div>

<p>在<code>Product</code> 控制器中涉及的实体类 <code>Product</code> 创建在 <code>com.one.learn.resttemplate.bean</code> 包下，代码如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> </span>&#123;
    <span class="hljs-keyword">private</span> Integer id;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> BigDecimal price;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Product</span><span class="hljs-params">()</span> </span>&#123;
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Product</span><span class="hljs-params">(Integer id, String name, BigDecimal price)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.id = id;
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.price = price;
    &#125;

			    <span class="hljs-comment">// 省去 setter getter 方法</span>
	
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Product&#123;&quot;</span> +
                <span class="hljs-string">&quot;id=&#x27;&quot;</span> + id + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +
                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +
                <span class="hljs-string">&quot;, price=&#x27;&quot;</span> + price + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +
                <span class="hljs-string">&#x27;&#125;&#x27;</span>;
    &#125;
&#125;
</code></pre></div>

<p>有了这些类，就可以利用程序引导类 <code>ResttemplateApplication</code> 启动 Spring Boot 项目，一个简单的 Web 应用就诞生了,监听 8080 端口，结果如下图所示：</p>
<p><img src="/img/springrest/4.jpg" srcset="/img/loading.gif" lazyload alt="项目启动"></p>
<p>我们可以简单测试一下，打开浏览器，访问 <code>http://localhost:8080/product/get_product1</code>，会看到如图所示的结果：</p>
<p><img src="/img/springrest/5.jpg" srcset="/img/loading.gif" lazyload alt="项目访问"></p>
<h3 id="3-编写测试类用-RestTemplate-发送-HTTP-请求"><a href="#3-编写测试类用-RestTemplate-发送-HTTP-请求" class="headerlink" title="3. 编写测试类用 RestTemplate 发送 HTTP 请求"></a>3. 编写测试类用 RestTemplate 发送 HTTP 请求</h3><p>有了 Web 服务，接下来该使用 <code>RestTemplate</code> 来发送请求并处理响应了。我们在 <code>test</code> 文件下新建一个测试类 <code>com.one.learn.resttemplate.RestTemplateTests</code>,代码如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RestTemplateTests</span> </span>&#123;
    RestTemplate restTemplate = <span class="hljs-keyword">null</span>;

    <span class="hljs-meta">@Before</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>&#123;
        restTemplate = <span class="hljs-keyword">new</span> RestTemplate();
    &#125;
    
&#125;
</code></pre></div>

<p>这里我们通过编写测试方法来用 <code>RestTemplate</code> API 实现对 <code>Product</code> 控制器各个接口的请求。</p>
<h4 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h4><p>我们先最简单的下手，尝试用 <code>RestTemplate</code> 访问请求路径为 <code>product/get_product1</code>, 一个不带任何参数 的 GET 请求，代码如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGet_product1</span><span class="hljs-params">()</span> </span>&#123;
   String url = <span class="hljs-string">&quot;http://localhost:8080/product/get_product1&quot;</span>;
   <span class="hljs-comment">//方式一：GET 方式获取 JSON 串数据</span>
   String result = restTemplate.getForObject(url, String.class);
   System.out.println(<span class="hljs-string">&quot;get_product1返回结果：&quot;</span> + result);
   Assert.hasText(result, <span class="hljs-string">&quot;get_product1返回结果为空&quot;</span>);
	
	   <span class="hljs-comment">//方式二：GET 方式获取 JSON 数据映射后的 Product 实体对象</span>
   Product product = restTemplate.getForObject(url, Product.class);
   System.out.println(<span class="hljs-string">&quot;get_product1返回结果：&quot;</span> + product);
   Assert.notNull(product, <span class="hljs-string">&quot;get_product1返回结果为空&quot;</span>);
	
	   <span class="hljs-comment">//方式三：GET 方式获取包含 Product 实体对象 的响应实体 ResponseEntity 对象,用 getBody() 获取</span>
   ResponseEntity&lt;Product&gt; responseEntity = restTemplate.getForEntity(url, Product.class);
   System.out.println(<span class="hljs-string">&quot;get_product1返回结果：&quot;</span> + responseEntity);
   Assert.isTrue(responseEntity.getStatusCode().equals(HttpStatus.OK), <span class="hljs-string">&quot;get_product1响应不成功&quot;</span>);
   
&#125;
</code></pre></div>

<p>首先看下运行测试方法 <code>testGet_product1</code> 后控制台的输出日志：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java">...
get_product1返回结果：&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;ProductA&quot;</span>,<span class="hljs-string">&quot;price&quot;</span>:<span class="hljs-number">6666.0</span>&#125;
...
get_product1返回结果：Product&#123;id=<span class="hljs-string">&#x27;1&#x27;</span>, name=<span class="hljs-string">&#x27;ProductA&#x27;</span>, price=<span class="hljs-string">&#x27;6666.0&#x27;</span>&#125;
...
get_product1返回结果：&lt;<span class="hljs-number">200</span>,Product&#123;id=<span class="hljs-string">&#x27;1&#x27;</span>, name=<span class="hljs-string">&#x27;ProductA&#x27;</span>, price=<span class="hljs-string">&#x27;6666.0&#x27;</span>&#125;,[Content-Type:<span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>, Transfer-Encoding:<span class="hljs-string">&quot;chunked&quot;</span>, Date:<span class="hljs-string">&quot;Thu, 09 May 2019 15:37:25 GMT&quot;</span>]&gt;
...
</code></pre></div>

<p>可以看到 <code>testGet_product1</code> 请求都是成功响应并获取到了数据，从上面代码上看是不是很简单。现在来点略复杂的请求方式，使用 <code>RestTemplate</code> API 中 <code>exchange</code> 和 <code>execute</code> 方法发送 GET 请求，可以更加细粒度控制请求的行为，如 <code>Header</code> 信息，数据处理方式等,同样在 <code>testGet_product1</code> 方法里添加代码如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGet_product1</span><span class="hljs-params">()</span> </span>&#123;
    String url = <span class="hljs-string">&quot;http://localhost:8080/product/get_product1&quot;</span>;
    <span class="hljs-comment">//....</span>
    
    <span class="hljs-comment">//方式一： 构建请求实体 HttpEntity 对象，用于配置 Header 信息和请求参数</span>
    MultiValueMap header = <span class="hljs-keyword">new</span> LinkedMultiValueMap();
    header.add(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE);
    HttpEntity&lt;Object&gt; requestEntity = <span class="hljs-keyword">new</span> HttpEntity&lt;&gt;(header);
    <span class="hljs-comment">//方式二： 执行请求获取包含 Product 实体对象 的响应实体 ResponseEntity 对象,用 getBody() 获取</span>
    ResponseEntity&lt;Product&gt; exchangeResult = restTemplate.exchange(url, HttpMethod.GET, requestEntity, Product.class);
    System.out.println(<span class="hljs-string">&quot;get_product1返回结果：&quot;</span> + exchangeResult);
    Assert.isTrue(exchangeResult.getStatusCode().equals(HttpStatus.OK), <span class="hljs-string">&quot;get_product1响应不成功&quot;</span>);

    	<span class="hljs-comment">//方式三： 根据 RequestCallback 接口实现类设置Header信息,用 ResponseExtractor 接口实现类读取响应数据</span>
    String executeResult = restTemplate.execute(url, HttpMethod.GET, request -&gt; &#123;
        request.getHeaders().add(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE);
    &#125;, (clientHttpResponse) -&gt; &#123;
        InputStream body = clientHttpResponse.getBody();
        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[body.available()];
        body.read(bytes);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(bytes);
    &#125;); <span class="hljs-comment">// 备注：这里使用了 Java8 特性：Lambda 表达式语法，若未接触 Lambda 表达式后可以使用匿名内部类代替实现</span>
    System.out.println(<span class="hljs-string">&quot;get_product1返回结果：&quot;</span> + executeResult);
    Assert.hasText(executeResult, <span class="hljs-string">&quot;get_product1返回结果为空&quot;</span>);
&#125;
</code></pre></div>

<p>同样再运行测试方法 <code>testGet_product1</code> 后控制台的输出日志：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java">...
get_product1返回结果：&lt;<span class="hljs-number">200</span>,Product&#123;id=<span class="hljs-string">&#x27;1&#x27;</span>, name=<span class="hljs-string">&#x27;ProductA&#x27;</span>, price=<span class="hljs-string">&#x27;6666.0&#x27;</span>&#125;,[Content-Type:<span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>, Transfer-Encoding:<span class="hljs-string">&quot;chunked&quot;</span>, Date:<span class="hljs-string">&quot;Thu, 09 May 2019 16:00:22 GMT&quot;</span>]&gt;
...
get_product1返回结果：&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;ProductA&quot;</span>,<span class="hljs-string">&quot;price&quot;</span>:<span class="hljs-number">6666.0</span>&#125;
...
</code></pre></div>

<p>结果也都是正常返回，说明执行的请求都是正确的。</p>
<p>现在来尝试执行带有参数的 GET 请求，同样的方式编写一个新的测试方法，实现代码如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGet_product2</span><span class="hljs-params">()</span> </span>&#123;
    String url = <span class="hljs-string">&quot;http://localhost:8080/product/get_product2/id=&#123;id&#125;&quot;</span>;
	
	    <span class="hljs-comment">//方式一：将参数的值存在可变长度参数里，按照顺序进行参数匹配</span>
    ResponseEntity&lt;Product&gt; responseEntity = restTemplate.getForEntity(url, Product.class, <span class="hljs-number">101</span>);
    System.out.println(responseEntity);
    Assert.isTrue(responseEntity.getStatusCode().equals(HttpStatus.OK), <span class="hljs-string">&quot;get_product2 请求不成功&quot;</span>);
    Assert.notNull(responseEntity.getBody().getId(), <span class="hljs-string">&quot;get_product2  传递参数不成功&quot;</span>);

	    <span class="hljs-comment">//方式二：将请求参数以键值对形式存储到 Map 集合中，用于请求时URL上的拼接</span>
    Map&lt;String, Object&gt; uriVariables = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
    uriVariables.put(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-number">101</span>);
    Product result = restTemplate.getForObject(url, Product.class, uriVariables);
    System.out.println(result);
    Assert.notNull(result.getId(), <span class="hljs-string">&quot;get_product2  传递参数不成功&quot;</span>);
&#125;
</code></pre></div>

<p>正常运行结果如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java">...
&lt;<span class="hljs-number">200</span>,Product&#123;id=<span class="hljs-string">&#x27;101&#x27;</span>, name=<span class="hljs-string">&#x27;ProductC&#x27;</span>, price=<span class="hljs-string">&#x27;6666.0&#x27;</span>&#125;,[Content-Type:<span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>, Transfer-Encoding:<span class="hljs-string">&quot;chunked&quot;</span>, Date:<span class="hljs-string">&quot;Fri, 10 May 2019 14:53:41 GMT&quot;</span>]&gt;
...
Product&#123;id=<span class="hljs-string">&#x27;101&#x27;</span>, name=<span class="hljs-string">&#x27;ProductC&#x27;</span>, price=<span class="hljs-string">&#x27;6666.0&#x27;</span>&#125;
...
</code></pre></div>

<h4 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h4><p>了解完如何用 <code>RestTemplate</code> API 发送 GET 请求后，再看下平时也很常见的 POST 请求如何使用。由于 POST 请求数据的内容类型 <code>Content-Type</code> 不同，发送 POST 请求情况相对就多了，我们这里以常用的 <code>application/x-www-form-urlencoded</code> 和 <code>application/json</code> 这两种内容类型为例子。</p>
<ul>
<li><p>发送 <code>Content-Type</code> 为 <code>application/x-www-form-urlencoded</code> 的 POST 请求：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testPost_product1</span><span class="hljs-params">()</span> </span>&#123;
    String url = <span class="hljs-string">&quot;http://localhost:8080/product/post_product1&quot;</span>;
	Product product = <span class="hljs-keyword">new</span> Product(<span class="hljs-number">201</span>, <span class="hljs-string">&quot;Macbook&quot;</span>, BigDecimal.valueOf(<span class="hljs-number">10000</span>));
	  <span class="hljs-comment">// 设置请求的 Content-Type 为 application/x-www-form-urlencoded</span>
    MultiValueMap&lt;String, String&gt; header = <span class="hljs-keyword">new</span> LinkedMultiValueMap();
    header.add(HttpHeaders.CONTENT_TYPE, (MediaType.APPLICATION_FORM_URLENCODED_VALUE));
    
    <span class="hljs-comment">//方式二： 将请求参数值以 K=V 方式用 &amp; 拼接，发送请求使用</span>
    String productStr = <span class="hljs-string">&quot;id=&quot;</span> + product.getId() + <span class="hljs-string">&quot;&amp;name=&quot;</span> + product.getName() + <span class="hljs-string">&quot;&amp;price=&quot;</span> + product.getPrice();
    HttpEntity&lt;String&gt; request = <span class="hljs-keyword">new</span> HttpEntity&lt;&gt;(productStr, header);
    ResponseEntity&lt;String&gt; exchangeResult = restTemplate.exchange(url, HttpMethod.POST, request, String.class);
    System.out.println(<span class="hljs-string">&quot;post_product1: &quot;</span> + exchangeResult);
    Assert.isTrue(exchangeResult.getStatusCode().equals(HttpStatus.OK), <span class="hljs-string">&quot;post_product1 请求不成功&quot;</span>);

    <span class="hljs-comment">//方式一： 将请求参数以键值对形式存储在 MultiValueMap 集合，发送请求时使用</span>
    MultiValueMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> LinkedMultiValueMap();
    map.add(<span class="hljs-string">&quot;id&quot;</span>, (product.getId()));
    map.add(<span class="hljs-string">&quot;name&quot;</span>, (product.getName()));
    map.add(<span class="hljs-string">&quot;price&quot;</span>, (product.getPrice()));
    HttpEntity&lt;MultiValueMap&gt; request2 = <span class="hljs-keyword">new</span> HttpEntity&lt;&gt;(map, header);
    ResponseEntity&lt;String&gt; exchangeResult2 = restTemplate.exchange(url, HttpMethod.POST, request2, String.class);
    System.out.println(<span class="hljs-string">&quot;post_product1： &quot;</span> + exchangeResult2);
    Assert.isTrue(exchangeResult.getStatusCode().equals(HttpStatus.OK), <span class="hljs-string">&quot;post_product1 请求不成功&quot;</span>);
&#125;
</code></pre></div>

<p>对应的输出日志如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java">...
post_product1: &lt;<span class="hljs-number">200</span>,Product&#123;id=<span class="hljs-string">&#x27;201&#x27;</span>, name=<span class="hljs-string">&#x27;Macbook&#x27;</span>, price=<span class="hljs-string">&#x27;10000&#x27;</span>&#125;,[Content-Type:<span class="hljs-string">&quot;text/plain;charset=UTF-8&quot;</span>, Content-Length:<span class="hljs-string">&quot;48&quot;</span>, Date:<span class="hljs-string">&quot;Fri, 10 May 2019 16:07:43 GMT&quot;</span>]&gt;
...
post_product1： &lt;<span class="hljs-number">200</span>,Product&#123;id=<span class="hljs-string">&#x27;201&#x27;</span>, name=<span class="hljs-string">&#x27;Macbook&#x27;</span>, price=<span class="hljs-string">&#x27;10000&#x27;</span>&#125;,[Content-Type:<span class="hljs-string">&quot;text/plain;charset=UTF-8&quot;</span>, Content-Length:<span class="hljs-string">&quot;48&quot;</span>, Date:<span class="hljs-string">&quot;Fri, 10 May 2019 16:07:43 GMT&quot;</span>]&gt;
</code></pre></div></li>
<li><p>发送 <code>Content-Type</code> 为 <code>application/json</code> 的 POST 请求：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testPost_product2</span><span class="hljs-params">()</span> </span>&#123;
    String url = <span class="hljs-string">&quot;http://localhost:8080/product/post_product2&quot;</span>;
    
   	<span class="hljs-comment">// 设置请求的 Content-Type 为 application/json</span>
    MultiValueMap&lt;String, String&gt; header = <span class="hljs-keyword">new</span> LinkedMultiValueMap();
    header.put(HttpHeaders.CONTENT_TYPE, Arrays.asList(MediaType.APPLICATION_JSON_VALUE));
    <span class="hljs-comment">// 设置 Accept 向服务器表明客户端可处理的内容类型</span>
    header.put(HttpHeaders.ACCEPT, Arrays.asList(MediaType.APPLICATION_JSON_VALUE));
    <span class="hljs-comment">// 直接将实体 Product 作为请求参数传入，底层利用 Jackson 框架序列化成 JSON 串发送请求</span>
    HttpEntity&lt;Product&gt; request = <span class="hljs-keyword">new</span> HttpEntity&lt;&gt;(<span class="hljs-keyword">new</span> Product(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Macbook&quot;</span>, BigDecimal.valueOf(<span class="hljs-number">10000</span>)), header);
    ResponseEntity&lt;String&gt; exchangeResult = restTemplate.exchange(url, HttpMethod.POST, request, String.class);
    System.out.println(<span class="hljs-string">&quot;post_product2: &quot;</span> + exchangeResult);
    Assert.isTrue(exchangeResult.getStatusCode().equals(HttpStatus.OK), <span class="hljs-string">&quot;post_product2 请求不成功&quot;</span>);
&#125;
</code></pre></div>

<p>验证的输出日志如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java">···
post_product2: &lt;<span class="hljs-number">200</span>,Product&#123;id=<span class="hljs-string">&#x27;2&#x27;</span>, name=<span class="hljs-string">&#x27;Macbook&#x27;</span>, price=<span class="hljs-string">&#x27;10000&#x27;</span>&#125;,[Content-Type:<span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>, Content-Length:<span class="hljs-string">&quot;46&quot;</span>, Date:<span class="hljs-string">&quot;Fri, 10 May 2019 16:09:11 GMT&quot;</span>]&gt;
···
</code></pre></div></li>
</ul>
<h4 id="DELETE-请求-和-PUT-请求"><a href="#DELETE-请求-和-PUT-请求" class="headerlink" title="DELETE 请求 和 PUT 请求"></a>DELETE 请求 和 PUT 请求</h4><p>DELETE 请求和 PUT 请求属于 RESTful 请求方式的两种，但通常不会被使用到，这里也只是简单演示下，具体代码如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// DELETE 方法请求</span>
<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDelete</span><span class="hljs-params">()</span> </span>&#123;
   String url = <span class="hljs-string">&quot;http://localhost:8080/product/delete/&#123;id&#125;&quot;</span>;
   restTemplate.delete(url, <span class="hljs-number">101</span>);
&#125;

<span class="hljs-comment">// PUT 方法请求</span>
<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testPut</span><span class="hljs-params">()</span> </span>&#123;
    String url = <span class="hljs-string">&quot;http://localhost:8080/product/update&quot;</span>;
    Map&lt;String, ?&gt; variables = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
    MultiValueMap&lt;String, String&gt; header = <span class="hljs-keyword">new</span> LinkedMultiValueMap();
    header.put(HttpHeaders.CONTENT_TYPE, Arrays.asList(MediaType.APPLICATION_FORM_URLENCODED_VALUE));
    Product product = <span class="hljs-keyword">new</span> Product(<span class="hljs-number">101</span>, <span class="hljs-string">&quot;iWatch&quot;</span>, BigDecimal.valueOf(<span class="hljs-number">2333</span>));
    String productStr = <span class="hljs-string">&quot;id=&quot;</span> + product.getId() + <span class="hljs-string">&quot;&amp;name=&quot;</span> + product.getName() + <span class="hljs-string">&quot;&amp;price=&quot;</span> + product.getPrice();
    HttpEntity&lt;String&gt; request = <span class="hljs-keyword">new</span> HttpEntity&lt;&gt;(productStr, header);
    restTemplate.put(url, request);
&#125;
</code></pre></div>

<h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><p>现在我们再试下如何使用 <code>RestTemplate</code> API 进行文件上传,也比较简单，首先看下实现代码:</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUploadFile</span><span class="hljs-params">()</span> </span>&#123;
    String url = <span class="hljs-string">&quot;http://localhost:8080/product/upload&quot;</span>;
    MultiValueMap&lt;String, Object&gt; body = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;();
    FileSystemResource file = <span class="hljs-keyword">new</span> FileSystemResource(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;/Users/One/Desktop/b.txt&quot;</span>));
    body.add(<span class="hljs-string">&quot;file&quot;</span>, file);

    MultiValueMap&lt;String, String&gt; header = <span class="hljs-keyword">new</span> LinkedMultiValueMap();
    header.put(HttpHeaders.CONTENT_TYPE, Arrays.asList(MediaType.MULTIPART_FORM_DATA_VALUE));
    HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; requestEntity = <span class="hljs-keyword">new</span> HttpEntity&lt;&gt;(body, header);
    ResponseEntity&lt;String&gt; responseEntity = restTemplate.postForEntity(url, requestEntity, String.class);
    System.out.println(<span class="hljs-string">&quot;upload: &quot;</span> + responseEntity);
    Assert.isTrue(responseEntity.getStatusCode().equals(HttpStatus.OK), <span class="hljs-string">&quot;upload 请求不成功&quot;</span>);
&#125;
</code></pre></div>

<p>如果需要上传文件类型数据，就只能使用 POST 请求，并且内容类型为 <code>multipart/form-data</code>,需要手动给 <code>Header</code> 指定这个 <code>Content-Type</code>。而需要上传的文件可以用 <code>FileSystemResource</code> 对象封装，表示了一个文件资源，同时服务端需要用 <code>MultipartRequest</code> 对象来获取文件数据。结合已运行的 Web 服务，运行上述测试方法即可得到下面日志输出:</p>
<div class="hljs code-wrapper"><pre><code class="hljs java">...
upload: &lt;<span class="hljs-number">200</span>,upload success filename: b.txt,[Content-Type:<span class="hljs-string">&quot;text/plain;charset=UTF-8&quot;</span>, Content-Length:<span class="hljs-string">&quot;30&quot;</span>, Date:<span class="hljs-string">&quot;Fri, 10 May 2019 17:00:45 GMT&quot;</span>]&gt;
...
</code></pre></div>

<h2 id="进阶-RestTemplate"><a href="#进阶-RestTemplate" class="headerlink" title="进阶 RestTemplate"></a>进阶 RestTemplate</h2><p>到这里我们就学习了 <code>RestTemplate</code> API 请求数据的几种常见方式，现在来进一步地深入使用 <code>RestTemplate</code>。</p>
<h3 id="底层-HTTP-请求库切换"><a href="#底层-HTTP-请求库切换" class="headerlink" title="底层 HTTP 请求库切换"></a>底层 HTTP 请求库切换</h3><p>我们首先看下官方文档的描述：</p>
<blockquote>
<p>The default constructor uses java.net.HttpURLConnection to perform requests. You can switch to a different HTTP library with an implementation of ClientHttpRequestFactory. There is built-in support for the following:</p>
<ul>
<li>Apache HttpComponents</li>
<li>Netty</li>
<li>OkHttp</li>
</ul>
</blockquote>
<p>从上面可以看出 <code>RestTemplate</code> 默认使用 JDK 原生的 <code>java.net.HttpURLConnection</code> 执行请求。而除此之外，Spring 还封装了 Apache HttpComponents， Netty， OkHttp 三种请求库，第一个就是我们平常用的 <code>HttpClient</code> API 相关的库，而 <a target="_blank" rel="noopener" href="https://netty.io/">Netty</a> 则是一个性能高的NIO 请求处理网络库，<a target="_blank" rel="noopener" href="https://square.github.io/okhttp">OkHttp</a> 为功能丰富且高效的网络框架，多用于 Android 程序。</p>
<p>而我们上文采用默认的构造器方法创建的 <code>RestTemplate</code> 实例，即采用了 JDK 原生的网络 API。想要切换，只需要在构造方法中传入特定 <code>ClientHttpRequestFactory</code> 实现类即可,如下代码：</p>
<div class="hljs code-wrapper"><pre><code class="hljs haxe">RestTemplate template = <span class="hljs-keyword">new</span> <span class="hljs-type">RestTemplate</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">HttpComponentsClientHttpRequestFactory</span>());
</code></pre></div>

<p>我们查看 <code>RestTemplate</code> 源码找不到默认采用JDK <code>HttpURLConnection</code> API 的代码，那就根据前文给出 <code>RestTemplate</code> 类层次图向上查找，可以在父类 <code>HttpAccessor</code> 上能找到如下代码：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpAccessor</span> </span>&#123;
	<span class="hljs-comment">// ...</span>
	<span class="hljs-keyword">private</span> ClientHttpRequestFactory requestFactory = <span class="hljs-keyword">new</span> SimpleClientHttpRequestFactory();
	<span class="hljs-comment">// ...</span>
&#125;
</code></pre></div>

<p>而 Spring 对工厂类 <code>SimpleClientHttpRequestFactory</code> 描述为: <code>implementation that uses standard JDK facilities</code>， 也正说明了默认构造 <code>RestTemplate</code> 实例的行为都会直接使用 JDK 网络 API。</p>
<h3 id="请求超时设置"><a href="#请求超时设置" class="headerlink" title="请求超时设置"></a>请求超时设置</h3><p>通常我们会对 HTTP 请求类进行执行行为的定制，例如调用超时时间设置，连接时长的限制等，而采用默认的 <code>HttpURLConnection</code> 默认的配置时， 从 <code>SimpleClientHttpRequestFactory</code> 源码类可以看到是没有超时限制，也就意味着无限等待请求响应：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// RestTemplate 默认超时设置</span>
...
<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> connectTimeout = -<span class="hljs-number">1</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> readTimeout = -<span class="hljs-number">1</span>;
...
</code></pre></div>

<p>那么我们该如何调整超时时间,可以参考如下代码：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java">RestTemplate customRestTemplate = <span class="hljs-keyword">new</span> RestTemplate(getClientHttpRequestFactory());

<span class="hljs-function"><span class="hljs-keyword">private</span> SimpleClientHttpRequestFactory <span class="hljs-title">getClientHttpRequestFactory</span><span class="hljs-params">()</span> </span>&#123;
    SimpleClientHttpRequestFactory clientHttpRequestFactory
            = <span class="hljs-keyword">new</span> SimpleClientHttpRequestFactory();
    <span class="hljs-comment">// 连接超时设置 10s</span>
    clientHttpRequestFactory.setConnectTimeout(<span class="hljs-number">10_000</span>);

    <span class="hljs-comment">// 读取超时设置 10s</span>
    clientHttpRequestFactory.setReadTimeout(<span class="hljs-number">10_000</span>);
    <span class="hljs-keyword">return</span> clientHttpRequestFactory;
&#125;
</code></pre></div>

<p>如果要调整 <code>HttpComponentsClient</code> 的超时设置，可以参考文章<a target="_blank" rel="noopener" href="https://howtodoinjava.com/spring-boot2/resttemplate-timeout-example/">resttemplate-timeout-example</a> 。当然除了java设置超时时间之外，还有更多参数进行定制，这里就不一一列举，可以参考文章 <a target="_blank" rel="noopener" href="https://howtodoinjava.com/spring-restful/resttemplate-httpclient-java-config/">resttemplate-httpclient-java-config</a> 进一步学习。</p>
<p>到这里我们对 <code>RestTemplate</code> 的学习告一段落，如果有兴趣可以进一步研究下相关源码，有机会尝试使起来吧。😁</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/java/">java</a>
                    
                      <a class="hover-with-bg" href="/categories/java/spring/">spring</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/RestTemplate/">RestTemplate</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/11/28/other-logical-operations/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">逻辑运算符</span>
                        <span class="visible-mobile">Vorheriger</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/11/04/mybatis-autosql/">
                        <span class="hidden-mobile">mybatis动态sql</span>
                        <span class="visible-mobile">Nächster</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"Jf1XC66LVfvBgBpG1uzXEivd-gzGzoHsz","appKey":"UyOEEpxFaJC2kPqgBkDOeMPE","path":"window.location.pathname","placeholder":"说点什么","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":true,"recordIP":true,"serverURLs":"https://jf1xc66l.lc-cn-n1-shared.com","emojiCDN":null,"emojiMaps":null,"enableQQ":false,"appid":"Jf1XC66LVfvBgBpG1uzXEivd-gzGzoHsz","appkey":"UyOEEpxFaJC2kPqgBkDOeMPE"},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          Fluid.plugins.initFancyBox('#valine .vcontent img:not(.vemoji)');
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" lazyload class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Suchen</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">Stichwort</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
      <div class="col-lg-7 mx-auto nopadding-x-md">
        <div class="container custom mx-auto">
          </script><script src="/js/fireworks.js"></script><script src="https://api.vvhan.com/api/snow"></script>
        </div>
      </div>
    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <i class="iconfont icon-love"></i> <a href="https://github.com/czy1024" target="_blank" rel="nofollow noopener"><span>luna</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":true,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
