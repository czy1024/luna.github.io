---
title: mysql-master-slave
date: 2021-11-04
banner_img: /img/baisc/mysql-binner.jpg
index_img: /img/baisc/mysql-index.jpg
tags: 
 - mysql
categories:
 - basic-component
 - mysql
---

# Mysql 主从复制

## **一、概要**

mysql从3.23版本开始提供复制功能，复制是将主库的**DDL**和**DML**操作通过二进制日志传递到复制服务器（从库）上，然后从库对这些日志重新执行（重做），从而使得主库和从库保持数据一致。

 

## **1.1** **mysql** 复制的优点**

- 如果主库出现问题，可以快速切换到从库提供服务
- 可以在从库执行查询操作，降低主库的访问压力。
- 可以在从库进行备份，以免备份期间影响主库的服务。

 

## **1.2** **Mysql** 复制解决的问题**

- 数据分布 (Data distribution )
- 负载平衡(load balancing)
- 数据备份(Backups) ，保证数据安全
- 高可用性和容错行(High availability and failover)
- 实现读写分离，缓解数据库压力

> *注意：由于* *mysql* *实现的异步复制，所以主库和从库数据之间存在一定的差异，在从库执行查询操作需要考虑这些数据的差异，一般只有更新不频繁和对实时性要求不高的数据可以通过从库查询，实行要求高的仍要从主库查询。*

 

# **二、** MySQL** 主从复制的概念**

**MySQL 主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点**。MySQL 默认采用**异步复制**方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。

 

# **三、** MySQL** 主从复制的主要用途**

## **3.1** **读写分离**

在开发工作中，有时候会遇见某个sql 语句需要锁表，导致暂时不能使用读的服务，这样就会影响现有业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。

 

## **3.2** **数据实时备份，当系统中某个节点发生故障时，可以方便的故障切换(** 主从切换** )**

 

## **3.3** **高可用** （** HA** ）**

 

## **3.4** **架构扩展**

随着系统中业务访问量的增大，如果是单机部署数据库，就会导致I/O访问频率过高。有了主从复制，增加多个数据存储节点，将负载分布在多个从节点上，降低单机磁盘I/O访问的频率，提高单个机器的I/O性能。

 

# **四、** MySQL** 主从形式一主一从**

## **4.1** **一主多从**

提高系统的读性能

![img](https://tva1.sinaimg.cn/large/008i3skNly1gw24d8i4k4j306s07ct8m.jpg)

一主一从和一主多从是最常见的主从架构，实施起来简单并且有效，不仅可以实现HA，而且还能读写分离，进而提升集群的并发能力。

 

## **4.2** **多主一从 （从** 5.7** 开始支持）**

![img](https://tva1.sinaimg.cn/large/008i3skNly1gw24db1yhrj3060058q2s.jpg)

多主一从可以将多个mysql数据库备份到一台存储性能比较好的服务器上。

 

## **4.3** **双主复制**

双主复制，也就是互做主从复制，每个**master** （主）**既是master，又是另外一台服务器的**slave** （从）**。这样任何一方所做的变更，都会通过复制应用到另外一方的数据库中。

 

## **4.4 级联复制**

![img](https://tva1.sinaimg.cn/large/008i3skNly1gw24dbqy71j308e02y744.jpg)

级联复制模式下，部分slave的数据同步不连接主节点，而是连接从节点。因为如果主节点有太多的从节点，就会损耗一部分性能用于**replication** （复制）**，那么我们可以让3~5个从节点连接主节点，其它从节点作为二级或者三级与从节点连接，这样不仅可以缓解主节点的压力，并且对数据一致性没有负面影响。**级联复制下从节点也要开启** binary log** （** bin-log** ）功能**。

 

# **五、** MySQL** 主从复制的原理**

MySQL主从复制涉及到三个线程，一个运行在**主节点（** log dump thread** ）**，其余两个(**I/O thread**, **SQL thread**)运行在从节点，如下图所示:

![img](https://tva1.sinaimg.cn/large/008i3skNly1gw24d9axmcj30hs06zaaa.jpg)

## **5.1** **主节点** **log dump** **线程**

当从节点连接主节点时，主节点会为其创建一个log dump 线程，用于发送和读取bin-log的内容。在读取bin-log中的操作时，log dump线程会对主节点上的bin-log加锁，当读取完成，在发送给从节点之前，锁会被释放。**主节点会为自己的每一个从节点创建一个** log dump** **线程**。

 

## **5.2** **从节点** **I/O** 线程**

当从节点上执行`start slave`命令之后，从节点会创建一个I/O线程用来连接主节点，请求主库中更新的bin-log。I/O线程接收到主节点的blog dump进程发来的更新之后，保存在本地**relay-log** （中继日志）**中。

 

## **5.3** **从节点** **SQL** 线程**

SQL线程负责读取relay-log中的内容，解析成具体的操作并执行，最终保证主从数据的一致性。

对于每一个主从连接，都需要这三个进程来完成。当主节点有多个从节点时，主节点会为每一个当前连接的从节点建一个**log dump** **进程**，而每个从节点都有自己的**I/O** 进程**，**SQL** 进程**。从节点用两个线程将从主库拉取更新和执行分成独立的任务，这样在执行同步数据任务的时候，不会降低读操作的性能。比如，如果从节点没有运行，此时I/O进程可以很快从主节点获取更新，尽管SQL进程还没有执行。如果在SQL进程执行之前从节点服务停止，至少I/O进程已经从主节点拉取到了最新的变更并且保存在本地relay日志中，当服务再次起来之后，就可以完成数据的同步。

要实施复制，首先**必须打开** Master** **端的** binary log** （** bin-log** ）功能，否则无法实现**。

因为整个复制过程实际上就是Slave 从Master 端获取该日志然后再在自己身上完全顺序的执行日志中所记录的各种操作。如下图所示：

![img](https://tva1.sinaimg.cn/large/008i3skNly1gw24d9o2bgj30hs0733yl.jpg)

## **5.4** **复制的基本过程**

1. 在从节点上执行sart slave命令开启主从复制开关，开始进行主从复制。从节点上的I/O 进程连接主节点，并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容；
2. 主节点接收到来自从节点的I/O请求后，通过负责复制的I/O进程（log dump 线程）根据请求信息读取指定日志指定位置之后的日志信息，返回给从节点。返回信息中除了日志所包含的信息之外，还包括本次返回的信息的bin-log file 的以及bin-log position（bin-log中的下一个指定更新位置）；
3. 从节点的I/O进程接收到主节点发送过来的日志内容、日志文件及位置点后，将接收到的日志内容更新到本机的relay-log（中继日志）的文件（Mysql-relay-bin.xxx）的最末端，并将读取到的binary log（bin-log）文件名和位置保存到**master-info** **文件**中，以便在下一次读取的时候能够清楚的告诉Master“我需要从某个bin-log 的哪个位置开始往后的日志内容，请发给我”；
4. Slave 的 SQL线程检测到relay-log 中新增加了内容后，会将relay-log的内容解析成在主节点上实际执行过SQL语句，然后在本数据库中按照解析出来的顺序执行，并在**relay-log.info**中记录当前应用中继日志的文件名和位置点。

 

# **六、** MySQL** 主从复制的模式**

MySQL 主从复制默认是**异步的模式**。MySQL增删改操作会全部记录在**bin** -** log** （** binary log** ）**中，当slave节点连接master时，会主动从master处获取最新的bin-log文件。并把bin-log存储到本地的relay-log中，然后去执行relay-log的更新内容。

## **6.1** **异步模式（** mysql async-mode** ）**

异步模式如下图所示，这种模式下，主节点不会主动推送bin-log到从节点，主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已经接收并处理，这样就会有一个问题，主节点如果崩溃掉了，此时主节点上已经提交的事务可能并没有传到从节点上，如果此时，强行将从提升为主，可能导致新主节点上的数据不完整。

![img](https://tva1.sinaimg.cn/large/008i3skNly1gw24dab5opj30hs07u0t2.jpg)

 

## **6.2** **半同步模式** (mysql semi-sync)**

介于异步复制和全同步复制之间，主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到relay-log中才返回成功信息给客户端（只能保证主库的bin-log至少传输到了一个从节点上，但并不能保证从节点将此事务执行更新到db中），否则需要等待直到超时时间然后切换成异步模式再提交。相对于异步复制，半同步复制提高了数据的安全性，一定程度的保证了数据能成功备份到从库，同时它也造成了一定程度的延迟，但是比全同步模式延迟要低，这个延迟最少是一个TCP/IP往返的时间。所以，半同步复制最好在低延时的网络中使用。如下图所示：

![img](https://tva1.sinaimg.cn/large/008i3skNly1gw24dciy1nj30hs08b0t9.jpg)

半同步模式不是mysql内置的，从mysql 5.5开始集成，需要master 和slave 安装插件开启半同步模式。

 

## **6.3** **全同步模式**

指当主库执行完一个事务，然后所有的从库都复制了该事务并成功执行完才返回成功信息给客户端。因为需要等待所有从库执行完该事务才能返回成功信息，所以全同步复制的性能必然会收到严重的影响。

 

## **6.4** **异步模式，全同步模式，半同步模式** 的对比图**

![img](https://tva1.sinaimg.cn/large/008i3skNly1gw24dambalj30j50dwq3n.jpg)

 

## **6.5 GTID** 复制模式**

在传统的复制里面，当发生故障，需要**主从切换**，需要找到bin-log和pos点（指从库更新到了主库bin-log的哪个位置，这个位置之前都已经更显完毕，这个位置之后未更新），然后将主节点指向新的主节点，相对来说比较麻烦，也容易出错。在MySQL 5.6里面，不用再找bin-log和pos点，我们只需要知道主节点的ip，端口，以及账号密码就行，因为复制是自动的，MySQL会通过内部机制**GTID**自动找点同步。

基于GTID的复制是MySQL 5.6后新增的复制方式.

**GTID (global transaction identifier)** 即全局事务ID, 保证了在每个在主库上提交的事务在集群中有一个唯一的ID.

 

### **6.5.1 GTID** 复制原理**

在原来基于日志的复制中, 从库需要告知主库要从哪个偏移量进行增量同步, 如果指定错误会造成数据的遗漏, 从而造成数据的不一致.

而基于GTID的复制中, 从库会告知主库已经执行的事务的GTID的值, 然后主库会将所有未执行的事务的GTID的列表返回给从库. 并且可以保证同一个事务只在指定的从库执行一次.**通过全局的事务** ID** 确定从库要执行的事务的方式代替了以前需要用** bin-log** 和** pos** 点确定从库要执行的事务的方式**。

GTID是由server_uuid和事物id组成，格式为：GTID=server_uuid:transaction_id。server_uuid是在数据库启动过程中自动生成，每台机器的server-uuid不一样。uuid存放在数据目录的auto.conf文件中，而transaction_id就是事务提交时系统顺序分配的一个不会重复的序列号。

主节点更新数据时，会在事务前产生GTID，一起记录到bin-log日志中。从节点的I/O线程将变更的bin-log，写入到本地的relay-log中。SQL线程从relay-log中获取GTID，然后对比本地bin-log是否有记录（所以MySQL从节点必须要开启binary-log）。如果有记录，说明该GTID的事务已经执行，从节点会忽略。如果没有记录，从节点就会从relay-log中执行该GTID的事务，并记录到binlog。在解析过程中会判断是否有主键，如果没有就用二级索引，如果有就用全部扫描。

 

### **6.5.2** **GTID** 的好处**

1. GTID使用master_auto_position=1代替了binlog和position号的主从复制搭建方式，相比binlog和position方式更容易搭建主从复制。
2. GTID方便实现主从之间的failover（主从切换），不用一步一步的去查找position和binlog文件。

 

### **6.5.3** **GTID** 模式复制局限性**

1. 不能使用create table table_name select * from table_name模式的语句
2. 在一个事务中既包含事务表的操作又包含非事务表
3. 不支持CREATE TEMPORARY TABLE or DROP TEMPORARY TABLE语句操作
4. 使用GTID复制从库跳过错误时，不支持sql_slave_skip_counter参数的语法

 

## **6.6** **多线程复制**

多线程复制（基于库），在MySQL 5.6以前的版本，slave的复制是单线程的，而master是并发写入的，所以延时是避免不了的。唯一有效的方法是把多个库放在多台slave，这样又有点浪费服务器。在MySQL 5.6里面，我们可以把多个表放在多个库，这样就可以使用多线程复制。

但 5.6 中的每个线程只能处理一个数据库，所以如果只有一个数据库，或者绝大多数写操作都是集中在某一个数据库的，那么这个“多线程复制”就不能充分发挥作用了

Mysql 5.7 对 “多线程复制” 进行了改善，可以按照逻辑时钟的方式来分配线程，大大提高了复制性能

 

# **七、MySQL主从复制的方式**

MySQL 主从复制有三种方式：**基于** SQL** 语句的复制**（statement-based replication，SBR），**基于行的复制**（row-based replication，RBR)，**混合模式复制**（mixed-based replication,MBR)。对应的bin-log文件的格式也有三种：**STATEMENT**, **ROW**, **MIXED**。

 

## **7.1** **Statement-base Replication (SBR)** 

就是记录sql语句在bin-log中，Mysql 5.1.4 及之前的版本都是使用的这种复制格式。优点是只需要记录会修改数据的sql语句到bin-log中，减少了bin-log日质量，节约I/O，提高性能。缺点是在某些情况下，会导致主从节点中数据不一致（比如sleep(),now()等）。

 

## **7.2 Row-based Relication(RBR)**

mysql master将SQL语句分解为基于Row更改的语句并记录在bin-log中，也就是只记录哪条数据被修改了，修改成什么样。优点是不会出现某些特定情况下的存储过程、或者函数、或者trigger的调用或者触发无法被正确复制的问题。缺点是会产生大量的日志，尤其是修改table的时候会让日志暴增,同时增加bin-log同步时间。也不能通过bin-log解析获取执行过的sql语句，只能看到发生的data变更。

 

## **7.3** **Mixed-format Replication(MBR)**

MySQL NDB cluster 7.3 和7.4 使用的MBR。是以上两种模式的混合，对于一般的复制使用STATEMENT模式保存到bin-log，对于STATEMENT模式无法复制的操作则使用ROW模式来保存，MySQL会根据执行的SQL语句选择日志保存方式。

 

# **八、总结**

Mysql 主从复制是mysql 高可用，高性能的基础，有了这个基础，mysql 的部署会变得简单、灵活并且具有多样性，从而可以根据不同的业务场景做出灵活的调整。
