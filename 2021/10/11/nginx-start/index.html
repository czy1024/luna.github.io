

<!DOCTYPE html>
<html lang="ZH-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" href="/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="luna">
  <meta name="keywords" content="博客,luna,java,spring,utils,linux,idea">
  <meta name="description" content="Nginx学习Nginx 是开源、高性能、高可靠的 Web 和反向代理服务器，而且支持热部署，几乎可以做到 7 * 24 小时不间断运行，即使运行几个月也不需要重新启动，还能在不间断服务的情况下对软件版本进行热更新。性能是 Nginx 最重要的考量，其占用内存少、并发能力强、能支持高达 5w 个并发连接数，最重要的是， Nginx 是免费的并可以商业化，配置使用也比较简单。 Nginx 特点  高">
<meta property="og:type" content="article">
<meta property="og:title" content="nginx">
<meta property="og:url" content="https://lunasaw.github.io/2021/10/11/nginx-start/index.html">
<meta property="og:site_name" content="十平方米小屋">
<meta property="og:description" content="Nginx学习Nginx 是开源、高性能、高可靠的 Web 和反向代理服务器，而且支持热部署，几乎可以做到 7 * 24 小时不间断运行，即使运行几个月也不需要重新启动，还能在不间断服务的情况下对软件版本进行热更新。性能是 Nginx 最重要的考量，其占用内存少、并发能力强、能支持高达 5w 个并发连接数，最重要的是， Nginx 是免费的并可以商业化，配置使用也比较简单。 Nginx 特点  高">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/05/12/cHgeKZTvGRlxbNs.png">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNgy1gqgipd9lr4j304w0bd3ye.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNgy1gqgipukswcj30h20cj3yl.jpg">
<meta property="og:image" content="https://i.loli.net/2021/05/13/xSXV4IvkreYuOa2.png">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNgy1gqgionqq4ij30k212ydkv.jpg">
<meta property="og:image" content="https://i.loli.net/2021/05/13/fSs4pyHmb5AQtiU.png">
<meta property="og:image" content="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==">
<meta property="og:image" content="https://i.loli.net/2021/05/13/Wsy3nxX6OkcjU5f.png">
<meta property="og:image" content="https://i.loli.net/2021/05/13/L7Au6MSZ8NUcmeO.png">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNgy1gqgio8wopaj30ry054glt.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNgy1gqgiu2hh9mj30ip06675k.jpg">
<meta property="og:image" content="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==">
<meta property="og:image" content="https://i.loli.net/2021/05/13/2InKAg9biCSdoPj.png">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNgy1gqgj9dsw29j30rn0aj74h.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNgy1gqgil28gi4j30u00kudje.jpg">
<meta property="article:published_time" content="2021-10-11T11:34:07.000Z">
<meta property="article:modified_time" content="2022-09-16T02:41:51.992Z">
<meta property="article:author" content="luna">
<meta property="article:tag" content="nginx">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://i.loli.net/2021/05/12/cHgeKZTvGRlxbNs.png">
  
    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas><script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
  
  <title>nginx - 十平方米小屋</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/idea.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"lunasaw.github.io","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":65,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":true,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"1WlABYJFX3ooWNnixAEsUHg2-gzGzoHsz","app_key":"4HAsQYXea2QPsxkF5wOFFpbH","server_url":"https://cn-n1-cell1.leancloud.cn","path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>十平方米小屋</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                链接
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/basic/nginx-binner.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.2)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="nginx">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      luna
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-10-11 19:34" pubdate>
        2021年10月11日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      24k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      74 分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">nginx</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：10 天前
                
              </p>
            
            <div class="markdown-body">
              <h1 id="Nginx学习"><a href="#Nginx学习" class="headerlink" title="Nginx学习"></a>Nginx学习</h1><p><code>Nginx</code> 是开源、高性能、高可靠的 <code>Web</code> 和反向代理服务器，而且支持热部署，几乎可以做到 7 * 24 小时不间断运行，即使运行几个月也不需要重新启动，还能在不间断服务的情况下对软件版本进行热更新。性能是 <code>Nginx</code> 最重要的考量，其占用内存少、并发能力强、能支持高达 5w 个并发连接数，最重要的是， <code>Nginx</code> 是免费的并可以商业化，配置使用也比较简单。</p>
<p><strong>Nginx 特点</strong></p>
<ul>
<li>高并发、高性能；</li>
<li>模块化架构使得它的扩展性非常好；</li>
<li>异步非阻塞的事件驱动模型这点和 <code>Node.js</code> 相似；</li>
<li>相对于其它服务器来说它可以连续几个月甚至更长而不需要重启服务器使得它具有高可靠性；</li>
<li>热部署、平滑升级；</li>
<li>完全开源，生态繁荣；</li>
</ul>
<h1 id="Nginx-作用"><a href="#Nginx-作用" class="headerlink" title="Nginx 作用"></a>Nginx 作用</h1><p>Nginx 的最重要的几个使用场景：</p>
<ol>
<li>静态资源服务，通过本地文件系统提供服务；</li>
<li>反向代理服务，延伸出包括缓存、负载均衡等；</li>
<li><code>API</code> 服务， <code>OpenResty</code> ；</li>
</ol>
<p>对于前端来说 <code>Node.js</code> 并不陌生， <code>Nginx</code> 和 <code>Node.js</code> 的很多理念类似， <code>HTTP</code> 服务器、事件驱动、异步非阻塞等，且 <code>Nginx</code> 的大部分功能使用 <code>Node.js</code> 也可以实现，但 <code>Nginx</code> 和<code>Node.js</code> 并不冲突，都有自己擅长的领域。<code>Nginx</code> 擅长于底层服务器端资源的处理（静态资源处理转发、反向代理，负载均衡等）， <code>Node.js</code> 更擅长上层具体业务逻辑的处理，两者可以完美组合。</p>
<p>用一张图表示：</p>
<p><img src="https://i.loli.net/2021/05/12/cHgeKZTvGRlxbNs.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<p><strong>Nginx 安装</strong></p>
<p>本文演示的是 <code>Linux</code> <code>centOS 7.x</code> 的操作系统上安装 <code>Nginx</code> ，至于在其它操作系统上进行安装可以网上自行搜索，都非常简单的。</p>
<p>使用 <code>yum</code> 安装 <code>Nginx</code> ：</p>
<div class="hljs code-wrapper"><pre><code class="hljs bash">yum install nginx -y</code></pre></div>

<p>安装完成后，通过 <code>rpm \-ql nginx</code> 命令查看 <code>Nginx</code> 的安装信息：</p>
<div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># Nginx配置文件</span>
/etc/nginx/nginx.conf <span class="hljs-comment"># nginx 主配置文件</span>
/etc/nginx/nginx.conf.default

<span class="hljs-comment"># 可执行程序文件</span>
/usr/bin/nginx-upgrade
/usr/sbin/nginx

<span class="hljs-comment"># nginx库文件</span>
/usr/lib/systemd/system/nginx.service <span class="hljs-comment"># 用于配置系统守护进程</span>
/usr/lib64/nginx/modules <span class="hljs-comment"># Nginx模块目录</span>

<span class="hljs-comment"># 帮助文档</span>
/usr/share/doc/nginx-1.16.1
/usr/share/doc/nginx-1.16.1/CHANGES
/usr/share/doc/nginx-1.16.1/README
/usr/share/doc/nginx-1.16.1/README.dynamic
/usr/share/doc/nginx-1.16.1/UPGRADE-NOTES-1.6-to-1.10

<span class="hljs-comment"># 静态资源目录</span>
/usr/share/nginx/html/404.html
/usr/share/nginx/html/50x.html
/usr/share/nginx/html/index.html

<span class="hljs-comment"># 存放Nginx日志文件</span>
/var/<span class="hljs-built_in">log</span>/nginx</code></pre></div>

<p>主要关注的文件夹有两个：</p>
<p><code>1. /etc/nginx/conf.d/</code> 是子配置项存放处， <code>/etc/nginx/nginx.conf</code> 主配置文件会默认把这个文件夹中所有子配置项都引入；</p>
<p><code>2. /usr/share/nginx/html/</code> 静态文件都放在这个文件夹，也可以根据你自己的习惯放在其他地方；</p>
<p><strong>Nginx 常用命令</strong></p>
<p><code>systemctl</code> 系统命令：</p>
<div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 开机配置</span>
systemctl <span class="hljs-built_in">enable</span> nginx <span class="hljs-comment"># 开机自动启动</span>
systemctl <span class="hljs-built_in">disable</span> nginx <span class="hljs-comment"># 关闭开机自动启动</span>

<span class="hljs-comment"># 启动Nginx</span>
systemctl start nginx <span class="hljs-comment"># 启动Nginx成功后，可以直接访问主机IP，此时会展示Nginx默认页面</span>

<span class="hljs-comment"># 停止Nginx</span>
systemctl stop nginx

<span class="hljs-comment"># 重启Nginx</span>
systemctl restart nginx

<span class="hljs-comment"># 重新加载Nginx</span>
systemctl reload nginx

<span class="hljs-comment"># 查看 Nginx 运行状态</span>
systemctl status nginx

<span class="hljs-comment"># 查看Nginx进程</span>
ps -ef | grep nginx

<span class="hljs-comment"># 杀死Nginx进程</span>
<span class="hljs-built_in">kill</span> -9 pid <span class="hljs-comment"># 根据上面查看到的Nginx进程号，杀死Nginx进程，-9 表示强制结束进程</span></code></pre></div>

<p><code>Nginx</code> 应用程序命令：</p>
<div class="hljs code-wrapper"><pre><code class="hljs bash">nginx -s reload <span class="hljs-comment"># 向主进程发送信号，重新加载配置文件，热重启</span>
nginx -s reopen <span class="hljs-comment"># 重启 Nginx</span>
nginx -s stop <span class="hljs-comment"># 快速关闭</span>
nginx -s quit <span class="hljs-comment"># 等待工作进程处理完成后关闭</span>
nginx -T <span class="hljs-comment"># 查看当前 Nginx 最终的配置</span>
nginx -t <span class="hljs-comment"># 检查配置是否有问题</span></code></pre></div>

<h1 id="Nginx-核心配置"><a href="#Nginx-核心配置" class="headerlink" title="Nginx 核心配置"></a>Nginx 核心配置</h1><h2 id="配置文件结构"><a href="#配置文件结构" class="headerlink" title="配置文件结构"></a>配置文件结构</h2><p><code>Nginx</code> 的典型配置示例：</p>
<div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># main段配置信息</span>
user  nginx; <span class="hljs-comment"># 运行用户，默认即是nginx，可以不进行设置</span>
worker_processes  auto; <span class="hljs-comment"># Nginx 进程数，一般设置为和 CPU 核数一样</span>
error_log  /var/<span class="hljs-built_in">log</span>/nginx/error.log warn; <span class="hljs-comment"># Nginx 的错误日志存放目录</span>
pid        /var/run/nginx.pid; <span class="hljs-comment"># Nginx 服务启动时的 pid 存放位置</span>

<span class="hljs-comment"># events段配置信息</span>
events &#123;
    use epoll; <span class="hljs-comment"># 使用epoll的I/O模型(如果你不知道Nginx该使用哪种轮询方法，会自动选择一个最适合你操作系统的)</span>
    worker_connections 1024; <span class="hljs-comment"># 每个进程允许最大并发数</span>
&#125;

<span class="hljs-comment"># http段配置信息</span>
<span class="hljs-comment"># 配置使用最频繁的部分，代理、缓存、日志定义等绝大多数功能和第三方模块的配置都在这里设置</span>
http &#123; 
    <span class="hljs-comment"># 设置日志模式</span>
    log_format  main <span class="hljs-string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span>
                      <span class="hljs-string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span>
                      <span class="hljs-string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;

    access_log  /var/<span class="hljs-built_in">log</span>/nginx/access.log main; <span class="hljs-comment"># Nginx访问日志存放位置</span>

    sendfile            on; <span class="hljs-comment"># 开启高效传输模式</span>
    tcp_nopush          on; <span class="hljs-comment"># 减少网络报文段的数量</span>
    tcp_nodelay         on;
    keepalive_timeout   65; <span class="hljs-comment"># 保持连接的时间，也叫超时时间，单位秒</span>
    types_hash_max_size 2048;

    include             /etc/nginx/mime.types; <span class="hljs-comment"># 文件扩展名与类型映射表</span>
    default_type        application/octet-stream; <span class="hljs-comment"># 默认文件类型</span>

    include /etc/nginx/conf.d/*.conf; <span class="hljs-comment"># 加载子配置项</span>
    
    <span class="hljs-comment"># server段配置信息</span>
    server &#123;
     listen       80; <span class="hljs-comment"># 配置监听的端口</span>
     server_name  localhost; <span class="hljs-comment"># 配置的域名</span>
      
     <span class="hljs-comment"># location段配置信息</span>
     location / &#123;
      root   /usr/share/nginx/html; <span class="hljs-comment"># 网站根目录</span>
      index  index.html index.htm; <span class="hljs-comment"># 默认首页文件</span>
      deny 172.168.22.11; <span class="hljs-comment"># 禁止访问的ip地址，可以为all</span>
      allow 172.168.33.44；<span class="hljs-comment"># 允许访问的ip地址，可以为all</span>
     &#125;
     
     error_page 500 502 503 504 /50x.html; <span class="hljs-comment"># 默认50x对应的访问页面</span>
     error_page 400 404 error.html; <span class="hljs-comment"># 同上</span>
    &#125;
&#125;</code></pre></div>

<ul>
<li> 全局配置，对全局生效；</li>
<li><code>events</code> 配置影响 <code>Nginx</code> 服务器与用户的网络连接；</li>
<li><code>http</code> 配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置；</li>
<li><code>server</code> 配置虚拟主机的相关参数，一个 <code>http</code> 块中可以有多个 <code>server</code> 块；</li>
<li><code>location</code> 用于配置匹配的 <code>uri</code> ；</li>
<li><code>upstream</code> 配置后端服务器具体地址，负载均衡配置不可或缺的部分；</li>
</ul>
<p>用一张图清晰的展示它的层级结构：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqgipd9lr4j304w0bd3ye.jpg" srcset="/img/loading.gif" lazyload alt="Image"></p>
<h2 id="配置文件-main-段核心参数"><a href="#配置文件-main-段核心参数" class="headerlink" title="配置文件 main 段核心参数"></a>配置文件 main 段核心参数</h2><h2 id="user"><a href="#user" class="headerlink" title="user"></a>user</h2><p>指定运行 <code>Nginx</code> 的 <code>woker</code> 子进程的属主和属组，其中组可以不指定。</p>
<div class="hljs code-wrapper"><pre><code class="hljs bash">user USERNAME [GROUP]

user nginx lion; <span class="hljs-comment"># 用户是nginx;组是lion</span></code></pre></div>



<p><strong>pid</strong></p>
<p>指定运行 <code>Nginx</code> <code>master</code> 主进程的 <code>pid</code> 文件存放路径。</p>
<div class="hljs code-wrapper"><pre><code class="hljs bash">pid /opt/nginx/logs/nginx.pid <span class="hljs-comment"># master主进程的的pid存放在nginx.pid的文件</span></code></pre></div>

<h3 id="worker-rlimit-nofile-number"><a href="#worker-rlimit-nofile-number" class="headerlink" title="worker_rlimit_nofile_number"></a>worker_rlimit_nofile_number</h3><p>指定 <code>worker</code> 子进程可以打开的最大文件句柄数。</p>
<div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">worker_rlimit_nofile</span> <span class="hljs-number">20480</span>; <span class="hljs-comment"># 可以理解成每个worker子进程的最大连接数量。</span></code></pre></div>



<p><strong>worker_rlimit_core</strong></p>
<p>指定 <code>worker</code> 子进程异常终止后的 <code>core</code> 文件，用于记录分析问题。</p>
<div class="hljs code-wrapper"><pre><code class="hljs awk">worker_rlimit_core <span class="hljs-number">50</span>M; <span class="hljs-comment"># 存放大小限制</span>
working_directory <span class="hljs-regexp">/opt/</span>nginx/tmp; <span class="hljs-comment"># 存放目录</span></code></pre></div>

<h3 id="worker-processes-number"><a href="#worker-processes-number" class="headerlink" title="worker_processes_number"></a>worker_processes_number</h3><p>指定 <code>Nginx</code> 启动的 <code>worker</code> 子进程数量。</p>
<div class="hljs code-wrapper"><pre><code class="hljs bash">worker_processes 4; <span class="hljs-comment"># 指定具体子进程数量</span>
worker_processes auto; <span class="hljs-comment"># 与当前cpu物理核心数一致</span></code></pre></div>

<h3 id="worker-cpu-affinity"><a href="#worker-cpu-affinity" class="headerlink" title="worker_cpu_affinity"></a>worker_cpu_affinity</h3><p>将每个 <code>worker</code> 子进程与我们的 <code>cpu</code> 物理核心绑定。</p>
<div class="hljs code-wrapper"><pre><code class="hljs bash">worker_cpu_affinity 0001 0010 0100 1000; <span class="hljs-comment"># 4个物理核心，4个worker子进程</span></code></pre></div>



<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqgipukswcj30h20cj3yl.jpg" srcset="/img/loading.gif" lazyload alt="Image"></p>
<p>将每个 <code>worker</code> 子进程与特定 <code>CPU</code> 物理核心绑定，优势在于，避免同一个 <code>worker</code> 子进程在不同的 <code>CPU</code> 核心上切换，缓存失效，降低性能。但其并不能真正的避免进程切换。</p>
<p><strong>worker_priority</strong></p>
<p>指定 <code>worker</code> 子进程的 <code>nice</code> 值，以调整运行 <code>Nginx</code> 的优先级，通常设定为负值，以优先调用<code>Nginx</code> 。</p>
<div class="hljs code-wrapper"><pre><code class="hljs bash">worker_priority -10; <span class="hljs-comment"># 120-10=110，110就是最终的优先级</span></code></pre></div>

<p><code>Linux</code> 默认进程的优先级值是120，值越小越优先；<code>nice</code> 定范围为 <code>-20</code> 到 <code>+19</code> 。</p>
<p>[备注] 应用的默认优先级值是120加上 <code>nice</code> 值等于它最终的值，这个值越小，优先级越高。</p>
<h3 id="worker-shutdown-timeout"><a href="#worker-shutdown-timeout" class="headerlink" title="worker_shutdown_timeout"></a>worker_shutdown_timeout</h3><p>指定 <code>worker</code> 子进程优雅退出时的超时时间。</p>
<div class="hljs code-wrapper"><pre><code class="hljs bash">worker_shutdown_timeout 5s;</code></pre></div>

<h3 id="timer-resolution"><a href="#timer-resolution" class="headerlink" title="timer_resolution"></a>timer_resolution</h3><p><code>worker</code> 子进程内部使用的计时器精度，调整时间间隔越大，系统调用越少，有利于性能提升；反之，系统调用越多，性能下降。</p>
<div class="hljs code-wrapper"><pre><code class="hljs bash">timer_resolution 100ms;</code></pre></div>

<p>在 <code>Linux</code> 系统中，用户需要获取计时器时需要向操作系统内核发送请求，有请求就必然会有开销，因此这个间隔越大开销就越小。</p>
<p><strong>daemon</strong></p>
<p>指定 <code>Nginx</code> 的运行方式，前台还是后台，前台用于调试，后台用于生产。</p>
<div class="hljs code-wrapper"><pre><code class="hljs bash">daemon off; <span class="hljs-comment"># 默认是on，后台运行模式</span></code></pre></div>

<h2 id="配置文件-events-段核心参数"><a href="#配置文件-events-段核心参数" class="headerlink" title="配置文件 events 段核心参数"></a>配置文件 events 段核心参数</h2><h3 id="use"><a href="#use" class="headerlink" title="use"></a>use</h3><p><code>Nginx</code> 使用何种事件驱动模型。</p>
<div class="hljs code-wrapper"><pre><code class="hljs bash">use method; <span class="hljs-comment"># 不推荐配置它，让nginx自己选择</span>

method 可选值为：select、poll、kqueue、epoll、/dev/poll、eventport</code></pre></div>

<h3 id="worker-connections"><a href="#worker-connections" class="headerlink" title="worker_connections"></a>worker_connections</h3><p><code>worker</code> 子进程能够处理的最大并发连接数。</p>
<div class="hljs code-wrapper"><pre><code class="hljs bash">worker_connections 1024 <span class="hljs-comment"># 每个子进程的最大连接数为1024</span></code></pre></div>

<p><strong>accept_mutex</strong></p>
<p>是否打开负载均衡互斥锁。</p>
<div class="hljs code-wrapper"><pre><code class="hljs bash">accept_mutex on <span class="hljs-comment"># 默认是off关闭的，这里推荐打开</span></code></pre></div>

<p><strong>server_name 指令</strong></p>
<p>指定虚拟主机域名。</p>
<div class="hljs code-wrapper"><pre><code class="hljs bash">server_name name1 name2 name3

<span class="hljs-comment"># 示例：</span>
server_name www.nginx.com;</code></pre></div>

<p>域名匹配的四种写法：</p>
<ul>
<li>精确匹配：<code>server_name www.nginx.com</code> ;</li>
<li>左侧通配：<code>server_name *.nginx.com</code> ;</li>
<li>右侧统配：<code>server_name www.nginx.*</code> ;</li>
<li>正则匹配：<code>server_name ~^www\.nginx\.*$</code> ;</li>
</ul>
<p>匹配优先级：<strong>精确匹配 &gt; 左侧通配符匹配 &gt; 右侧通配符匹配 &gt; 正则表达式匹配</strong></p>
<p><code>server_name</code> 配置实例：</p>
<p>1、配置本地 <code>DNS</code> 解析 <code>vim /etc/hosts</code> （ <code>macOS</code> 系统）</p>
<div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 添加如下内容，其中 121.42.11.34 是阿里云服务器IP地址</span>
121.42.11.34 www.nginx-test.com
121.42.11.34 mail.nginx-test.com
121.42.11.34 www.nginx-test.org
121.42.11.34 doc.nginx-test.com
121.42.11.34 www.nginx-test.cn
121.42.11.34 fe.nginx-test.club</code></pre></div>

<p>[注意] 这里使用的是虚拟域名进行测试，因此需要配置本地 <code>DNS</code> 解析，如果使用阿里云上购买的域名，则需要在阿里云上设置好域名解析。</p>
<p>2、配置阿里云 <code>Nginx</code> ，<code>vim /etc/nginx/nginx.conf</code></p>
<div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 这里只列举了http端中的sever端配置</span>

<span class="hljs-comment"># 左匹配</span>
server &#123;
 listen 80;
 server_name *.nginx-test.com;
 root /usr/share/nginx/html/nginx-test/left-match/;
 location / &#123;
  index index.html;
 &#125;
&#125;

<span class="hljs-comment"># 正则匹配</span>
server &#123;
 listen 80;
 server_name ~^.*\.nginx-test\..*$;
 root /usr/share/nginx/html/nginx-test/reg-match/;
 location / &#123;
  index index.html;
 &#125;
&#125;

<span class="hljs-comment"># 右匹配</span>
server &#123;
 listen 80;
 server_name www.nginx-test.*;
 root /usr/share/nginx/html/nginx-test/right-match/;
 location / &#123;
  index index.html;
 &#125;
&#125;

<span class="hljs-comment"># 完全匹配</span>
server &#123;
 listen 80;
 server_name www.nginx-test.com;
 root /usr/share/nginx/html/nginx-test/all-match/;
 location / &#123;
  index index.html;
 &#125;
&#125;</code></pre></div>

<p>3、访问分析</p>
<ul>
<li>当访问 <code>www.nginx-test.com</code> 时，都可以被匹配上，因此选择优先级最高的“完全匹配”；</li>
<li>当访问 <code>mail.nginx-test.com</code> 时，会进行“左匹配”；</li>
<li>当访问 <code>www.nginx-test.org</code> 时，会进行“右匹配”；</li>
<li>当访问 <code>doc.nginx-test.com</code> 时，会进行“左匹配”；</li>
<li>当访问 <code>www.nginx-test.cn</code> 时，会进行“右匹配”；</li>
<li>当访问 <code>fe.nginx-test.club</code> 时，会进行“正则匹配”；</li>
</ul>
<h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p>指定静态资源目录位置，它可以写在 <code>http</code> 、 <code>server</code> 、 <code>location</code> 等配置中。</p>
<div class="hljs code-wrapper"><pre><code class="hljs bash">root path

例如：
location /image &#123;
 root /opt/nginx/static;
&#125;

当用户访问 www.test.com/image/1.png 时，实际在服务器找的路径是 /opt/nginx/static/image/1.png</code></pre></div>

<p>[注意] <code>root</code> 会将定义路径与 <code>URI</code> 叠加， <code>alias</code> 则只取定义路径。</p>
<h2 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h2><p>它也是指定静态资源目录位置，它只能写在 <code>location</code> 中。</p>
<div class="hljs code-wrapper"><pre><code class="hljs awk">location /image &#123;
 alias <span class="hljs-regexp">/opt/</span>nginx<span class="hljs-regexp">/static/im</span>age/;
&#125;

当用户访问 www.test.com<span class="hljs-regexp">/image/</span><span class="hljs-number">1</span>.png 时，实际在服务器找的路径是 <span class="hljs-regexp">/opt/</span>nginx<span class="hljs-regexp">/static/im</span>age/<span class="hljs-number">1</span>.png</code></pre></div>

<p>[注意] 使用 alias 末尾一定要添加 <code>/</code> ，并且它只能位于 <code>location</code> 中。</p>
<p><strong>location</strong></p>
<p>配置路径。</p>
<div class="hljs code-wrapper"><pre><code class="hljs crmsh"><span class="hljs-keyword">location</span> <span class="hljs-title">[ = | ~ | ~* | ^~ ] uri</span> &#123;
 ...
&#125;</code></pre></div>

<p>匹配规则：</p>
<ul>
<li><code>=</code> 精确匹配；</li>
<li><code>~</code> 正则匹配，区分大小写；</li>
<li><code>~*</code> 正则匹配，不区分大小写；</li>
<li><code>^~</code> 匹配到即停止搜索；</li>
</ul>
<p>匹配优先级：<code>=</code> &gt; <code>^~</code> &gt; <code>~</code> &gt; <code>~*</code> &gt; 不带任何字符。</p>
<p>实例：</p>
<div class="hljs code-wrapper"><pre><code class="hljs gradle">server &#123;
  listen <span class="hljs-number">80</span>;
  server_name www.nginx-test.com;
  
  # 只有当访问 www.nginx-test.com<span class="hljs-regexp">/match_all/</span> 时才会匹配到<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html<span class="hljs-regexp">/match_all/i</span>ndex.html
  location = <span class="hljs-regexp">/match_all/</span> &#123;
      root <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html
      index index.html
  &#125;
  
  # 当访问 www.nginx-test.com<span class="hljs-regexp">/1.jpg 等路径时会去 /u</span>sr<span class="hljs-regexp">/share/</span>nginx<span class="hljs-regexp">/images/</span><span class="hljs-number">1</span>.jpg 找对应的资源
  location ~ \.(jpeg|jpg|png|svg)$ &#123;
   root <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/im</span>ages;
  &#125;
  
  # 当访问 www.nginx-test.com<span class="hljs-regexp">/bbs/</span> 时会匹配上 <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html<span class="hljs-regexp">/bbs/i</span>ndex.html
  location ^~ <span class="hljs-regexp">/bbs/</span> &#123;
   root <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html;
    index index.html index.htm;
  &#125;
&#125;</code></pre></div>

<p><strong>location 中的反斜线</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs crmsh"><span class="hljs-keyword">location</span> <span class="hljs-title">/test</span> &#123;
 ...
&#125;

<span class="hljs-keyword">location</span> <span class="hljs-title">/test</span>/ &#123;
 ...
&#125;</code></pre></div>

<ul>
<li>不带 <code>/</code> 当访问 <code>www.nginx-test.com/test</code> 时， <code>Nginx</code> 先找是否有 <code>test</code> 目录，如果有则找<code>test</code> 目录下的 <code>index.html</code> ；如果没有 <code>test</code> 目录， <code>nginx</code> 则会找是否有 <code>test</code> 文件。</li>
<li>带 <code>/</code> 当访问 <code>www.nginx-test.com/test</code> 时， <code>Nginx</code> 先找是否有 <code>test</code> 目录，如果有则找<code>test</code> 目录下的 <code>index.html</code> ，如果没有它也不会去找是否存在 <code>test</code> 文件。</li>
</ul>
<h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><p>停止处理请求，直接返回响应码或重定向到其他 <code>URL</code> ；执行 <code>return</code> 指令后， <code>location</code> 中后续指令将不会被执行。</p>
<div class="hljs code-wrapper"><pre><code class="hljs crmsh">return code [text];
return code URL;
return URL;

例如：
<span class="hljs-keyword">location</span> <span class="hljs-title">/ &#123;</span>
<span class="hljs-title"> return</span> <span class="hljs-number">404</span>; <span class="hljs-comment"># 直接返回状态码</span>
&#125;

<span class="hljs-keyword">location</span> <span class="hljs-title">/ &#123;</span>
<span class="hljs-title"> return</span> <span class="hljs-number">404</span> <span class="hljs-string">&quot;pages not found&quot;</span>; <span class="hljs-comment"># 返回状态码 + 一段文本</span>
&#125;

<span class="hljs-keyword">location</span> <span class="hljs-title">/ &#123;</span>
<span class="hljs-title"> return</span> <span class="hljs-number">302</span> /bbs ; <span class="hljs-comment"># 返回状态码 + 重定向地址</span>
&#125;

<span class="hljs-keyword">location</span> <span class="hljs-title">/ &#123;</span>
<span class="hljs-title"> return</span> https://www.baidu.com ; <span class="hljs-comment"># 返回重定向地址</span>
&#125;</code></pre></div>

<h2 id="rewrite"><a href="#rewrite" class="headerlink" title="rewrite"></a>rewrite</h2><p>根据指定正则表达式匹配规则，重写 <code>URL</code> 。</p>
<div class="hljs code-wrapper"><pre><code class="hljs awk">语法：rewrite 正则表达式 要替换的内容 [flag];

上下文：server、location、<span class="hljs-keyword">if</span>

示例：rewirte <span class="hljs-regexp">/images/</span>(.*\.jpg)$ <span class="hljs-regexp">/pic/</span><span class="hljs-variable">$1</span>; <span class="hljs-comment"># $1是前面括号(.*\.jpg)的反向引用</span></code></pre></div>

<p><code>flag</code> 可选值的含义：</p>
<ul>
<li><code>last</code> 重写后的 <code>URL</code> 发起新请求，再次进入 <code>server</code> 段，重试 <code>location</code> 的中的匹配；</li>
<li><code>break</code> 直接使用重写后的 <code>URL</code> ，不再匹配其它 <code>location</code> 中语句；</li>
<li><code>redirect</code> 返回302临时重定向；</li>
<li><code>permanent</code> 返回301永久重定向；</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs crmsh">server&#123;
  listen <span class="hljs-number">80</span>;
  server_name fe.lion.club; <span class="hljs-comment"># 要在本地hosts文件进行配置</span>
  root html;
  <span class="hljs-keyword">location</span> <span class="hljs-title">/search</span> &#123;
   rewrite ^/(.*) https://www.baidu.com redirect;
  &#125;
  
  <span class="hljs-keyword">location</span> <span class="hljs-title">/images</span> &#123;
   rewrite /images/(.*) /pics/$<span class="hljs-number">1</span>;
  &#125;
  
  <span class="hljs-keyword">location</span> <span class="hljs-title">/pics</span> &#123;
   rewrite /pics/(.*) /photos/$<span class="hljs-number">1</span>;
  &#125;
  
  <span class="hljs-keyword">location</span> <span class="hljs-title">/photos</span> &#123;
  
  &#125;
&#125;</code></pre></div>

<p>按照这个配置我们来分析：</p>
<ul>
<li>当访问 <code>fe.lion.club/search</code> 时，会自动帮我们重定向到 <code>https://www.baidu.com</code>。</li>
<li>当访问 <code>fe.lion.club/images/1.jpg</code> 时，第一步重写 <code>URL</code> 为 <code>fe.lion.club/pics/1.jpg</code> ，找到 <code>pics</code> 的 <code>location</code> ，继续重写 <code>URL</code> 为 <code>fe.lion.club/photos/1.jpg</code> ，找到 <code>/photos</code> 的<code>location</code> 后，去 <code>html/photos</code> 目录下寻找 <code>1.jpg</code> 静态资源。</li>
</ul>
<h2 id="if-指令"><a href="#if-指令" class="headerlink" title="if 指令"></a>if 指令</h2><div class="hljs code-wrapper"><pre><code class="hljs nim">语法：<span class="hljs-keyword">if</span> (condition) <span class="hljs-meta">&#123;...&#125;</span>

上下文：server、location

示例：
<span class="hljs-keyword">if</span>($http_user_agent ~ <span class="hljs-type">Chrome</span>)&#123;
  rewrite /(.*)/browser/$<span class="hljs-number">1</span> <span class="hljs-keyword">break</span>;
&#125;</code></pre></div>

<p><code>condition</code> 判断条件：</p>
<ul>
<li><code>$variable</code> 仅为变量时，值为空或以0开头字符串都会被当做 <code>false</code> 处理；</li>
<li><code>=</code> 或 <code>!=</code> 相等或不等；</li>
<li><code>~</code> 正则匹配；</li>
<li><code>! ~</code> 非正则匹配；</li>
<li><code>~*</code> 正则匹配，不区分大小写；</li>
<li><code>-f</code> 或 <code>! -f</code> 检测文件存在或不存在；</li>
<li><code>-d</code> 或 <code>! -d</code> 检测目录存在或不存在；</li>
<li><code>-e</code> 或 <code>! -e</code> 检测文件、目录、符号链接等存在或不存在；</li>
<li><code>-x</code> 或 <code>! -x</code> 检测文件可以执行或不可执行；</li>
</ul>
<p>实例：</p>
<div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;
  <span class="hljs-attribute">listen</span> <span class="hljs-number">8080</span>;
  <span class="hljs-attribute">server_name</span> localhost;
  <span class="hljs-attribute">root</span> html;
  
  <span class="hljs-attribute">location</span> / &#123;
   <span class="hljs-attribute">if</span> ( $uri = <span class="hljs-string">&quot;/images/&quot;</span> )&#123;
     <span class="hljs-attribute">rewrite</span> (.*) /pics/ <span class="hljs-literal">break</span>;
    &#125;
  &#125;
&#125;</code></pre></div>

<p>当访问 <code>localhost:8080/images/</code> 时，会进入 <code>if</code> 判断里面执行 <code>rewrite</code> 命令。</p>
<p><strong>autoindex</strong></p>
<p>用户请求以 <code>/</code> 结尾时，列出目录结构，可以用于快速搭建静态资源下载网站。</p>
<p><code>autoindex.conf</code> 配置信息：</p>
<div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;
  <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;
  <span class="hljs-attribute">server_name</span> fe.lion-test.club;
  
  <span class="hljs-attribute">location</span> /download/ &#123;
    <span class="hljs-attribute">root</span> /opt/source;
    
    <span class="hljs-attribute">autoindex</span> <span class="hljs-literal">on</span>; <span class="hljs-comment"># 打开 autoindex，，可选参数有 on | off</span>
    <span class="hljs-attribute">autoindex_exact_size</span> <span class="hljs-literal">on</span>; <span class="hljs-comment"># 修改为off，以KB、MB、GB显示文件大小，默认为on，以bytes显示出⽂件的确切⼤⼩</span>
    <span class="hljs-attribute">autoindex_format</span> html; <span class="hljs-comment"># 以html的方式进行格式化，可选参数有 html | json | xml</span>
    <span class="hljs-attribute">autoindex_localtime</span> <span class="hljs-literal">off</span>; <span class="hljs-comment"># 显示的⽂件时间为⽂件的服务器时间。默认为off，显示的⽂件时间为GMT时间</span>
  &#125;
&#125;</code></pre></div>

<p>当访问 <code>fe.lion.com/download/</code> 时，会把服务器 <code>/opt/source/download/</code> 路径下的文件展示出来，如下图所示：</p>
<p><img src="https://i.loli.net/2021/05/13/xSXV4IvkreYuOa2.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<p><strong>变量</strong></p>
<p><code>Nginx</code> 提供给使用者的变量非常多，但是终究是一个完整的请求过程所产生数据， <code>Nginx</code> 将这些数据以变量的形式提供给使用者。</p>
<p>下面列举些项目中常用的变量：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqgionqq4ij30k212ydkv.jpg" srcset="/img/loading.gif" lazyload alt="Image"></p>
<p>实例演示 <code>var.conf</code> ：</p>
<div class="hljs code-wrapper"><pre><code class="hljs stata">server&#123;
 listen 8081;
 server_name <span class="hljs-keyword">var</span>.lion-<span class="hljs-keyword">test</span>.club;
 root /usr/share/nginx/html;
 location / &#123;
  <span class="hljs-keyword">return</span> 200 &quot;
remote_addr: <span class="hljs-variable">$remote_addr</span>
remote_port: <span class="hljs-variable">$remote_port</span>
server_addr: <span class="hljs-variable">$server_addr</span>
server_port: <span class="hljs-variable">$server_port</span>
server_protocol: <span class="hljs-variable">$server_protocol</span>
binary_remote_addr: <span class="hljs-variable">$binary_remote_addr</span>
connection: <span class="hljs-variable">$connection</span>
uri: <span class="hljs-variable">$uri</span>
request_uri: <span class="hljs-variable">$request_uri</span>
scheme: <span class="hljs-variable">$scheme</span>
request_method: <span class="hljs-variable">$request_method</span>
request_length: <span class="hljs-variable">$request_length</span>
<span class="hljs-keyword">args</span>: <span class="hljs-variable">$args</span>
arg_pid: <span class="hljs-variable">$arg_pid</span>
is_args: <span class="hljs-variable">$is_args</span>
query_string: <span class="hljs-variable">$query_string</span>
host: <span class="hljs-variable">$host</span>
http_user_agent: <span class="hljs-variable">$http_user_agent</span>
http_referer: <span class="hljs-variable">$http_referer</span>
http_via: <span class="hljs-variable">$http_via</span>
request_time: <span class="hljs-variable">$request_time</span>
https: <span class="hljs-variable">$https</span>
request_filename: <span class="hljs-variable">$request_filename</span>
document_root: <span class="hljs-variable">$document_root</span>
&quot;;
 &#125;
&#125;</code></pre></div>

<p>当我们访问 <code>http://var.lion-test.club:8081/test?pid=121414&amp;cid=sadasd</code> 时，由于 <code>Nginx</code>中写了 <code>return</code> 方法，因此 <code>chrome</code> 浏览器会默认为我们下载一个文件，下面展示的就是下载的文件内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-symbol">remote_addr:</span> <span class="hljs-number">27.16</span><span class="hljs-number">.220</span><span class="hljs-number">.84</span>
<span class="hljs-symbol">remote_port:</span> <span class="hljs-number">56838</span>
<span class="hljs-symbol">server_addr:</span> <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span>
<span class="hljs-symbol">server_port:</span> <span class="hljs-number">8081</span>
<span class="hljs-symbol">server_protocol:</span> HTTP/<span class="hljs-number">1.1</span>
<span class="hljs-symbol">binary_remote_addr:</span> 茉
<span class="hljs-symbol">connection:</span> <span class="hljs-number">126</span>
<span class="hljs-symbol">uri:</span> <span class="hljs-meta-keyword">/test/</span>
<span class="hljs-symbol">request_uri:</span> <span class="hljs-meta-keyword">/test/</span>?pid=<span class="hljs-number">121414</span><span class="hljs-variable">&amp;cid</span>=sadasd
<span class="hljs-symbol">scheme:</span> http
<span class="hljs-symbol">request_method:</span> GET
<span class="hljs-symbol">request_length:</span> <span class="hljs-number">518</span>
<span class="hljs-symbol">args:</span> pid=<span class="hljs-number">121414</span><span class="hljs-variable">&amp;cid</span>=sadasd
<span class="hljs-symbol">arg_pid:</span> <span class="hljs-number">121414</span>
<span class="hljs-symbol">is_args:</span> ?
<span class="hljs-symbol">query_string:</span> pid=<span class="hljs-number">121414</span><span class="hljs-variable">&amp;cid</span>=sadasd
<span class="hljs-symbol">host:</span> var.lion-test.club
<span class="hljs-symbol">http_user_agent:</span> Mozilla/<span class="hljs-number">5.0</span> (Macintosh; Intel Mac OS X <span class="hljs-number">10</span>_14_0) AppleWebKit/<span class="hljs-number">537.36</span> (KHTML, like Gecko) Chrome/<span class="hljs-number">88.0</span><span class="hljs-number">.4324</span><span class="hljs-number">.182</span> Safari/<span class="hljs-number">537.36</span>
<span class="hljs-symbol">http_referer:</span> 
<span class="hljs-symbol">http_via:</span> 
<span class="hljs-symbol">request_time:</span> <span class="hljs-number">0.000</span>
<span class="hljs-symbol">https:</span> 
<span class="hljs-symbol">request_filename:</span> <span class="hljs-meta-keyword">/usr/</span>share<span class="hljs-meta-keyword">/nginx/</span>html<span class="hljs-meta-keyword">/test/</span>
<span class="hljs-symbol">document_root:</span> <span class="hljs-meta-keyword">/usr/</span>share<span class="hljs-meta-keyword">/nginx/</span>html</code></pre></div>

<p><code>Nginx</code> 的配置还有非常多，以上只是罗列了一些常用的配置，在实际项目中还是要学会查阅文档。</p>
<p><strong>Nginx 应用核心概念</strong></p>
<p>代理是在服务器和客户端之间假设的一层服务器，代理将接收客户端的请求并将它转发给服务器，然后将服务端的响应转发给客户端。</p>
<p>不管是正向代理还是反向代理，实现的都是上面的功能。</p>
<p><img src="https://i.loli.net/2021/05/13/fSs4pyHmb5AQtiU.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<p><strong>正向代理</strong></p>
<blockquote>
<p>正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。</p>
</blockquote>
<p>正向代理是为我们服务的，即为客户端服务的，客户端可以根据正向代理访问到它本身无法访问到的服务器资源。</p>
<p>正向代理对我们是透明的，对服务端是非透明的，即服务端并不知道自己收到的是来自代理的访问还是来自真实客户端的访问。</p>
<p><strong>反向代理</strong></p>
<blockquote>
<ul>
<li>反向代理*（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</li>
</ul>
</blockquote>
<p>反向代理是为服务端服务的，反向代理可以帮助服务器接收来自客户端的请求，帮助服务器做请求转发，负载均衡等。</p>
<p>反向代理对服务端是透明的，对我们是非透明的，即我们并不知道自己访问的是代理服务器，而服务器知道反向代理在为他服务。</p>
<p>反向代理的优势：</p>
<ul>
<li>隐藏真实服务器；</li>
<li>负载均衡便于横向扩充后端动态服务；</li>
<li>动静分离，提升系统健壮性；</li>
</ul>
<p>那么“动静分离”是什么？负载均衡又是什么？</p>
<p><strong>动静分离</strong></p>
<p>动静分离是指在 <code>web</code> 服务器架构中，将静态页面与动态页面或者静态内容接口和动态内容接口分开不同系统访问的架构设计方法，进而提示整个服务的访问性和可维护性。</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" srcset="/img/loading.gif" lazyload alt="Image"></p>
<p>一般来说，都需要将动态资源和静态资源分开，由于 <code>Nginx</code> 的高并发和静态资源缓存等特性，经常将静态资源部署在 <code>Nginx</code> 上。如果请求的是静态资源，直接到静态资源目录获取资源，如果是动态资源的请求，则利用反向代理的原理，把请求转发给对应后台应用去处理，从而实现动静分离。</p>
<p>使用前后端分离后，可以很大程度提升静态资源的访问速度，即使动态服务不可用，静态资源的访问也不会受到影响。</p>
<p><strong>负载均衡</strong></p>
<p>一般情况下，客户端发送多个请求到服务器，服务器处理请求，其中一部分可能要操作一些资源比如数据库、静态资源等，服务器处理完毕后，再将结果返回给客户端。</p>
<p>这种模式对于早期的系统来说，功能要求不复杂，且并发请求相对较少的情况下还能胜任，成本也低。随着信息数量不断增长，访问量和数据量飞速增长，以及系统业务复杂度持续增加，这种做法已无法满足要求，并发量特别大时，服务器容易崩。</p>
<p>很明显这是由于服务器性能的瓶颈造成的问题，除了堆机器之外，最重要的做法就是负载均衡。</p>
<p>请求爆发式增长的情况下，单个机器性能再强劲也无法满足要求了，这个时候集群的概念产生了，单个服务器解决不了的问题，可以使用多个服务器，然后将请求分发到各个服务器上，将负载分发到不同的服务器，这就是负载均衡，核心是「分摊压力」。<code>Nginx</code> 实现负载均衡，一般来说指的是将请求转发给服务器集群。</p>
<p>举个具体的例子，晚高峰乘坐地铁的时候，入站口经常会有地铁工作人员大喇叭“请走 <code>B</code> 口， <code>B</code>口人少车空….”，这个工作人员的作用就是负载均衡。</p>
<p><img src="https://i.loli.net/2021/05/13/Wsy3nxX6OkcjU5f.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<p><code>Nginx</code> 实现负载均衡的策略：</p>
<ul>
<li>轮询策略：默认情况下采用的策略，将所有客户端请求轮询分配给服务端。这种策略是可以正常工作的，但是如果其中某一台服务器压力太大，出现延迟，会影响所有分配在这台服务器下的用户。</li>
<li>最小连接数策略：将请求优先分配给压力较小的服务器，它可以平衡每个队列的长度，并避免向压力大的服务器添加更多的请求。</li>
<li>最快响应时间策略：优先分配给响应时间最短的服务器。</li>
<li>客户端 <code>ip</code> 绑定策略：来自同一个 <code>ip</code> 的请求永远只分配一台服务器，有效解决了动态网页存在的 <code>session</code> 共享问题。</li>
</ul>
<p><strong>Nginx 实战配置</strong></p>
<p>在配置反向代理和负载均衡等等功能之前，有两个核心模块是我们必须要掌握的，这两个模块应该说是 <code>Nginx</code> 应用配置中的核心，它们分别是：<code>upstream</code> 、<code>proxy_pass</code> 。</p>
<p><strong>upstream</strong></p>
<p>用于定义上游服务器（指的就是后台提供的应用服务器）的相关信息。</p>
<p><img src="https://i.loli.net/2021/05/13/L7Au6MSZ8NUcmeO.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<div class="hljs code-wrapper"><pre><code class="hljs dust"><span class="xml">语法：upstream name </span><span class="hljs-template-variable">&#123;</span>
<span class="hljs-template-variable"> ...</span>
<span class="hljs-template-variable">&#125;</span>

<span class="xml">上下文：http</span>

<span class="xml">示例：</span>
<span class="xml">upstream back_end_server</span><span class="hljs-template-variable">&#123;</span>
<span class="hljs-template-variable">  server 192.168.100.33:8081</span>
<span class="hljs-template-variable">&#125;</span></code></pre></div>

<p>在 <code>upstream</code> 内可使用的指令：</p>
<ul>
<li><code>server</code> 定义上游服务器地址；</li>
<li><code>zone</code> 定义共享内存，用于跨 <code>worker</code> 子进程；</li>
<li><code>keepalive</code> 对上游服务启用长连接；</li>
<li><code>keepalive_requests</code> 一个长连接最多请求 <code>HTTP</code> 的个数；</li>
<li><code>keepalive_timeout</code> 空闲情形下，一个长连接的超时时长；</li>
<li><code>hash</code> 哈希负载均衡算法；</li>
<li><code>ip_hash</code> 依据 <code>IP</code> 进行哈希计算的负载均衡算法；</li>
<li><code>least_conn</code> 最少连接数负载均衡算法；</li>
<li><code>least_time</code> 最短响应时间负载均衡算法；</li>
<li><code>random</code> 随机负载均衡算法；</li>
</ul>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>定义上游服务器地址。</p>
<div class="hljs code-wrapper"><pre><code class="hljs css">语法：server <span class="hljs-selector-tag">address</span> <span class="hljs-selector-attr">[parameters]</span>

上下文：upstream</code></pre></div>

<p><code>parameters</code> 可选值：</p>
<ul>
<li><code>weight=number</code> 权重值，默认为1；</li>
<li><code>max_conns=number</code> 上游服务器的最大并发连接数；</li>
<li><code>fail_timeout=time</code> 服务器不可用的判定时间；</li>
<li><code>max_fails=numer</code> 服务器不可用的检查次数；</li>
<li><code>backup</code> 备份服务器，仅当其他服务器都不可用时才会启用；</li>
<li><code>down</code> 标记服务器长期不可用，离线维护；</li>
</ul>
<h3 id="keepalive"><a href="#keepalive" class="headerlink" title="keepalive"></a>keepalive</h3><p>限制每个 <code>worker</code> 子进程与上游服务器空闲长连接的最大数量。</p>
<div class="hljs code-wrapper"><pre><code class="hljs abnf">keepalive connections<span class="hljs-comment">;</span>

上下文：upstream

示例：keepalive <span class="hljs-number">16</span><span class="hljs-comment">;</span></code></pre></div>

<h3 id="keepalive-requests"><a href="#keepalive-requests" class="headerlink" title="keepalive_requests"></a>keepalive_requests</h3><p>单个长连接可以处理的最多 <code>HTTP</code> 请求个数。</p>
<div class="hljs code-wrapper"><pre><code class="hljs abnf">语法：keepalive_requests number<span class="hljs-comment">;</span>

默认值：keepalive_requests <span class="hljs-number">100</span><span class="hljs-comment">;</span>

上下文：upstream</code></pre></div>



<p><strong>keepalive_timeout</strong></p>
<p>空闲长连接的最长保持时间。</p>
<div class="hljs code-wrapper"><pre><code class="hljs abnf">语法：keepalive_timeout time<span class="hljs-comment">;</span>

默认值：keepalive_timeout <span class="hljs-number">60</span>s<span class="hljs-comment">;</span>

上下文：upstream</code></pre></div>

<h3 id="配置实例"><a href="#配置实例" class="headerlink" title="配置实例"></a>配置实例</h3><div class="hljs code-wrapper"><pre><code class="hljs routeros">upstream back_end&#123;
<span class="hljs-built_in"> server </span>127.0.0.1:8081 <span class="hljs-attribute">weight</span>=3 <span class="hljs-attribute">max_conns</span>=1000 <span class="hljs-attribute">fail_timeout</span>=10s <span class="hljs-attribute">max_fails</span>=2;
  keepalive 32;
  keepalive_requests 50;
  keepalive_timeout 30s;
&#125;</code></pre></div>

<h2 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a>proxy_pass</h2><p>用于配置代理服务器。</p>
<div class="hljs code-wrapper"><pre><code class="hljs awk">语法：proxy_pass URL;

上下文：location、<span class="hljs-keyword">if</span>、limit_except

示例：
proxy_pass http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8081</span>
proxy_pass http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8081</span>/proxy</code></pre></div>

<p><code>URL</code> 参数原则</p>
<p><code>1. URL</code> 必须以 <code>http</code> 或 <code>https</code> 开头；</p>
<p><code>2. URL</code> 中可以携带变量；</p>
<p><code>3. URL</code> 中是否带 <code>URI</code> ，会直接影响发往上游请求的 <code>URL</code> ；</p>
<p>接下来让我们来看看两种常见的 <code>URL</code> 用法：</p>
<ol>
<li><code>proxy_pass http://192.168.100.33:8081</code></li>
<li><code>proxy_pass http://192.168.100.33:8081/</code></li>
</ol>
<p>这两种用法的区别就是带 <code>/</code> 和不带 <code>/</code> ，在配置代理时它们的区别可大了：</p>
<ul>
<li>不带 <code>/</code> 意味着 <code>Nginx</code> 不会修改用户 <code>URL</code> ，而是直接透传给上游的应用服务器；</li>
<li>带 <code>/</code> 意味着 <code>Nginx</code> 会修改用户 <code>URL</code> ，修改方法是将 <code>location</code> 后的 <code>URL</code> 从用户 <code>URL</code> 中删除；</li>
</ul>
<p>不带 <code>/</code> 的用法：</p>
<div class="hljs code-wrapper"><pre><code class="hljs awk">location <span class="hljs-regexp">/bbs/</span>&#123;
  proxy_pass http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8080</span>;
&#125;</code></pre></div>

<p>分析：</p>
<p>\1. 用户请求 <code>URL</code> ：<code>/bbs/abc/test.html</code></p>
<p>\2. 请求到达 <code>Nginx</code> 的 <code>URL</code> ：<code>/bbs/abc/test.html</code></p>
<p>3 .请求到达上游应用服务器的 <code>URL</code> ：<code>/bbs/abc/test.html</code></p>
<p>带 <code>/</code> 的用法：</p>
<div class="hljs code-wrapper"><pre><code class="hljs awk">location <span class="hljs-regexp">/bbs/</span>&#123;
  proxy_pass http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8080</span>/;
&#125;</code></pre></div>

<p>分析：</p>
<p>\1. 用户请求 <code>URL</code> ：<code>/bbs/abc/test.html</code></p>
<p>\2. 请求到达 <code>Nginx</code> 的 <code>URL</code> ：<code>/bbs/abc/test.html</code></p>
<p>\3. 请求到达上游应用服务器的 <code>URL</code> ：<code>/abc/test.html</code></p>
<p>并没有拼接上 <code>/bbs</code> ，这点和 <code>root</code> 与 <code>alias</code> 之间的区别是保持一致的。</p>
<p><strong>配置反向代理</strong></p>
<p>这里为了演示更加接近实际，作者准备了两台云服务器，它们的公网 <code>IP</code> 分别是：<code>121.42.11.34</code>与 <code>121.5.180.193</code> 。</p>
<p>我们把 <code>121.42.11.34</code> 服务器作为上游服务器，做如下配置：</p>
<div class="hljs code-wrapper"><pre><code class="hljs gradle"># <span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/conf.d/</span>proxy.conf
server&#123;
  listen <span class="hljs-number">8080</span>;
  server_name localhost;
  
  location <span class="hljs-regexp">/proxy/</span> &#123;
    root <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html/proxy;
    index index.html;
  &#125;
&#125;

# <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html<span class="hljs-regexp">/proxy/i</span>ndex.html
&lt;h1&gt; <span class="hljs-number">121.42</span>.<span class="hljs-number">11.34</span> proxy html &lt;/h1&gt;</code></pre></div>



<p>配置完成后重启 <code>Nginx</code> 服务器 <code>nginx \-s reload</code> 。</p>
<p>把 <code>121.5.180.193</code> 服务器作为代理服务器，做如下配置：</p>
<div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-comment"># /etc/nginx/conf.d/proxy.conf</span>
<span class="hljs-attribute">upstream</span> back_end &#123;
  <span class="hljs-attribute">server</span> <span class="hljs-number">121.42.11.34:8080</span> weight=<span class="hljs-number">2</span> max_conns=<span class="hljs-number">1000</span> fail_timeout=<span class="hljs-number">10s</span> max_fails=<span class="hljs-number">3</span>;
  <span class="hljs-attribute">keepalive</span> <span class="hljs-number">32</span>;
  <span class="hljs-attribute">keepalive_requests</span> <span class="hljs-number">80</span>;
  <span class="hljs-attribute">keepalive_timeout</span> <span class="hljs-number">20s</span>;
&#125;

<span class="hljs-section">server</span> &#123;
  <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;
  <span class="hljs-attribute">server_name</span> proxy.lion.club;
  <span class="hljs-attribute">location</span> /proxy &#123;
   <span class="hljs-attribute">proxy_pass</span> http://back_end/proxy;
  &#125;
&#125;</code></pre></div>

<p>本地机器要访问 <code>proxy.lion.club</code> 域名，因此需要配置本地 <code>hosts</code> ，通过命令：<code>vim /etc/hosts</code>进入配置文件，添加如下内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs accesslog"><span class="hljs-number">121.5.180.193</span> proxy.lion.club</code></pre></div>

<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqgio8wopaj30ry054glt.jpg" srcset="/img/loading.gif" lazyload alt="Image"></p>
<p>分析：</p>
<p>当访问 <code>proxy.lion.club/proxy</code> 时通过 <code>upstream</code> 的配置找到 <code>121.42.11.34:8080</code> ；</p>
<p>因此访问地址变为 <code>http://121.42.11.34:8080/proxy</code> ；</p>
<p>连接到 <code>121.42.11.34</code> 服务器，找到 <code>8080</code> 端口提供的 <code>server</code> ；</p>
<p>通过 <code>server</code> 找到 <code>/usr/share/nginx/html/proxy/index.html</code> 资源，最终展示出来。</p>
<h2 id="配置负载均衡"><a href="#配置负载均衡" class="headerlink" title="配置负载均衡"></a>配置负载均衡</h2><p>配置负载均衡主要是要使用 <code>upstream</code> 指令。</p>
<p>我们把 <code>121.42.11.34</code> 服务器作为上游服务器，做如下配置（ <code>/etc/nginx/conf.d/balance.conf</code>）：</p>
<div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">server</span>&#123;
  <span class="hljs-keyword">listen</span> <span class="hljs-number">8020</span>;
  <span class="hljs-keyword">location</span> / &#123;
   <span class="hljs-keyword">return</span> <span class="hljs-number">200</span> <span class="hljs-string">&#x27;return 8020 \n&#x27;</span>;
  &#125;
&#125;

<span class="hljs-keyword">server</span>&#123;
  <span class="hljs-keyword">listen</span> <span class="hljs-number">8030</span>;
  <span class="hljs-keyword">location</span> / &#123;
   <span class="hljs-keyword">return</span> <span class="hljs-number">200</span> <span class="hljs-string">&#x27;return 8030 \n&#x27;</span>;
  &#125;
&#125;

<span class="hljs-keyword">server</span>&#123;
  <span class="hljs-keyword">listen</span> <span class="hljs-number">8040</span>;
  <span class="hljs-keyword">location</span> / &#123;
   <span class="hljs-keyword">return</span> <span class="hljs-number">200</span> <span class="hljs-string">&#x27;return 8040 \n&#x27;</span>;
  &#125;
&#125;</code></pre></div>

<p>配置完成后：</p>
<p><code>1. nginx -t</code> 检测配置是否正确；</p>
<p><code>2. nginx -s reload</code> 重启 <code>Nginx</code> 服务器；</p>
<p>\3. 执行 <code>ss -nlt</code> 命令查看端口是否被占用，从而判断 <code>Nginx</code> 服务是否正确启动。</p>
<p>把 <code>121.5.180.193</code> 服务器作为代理服务器，做如下配置（ <code>/etc/nginx/conf.d/balance.conf</code>）：</p>
<div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">upstream</span> demo_server &#123;
  <span class="hljs-attribute">server</span> <span class="hljs-number">121.42.11.34:8020</span>;
  <span class="hljs-attribute">server</span> <span class="hljs-number">121.42.11.34:8030</span>;
  <span class="hljs-attribute">server</span> <span class="hljs-number">121.42.11.34:8040</span>;
&#125;

<span class="hljs-section">server</span> &#123;
  <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;
  <span class="hljs-attribute">server_name</span> balance.lion.club;
  
  <span class="hljs-attribute">location</span> /balance/ &#123;
   <span class="hljs-attribute">proxy_pass</span> http://demo_server;
  &#125;
&#125;</code></pre></div>

<p>配置完成后重启 <code>Nginx</code> 服务器。并且在需要访问的客户端配置好 <code>ip</code> 和域名的映射关系。</p>
<div class="hljs code-wrapper"><pre><code class="hljs accesslog"># /etc/hosts

<span class="hljs-number">121.5.180.193</span> balance.lion.club</code></pre></div>

<p>在客户端机器执行 <code>curl http://balance.lion.club/balance/</code> 命令：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqgiu2hh9mj30ip06675k.jpg" srcset="/img/loading.gif" lazyload alt="Image"></p>
<p>不难看出，负载均衡的配置已经生效了，每次给我们分发的上游服务器都不一样。就是通过简单的轮询策略进行上游服务器分发。</p>
<p>接下来，我们再来了解下 <code>Nginx</code> 的其它分发策略。</p>
<p><strong>hash 算法</strong></p>
<p>通过制定关键字作为 <code>hash key</code> ，基于 <code>hash</code> 算法映射到特定的上游服务器中。关键字可以包含有变量、字符串。</p>
<div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">upstream</span> demo_server &#123;
  <span class="hljs-attribute">hash</span> $request_uri;
  <span class="hljs-attribute">server</span> <span class="hljs-number">121.42.11.34:8020</span>;
  <span class="hljs-attribute">server</span> <span class="hljs-number">121.42.11.34:8030</span>;
  <span class="hljs-attribute">server</span> <span class="hljs-number">121.42.11.34:8040</span>;
&#125;

<span class="hljs-section">server</span> &#123;
  <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;
  <span class="hljs-attribute">server_name</span> balance.lion.club;
  
  <span class="hljs-attribute">location</span> /balance/ &#123;
   <span class="hljs-attribute">proxy_pass</span> http://demo_server;
  &#125;
&#125;</code></pre></div>

<p><code>hash $request_uri</code> 表示使用 <code>request_uri</code> 变量作为 <code>hash</code> 的 <code>key</code> 值，只要访问的 <code>URI</code> 保持不变，就会一直分发给同一台服务器。</p>
<p><strong>ip_hash</strong></p>
<p>根据客户端的请求 <code>ip</code> 进行判断，只要 <code>ip</code> 地址不变就永远分配到同一台主机。它可以有效解决后台服务器 <code>session</code> 保持的问题。</p>
<div class="hljs code-wrapper"><pre><code class="hljs pgsql">upstream demo_server &#123;
  ip_hash;
  <span class="hljs-keyword">server</span> <span class="hljs-number">121.42</span><span class="hljs-number">.11</span><span class="hljs-number">.34</span>:<span class="hljs-number">8020</span>;
  <span class="hljs-keyword">server</span> <span class="hljs-number">121.42</span><span class="hljs-number">.11</span><span class="hljs-number">.34</span>:<span class="hljs-number">8030</span>;
  <span class="hljs-keyword">server</span> <span class="hljs-number">121.42</span><span class="hljs-number">.11</span><span class="hljs-number">.34</span>:<span class="hljs-number">8040</span>;
&#125;

<span class="hljs-keyword">server</span> &#123;
  <span class="hljs-keyword">listen</span> <span class="hljs-number">80</span>;
  server_name balance.lion.club;
  
  <span class="hljs-keyword">location</span> /balance/ &#123;
   proxy_pass http://demo_server;
  &#125;
&#125;</code></pre></div>

<h3 id="最少连接数算法"><a href="#最少连接数算法" class="headerlink" title="最少连接数算法"></a>最少连接数算法</h3><p>各个 <code>worker</code> 子进程通过读取共享内存的数据，来获取后端服务器的信息。来挑选一台当前已建立连接数最少的服务器进行分配请求。</p>
<div class="hljs code-wrapper"><pre><code class="hljs abnf">语法：least_conn<span class="hljs-comment">;</span>

上下文：upstream<span class="hljs-comment">;</span></code></pre></div>

<p>示例：</p>
<div class="hljs code-wrapper"><pre><code class="hljs pgsql">upstream demo_server &#123;
  <span class="hljs-type">zone</span> test <span class="hljs-number">10</span>M; # <span class="hljs-type">zone</span>可以设置共享内存空间的名字和大小
  least_conn;
  <span class="hljs-keyword">server</span> <span class="hljs-number">121.42</span><span class="hljs-number">.11</span><span class="hljs-number">.34</span>:<span class="hljs-number">8020</span>;
  <span class="hljs-keyword">server</span> <span class="hljs-number">121.42</span><span class="hljs-number">.11</span><span class="hljs-number">.34</span>:<span class="hljs-number">8030</span>;
  <span class="hljs-keyword">server</span> <span class="hljs-number">121.42</span><span class="hljs-number">.11</span><span class="hljs-number">.34</span>:<span class="hljs-number">8040</span>;
&#125;

<span class="hljs-keyword">server</span> &#123;
  <span class="hljs-keyword">listen</span> <span class="hljs-number">80</span>;
  server_name balance.lion.club;
  
  <span class="hljs-keyword">location</span> /balance/ &#123;
   proxy_pass http://demo_server;
  &#125;
&#125;</code></pre></div>

<p>最后你会发现，负载均衡的配置其实一点都不复杂。</p>
<p><strong>配置缓存</strong></p>
<p>缓存可以非常有效的提升性能，因此不论是客户端（浏览器），还是代理服务器（ <code>Nginx</code> ），乃至上游服务器都多少会涉及到缓存。可见缓存在每个环节都是非常重要的。下面让我们来学习<code>Nginx</code> 中如何设置缓存策略。</p>
<p><strong>proxy_cache</strong></p>
<p>存储一些之前被访问过、而且可能将要被再次访问的资源，使用户可以直接从代理服务器获得，从而减少上游服务器的压力，加快整个访问速度。</p>
<div class="hljs code-wrapper"><pre><code class="hljs pgsql">语法：proxy_cache <span class="hljs-type">zone</span> | <span class="hljs-keyword">off</span> ; # <span class="hljs-type">zone</span> 是共享内存的名称

默认值：proxy_cache <span class="hljs-keyword">off</span>;

上下文：http、<span class="hljs-keyword">server</span>、<span class="hljs-keyword">location</span></code></pre></div>

<p><strong>proxy_cache_path</strong></p>
<p>设置缓存文件的存放路径。</p>
<div class="hljs code-wrapper"><pre><code class="hljs routeros">语法：proxy_cache_path path [<span class="hljs-attribute">level</span>=levels] <span class="hljs-built_in">..</span>.可选参数省略，下面会详细列举

默认值：proxy_cache_path off

上下文：http</code></pre></div>

<p>参数含义：</p>
<ul>
<li><code>path</code> 缓存文件的存放路径；</li>
<li><code>level path</code> 的目录层级；</li>
<li><code>keys_zone</code> 设置共享内存；</li>
<li><code>inactive</code> 在指定时间内没有被访问，缓存会被清理，默认10分钟；</li>
</ul>
<h3 id="proxy-cache-key"><a href="#proxy-cache-key" class="headerlink" title="proxy_cache_key"></a>proxy_cache_key</h3><p>设置缓存文件的 <code>key</code> 。</p>
<div class="hljs code-wrapper"><pre><code class="hljs tcl">语法：proxy_cache_key

默认值：proxy_cache_key <span class="hljs-variable">$scheme</span><span class="hljs-variable">$proxy_host</span><span class="hljs-variable">$request_uri</span>;

上下文：<span class="hljs-keyword">http</span>、server、location</code></pre></div>



<p><strong>proxy_cache_valid</strong></p>
<p>配置什么状态码可以被缓存，以及缓存时长。</p>
<div class="hljs code-wrapper"><pre><code class="hljs crmsh">语法：proxy_cache_valid [code...] time;

上下文：http、server、location

配置示例：proxy_cache_valid <span class="hljs-number">200</span> <span class="hljs-number">304</span> <span class="hljs-number">2m</span>;; <span class="hljs-comment"># 说明对于状态为200和304的缓存文件的缓存时间是2分钟</span></code></pre></div>

<h3 id="proxy-no-cache"><a href="#proxy-no-cache" class="headerlink" title="proxy_no_cache"></a>proxy_no_cache</h3><p>定义相应保存到缓存的条件，如果字符串参数的至少一个值不为空且不等于“ 0”，则将不保存该响应到缓存。</p>
<div class="hljs code-wrapper"><pre><code class="hljs crmsh">语法：proxy_no_cache <span class="hljs-keyword">string</span>;

上下文：http、server、location

示例：proxy_no_cache $http_pragma    $http_authorization;</code></pre></div>

<h3 id="proxy-cache-bypass"><a href="#proxy-cache-bypass" class="headerlink" title="proxy_cache_bypass"></a>proxy_cache_bypass</h3><p>定义条件，在该条件下将不会从缓存中获取响应。</p>
<div class="hljs code-wrapper"><pre><code class="hljs crmsh">语法：proxy_cache_bypass <span class="hljs-keyword">string</span>;

上下文：http、server、location

示例：proxy_cache_bypass $http_pragma    $http_authorization;</code></pre></div>

<h3 id="upstream-cache-status-变量"><a href="#upstream-cache-status-变量" class="headerlink" title="upstream_cache_status 变量"></a>upstream_cache_status 变量</h3><p>它存储了缓存是否命中的信息，会设置在响应头信息中，在调试中非常有用。</p>
<div class="hljs code-wrapper"><pre><code class="hljs avrasm"><span class="hljs-symbol">MISS:</span> 未命中缓存
HIT：命中缓存
<span class="hljs-symbol">EXPIRED:</span> 缓存过期
<span class="hljs-symbol">STALE:</span> 命中了陈旧缓存
<span class="hljs-symbol">REVALIDDATED:</span> Nginx验证陈旧缓存依然有效
<span class="hljs-symbol">UPDATING:</span> 内容陈旧，但正在更新
<span class="hljs-symbol">BYPASS:</span> <span class="hljs-built_in">X</span>响应从原始服务器获取</code></pre></div>

<h3 id="配置实例-1"><a href="#配置实例-1" class="headerlink" title="配置实例"></a>配置实例</h3><p>我们把 <code>121.42.11.34</code> 服务器作为上游服务器，做如下配置（ <code>/etc/nginx/conf.d/cache.conf</code>）：</p>
<div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">server</span> &#123;
  <span class="hljs-keyword">listen</span> <span class="hljs-number">1010</span>;
  root /usr/<span class="hljs-keyword">share</span>/nginx/html/<span class="hljs-number">1010</span>;
  <span class="hljs-keyword">location</span> / &#123;
   <span class="hljs-keyword">index</span> <span class="hljs-keyword">index</span>.html;
  &#125;
&#125;

<span class="hljs-keyword">server</span> &#123;
  <span class="hljs-keyword">listen</span> <span class="hljs-number">1020</span>;
  root /usr/<span class="hljs-keyword">share</span>/nginx/html/<span class="hljs-number">1020</span>;
  <span class="hljs-keyword">location</span> / &#123;
   <span class="hljs-keyword">index</span> <span class="hljs-keyword">index</span>.html;
  &#125;
&#125;</code></pre></div>

<p>把 <code>121.5.180.193</code> 服务器作为代理服务器，做如下配置（ <code>/etc/nginx/conf.d/cache.conf</code> ）：</p>
<div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">proxy_cache_path</span> /etc/nginx/cache_temp levels=<span class="hljs-number">2</span>:<span class="hljs-number">2</span> keys_zone=cache_zone:<span class="hljs-number">30m</span> max_size=<span class="hljs-number">2g</span> inactive=<span class="hljs-number">60m</span> use_temp_path=<span class="hljs-literal">off</span>;

<span class="hljs-attribute">upstream</span> cache_server&#123;
  <span class="hljs-attribute">server</span> <span class="hljs-number">121.42.11.34:1010</span>;
  <span class="hljs-attribute">server</span> <span class="hljs-number">121.42.11.34:1020</span>;
&#125;

<span class="hljs-section">server</span> &#123;
  <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;
  <span class="hljs-attribute">server_name</span> cache.lion.club;
  <span class="hljs-attribute">location</span> / &#123;
    <span class="hljs-attribute">proxy_cache</span> cache_zone; <span class="hljs-comment"># 设置缓存内存，上面配置中已经定义好的</span>
    <span class="hljs-attribute">proxy_cache_valid</span> <span class="hljs-number">200</span> <span class="hljs-number">5m</span>; <span class="hljs-comment"># 缓存状态为200的请求，缓存时长为5分钟</span>
    <span class="hljs-attribute">proxy_cache_key</span> $request_uri; <span class="hljs-comment"># 缓存文件的key为请求的URI</span>
    <span class="hljs-attribute">add_header</span> Nginx-Cache-Status $upstream_cache_status <span class="hljs-comment"># 把缓存状态设置为头部信息，响应给客户端</span>
    proxy_pass http://cache_server; <span class="hljs-comment"># 代理转发</span>
  &#125;
&#125;</code></pre></div>

<p>缓存就是这样配置，我们可以在 <code>/etc/nginx/cache_temp</code> 路径下找到相应的缓存文件。</p>
<p><strong>对于一些实时性要求非常高的页面或数据来说，就不应该去设置缓存，下面来看看如何配置不缓存的内容。</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs awk">...

server &#123;
  listen <span class="hljs-number">80</span>;
  server_name cache.lion.club;
  <span class="hljs-comment"># URI 中后缀为 .txt 或 .text 的设置变量值为 &quot;no cache&quot;</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-variable">$request_uri</span> ~ \.(txt|text)$) &#123;
   set <span class="hljs-variable">$cache_name</span> <span class="hljs-string">&quot;no cache&quot;</span>
  &#125;
  
  location / &#123;
    proxy_no_cache <span class="hljs-variable">$cache_name</span>; <span class="hljs-comment"># 判断该变量是否有值，如果有值则不进行缓存，如果没有值则进行缓存</span>
    proxy_cache cache_zone; <span class="hljs-comment"># 设置缓存内存</span>
    proxy_cache_valid <span class="hljs-number">200</span> <span class="hljs-number">5</span>m; <span class="hljs-comment"># 缓存状态为200的请求，缓存时长为5分钟</span>
    proxy_cache_key <span class="hljs-variable">$request_uri</span>; <span class="hljs-comment"># 缓存文件的key为请求的URI</span>
    add_header Nginx-Cache-Status <span class="hljs-variable">$upstream_cache_status</span> <span class="hljs-comment"># 把缓存状态设置为头部信息，响应给客户端</span>
    proxy_pass http:<span class="hljs-regexp">//</span>cache_server; <span class="hljs-comment"># 代理转发</span>
  &#125;
&#125;</code></pre></div>

<p><strong>HTTPS</strong></p>
<p>在学习如何配置 <code>HTTPS</code> 之前，我们先来简单回顾下 <code>HTTPS</code> 的工作流程是怎么样的？它是如何进行加密保证安全的？</p>
<p><strong>HTTPS 工作流程</strong></p>
<p>\1. 客户端（浏览器）访问 <code>https://www.baidu.com</code> 百度网站；</p>
<p>\2. 百度服务器返回 <code>HTTPS</code> 使用的 <code>CA</code> 证书；</p>
<p>\3. 浏览器验证 <code>CA</code> 证书是否为合法证书；</p>
<p>\4. 验证通过，证书合法，生成一串随机数并使用公钥（证书中提供的）进行加密；</p>
<p>\5. 发送公钥加密后的随机数给百度服务器；</p>
<p>\6. 百度服务器拿到密文，通过私钥进行解密，获取到随机数（公钥加密，私钥解密，反之也可以）；</p>
<p>\7. 百度服务器把要发送给浏览器的内容，使用随机数进行加密后传输给浏览器；</p>
<p>\8. 此时浏览器可以使用随机数进行解密，获取到服务器的真实传输内容；</p>
<p>这就是 <code>HTTPS</code> 的基本运作原理，使用对称加密和非对称机密配合使用，保证传输内容的安全性。</p>
<p>关于HTTPS更多知识，可以查看作者的另外一篇文章《学习 HTTP 协议》。</p>
<h3 id="配置证书"><a href="#配置证书" class="headerlink" title="配置证书"></a>配置证书</h3><p>下载证书的压缩文件，里面有个 <code>Nginx</code> 文件夹，把 <code>xxx.crt</code> 和 <code>xxx.key</code> 文件拷贝到服务器目录，再进行如下配置：</p>
<div class="hljs code-wrapper"><pre><code class="hljs awk">server &#123;
  listen <span class="hljs-number">443</span> ssl http2 default_server; <span class="hljs-comment"># SSL 访问端口号为 443</span>
  server_name lion.club; <span class="hljs-comment"># 填写绑定证书的域名(我这里是随便写的)</span>
  ssl_certificate <span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/https/</span>lion.club_bundle.crt; <span class="hljs-comment"># 证书地址</span>
  ssl_certificate_key <span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/https/</span>lion.club.key; <span class="hljs-comment"># 私钥地址</span>
  ssl_session_timeout <span class="hljs-number">10</span>m;
  ssl_protocols TLSv1 TLSv1.<span class="hljs-number">1</span> TLSv1.<span class="hljs-number">2</span>; <span class="hljs-comment"># 支持ssl协议版本，默认为后三个，主流版本是[TLSv1.2]</span>
 
  location / &#123;
    root         <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html;
    index        index.html index.htm;
  &#125;
&#125;</code></pre></div>

<p>如此配置后就能正常访问 <code>HTTPS</code> 版的网站了。</p>
<p><strong>配置跨域 CORS</strong></p>
<p>先简单回顾下跨域究竟是怎么回事。</p>
<p><strong>跨域的定义</strong></p>
<p>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。通常不允许不同源间的读操作。</p>
<p><strong>同源的定义</strong></p>
<p>如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。</p>
<p>下面给出了与 URL <code>http://store.company.com/dir/page.html</code> 的源进行对比的示例:</p>
<div class="hljs code-wrapper"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>store.company.com<span class="hljs-regexp">/dir2/</span>other.html 同源
https:<span class="hljs-regexp">//</span>store.company.com/secure.html 不同源，协议不同
http:<span class="hljs-regexp">//</span>store.company.com:<span class="hljs-number">81</span><span class="hljs-regexp">/dir/</span>etc.html 不同源，端口不同
http:<span class="hljs-regexp">//</span>news.company.com<span class="hljs-regexp">/dir/</span>other.html 不同源，主机不同</code></pre></div>

<p>不同源会有如下限制：</p>
<ul>
<li><code>Web</code> 数据层面，同源策略限制了不同源的站点读取当前站点的 <code>Cookie</code> 、 <code>IndexDB</code> 、<code>LocalStorage</code> 等数据。</li>
<li><code>DOM</code> 层面，同源策略限制了来自不同源的 <code>JavaScript</code> 脚本对当前 <code>DOM</code> 对象读和写的操作。</li>
<li>网络层面，同源策略限制了通过 <code>XMLHttpRequest</code> 等方式将站点的数据发送给不同源的站点。</li>
</ul>
<h3 id="Nginx-解决跨域的原理"><a href="#Nginx-解决跨域的原理" class="headerlink" title="Nginx 解决跨域的原理"></a>Nginx 解决跨域的原理</h3><p>例如：</p>
<ul>
<li>前端 <code>server</code> 的域名为：<code>fe.server.com</code></li>
<li>后端服务的域名为：<code>dev.server.com</code></li>
</ul>
<p>现在我在 <code>fe.server.com</code> 对 <code>dev.server.com</code> 发起请求一定会出现跨域。</p>
<p>现在我们只需要启动一个 <code>Nginx</code> 服务器，将 <code>server_name</code> 设置为 <code>fe.server.com</code> 然后设置相应的 <code>location</code> 以拦截前端需要跨域的请求，最后将请求代理回 <code>dev.server.com</code> 。如下面的配置：</p>
<div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;
 <span class="hljs-attribute">listen</span>      <span class="hljs-number">80</span>;
 <span class="hljs-attribute">server_name</span>  fe.server.com;
 <span class="hljs-attribute">location</span> / &#123;
  <span class="hljs-attribute">proxy_pass</span> dev.server.com;
 &#125;
&#125;</code></pre></div>

<p>这样可以完美绕过浏览器的同源策略：<code>fe.server.com</code> 访问 <code>Nginx</code> 的 <code>fe.server.com</code> 属于同源访问，而 <code>Nginx</code> 对服务端转发的请求不会触发浏览器的同源策略。</p>
<p><strong>配置开启 gzip 压缩</strong></p>
<p><code>GZIP</code> 是规定的三种标准 <code>HTTP</code> 压缩格式之一。目前绝大多数的网站都在使用 <code>GZIP</code> 传输 <code>HTML</code>、<code>CSS</code> 、 <code>JavaScript</code> 等资源文件。</p>
<p>对于文本文件， <code>GZiP</code> 的效果非常明显，开启后传输所需流量大约会降至 <code>1/4~1/3</code> 。</p>
<p>并不是每个浏览器都支持 <code>gzip</code> 的，如何知道客户端是否支持 <code>gzip</code> 呢，请求头中的 <code>Accept-Encoding</code> 来标识对压缩的支持。</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" srcset="/img/loading.gif" lazyload alt="Image"></p>
<p>启用 <code>gzip</code> 同时需要客户端和服务端的支持，如果客户端支持 <code>gzip</code> 的解析，那么只要服务端能够返回 <code>gzip</code> 的文件就可以启用 <code>gzip</code> 了,我们可以通过 <code>Nginx</code> 的配置来让服务端支持 <code>gzip</code> 。下面的 <code>respone</code> 中 <code>content-encoding:gzip</code> ，指服务端开启了 <code>gzip</code> 的压缩方式。</p>
<p><img src="https://i.loli.net/2021/05/13/2InKAg9biCSdoPj.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<p>在 <code>/etc/nginx/conf.d/</code> 文件夹中新建配置文件 <code>gzip.conf</code> ：</p>
<div class="hljs code-wrapper"><pre><code class="hljs applescript"><span class="hljs-comment"># # 默认off，是否开启gzip</span>
gzip <span class="hljs-keyword">on</span>; 
<span class="hljs-comment"># 要采用 gzip 压缩的 MIME 文件类型，其中 text/html 被系统强制启用；</span>
gzip_types <span class="hljs-built_in">text</span>/plain <span class="hljs-built_in">text</span>/css <span class="hljs-built_in">application</span>/json <span class="hljs-built_in">application</span>/x-javascript <span class="hljs-built_in">text</span>/xml <span class="hljs-built_in">application</span>/xml <span class="hljs-built_in">application</span>/xml+rss <span class="hljs-built_in">text</span>/javascript;

<span class="hljs-comment"># ---- 以上两个参数开启就可以支持Gzip压缩了 ---- #</span>

<span class="hljs-comment"># 默认 off，该模块启用后，Nginx 首先检查是否存在请求静态文件的 gz 结尾的文件，如果有则直接返回该 .gz 文件内容；</span>
gzip_static <span class="hljs-keyword">on</span>;

<span class="hljs-comment"># 默认 off，nginx做为反向代理时启用，用于设置启用或禁用从代理服务器上收到相应内容 gzip 压缩；</span>
gzip_proxied any;

<span class="hljs-comment"># 用于在响应消息头中添加 Vary：Accept-Encoding，使代理服务器根据请求头中的 Accept-Encoding 识别是否启用 gzip 压缩；</span>
gzip_vary <span class="hljs-keyword">on</span>;

<span class="hljs-comment"># gzip 压缩比，压缩级别是 1-9，1 压缩级别最低，9 最高，级别越高压缩率越大，压缩时间越长，建议 4-6；</span>
gzip_comp_level <span class="hljs-number">6</span>;

<span class="hljs-comment"># 获取多少内存用于缓存压缩结果，16 8k 表示以 8k*16 为单位获得；</span>
gzip_buffers <span class="hljs-number">16</span> <span class="hljs-number">8</span>k;

<span class="hljs-comment"># 允许压缩的页面最小字节数，页面字节数从header头中的 Content-Length 中进行获取。默认值是 0，不管页面多大都压缩。建议设置成大于 1k 的字节数，小于 1k 可能会越压越大；</span>
<span class="hljs-comment"># gzip_min_length 1k;</span>

<span class="hljs-comment"># 默认 1.1，启用 gzip 所需的 HTTP 最低版本；</span>
gzip_http_version <span class="hljs-number">1.1</span>;</code></pre></div>



<p>其实也可以通过前端构建工具例如 <code>webpack</code> 、<code>rollup</code> 等在打生产包时就做好 <code>Gzip</code> 压缩，然后放到 <code>Nginx</code> 服务器中，这样可以减少服务器的开销，加快访问速度。</p>
<p>关于 <code>Nginx</code> 的实际应用就学习到这里，相信通过掌握了 <code>Nginx</code> 核心配置以及实战配置，之后再遇到什么需求，我们也能轻松应对。接下来，让我们再深入一点学习下 <code>Nginx</code> 的架构。</p>
<p><strong>Nginx 架构</strong></p>
<p><strong>进程结构</strong></p>
<p>多进程结构 <code>Nginx</code> 的进程模型图：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqgj9dsw29j30rn0aj74h.jpg" srcset="/img/loading.gif" lazyload alt="Image"></p>
<p>多进程中的 <code>Nginx</code> 进程架构如下图所示，会有一个父进程（ <code>Master Process</code> ），它会有很多子进程（ <code>Child Processes</code> ）。</p>
<ul>
<li><p><code>Master Process</code> 用来管理子进程的，其本身并不真正处理用户请求。</p>
</li>
<li><ul>
<li>某个子进程 <code>down</code> 掉的话，它会向 <code>Master</code> 进程发送一条消息，表明自己不可用了，此时 <code>Master</code> 进程会去新起一个子进程。</li>
<li>某个配置文件被修改了 <code>Master</code> 进程会去通知 <code>work</code> 进程获取新的配置信息，这也就是我们所说的热部署。</li>
</ul>
</li>
<li><p>子进程间是通过共享内存的方式进行通信的。</p>
</li>
</ul>
<h2 id="配置文件重载原理"><a href="#配置文件重载原理" class="headerlink" title="配置文件重载原理"></a>配置文件重载原理</h2><p><code>reload</code> 重载配置文件的流程：</p>
<p>\1. 向 <code>master</code> 进程发送 <code>HUP</code> 信号（ <code>reload</code> 命令）；</p>
<p><code>2. master</code> 进程检查配置语法是否正确；</p>
<p><code>3. master</code> 进程打开监听端口；</p>
<p><code>4. master</code> 进程使用新的配置文件启动新的 <code>worker</code> 子进程；</p>
<p><code>5. master</code> 进程向老的 <code>worker</code> 子进程发送 <code>QUIT</code> 信号；</p>
<p>\6. 老的 <code>worker</code> 进程关闭监听句柄，处理完当前连接后关闭进程；</p>
<p>\7. 整个过程 <code>Nginx</code> 始终处于平稳运行中，实现了平滑升级，用户无感知；</p>
<h2 id="Nginx-模块化管理机制"><a href="#Nginx-模块化管理机制" class="headerlink" title="Nginx 模块化管理机制"></a>Nginx 模块化管理机制</h2><p><code>Nginx</code> 的内部结构是由核心部分和一系列的功能模块所组成。这样划分是为了使得每个模块的功能相对简单，便于开发，同时也便于对系统进行功能扩展。<code>Nginx</code> 的模块是互相独立的,低耦合高内聚。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqgil28gi4j30u00kudje.jpg" srcset="/img/loading.gif" lazyload alt="Image"></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/basic-component/">basic-component</a>
                    
                      <a class="hover-with-bg" href="/categories/basic-component/nginx/">nginx</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/nginx/">nginx</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/10/12/linux-du/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">linux du</span>
                        <span class="visible-mobile">Vorheriger</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/10/09/linux-chmod/">
                        <span class="hidden-mobile">linux chmod</span>
                        <span class="visible-mobile">Nächster</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"Jf1XC66LVfvBgBpG1uzXEivd-gzGzoHsz","appKey":"UyOEEpxFaJC2kPqgBkDOeMPE","path":"window.location.pathname","placeholder":"说点什么","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":true,"recordIP":true,"serverURLs":"https://jf1xc66l.lc-cn-n1-shared.com","emojiCDN":null,"emojiMaps":null,"enableQQ":false,"appid":"Jf1XC66LVfvBgBpG1uzXEivd-gzGzoHsz","appkey":"UyOEEpxFaJC2kPqgBkDOeMPE"},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          Fluid.plugins.initFancyBox('#valine .vcontent img:not(.vemoji)');
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" lazyload class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Suchen</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">Stichwort</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
      <div class="col-lg-7 mx-auto nopadding-x-md">
        <div class="container custom mx-auto">
          </script><script src="/js/fireworks.js"></script><script src="https://api.vvhan.com/api/snow"></script>
        </div>
      </div>
    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <i class="iconfont icon-love"></i> <a href="https://github.com/czy1024" target="_blank" rel="nofollow noopener"><span>luna</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":true,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
